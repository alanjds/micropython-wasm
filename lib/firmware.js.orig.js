// Copyright 2010 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

// The Module object: Our interface to the outside world. We import
// and export values on it. There are various ways Module can be used:
// 1. Not defined. We create it here
// 2. A function parameter, function(Module) { ..generated code.. }
// 3. pre-run appended it, var Module = {}; ..generated code..
// 4. External script tag defines var Module.
// We need to check if Module already exists (e.g. case 3 above).
// Substitution will be replaced with actual code on later stage of the build,
// this way Closure Compiler will not mangle it (e.g. case 4. above).
// Note that if you want to run closure, and also to use Module
// after the generated code, you will need to define   var Module = {};
// before the code. Then that object will be used in the code, and you
// can continue to use Module afterwards as well.
var Module = typeof Module !== 'undefined' ? Module : {};

// --pre-jses are emitted after the Module integration code, so that they can
// refer to Module (if they choose; they can also define Module)
// {{PRE_JSES}}

// Sometimes an existing Module object exists with properties
// meant to overwrite the default module functionality. Here
// we collect those properties and reapply _after_ we configure
// the current environment's defaults to avoid having to be so
// defensive during initialization.
var moduleOverrides = {};
var key;
for (key in Module) {
  if (Module.hasOwnProperty(key)) {
    moduleOverrides[key] = Module[key];
  }
}

Module['arguments'] = [];
Module['thisProgram'] = './this.program';
Module['quit'] = function(status, toThrow) {
  throw toThrow;
};
Module['preRun'] = [];
Module['postRun'] = [];

// Determine the runtime environment we are in. You can customize this by
// setting the ENVIRONMENT setting at compile time (see settings.js).

var ENVIRONMENT_IS_WEB = false;
var ENVIRONMENT_IS_WORKER = false;
var ENVIRONMENT_IS_NODE = false;
var ENVIRONMENT_IS_SHELL = false;
ENVIRONMENT_IS_WEB = typeof window === 'object';
ENVIRONMENT_IS_WORKER = typeof importScripts === 'function';
ENVIRONMENT_IS_NODE = typeof process === 'object' && typeof require === 'function' && !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_WORKER;
ENVIRONMENT_IS_SHELL = !ENVIRONMENT_IS_WEB && !ENVIRONMENT_IS_NODE && !ENVIRONMENT_IS_WORKER;

if (Module['ENVIRONMENT']) {
  throw new Error('Module.ENVIRONMENT has been deprecated. To force the environment, use the ENVIRONMENT compile-time option (for example, -s ENVIRONMENT=web or -s ENVIRONMENT=node)');
}


// Three configurations we can be running in:
// 1) We could be the application main() thread running in the main JS UI thread. (ENVIRONMENT_IS_WORKER == false and ENVIRONMENT_IS_PTHREAD == false)
// 2) We could be the application main() thread proxied to worker. (with Emscripten -s PROXY_TO_WORKER=1) (ENVIRONMENT_IS_WORKER == true, ENVIRONMENT_IS_PTHREAD == false)
// 3) We could be an application pthread running in a worker. (ENVIRONMENT_IS_WORKER == true and ENVIRONMENT_IS_PTHREAD == true)




// `/` should be present at the end if `scriptDirectory` is not empty
var scriptDirectory = '';
function locateFile(path) {
  if (Module['locateFile']) {
    return Module['locateFile'](path, scriptDirectory);
  } else {
    return scriptDirectory + path;
  }
}

if (ENVIRONMENT_IS_NODE) {
  scriptDirectory = __dirname + '/';

  // Expose functionality in the same simple way that the shells work
  // Note that we pollute the global namespace here, otherwise we break in node
  var nodeFS;
  var nodePath;

  Module['read'] = function shell_read(filename, binary) {
    var ret;
      if (!nodeFS) nodeFS = require('fs');
      if (!nodePath) nodePath = require('path');
      filename = nodePath['normalize'](filename);
      ret = nodeFS['readFileSync'](filename);
    return binary ? ret : ret.toString();
  };

  Module['readBinary'] = function readBinary(filename) {
    var ret = Module['read'](filename, true);
    if (!ret.buffer) {
      ret = new Uint8Array(ret);
    }
    assert(ret.buffer);
    return ret;
  };

  if (process['argv'].length > 1) {
    Module['thisProgram'] = process['argv'][1].replace(/\\/g, '/');
  }

  Module['arguments'] = process['argv'].slice(2);

  if (typeof module !== 'undefined') {
    module['exports'] = Module;
  }

  process['on']('uncaughtException', function(ex) {
    // suppress ExitStatus exceptions from showing an error
    if (!(ex instanceof ExitStatus)) {
      throw ex;
    }
  });
  // Currently node will swallow unhandled rejections, but this behavior is
  // deprecated, and in the future it will exit with error status.
  process['on']('unhandledRejection', abort);

  Module['quit'] = function(status) {
    process['exit'](status);
  };

  Module['inspect'] = function () { return '[Emscripten Module object]'; };
} else
if (ENVIRONMENT_IS_SHELL) {


  if (typeof read != 'undefined') {
    Module['read'] = function shell_read(f) {
      return read(f);
    };
  }

  Module['readBinary'] = function readBinary(f) {
    var data;
    if (typeof readbuffer === 'function') {
      return new Uint8Array(readbuffer(f));
    }
    data = read(f, 'binary');
    assert(typeof data === 'object');
    return data;
  };

  if (typeof scriptArgs != 'undefined') {
    Module['arguments'] = scriptArgs;
  } else if (typeof arguments != 'undefined') {
    Module['arguments'] = arguments;
  }

  if (typeof quit === 'function') {
    Module['quit'] = function(status) {
      quit(status);
    }
  }
} else
if (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) {
  if (ENVIRONMENT_IS_WORKER) { // Check worker, not web, since window could be polyfilled
    scriptDirectory = self.location.href;
  } else if (document.currentScript) { // web
    scriptDirectory = document.currentScript.src;
  }
  // blob urls look like blob:http://site.com/etc/etc and we cannot infer anything from them.
  // otherwise, slice off the final part of the url to find the script directory.
  // if scriptDirectory does not contain a slash, lastIndexOf will return -1,
  // and scriptDirectory will correctly be replaced with an empty string.
  if (scriptDirectory.indexOf('blob:') !== 0) {
    scriptDirectory = scriptDirectory.substr(0, scriptDirectory.lastIndexOf('/')+1);
  } else {
    scriptDirectory = '';
  }


  Module['read'] = function shell_read(url) {
      var xhr = new XMLHttpRequest();
      xhr.open('GET', url, false);
      xhr.send(null);
      return xhr.responseText;
  };

  if (ENVIRONMENT_IS_WORKER) {
    Module['readBinary'] = function readBinary(url) {
        var xhr = new XMLHttpRequest();
        xhr.open('GET', url, false);
        xhr.responseType = 'arraybuffer';
        xhr.send(null);
        return new Uint8Array(xhr.response);
    };
  }

  Module['readAsync'] = function readAsync(url, onload, onerror) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', url, true);
    xhr.responseType = 'arraybuffer';
    xhr.onload = function xhr_onload() {
      if (xhr.status == 200 || (xhr.status == 0 && xhr.response)) { // file URLs can return 0
        onload(xhr.response);
        return;
      }
      onerror();
    };
    xhr.onerror = onerror;
    xhr.send(null);
  };

  Module['setWindowTitle'] = function(title) { document.title = title };
} else
{
  throw new Error('environment detection error');
}

// Set up the out() and err() hooks, which are how we can print to stdout or
// stderr, respectively.
// If the user provided Module.print or printErr, use that. Otherwise,
// console.log is checked first, as 'print' on the web will open a print dialogue
// printErr is preferable to console.warn (works better in shells)
// bind(console) is necessary to fix IE/Edge closed dev tools panel behavior.
var out = Module['print'] || (typeof console !== 'undefined' ? console.log.bind(console) : (typeof print !== 'undefined' ? print : null));
var err = Module['printErr'] || (typeof printErr !== 'undefined' ? printErr : ((typeof console !== 'undefined' && console.warn.bind(console)) || out));

// Merge back in the overrides
for (key in moduleOverrides) {
  if (moduleOverrides.hasOwnProperty(key)) {
    Module[key] = moduleOverrides[key];
  }
}
// Free the object hierarchy contained in the overrides, this lets the GC
// reclaim data used e.g. in memoryInitializerRequest, which is a large typed array.
moduleOverrides = undefined;

// perform assertions in shell.js after we set up out() and err(), as otherwise if an assertion fails it cannot print the message
assert(typeof Module['memoryInitializerPrefixURL'] === 'undefined', 'Module.memoryInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['pthreadMainPrefixURL'] === 'undefined', 'Module.pthreadMainPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['cdInitializerPrefixURL'] === 'undefined', 'Module.cdInitializerPrefixURL option was removed, use Module.locateFile instead');
assert(typeof Module['filePackagePrefixURL'] === 'undefined', 'Module.filePackagePrefixURL option was removed, use Module.locateFile instead');



// Copyright 2017 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

// {{PREAMBLE_ADDITIONS}}

var STACK_ALIGN = 16;

// stack management, and other functionality that is provided by the compiled code,
// should not be used before it is ready
stackSave = stackRestore = stackAlloc = function() {
  abort('cannot use the stack before compiled code is ready to run, and has provided stack access');
};

function staticAlloc(size) {
  abort('staticAlloc is no longer available at runtime; instead, perform static allocations at compile time (using makeStaticAlloc)');
}

function dynamicAlloc(size) {
  assert(DYNAMICTOP_PTR);
  var ret = HEAP32[DYNAMICTOP_PTR>>2];
  var end = (ret + size + 15) & -16;
  if (end <= _emscripten_get_heap_size()) {
    HEAP32[DYNAMICTOP_PTR>>2] = end;
  } else {
    return 0;
  }
  return ret;
}

function alignMemory(size, factor) {
  if (!factor) factor = STACK_ALIGN; // stack alignment (16-byte) by default
  return Math.ceil(size / factor) * factor;
}

function getNativeTypeSize(type) {
  switch (type) {
    case 'i1': case 'i8': return 1;
    case 'i16': return 2;
    case 'i32': return 4;
    case 'i64': return 8;
    case 'float': return 4;
    case 'double': return 8;
    default: {
      if (type[type.length-1] === '*') {
        return 4; // A pointer
      } else if (type[0] === 'i') {
        var bits = parseInt(type.substr(1));
        assert(bits % 8 === 0, 'getNativeTypeSize invalid bits ' + bits + ', type ' + type);
        return bits / 8;
      } else {
        return 0;
      }
    }
  }
}

function warnOnce(text) {
  if (!warnOnce.shown) warnOnce.shown = {};
  if (!warnOnce.shown[text]) {
    warnOnce.shown[text] = 1;
    err(text);
  }
}

var asm2wasmImports = { // special asm2wasm imports
    "f64-rem": function(x, y) {
        return x % y;
    },
    "debugger": function() {
        debugger;
    }
};



var jsCallStartIndex = 1;
var functionPointers = new Array(0);

// Wraps a JS function as a wasm function with a given signature.
// In the future, we may get a WebAssembly.Function constructor. Until then,
// we create a wasm module that takes the JS function as an import with a given
// signature, and re-exports that as a wasm function.
function convertJsFunctionToWasm(func, sig) {
  // The module is static, with the exception of the type section, which is
  // generated based on the signature passed in.
  var typeSection = [
    0x01, // id: section,
    0x00, // length: 0 (placeholder)
    0x01, // count: 1
    0x60, // form: func
  ];
  var sigRet = sig.slice(0, 1);
  var sigParam = sig.slice(1);
  var typeCodes = {
    'i': 0x7f, // i32
    'j': 0x7e, // i64
    'f': 0x7d, // f32
    'd': 0x7c, // f64
  };

  // Parameters, length + signatures
  typeSection.push(sigParam.length);
  for (var i = 0; i < sigParam.length; ++i) {
    typeSection.push(typeCodes[sigParam[i]]);
  }

  // Return values, length + signatures
  // With no multi-return in MVP, either 0 (void) or 1 (anything else)
  if (sigRet == 'v') {
    typeSection.push(0x00);
  } else {
    typeSection = typeSection.concat([0x01, typeCodes[sigRet]]);
  }

  // Write the overall length of the type section back into the section header
  // (excepting the 2 bytes for the section id and length)
  typeSection[1] = typeSection.length - 2;

  // Rest of the module is static
  var bytes = new Uint8Array([
    0x00, 0x61, 0x73, 0x6d, // magic ("\0asm")
    0x01, 0x00, 0x00, 0x00, // version: 1
  ].concat(typeSection, [
    0x02, 0x07, // import section
      // (import "e" "f" (func 0 (type 0)))
      0x01, 0x01, 0x65, 0x01, 0x66, 0x00, 0x00,
    0x07, 0x05, // export section
      // (export "f" (func 0 (type 0)))
      0x01, 0x01, 0x66, 0x00, 0x00,
  ]));

   // We can compile this wasm module synchronously because it is very small.
  // This accepts an import (at "e.f"), that it reroutes to an export (at "f")
  var module = new WebAssembly.Module(bytes);
  var instance = new WebAssembly.Instance(module, {
    e: {
      f: func
    }
  });
  var wrappedFunc = instance.exports.f;
  return wrappedFunc;
}

// Add a wasm function to the table.
function addFunctionWasm(func, sig) {
  var table = wasmTable;
  var ret = table.length;

  // Grow the table
  try {
    table.grow(1);
  } catch (err) {
    if (!err instanceof RangeError) {
      throw err;
    }
    throw 'Unable to grow wasm table. Use a higher value for RESERVED_FUNCTION_POINTERS or set ALLOW_TABLE_GROWTH.';
  }

  // Insert new element
  try {
    // Attempting to call this with JS function will cause of table.set() to fail
    table.set(ret, func);
  } catch (err) {
    if (!err instanceof TypeError) {
      throw err;
    }
    assert(typeof sig !== 'undefined', 'Missing signature argument to addFunction');
    var wrapped = convertJsFunctionToWasm(func, sig);
    table.set(ret, wrapped);
  }

  return ret;
}

function removeFunctionWasm(index) {
  // TODO(sbc): Look into implementing this to allow re-using of table slots
}

// 'sig' parameter is required for the llvm backend but only when func is not
// already a WebAssembly function.
function addFunction(func, sig) {


  var base = 0;
  for (var i = base; i < base + 0; i++) {
    if (!functionPointers[i]) {
      functionPointers[i] = func;
      return jsCallStartIndex + i;
    }
  }
  throw 'Finished up all reserved function pointers. Use a higher value for RESERVED_FUNCTION_POINTERS.';

}

function removeFunction(index) {

  functionPointers[index-jsCallStartIndex] = null;
}

var funcWrappers = {};

function getFuncWrapper(func, sig) {
  if (!func) return; // on null pointer, return undefined
  assert(sig);
  if (!funcWrappers[sig]) {
    funcWrappers[sig] = {};
  }
  var sigCache = funcWrappers[sig];
  if (!sigCache[func]) {
    // optimize away arguments usage in common cases
    if (sig.length === 1) {
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func);
      };
    } else if (sig.length === 2) {
      sigCache[func] = function dynCall_wrapper(arg) {
        return dynCall(sig, func, [arg]);
      };
    } else {
      // general case
      sigCache[func] = function dynCall_wrapper() {
        return dynCall(sig, func, Array.prototype.slice.call(arguments));
      };
    }
  }
  return sigCache[func];
}


function makeBigInt(low, high, unsigned) {
  return unsigned ? ((+((low>>>0)))+((+((high>>>0)))*4294967296.0)) : ((+((low>>>0)))+((+((high|0)))*4294967296.0));
}

function dynCall(sig, ptr, args) {
  if (args && args.length) {
    assert(args.length == sig.length-1);
    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
    return Module['dynCall_' + sig].apply(null, [ptr].concat(args));
  } else {
    assert(sig.length == 1);
    assert(('dynCall_' + sig) in Module, 'bad function pointer type - no table for sig \'' + sig + '\'');
    return Module['dynCall_' + sig].call(null, ptr);
  }
}

var tempRet0 = 0;

var setTempRet0 = function(value) {
  tempRet0 = value;
}

var getTempRet0 = function() {
  return tempRet0;
}

function getCompilerSetting(name) {
  throw 'You must build with -s RETAIN_COMPILER_SETTINGS=1 for getCompilerSetting or emscripten_get_compiler_setting to work';
}

var Runtime = {
  // helpful errors
  getTempRet0: function() { abort('getTempRet0() is now a top-level function, after removing the Runtime object. Remove "Runtime."') },
  staticAlloc: function() { abort('staticAlloc() is now a top-level function, after removing the Runtime object. Remove "Runtime."') },
  stackAlloc: function() { abort('stackAlloc() is now a top-level function, after removing the Runtime object. Remove "Runtime."') },
};

// The address globals begin at. Very low in memory, for code size and optimization opportunities.
// Above 0 is static memory, starting with globals.
// Then the stack.
// Then 'dynamic' memory for sbrk.
var GLOBAL_BASE = 1024;




// === Preamble library stuff ===

// Documentation for the public APIs defined in this file must be updated in:
//    site/source/docs/api_reference/preamble.js.rst
// A prebuilt local version of the documentation is available at:
//    site/build/text/docs/api_reference/preamble.js.txt
// You can also build docs locally as HTML or other formats in site/
// An online HTML version (which may be of a different version of Emscripten)
//    is up at http://kripken.github.io/emscripten-site/docs/api_reference/preamble.js.html


if (typeof WebAssembly !== 'object') {
  abort('No WebAssembly support found. Build with -s WASM=0 to target JavaScript instead.');
}


/** @type {function(number, string, boolean=)} */
function getValue(ptr, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': return HEAP8[((ptr)>>0)];
      case 'i8': return HEAP8[((ptr)>>0)];
      case 'i16': return HEAP16[((ptr)>>1)];
      case 'i32': return HEAP32[((ptr)>>2)];
      case 'i64': return HEAP32[((ptr)>>2)];
      case 'float': return HEAPF32[((ptr)>>2)];
      case 'double': return HEAPF64[((ptr)>>3)];
      default: abort('invalid type for getValue: ' + type);
    }
  return null;
}




// Wasm globals

var wasmMemory;

// Potentially used for direct table calls.
var wasmTable;


//========================================
// Runtime essentials
//========================================

// whether we are quitting the application. no code should run after this.
// set in exit() and abort()
var ABORT = false;

// set by exit() and abort().  Passed to 'onExit' handler.
// NOTE: This is also used as the process return code code in shell environments
// but only when noExitRuntime is false.
var EXITSTATUS = 0;

/** @type {function(*, string=)} */
function assert(condition, text) {
  if (!condition) {
    abort('Assertion failed: ' + text);
  }
}

// Returns the C function with a specified identifier (for C++, you need to do manual name mangling)
function getCFunc(ident) {
  var func = Module['_' + ident]; // closure exported function
  assert(func, 'Cannot call unknown function ' + ident + ', make sure it is exported');
  return func;
}

// C calling interface.
function ccall(ident, returnType, argTypes, args, opts) {
  // For fast lookup of conversion functions
  var toC = {
    'string': function(str) {
      var ret = 0;
      if (str !== null && str !== undefined && str !== 0) { // null string
        // at most 4 bytes per UTF-8 code point, +1 for the trailing '\0'
        var len = (str.length << 2) + 1;
        ret = stackAlloc(len);
        stringToUTF8(str, ret, len);
      }
      return ret;
    },
    'array': function(arr) {
      var ret = stackAlloc(arr.length);
      writeArrayToMemory(arr, ret);
      return ret;
    }
  };

  function convertReturnValue(ret) {
    if (returnType === 'string') return UTF8ToString(ret);
    if (returnType === 'boolean') return Boolean(ret);
    return ret;
  }

  var func = getCFunc(ident);
  var cArgs = [];
  var stack = 0;
  assert(returnType !== 'array', 'Return type should not be "array".');
  if (args) {
    for (var i = 0; i < args.length; i++) {
      var converter = toC[argTypes[i]];
      if (converter) {
        if (stack === 0) stack = stackSave();
        cArgs[i] = converter(args[i]);
      } else {
        cArgs[i] = args[i];
      }
    }
  }
  var ret = func.apply(null, cArgs);
  if (typeof EmterpreterAsync === 'object' && EmterpreterAsync.state) {
    assert(opts && opts.async, 'The call to ' + ident + ' is running asynchronously. If this was intended, add the async option to the ccall/cwrap call.');
    assert(!EmterpreterAsync.restartFunc, 'Cannot have multiple async ccalls in flight at once');
    return new Promise(function(resolve) {
      EmterpreterAsync.restartFunc = func;
      EmterpreterAsync.asyncFinalizers.push(function(ret) {
        if (stack !== 0) stackRestore(stack);
        resolve(convertReturnValue(ret));
      });
    });
  }
  ret = convertReturnValue(ret);
  if (stack !== 0) stackRestore(stack);
  // If this is an async ccall, ensure we return a promise
  if (opts && opts.async) return Promise.resolve(ret);
  return ret;
}

function cwrap(ident, returnType, argTypes, opts) {
  return function() {
    return ccall(ident, returnType, argTypes, arguments, opts);
  }
}

/** @type {function(number, number, string, boolean=)} */
function setValue(ptr, value, type, noSafe) {
  type = type || 'i8';
  if (type.charAt(type.length-1) === '*') type = 'i32'; // pointers are 32-bit
    switch(type) {
      case 'i1': HEAP8[((ptr)>>0)]=value; break;
      case 'i8': HEAP8[((ptr)>>0)]=value; break;
      case 'i16': HEAP16[((ptr)>>1)]=value; break;
      case 'i32': HEAP32[((ptr)>>2)]=value; break;
      case 'i64': (tempI64 = [value>>>0,(tempDouble=value,(+(Math_abs(tempDouble))) >= (+1) ? (tempDouble > (+0) ? ((Math_min((+(Math_floor((tempDouble)/(+4294967296)))), (+4294967295)))|0)>>>0 : (~~((+(Math_ceil((tempDouble - +(((~~(tempDouble)))>>>0))/(+4294967296))))))>>>0) : 0)],HEAP32[((ptr)>>2)]=tempI64[0],HEAP32[(((ptr)+(4))>>2)]=tempI64[1]); break;
      case 'float': HEAPF32[((ptr)>>2)]=value; break;
      case 'double': HEAPF64[((ptr)>>3)]=value; break;
      default: abort('invalid type for setValue: ' + type);
    }
}

var ALLOC_NORMAL = 0; // Tries to use _malloc()
var ALLOC_STACK = 1; // Lives for the duration of the current function call
var ALLOC_DYNAMIC = 2; // Cannot be freed except through sbrk
var ALLOC_NONE = 3; // Do not allocate

// allocate(): This is for internal use. You can use it yourself as well, but the interface
//             is a little tricky (see docs right below). The reason is that it is optimized
//             for multiple syntaxes to save space in generated code. So you should
//             normally not use allocate(), and instead allocate memory using _malloc(),
//             initialize it with setValue(), and so forth.
// @slab: An array of data, or a number. If a number, then the size of the block to allocate,
//        in *bytes* (note that this is sometimes confusing: the next parameter does not
//        affect this!)
// @types: Either an array of types, one for each byte (or 0 if no type at that position),
//         or a single type which is used for the entire block. This only matters if there
//         is initial data - if @slab is a number, then this does not matter at all and is
//         ignored.
// @allocator: How to allocate memory, see ALLOC_*
/** @type {function((TypedArray|Array<number>|number), string, number, number=)} */
function allocate(slab, types, allocator, ptr) {
  var zeroinit, size;
  if (typeof slab === 'number') {
    zeroinit = true;
    size = slab;
  } else {
    zeroinit = false;
    size = slab.length;
  }

  var singleType = typeof types === 'string' ? types : null;

  var ret;
  if (allocator == ALLOC_NONE) {
    ret = ptr;
  } else {
    ret = [_malloc,
    stackAlloc,
    dynamicAlloc][allocator](Math.max(size, singleType ? 1 : types.length));
  }

  if (zeroinit) {
    var stop;
    ptr = ret;
    assert((ret & 3) == 0);
    stop = ret + (size & ~3);
    for (; ptr < stop; ptr += 4) {
      HEAP32[((ptr)>>2)]=0;
    }
    stop = ret + size;
    while (ptr < stop) {
      HEAP8[((ptr++)>>0)]=0;
    }
    return ret;
  }

  if (singleType === 'i8') {
    if (slab.subarray || slab.slice) {
      HEAPU8.set(/** @type {!Uint8Array} */ (slab), ret);
    } else {
      HEAPU8.set(new Uint8Array(slab), ret);
    }
    return ret;
  }

  var i = 0, type, typeSize, previousType;
  while (i < size) {
    var curr = slab[i];

    type = singleType || types[i];
    if (type === 0) {
      i++;
      continue;
    }
    assert(type, 'Must know what type to store in allocate!');

    if (type == 'i64') type = 'i32'; // special case: we have one i32 here, and one i32 later

    setValue(ret+i, curr, type);

    // no need to look up size unless type changes, so cache it
    if (previousType !== type) {
      typeSize = getNativeTypeSize(type);
      previousType = type;
    }
    i += typeSize;
  }

  return ret;
}

// Allocate memory during any stage of startup - static memory early on, dynamic memory later, malloc when ready
function getMemory(size) {
  if (!runtimeInitialized) return dynamicAlloc(size);
  return _malloc(size);
}




/** @type {function(number, number=)} */
function Pointer_stringify(ptr, length) {
  abort("this function has been removed - you should use UTF8ToString(ptr, maxBytesToRead) instead!");
}

// Given a pointer 'ptr' to a null-terminated ASCII-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

function AsciiToString(ptr) {
  var str = '';
  while (1) {
    var ch = HEAPU8[((ptr++)>>0)];
    if (!ch) return str;
    str += String.fromCharCode(ch);
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in ASCII form. The copy will require at most str.length+1 bytes of space in the HEAP.

function stringToAscii(str, outPtr) {
  return writeAsciiToMemory(str, outPtr, false);
}


// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the given array that contains uint8 values, returns
// a copy of that string as a Javascript String object.

var UTF8Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf8') : undefined;

/**
 * @param {number} idx
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ArrayToString(u8Array, idx, maxBytesToRead) {
  var endIdx = idx + maxBytesToRead;
  var endPtr = idx;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  // (As a tiny code save trick, compare endPtr against endIdx using a negation, so that undefined means Infinity)
  while (u8Array[endPtr] && !(endPtr >= endIdx)) ++endPtr;

  if (endPtr - idx > 16 && u8Array.subarray && UTF8Decoder) {
    return UTF8Decoder.decode(u8Array.subarray(idx, endPtr));
  } else {
    var str = '';
    // If building with TextDecoder, we have already computed the string length above, so test loop end condition against that
    while (idx < endPtr) {
      // For UTF8 byte structure, see:
      // http://en.wikipedia.org/wiki/UTF-8#Description
      // https://www.ietf.org/rfc/rfc2279.txt
      // https://tools.ietf.org/html/rfc3629
      var u0 = u8Array[idx++];
      if (!(u0 & 0x80)) { str += String.fromCharCode(u0); continue; }
      var u1 = u8Array[idx++] & 63;
      if ((u0 & 0xE0) == 0xC0) { str += String.fromCharCode(((u0 & 31) << 6) | u1); continue; }
      var u2 = u8Array[idx++] & 63;
      if ((u0 & 0xF0) == 0xE0) {
        u0 = ((u0 & 15) << 12) | (u1 << 6) | u2;
      } else {
        if ((u0 & 0xF8) != 0xF0) warnOnce('Invalid UTF-8 leading byte 0x' + u0.toString(16) + ' encountered when deserializing a UTF-8 string on the asm.js/wasm heap to a JS string!');
        u0 = ((u0 & 7) << 18) | (u1 << 12) | (u2 << 6) | (u8Array[idx++] & 63);
      }

      if (u0 < 0x10000) {
        str += String.fromCharCode(u0);
      } else {
        var ch = u0 - 0x10000;
        str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
      }
    }
  }
  return str;
}

// Given a pointer 'ptr' to a null-terminated UTF8-encoded string in the emscripten HEAP, returns a
// copy of that string as a Javascript String object.
// maxBytesToRead: an optional length that specifies the maximum number of bytes to read. You can omit
//                 this parameter to scan the string until the first \0 byte. If maxBytesToRead is
//                 passed, and the string at [ptr, ptr+maxBytesToReadr[ contains a null byte in the
//                 middle, then the string will cut short at that byte index (i.e. maxBytesToRead will
//                 not produce a string of exact length [ptr, ptr+maxBytesToRead[)
//                 N.B. mixing frequent uses of UTF8ToString() with and without maxBytesToRead may
//                 throw JS JIT optimizations off, so it is worth to consider consistently using one
//                 style or the other.
/**
 * @param {number} ptr
 * @param {number=} maxBytesToRead
 * @return {string}
 */
function UTF8ToString(ptr, maxBytesToRead) {
  return ptr ? UTF8ArrayToString(HEAPU8, ptr, maxBytesToRead) : '';
}

// Copies the given Javascript String object 'str' to the given byte array at address 'outIdx',
// encoded in UTF8 form and null-terminated. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outU8Array: the array to copy to. Each index in this array is assumed to be one 8-byte element.
//   outIdx: The starting offset in the array to begin the copying.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array.
//                    This count should include the null terminator,
//                    i.e. if maxBytesToWrite=1, only the null terminator will be written and nothing else.
//                    maxBytesToWrite=0 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8Array(str, outU8Array, outIdx, maxBytesToWrite) {
  if (!(maxBytesToWrite > 0)) // Parameter maxBytesToWrite is not optional. Negative values, 0, null, undefined and false each don't write out any bytes.
    return 0;

  var startIdx = outIdx;
  var endIdx = outIdx + maxBytesToWrite - 1; // -1 for string null terminator.
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    // For UTF8 byte structure, see http://en.wikipedia.org/wiki/UTF-8#Description and https://www.ietf.org/rfc/rfc2279.txt and https://tools.ietf.org/html/rfc3629
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) {
      var u1 = str.charCodeAt(++i);
      u = 0x10000 + ((u & 0x3FF) << 10) | (u1 & 0x3FF);
    }
    if (u <= 0x7F) {
      if (outIdx >= endIdx) break;
      outU8Array[outIdx++] = u;
    } else if (u <= 0x7FF) {
      if (outIdx + 1 >= endIdx) break;
      outU8Array[outIdx++] = 0xC0 | (u >> 6);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else if (u <= 0xFFFF) {
      if (outIdx + 2 >= endIdx) break;
      outU8Array[outIdx++] = 0xE0 | (u >> 12);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    } else {
      if (outIdx + 3 >= endIdx) break;
      if (u >= 0x200000) warnOnce('Invalid Unicode code point 0x' + u.toString(16) + ' encountered when serializing a JS string to an UTF-8 string on the asm.js/wasm heap! (Valid unicode code points should be in range 0-0x1FFFFF).');
      outU8Array[outIdx++] = 0xF0 | (u >> 18);
      outU8Array[outIdx++] = 0x80 | ((u >> 12) & 63);
      outU8Array[outIdx++] = 0x80 | ((u >> 6) & 63);
      outU8Array[outIdx++] = 0x80 | (u & 63);
    }
  }
  // Null-terminate the pointer to the buffer.
  outU8Array[outIdx] = 0;
  return outIdx - startIdx;
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF8 form. The copy will require at most str.length*4+1 bytes of space in the HEAP.
// Use the function lengthBytesUTF8 to compute the exact number of bytes (excluding null terminator) that this function will write.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF8(str, outPtr, maxBytesToWrite) {
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF8(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  return stringToUTF8Array(str, HEAPU8,outPtr, maxBytesToWrite);
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF8 byte array, EXCLUDING the null terminator byte.
function lengthBytesUTF8(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! So decode UTF16->UTF32->UTF8.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var u = str.charCodeAt(i); // possibly a lead surrogate
    if (u >= 0xD800 && u <= 0xDFFF) u = 0x10000 + ((u & 0x3FF) << 10) | (str.charCodeAt(++i) & 0x3FF);
    if (u <= 0x7F) ++len;
    else if (u <= 0x7FF) len += 2;
    else if (u <= 0xFFFF) len += 3;
    else len += 4;
  }
  return len;
}


// Given a pointer 'ptr' to a null-terminated UTF16LE-encoded string in the emscripten HEAP, returns
// a copy of that string as a Javascript String object.

var UTF16Decoder = typeof TextDecoder !== 'undefined' ? new TextDecoder('utf-16le') : undefined;
function UTF16ToString(ptr) {
  assert(ptr % 2 == 0, 'Pointer passed to UTF16ToString must be aligned to two bytes!');
  var endPtr = ptr;
  // TextDecoder needs to know the byte length in advance, it doesn't stop on null terminator by itself.
  // Also, use the length info to avoid running tiny strings through TextDecoder, since .subarray() allocates garbage.
  var idx = endPtr >> 1;
  while (HEAP16[idx]) ++idx;
  endPtr = idx << 1;

  if (endPtr - ptr > 32 && UTF16Decoder) {
    return UTF16Decoder.decode(HEAPU8.subarray(ptr, endPtr));
  } else {
    var i = 0;

    var str = '';
    while (1) {
      var codeUnit = HEAP16[(((ptr)+(i*2))>>1)];
      if (codeUnit == 0) return str;
      ++i;
      // fromCharCode constructs a character from a UTF-16 code unit, so we can pass the UTF16 string right through.
      str += String.fromCharCode(codeUnit);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF16 form. The copy will require at most str.length*4+2 bytes of space in the HEAP.
// Use the function lengthBytesUTF16() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=2, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<2 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF16(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 2 == 0, 'Pointer passed to stringToUTF16 must be aligned to two bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF16(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 2) return 0;
  maxBytesToWrite -= 2; // Null terminator.
  var startPtr = outPtr;
  var numCharsToWrite = (maxBytesToWrite < str.length*2) ? (maxBytesToWrite / 2) : str.length;
  for (var i = 0; i < numCharsToWrite; ++i) {
    // charCodeAt returns a UTF-16 encoded code unit, so it can be directly written to the HEAP.
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    HEAP16[((outPtr)>>1)]=codeUnit;
    outPtr += 2;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP16[((outPtr)>>1)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF16(str) {
  return str.length*2;
}

function UTF32ToString(ptr) {
  assert(ptr % 4 == 0, 'Pointer passed to UTF32ToString must be aligned to four bytes!');
  var i = 0;

  var str = '';
  while (1) {
    var utf32 = HEAP32[(((ptr)+(i*4))>>2)];
    if (utf32 == 0)
      return str;
    ++i;
    // Gotcha: fromCharCode constructs a character from a UTF-16 encoded code (pair), not from a Unicode code point! So encode the code point to UTF-16 for constructing.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    if (utf32 >= 0x10000) {
      var ch = utf32 - 0x10000;
      str += String.fromCharCode(0xD800 | (ch >> 10), 0xDC00 | (ch & 0x3FF));
    } else {
      str += String.fromCharCode(utf32);
    }
  }
}

// Copies the given Javascript String object 'str' to the emscripten HEAP at address 'outPtr',
// null-terminated and encoded in UTF32 form. The copy will require at most str.length*4+4 bytes of space in the HEAP.
// Use the function lengthBytesUTF32() to compute the exact number of bytes (excluding null terminator) that this function will write.
// Parameters:
//   str: the Javascript string to copy.
//   outPtr: Byte address in Emscripten HEAP where to write the string to.
//   maxBytesToWrite: The maximum number of bytes this function can write to the array. This count should include the null
//                    terminator, i.e. if maxBytesToWrite=4, only the null terminator will be written and nothing else.
//                    maxBytesToWrite<4 does not write any bytes to the output, not even the null terminator.
// Returns the number of bytes written, EXCLUDING the null terminator.

function stringToUTF32(str, outPtr, maxBytesToWrite) {
  assert(outPtr % 4 == 0, 'Pointer passed to stringToUTF32 must be aligned to four bytes!');
  assert(typeof maxBytesToWrite == 'number', 'stringToUTF32(str, outPtr, maxBytesToWrite) is missing the third parameter that specifies the length of the output buffer!');
  // Backwards compatibility: if max bytes is not specified, assume unsafe unbounded write is allowed.
  if (maxBytesToWrite === undefined) {
    maxBytesToWrite = 0x7FFFFFFF;
  }
  if (maxBytesToWrite < 4) return 0;
  var startPtr = outPtr;
  var endPtr = startPtr + maxBytesToWrite - 4;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i); // possibly a lead surrogate
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) {
      var trailSurrogate = str.charCodeAt(++i);
      codeUnit = 0x10000 + ((codeUnit & 0x3FF) << 10) | (trailSurrogate & 0x3FF);
    }
    HEAP32[((outPtr)>>2)]=codeUnit;
    outPtr += 4;
    if (outPtr + 4 > endPtr) break;
  }
  // Null-terminate the pointer to the HEAP.
  HEAP32[((outPtr)>>2)]=0;
  return outPtr - startPtr;
}

// Returns the number of bytes the given Javascript string takes if encoded as a UTF16 byte array, EXCLUDING the null terminator byte.

function lengthBytesUTF32(str) {
  var len = 0;
  for (var i = 0; i < str.length; ++i) {
    // Gotcha: charCodeAt returns a 16-bit word that is a UTF-16 encoded code unit, not a Unicode code point of the character! We must decode the string to UTF-32 to the heap.
    // See http://unicode.org/faq/utf_bom.html#utf16-3
    var codeUnit = str.charCodeAt(i);
    if (codeUnit >= 0xD800 && codeUnit <= 0xDFFF) ++i; // possibly a lead surrogate, so skip over the tail surrogate.
    len += 4;
  }

  return len;
}

// Allocate heap space for a JS string, and write it there.
// It is the responsibility of the caller to free() that memory.
function allocateUTF8(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = _malloc(size);
  if (ret) stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Allocate stack space for a JS string, and write it there.
function allocateUTF8OnStack(str) {
  var size = lengthBytesUTF8(str) + 1;
  var ret = stackAlloc(size);
  stringToUTF8Array(str, HEAP8, ret, size);
  return ret;
}

// Deprecated: This function should not be called because it is unsafe and does not provide
// a maximum length limit of how many bytes it is allowed to write. Prefer calling the
// function stringToUTF8Array() instead, which takes in a maximum length that can be used
// to be secure from out of bounds writes.
/** @deprecated */
function writeStringToMemory(string, buffer, dontAddNull) {
  warnOnce('writeStringToMemory is deprecated and should not be called! Use stringToUTF8() instead!');

  var /** @type {number} */ lastChar, /** @type {number} */ end;
  if (dontAddNull) {
    // stringToUTF8Array always appends null. If we don't want to do that, remember the
    // character that existed at the location where the null will be placed, and restore
    // that after the write (below).
    end = buffer + lengthBytesUTF8(string);
    lastChar = HEAP8[end];
  }
  stringToUTF8(string, buffer, Infinity);
  if (dontAddNull) HEAP8[end] = lastChar; // Restore the value under the null character.
}

function writeArrayToMemory(array, buffer) {
  assert(array.length >= 0, 'writeArrayToMemory array must have a length (should be an array or typed array)')
  HEAP8.set(array, buffer);
}

function writeAsciiToMemory(str, buffer, dontAddNull) {
  for (var i = 0; i < str.length; ++i) {
    assert(str.charCodeAt(i) === str.charCodeAt(i)&0xff);
    HEAP8[((buffer++)>>0)]=str.charCodeAt(i);
  }
  // Null-terminate the pointer to the HEAP.
  if (!dontAddNull) HEAP8[((buffer)>>0)]=0;
}





function demangle(func) {
  warnOnce('warning: build with  -s DEMANGLE_SUPPORT=1  to link in libcxxabi demangling');
  return func;
}

function demangleAll(text) {
  var regex =
    /__Z[\w\d_]+/g;
  return text.replace(regex,
    function(x) {
      var y = demangle(x);
      return x === y ? x : (y + ' [' + x + ']');
    });
}

function jsStackTrace() {
  var err = new Error();
  if (!err.stack) {
    // IE10+ special cases: It does have callstack info, but it is only populated if an Error object is thrown,
    // so try that as a special-case.
    try {
      throw new Error(0);
    } catch(e) {
      err = e;
    }
    if (!err.stack) {
      return '(no stack trace available)';
    }
  }
  return err.stack.toString();
}

function stackTrace() {
  var js = jsStackTrace();
  if (Module['extraStackTrace']) js += '\n' + Module['extraStackTrace']();
  return demangleAll(js);
}



// Memory management

var PAGE_SIZE = 16384;
var WASM_PAGE_SIZE = 65536;
var ASMJS_PAGE_SIZE = 16777216;

function alignUp(x, multiple) {
  if (x % multiple > 0) {
    x += multiple - (x % multiple);
  }
  return x;
}

var HEAP,
/** @type {ArrayBuffer} */
  buffer,
/** @type {Int8Array} */
  HEAP8,
/** @type {Uint8Array} */
  HEAPU8,
/** @type {Int16Array} */
  HEAP16,
/** @type {Uint16Array} */
  HEAPU16,
/** @type {Int32Array} */
  HEAP32,
/** @type {Uint32Array} */
  HEAPU32,
/** @type {Float32Array} */
  HEAPF32,
/** @type {Float64Array} */
  HEAPF64;

function updateGlobalBufferViews() {
  Module['HEAP8'] = HEAP8 = new Int8Array(buffer);
  Module['HEAP16'] = HEAP16 = new Int16Array(buffer);
  Module['HEAP32'] = HEAP32 = new Int32Array(buffer);
  Module['HEAPU8'] = HEAPU8 = new Uint8Array(buffer);
  Module['HEAPU16'] = HEAPU16 = new Uint16Array(buffer);
  Module['HEAPU32'] = HEAPU32 = new Uint32Array(buffer);
  Module['HEAPF32'] = HEAPF32 = new Float32Array(buffer);
  Module['HEAPF64'] = HEAPF64 = new Float64Array(buffer);
}


var STATIC_BASE = 1024,
    STACK_BASE = 42896,
    STACKTOP = STACK_BASE,
    STACK_MAX = 5285776,
    DYNAMIC_BASE = 5285776,
    DYNAMICTOP_PTR = 42864;

assert(STACK_BASE % 16 === 0, 'stack must start aligned');
assert(DYNAMIC_BASE % 16 === 0, 'heap must start aligned');


function abortStackOverflowEmterpreter() {
  abort("Emterpreter stack overflow! Decrease the recursion level or increase EMT_STACK_MAX in tools/emterpretify.py (current value " + EMT_STACK_MAX + ").");
}

var TOTAL_STACK = 5242880;
if (Module['TOTAL_STACK']) assert(TOTAL_STACK === Module['TOTAL_STACK'], 'the stack size can no longer be determined at runtime')

var INITIAL_TOTAL_MEMORY = Module['TOTAL_MEMORY'] || 16777216;
if (INITIAL_TOTAL_MEMORY < TOTAL_STACK) err('TOTAL_MEMORY should be larger than TOTAL_STACK, was ' + INITIAL_TOTAL_MEMORY + '! (TOTAL_STACK=' + TOTAL_STACK + ')');

// Initialize the runtime's memory
// check for full engine support (use string 'subarray' to avoid closure compiler confusion)
assert(typeof Int32Array !== 'undefined' && typeof Float64Array !== 'undefined' && Int32Array.prototype.subarray !== undefined && Int32Array.prototype.set !== undefined,
       'JS engine does not provide full typed array support');







// Use a provided buffer, if there is one, or else allocate a new one
if (Module['buffer']) {
  buffer = Module['buffer'];
  assert(buffer.byteLength === INITIAL_TOTAL_MEMORY, 'provided buffer should be ' + INITIAL_TOTAL_MEMORY + ' bytes, but it is ' + buffer.byteLength);
} else {
  // Use a WebAssembly memory where available
  if (typeof WebAssembly === 'object' && typeof WebAssembly.Memory === 'function') {
    assert(INITIAL_TOTAL_MEMORY % WASM_PAGE_SIZE === 0);
    wasmMemory = new WebAssembly.Memory({ 'initial': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE, 'maximum': INITIAL_TOTAL_MEMORY / WASM_PAGE_SIZE });
    buffer = wasmMemory.buffer;
  } else
  {
    buffer = new ArrayBuffer(INITIAL_TOTAL_MEMORY);
  }
  assert(buffer.byteLength === INITIAL_TOTAL_MEMORY);
}
updateGlobalBufferViews();


HEAP32[DYNAMICTOP_PTR>>2] = DYNAMIC_BASE;


// Initializes the stack cookie. Called at the startup of main and at the startup of each thread in pthreads mode.
function writeStackCookie() {
  assert((STACK_MAX & 3) == 0);
  HEAPU32[(STACK_MAX >> 2)-1] = 0x02135467;
  HEAPU32[(STACK_MAX >> 2)-2] = 0x89BACDFE;
}

function checkStackCookie() {
  if (HEAPU32[(STACK_MAX >> 2)-1] != 0x02135467 || HEAPU32[(STACK_MAX >> 2)-2] != 0x89BACDFE) {
    abort('Stack overflow! Stack cookie has been overwritten, expected hex dwords 0x89BACDFE and 0x02135467, but received 0x' + HEAPU32[(STACK_MAX >> 2)-2].toString(16) + ' ' + HEAPU32[(STACK_MAX >> 2)-1].toString(16));
  }
  // Also test the global address 0 for integrity.
  if (HEAP32[0] !== 0x63736d65 /* 'emsc' */) throw 'Runtime error: The application has corrupted its heap memory area (address zero)!';
}

function abortStackOverflow(allocSize) {
  abort('Stack overflow! Attempted to allocate ' + allocSize + ' bytes on the stack, but stack has only ' + (STACK_MAX - stackSave() + allocSize) + ' bytes available!');
}


  HEAP32[0] = 0x63736d65; /* 'emsc' */



// Endianness check (note: assumes compiler arch was little-endian)
HEAP16[1] = 0x6373;
if (HEAPU8[2] !== 0x73 || HEAPU8[3] !== 0x63) throw 'Runtime error: expected the system to be little-endian!';

function callRuntimeCallbacks(callbacks) {
  while(callbacks.length > 0) {
    var callback = callbacks.shift();
    if (typeof callback == 'function') {
      callback();
      continue;
    }
    var func = callback.func;
    if (typeof func === 'number') {
      if (callback.arg === undefined) {
        Module['dynCall_v'](func);
      } else {
        Module['dynCall_vi'](func, callback.arg);
      }
    } else {
      func(callback.arg === undefined ? null : callback.arg);
    }
  }
}

var __ATPRERUN__  = []; // functions called before the runtime is initialized
var __ATINIT__    = []; // functions called during startup
var __ATMAIN__    = []; // functions called when main() is to be run
var __ATEXIT__    = []; // functions called during shutdown
var __ATPOSTRUN__ = []; // functions called after the main() is called

var runtimeInitialized = false;
var runtimeExited = false;


function preRun() {
  // compatibility - merge in anything from Module['preRun'] at this time
  if (Module['preRun']) {
    if (typeof Module['preRun'] == 'function') Module['preRun'] = [Module['preRun']];
    while (Module['preRun'].length) {
      addOnPreRun(Module['preRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPRERUN__);
}

function ensureInitRuntime() {
  checkStackCookie();
  if (runtimeInitialized) return;
  runtimeInitialized = true;
  
  callRuntimeCallbacks(__ATINIT__);
}

function preMain() {
  checkStackCookie();
  
  callRuntimeCallbacks(__ATMAIN__);
}

function exitRuntime() {
  checkStackCookie();
  runtimeExited = true;
}

function postRun() {
  checkStackCookie();
  // compatibility - merge in anything from Module['postRun'] at this time
  if (Module['postRun']) {
    if (typeof Module['postRun'] == 'function') Module['postRun'] = [Module['postRun']];
    while (Module['postRun'].length) {
      addOnPostRun(Module['postRun'].shift());
    }
  }
  callRuntimeCallbacks(__ATPOSTRUN__);
}

function addOnPreRun(cb) {
  __ATPRERUN__.unshift(cb);
}

function addOnInit(cb) {
  __ATINIT__.unshift(cb);
}

function addOnPreMain(cb) {
  __ATMAIN__.unshift(cb);
}

function addOnExit(cb) {
}

function addOnPostRun(cb) {
  __ATPOSTRUN__.unshift(cb);
}

function unSign(value, bits, ignore) {
  if (value >= 0) {
    return value;
  }
  return bits <= 32 ? 2*Math.abs(1 << (bits-1)) + value // Need some trickery, since if bits == 32, we are right at the limit of the bits JS uses in bitshifts
                    : Math.pow(2, bits)         + value;
}
function reSign(value, bits, ignore) {
  if (value <= 0) {
    return value;
  }
  var half = bits <= 32 ? Math.abs(1 << (bits-1)) // abs is needed if bits == 32
                        : Math.pow(2, bits-1);
  if (value >= half && (bits <= 32 || value > half)) { // for huge values, we can hit the precision limit and always get true here. so don't do that
                                                       // but, in general there is no perfect solution here. With 64-bit ints, we get rounding and errors
                                                       // TODO: In i64 mode 1, resign the two parts separately and safely
    value = -2*half + value; // Cannot bitshift half, as it may be at the limit of the bits JS uses in bitshifts
  }
  return value;
}


assert(Math.imul, 'This browser does not support Math.imul(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.fround, 'This browser does not support Math.fround(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.clz32, 'This browser does not support Math.clz32(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');
assert(Math.trunc, 'This browser does not support Math.trunc(), build with LEGACY_VM_SUPPORT or POLYFILL_OLD_MATH_FUNCTIONS to add in a polyfill');

var Math_abs = Math.abs;
var Math_cos = Math.cos;
var Math_sin = Math.sin;
var Math_tan = Math.tan;
var Math_acos = Math.acos;
var Math_asin = Math.asin;
var Math_atan = Math.atan;
var Math_atan2 = Math.atan2;
var Math_exp = Math.exp;
var Math_log = Math.log;
var Math_sqrt = Math.sqrt;
var Math_ceil = Math.ceil;
var Math_floor = Math.floor;
var Math_pow = Math.pow;
var Math_imul = Math.imul;
var Math_fround = Math.fround;
var Math_round = Math.round;
var Math_min = Math.min;
var Math_max = Math.max;
var Math_clz32 = Math.clz32;
var Math_trunc = Math.trunc;



// A counter of dependencies for calling run(). If we need to
// do asynchronous work before running, increment this and
// decrement it. Incrementing must happen in a place like
// Module.preRun (used by emcc to add file preloading).
// Note that you can add dependencies in preRun, even though
// it happens right before run - run will be postponed until
// the dependencies are met.
var runDependencies = 0;
var runDependencyWatcher = null;
var dependenciesFulfilled = null; // overridden to take different actions when all run dependencies are fulfilled
var runDependencyTracking = {};

function getUniqueRunDependency(id) {
  var orig = id;
  while (1) {
    if (!runDependencyTracking[id]) return id;
    id = orig + Math.random();
  }
  return id;
}

function addRunDependency(id) {
  runDependencies++;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(!runDependencyTracking[id]);
    runDependencyTracking[id] = 1;
    if (runDependencyWatcher === null && typeof setInterval !== 'undefined') {
      // Check for missing dependencies every few seconds
      runDependencyWatcher = setInterval(function() {
        if (ABORT) {
          clearInterval(runDependencyWatcher);
          runDependencyWatcher = null;
          return;
        }
        var shown = false;
        for (var dep in runDependencyTracking) {
          if (!shown) {
            shown = true;
            err('still waiting on run dependencies:');
          }
          err('dependency: ' + dep);
        }
        if (shown) {
          err('(end of list)');
        }
      }, 10000);
    }
  } else {
    err('warning: run dependency added without ID');
  }
}

function removeRunDependency(id) {
  runDependencies--;
  if (Module['monitorRunDependencies']) {
    Module['monitorRunDependencies'](runDependencies);
  }
  if (id) {
    assert(runDependencyTracking[id]);
    delete runDependencyTracking[id];
  } else {
    err('warning: run dependency removed without ID');
  }
  if (runDependencies == 0) {
    if (runDependencyWatcher !== null) {
      clearInterval(runDependencyWatcher);
      runDependencyWatcher = null;
    }
    if (dependenciesFulfilled) {
      var callback = dependenciesFulfilled;
      dependenciesFulfilled = null;
      callback(); // can add another dependenciesFulfilled
    }
  }
}

Module["preloadedImages"] = {}; // maps url to image data
Module["preloadedAudios"] = {}; // maps url to audio data


var memoryInitializer = null;



// show errors on likely calls to FS when it was not included
var FS = {
  error: function() {
    abort('Filesystem support (FS) was not included. The problem is that you are using files from JS, but files were not used from C/C++, so filesystem support was not auto-included. You can force-include filesystem support with  -s FORCE_FILESYSTEM=1');
  },
  init: function() { FS.error() },
  createDataFile: function() { FS.error() },
  createPreloadedFile: function() { FS.error() },
  createLazyFile: function() { FS.error() },
  open: function() { FS.error() },
  mkdev: function() { FS.error() },
  registerDevice: function() { FS.error() },
  analyzePath: function() { FS.error() },
  loadFilesFromDB: function() { FS.error() },

  ErrnoError: function ErrnoError() { FS.error() },
};
Module['FS_createDataFile'] = FS.createDataFile;
Module['FS_createPreloadedFile'] = FS.createPreloadedFile;



// Copyright 2017 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

// Prefix of data URIs emitted by SINGLE_FILE and related options.
var dataURIPrefix = 'data:application/octet-stream;base64,';

// Indicates whether filename is a base64 data URI.
function isDataURI(filename) {
  return String.prototype.startsWith ?
      filename.startsWith(dataURIPrefix) :
      filename.indexOf(dataURIPrefix) === 0;
}




var wasmBinaryFile = 'firmware.wasm';
if (!isDataURI(wasmBinaryFile)) {
  wasmBinaryFile = locateFile(wasmBinaryFile);
}

function getBinary() {
  try {
    if (Module['wasmBinary']) {
      return new Uint8Array(Module['wasmBinary']);
    }
    if (Module['readBinary']) {
      return Module['readBinary'](wasmBinaryFile);
    } else {
      throw "both async and sync fetching of the wasm failed";
    }
  }
  catch (err) {
    abort(err);
  }
}

function getBinaryPromise() {
  // if we don't have the binary yet, and have the Fetch api, use that
  // in some environments, like Electron's render process, Fetch api may be present, but have a different context than expected, let's only use it on the Web
  if (!Module['wasmBinary'] && (ENVIRONMENT_IS_WEB || ENVIRONMENT_IS_WORKER) && typeof fetch === 'function') {
    return fetch(wasmBinaryFile, { credentials: 'same-origin' }).then(function(response) {
      if (!response['ok']) {
        throw "failed to load wasm binary file at '" + wasmBinaryFile + "'";
      }
      return response['arrayBuffer']();
    }).catch(function () {
      return getBinary();
    });
  }
  // Otherwise, getBinary should be able to get it synchronously
  return new Promise(function(resolve, reject) {
    resolve(getBinary());
  });
}

// Create the wasm instance.
// Receives the wasm imports, returns the exports.
function createWasm(env) {
  // prepare imports
  var info = {
    'env': env
    ,
    'global': {
      'NaN': NaN,
      'Infinity': Infinity
    },
    'global.Math': Math,
    'asm2wasm': asm2wasmImports
  };
  // Load the wasm module and create an instance of using native support in the JS engine.
  // handle a generated wasm instance, receiving its exports and
  // performing other necessary setup
  function receiveInstance(instance, module) {
    var exports = instance.exports;
    Module['asm'] = exports;
    removeRunDependency('wasm-instantiate');
  }
  addRunDependency('wasm-instantiate');

  // User shell pages can write their own Module.instantiateWasm = function(imports, successCallback) callback
  // to manually instantiate the Wasm module themselves. This allows pages to run the instantiation parallel
  // to any other async startup actions they are performing.
  if (Module['instantiateWasm']) {
    try {
      return Module['instantiateWasm'](info, receiveInstance);
    } catch(e) {
      err('Module.instantiateWasm callback failed with error: ' + e);
      return false;
    }
  }

  // Async compilation can be confusing when an error on the page overwrites Module
  // (for example, if the order of elements is wrong, and the one defining Module is
  // later), so we save Module and check it later.
  var trueModule = Module;
  function receiveInstantiatedSource(output) {
    // 'output' is a WebAssemblyInstantiatedSource object which has both the module and instance.
    // receiveInstance() will swap in the exports (to Module.asm) so they can be called
    assert(Module === trueModule, 'the Module object should not be replaced during async compilation - perhaps the order of HTML elements is wrong?');
    trueModule = null;
      // TODO: Due to Closure regression https://github.com/google/closure-compiler/issues/3193, the above line no longer optimizes out down to the following line.
      // When the regression is fixed, can restore the above USE_PTHREADS-enabled path.
    receiveInstance(output['instance']);
  }
  function instantiateArrayBuffer(receiver) {
    getBinaryPromise().then(function(binary) {
      return WebAssembly.instantiate(binary, info);
    }).then(receiver, function(reason) {
      err('failed to asynchronously prepare wasm: ' + reason);
      abort(reason);
    });
  }
  // Prefer streaming instantiation if available.
  if (!Module['wasmBinary'] &&
      typeof WebAssembly.instantiateStreaming === 'function' &&
      !isDataURI(wasmBinaryFile) &&
      typeof fetch === 'function') {
    WebAssembly.instantiateStreaming(fetch(wasmBinaryFile, { credentials: 'same-origin' }), info)
      .then(receiveInstantiatedSource, function(reason) {
        // We expect the most common failure cause to be a bad MIME type for the binary,
        // in which case falling back to ArrayBuffer instantiation should work.
        err('wasm streaming compile failed: ' + reason);
        err('falling back to ArrayBuffer instantiation');
        instantiateArrayBuffer(receiveInstantiatedSource);
      });
  } else {
    instantiateArrayBuffer(receiveInstantiatedSource);
  }
  return {}; // no exports yet; we'll fill them in later
}

// Provide an "asm.js function" for the application, called to "link" the asm.js module. We instantiate
// the wasm module at that time, and it receives imports and provides exports and so forth, the app
// doesn't need to care that it is wasm or asm.js.

Module['asm'] = function(global, env, providedBuffer) {
  // memory was already allocated (so js could use the buffer)
  env['memory'] = wasmMemory
  ;
  // import table
  env['table'] = wasmTable = new WebAssembly.Table({
    'initial': 13824,
    'maximum': 13824,
    'element': 'anyfunc'
  });
  // With the wasm backend __memory_base and __table_base and only needed for
  // relocatable output.
  env['__memory_base'] = 1024; // tell the memory segments where to place themselves
  // table starts at 0 by default (even in dynamic linking, for the main module)
  env['__table_base'] = 0;

  var exports = createWasm(env);
  assert(exports, 'binaryen setup failed (no wasm support?)');
  return exports;
};

// === Body ===

var ASM_CONSTS = [];





// STATICTOP = STATIC_BASE + 41872;
/* global initializers */ /*__ATINIT__.push();*/








/* no memory initializer */
var tempDoublePtr = 42880
assert(tempDoublePtr % 8 == 0);

function copyTempFloat(ptr) { // functions, because inlining this code increases code size too much
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];
  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];
  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];
}

function copyTempDouble(ptr) {
  HEAP8[tempDoublePtr] = HEAP8[ptr];
  HEAP8[tempDoublePtr+1] = HEAP8[ptr+1];
  HEAP8[tempDoublePtr+2] = HEAP8[ptr+2];
  HEAP8[tempDoublePtr+3] = HEAP8[ptr+3];
  HEAP8[tempDoublePtr+4] = HEAP8[ptr+4];
  HEAP8[tempDoublePtr+5] = HEAP8[ptr+5];
  HEAP8[tempDoublePtr+6] = HEAP8[ptr+6];
  HEAP8[tempDoublePtr+7] = HEAP8[ptr+7];
}

// {{PRE_LIBRARY}}


  function ___lock() {}

  
    

  
  var SYSCALLS={buffers:[null,[],[]],printChar:function (stream, curr) {
        var buffer = SYSCALLS.buffers[stream];
        assert(buffer);
        if (curr === 0 || curr === 10) {
          (stream === 1 ? out : err)(UTF8ArrayToString(buffer, 0));
          buffer.length = 0;
        } else {
          buffer.push(curr);
        }
      },varargs:0,get:function (varargs) {
        SYSCALLS.varargs += 4;
        var ret = HEAP32[(((SYSCALLS.varargs)-(4))>>2)];
        return ret;
      },getStr:function () {
        var ret = UTF8ToString(SYSCALLS.get());
        return ret;
      },get64:function () {
        var low = SYSCALLS.get(), high = SYSCALLS.get();
        if (low >= 0) assert(high === 0);
        else assert(high === -1);
        return low;
      },getZero:function () {
        assert(SYSCALLS.get() === 0);
      }};function ___syscall140(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // llseek
      var stream = SYSCALLS.getStreamFromFD(), offset_high = SYSCALLS.get(), offset_low = SYSCALLS.get(), result = SYSCALLS.get(), whence = SYSCALLS.get();
      abort('it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM');
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  
  function flush_NO_FILESYSTEM() {
      // flush anything remaining in the buffers during shutdown
      var fflush = Module["_fflush"];
      if (fflush) fflush(0);
      var buffers = SYSCALLS.buffers;
      if (buffers[1].length) SYSCALLS.printChar(1, 10);
      if (buffers[2].length) SYSCALLS.printChar(2, 10);
    }function ___syscall146(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // writev
      // hack to support printf in SYSCALLS_REQUIRE_FILESYSTEM=0
      var stream = SYSCALLS.get(), iov = SYSCALLS.get(), iovcnt = SYSCALLS.get();
      var ret = 0;
      for (var i = 0; i < iovcnt; i++) {
        var ptr = HEAP32[(((iov)+(i*8))>>2)];
        var len = HEAP32[(((iov)+(i*8 + 4))>>2)];
        for (var j = 0; j < len; j++) {
          SYSCALLS.printChar(stream, HEAPU8[ptr+j]);
        }
        ret += len;
      }
      return ret;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall54(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // ioctl
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  function ___syscall6(which, varargs) {SYSCALLS.varargs = varargs;
  try {
   // close
      var stream = SYSCALLS.getStreamFromFD();
      abort('it should not be possible to operate on streams when !SYSCALLS_REQUIRE_FILESYSTEM');
      return 0;
    } catch (e) {
    if (typeof FS === 'undefined' || !(e instanceof FS.ErrnoError)) abort(e);
    return -e.errno;
  }
  }

  
  
   
  
   
  
  function _llvm_cttz_i32(x) { // Note: Currently doesn't take isZeroUndef()
      x = x | 0;
      return (x ? (31 - (Math_clz32((x ^ (x - 1))) | 0) | 0) : 32) | 0;
    }  

  function ___unlock() {}

   

   

   

  function _emscripten_get_heap_size() {
      return HEAP8.length;
    }

  
  
   
  
   
  
   function _longjmp(env, value) {
      _setThrew(env, value || 1);
      throw 'longjmp';
    }function _emscripten_longjmp(env, value) {
      _longjmp(env, value);
    }

  
  function abortOnCannotGrowMemory(requestedSize) {
      abort('Cannot enlarge memory arrays to size ' + requestedSize + ' bytes (OOM). Either (1) compile with  -s TOTAL_MEMORY=X  with X higher than the current value ' + HEAP8.length + ', (2) compile with  -s ALLOW_MEMORY_GROWTH=1  which allows increasing the size at runtime, or (3) if you want malloc to return NULL (0) instead of this abort, compile with  -s ABORTING_MALLOC=0 ');
    }function _emscripten_resize_heap(requestedSize) {
      abortOnCannotGrowMemory(requestedSize);
    }

  function _emscripten_run_script_string(ptr) {
      var s = eval(UTF8ToString(ptr)) + '';
      var me = _emscripten_run_script_string;
      var len = lengthBytesUTF8(s);
      if (!me.bufferSize || me.bufferSize < len+1) {
        if (me.bufferSize) _free(me.buffer);
        me.bufferSize = len+1;
        me.buffer = _malloc(me.bufferSize);
      }
      stringToUTF8(s, me.buffer, me.bufferSize);
      return me.buffer;
    }

  
  
  
  
  function _emscripten_set_main_loop_timing(mode, value) {
      Browser.mainLoop.timingMode = mode;
      Browser.mainLoop.timingValue = value;
  
      if (!Browser.mainLoop.func) {
        console.error('emscripten_set_main_loop_timing: Cannot set timing mode for main loop since a main loop does not exist! Call emscripten_set_main_loop first to set one up.');
        return 1; // Return non-zero on failure, can't set timing mode when there is no main loop.
      }
  
      if (mode == 0 /*EM_TIMING_SETTIMEOUT*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setTimeout() {
          var timeUntilNextTick = Math.max(0, Browser.mainLoop.tickStartTime + value - _emscripten_get_now())|0;
          setTimeout(Browser.mainLoop.runner, timeUntilNextTick); // doing this each time means that on exception, we stop
        };
        Browser.mainLoop.method = 'timeout';
      } else if (mode == 1 /*EM_TIMING_RAF*/) {
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_rAF() {
          Browser.requestAnimationFrame(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'rAF';
      } else if (mode == 2 /*EM_TIMING_SETIMMEDIATE*/) {
        if (typeof setImmediate === 'undefined') {
          // Emulate setImmediate. (note: not a complete polyfill, we don't emulate clearImmediate() to keep code size to minimum, since not needed)
          var setImmediates = [];
          var emscriptenMainLoopMessageId = 'setimmediate';
          var Browser_setImmediate_messageHandler = function(event) {
            // When called in current thread or Worker, the main loop ID is structured slightly different to accommodate for --proxy-to-worker runtime listening to Worker events,
            // so check for both cases.
            if (event.data === emscriptenMainLoopMessageId || event.data.target === emscriptenMainLoopMessageId) {
              event.stopPropagation();
              setImmediates.shift()();
            }
          }
          addEventListener("message", Browser_setImmediate_messageHandler, true);
          setImmediate = function Browser_emulated_setImmediate(func) {
            setImmediates.push(func);
            if (ENVIRONMENT_IS_WORKER) {
              if (Module['setImmediates'] === undefined) Module['setImmediates'] = [];
              Module['setImmediates'].push(func);
              postMessage({target: emscriptenMainLoopMessageId}); // In --proxy-to-worker, route the message via proxyClient.js
            } else postMessage(emscriptenMainLoopMessageId, "*"); // On the main thread, can just send the message to itself.
          }
        }
        Browser.mainLoop.scheduler = function Browser_mainLoop_scheduler_setImmediate() {
          setImmediate(Browser.mainLoop.runner);
        };
        Browser.mainLoop.method = 'immediate';
      }
      return 0;
    }
  
  function _emscripten_get_now() { abort() }function _emscripten_set_main_loop(func, fps, simulateInfiniteLoop, arg, noSetTiming) {
      Module['noExitRuntime'] = true;
  
      assert(!Browser.mainLoop.func, 'emscripten_set_main_loop: there can only be one main loop function at once: call emscripten_cancel_main_loop to cancel the previous one before setting a new one with different parameters.');
  
      Browser.mainLoop.func = func;
      Browser.mainLoop.arg = arg;
  
      var browserIterationFunc;
      if (typeof arg !== 'undefined') {
        browserIterationFunc = function() {
          Module['dynCall_vi'](func, arg);
        };
      } else {
        browserIterationFunc = function() {
          Module['dynCall_v'](func);
        };
      }
  
      var thisMainLoopId = Browser.mainLoop.currentlyRunningMainloop;
  
      Browser.mainLoop.runner = function Browser_mainLoop_runner() {
        if (ABORT) return;
        if (Browser.mainLoop.queue.length > 0) {
          var start = Date.now();
          var blocker = Browser.mainLoop.queue.shift();
          blocker.func(blocker.arg);
          if (Browser.mainLoop.remainingBlockers) {
            var remaining = Browser.mainLoop.remainingBlockers;
            var next = remaining%1 == 0 ? remaining-1 : Math.floor(remaining);
            if (blocker.counted) {
              Browser.mainLoop.remainingBlockers = next;
            } else {
              // not counted, but move the progress along a tiny bit
              next = next + 0.5; // do not steal all the next one's progress
              Browser.mainLoop.remainingBlockers = (8*remaining + next)/9;
            }
          }
          console.log('main loop blocker "' + blocker.name + '" took ' + (Date.now() - start) + ' ms'); //, left: ' + Browser.mainLoop.remainingBlockers);
          Browser.mainLoop.updateStatus();
  
          // catches pause/resume main loop from blocker execution
          if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
          setTimeout(Browser.mainLoop.runner, 0);
          return;
        }
  
        // catch pauses from non-main loop sources
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
        // Implement very basic swap interval control
        Browser.mainLoop.currentFrameNumber = Browser.mainLoop.currentFrameNumber + 1 | 0;
        if (Browser.mainLoop.timingMode == 1/*EM_TIMING_RAF*/ && Browser.mainLoop.timingValue > 1 && Browser.mainLoop.currentFrameNumber % Browser.mainLoop.timingValue != 0) {
          // Not the scheduled time to render this frame - skip.
          Browser.mainLoop.scheduler();
          return;
        } else if (Browser.mainLoop.timingMode == 0/*EM_TIMING_SETTIMEOUT*/) {
          Browser.mainLoop.tickStartTime = _emscripten_get_now();
        }
  
        // Signal GL rendering layer that processing of a new frame is about to start. This helps it optimize
        // VBO double-buffering and reduce GPU stalls.
  
  
  
        if (Browser.mainLoop.method === 'timeout' && Module.ctx) {
          err('Looks like you are rendering without using requestAnimationFrame for the main loop. You should use 0 for the frame rate in emscripten_set_main_loop in order to use requestAnimationFrame, as that can greatly improve your frame rates!');
          Browser.mainLoop.method = ''; // just warn once per call to set main loop
        }
  
        Browser.mainLoop.runIter(browserIterationFunc);
  
        checkStackCookie();
  
        // catch pauses from the main loop itself
        if (thisMainLoopId < Browser.mainLoop.currentlyRunningMainloop) return;
  
        // Queue new audio data. This is important to be right after the main loop invocation, so that we will immediately be able
        // to queue the newest produced audio samples.
        // TODO: Consider adding pre- and post- rAF callbacks so that GL.newRenderingFrameStarted() and SDL.audio.queueNewAudioData()
        //       do not need to be hardcoded into this function, but can be more generic.
        if (typeof SDL === 'object' && SDL.audio && SDL.audio.queueNewAudioData) SDL.audio.queueNewAudioData();
  
        Browser.mainLoop.scheduler();
      }
  
      if (!noSetTiming) {
        if (fps && fps > 0) _emscripten_set_main_loop_timing(0/*EM_TIMING_SETTIMEOUT*/, 1000.0 / fps);
        else _emscripten_set_main_loop_timing(1/*EM_TIMING_RAF*/, 1); // Do rAF by rendering each frame (no decimating)
  
        Browser.mainLoop.scheduler();
      }
  
      if (simulateInfiniteLoop) {
        throw 'SimulateInfiniteLoop';
      }
    }var Browser={mainLoop:{scheduler:null,method:"",currentlyRunningMainloop:0,func:null,arg:0,timingMode:0,timingValue:0,currentFrameNumber:0,queue:[],pause:function () {
          Browser.mainLoop.scheduler = null;
          Browser.mainLoop.currentlyRunningMainloop++; // Incrementing this signals the previous main loop that it's now become old, and it must return.
        },resume:function () {
          Browser.mainLoop.currentlyRunningMainloop++;
          var timingMode = Browser.mainLoop.timingMode;
          var timingValue = Browser.mainLoop.timingValue;
          var func = Browser.mainLoop.func;
          Browser.mainLoop.func = null;
          _emscripten_set_main_loop(func, 0, false, Browser.mainLoop.arg, true /* do not set timing and call scheduler, we will do it on the next lines */);
          _emscripten_set_main_loop_timing(timingMode, timingValue);
          Browser.mainLoop.scheduler();
        },updateStatus:function () {
          if (Module['setStatus']) {
            var message = Module['statusMessage'] || 'Please wait...';
            var remaining = Browser.mainLoop.remainingBlockers;
            var expected = Browser.mainLoop.expectedBlockers;
            if (remaining) {
              if (remaining < expected) {
                Module['setStatus'](message + ' (' + (expected - remaining) + '/' + expected + ')');
              } else {
                Module['setStatus'](message);
              }
            } else {
              Module['setStatus']('');
            }
          }
        },runIter:function (func) {
          if (ABORT) return;
          if (Module['preMainLoop']) {
            var preRet = Module['preMainLoop']();
            if (preRet === false) {
              return; // |return false| skips a frame
            }
          }
          try {
            func();
          } catch (e) {
            if (e instanceof ExitStatus) {
              return;
            } else {
              if (e && typeof e === 'object' && e.stack) err('exception thrown: ' + [e, e.stack]);
              throw e;
            }
          }
          if (Module['postMainLoop']) Module['postMainLoop']();
        }},isFullscreen:false,pointerLock:false,moduleContextCreatedCallbacks:[],workers:[],init:function () {
        if (!Module["preloadPlugins"]) Module["preloadPlugins"] = []; // needs to exist even in workers
  
        if (Browser.initted) return;
        Browser.initted = true;
  
        try {
          new Blob();
          Browser.hasBlobConstructor = true;
        } catch(e) {
          Browser.hasBlobConstructor = false;
          console.log("warning: no blob constructor, cannot create blobs with mimetypes");
        }
        Browser.BlobBuilder = typeof MozBlobBuilder != "undefined" ? MozBlobBuilder : (typeof WebKitBlobBuilder != "undefined" ? WebKitBlobBuilder : (!Browser.hasBlobConstructor ? console.log("warning: no BlobBuilder") : null));
        Browser.URLObject = typeof window != "undefined" ? (window.URL ? window.URL : window.webkitURL) : undefined;
        if (!Module.noImageDecoding && typeof Browser.URLObject === 'undefined') {
          console.log("warning: Browser does not support creating object URLs. Built-in browser image decoding will not be available.");
          Module.noImageDecoding = true;
        }
  
        // Support for plugins that can process preloaded files. You can add more of these to
        // your app by creating and appending to Module.preloadPlugins.
        //
        // Each plugin is asked if it can handle a file based on the file's name. If it can,
        // it is given the file's raw data. When it is done, it calls a callback with the file's
        // (possibly modified) data. For example, a plugin might decompress a file, or it
        // might create some side data structure for use later (like an Image element, etc.).
  
        var imagePlugin = {};
        imagePlugin['canHandle'] = function imagePlugin_canHandle(name) {
          return !Module.noImageDecoding && /\.(jpg|jpeg|png|bmp)$/i.test(name);
        };
        imagePlugin['handle'] = function imagePlugin_handle(byteArray, name, onload, onerror) {
          var b = null;
          if (Browser.hasBlobConstructor) {
            try {
              b = new Blob([byteArray], { type: Browser.getMimetype(name) });
              if (b.size !== byteArray.length) { // Safari bug #118630
                // Safari's Blob can only take an ArrayBuffer
                b = new Blob([(new Uint8Array(byteArray)).buffer], { type: Browser.getMimetype(name) });
              }
            } catch(e) {
              warnOnce('Blob constructor present but fails: ' + e + '; falling back to blob builder');
            }
          }
          if (!b) {
            var bb = new Browser.BlobBuilder();
            bb.append((new Uint8Array(byteArray)).buffer); // we need to pass a buffer, and must copy the array to get the right data range
            b = bb.getBlob();
          }
          var url = Browser.URLObject.createObjectURL(b);
          assert(typeof url == 'string', 'createObjectURL must return a url as a string');
          var img = new Image();
          img.onload = function img_onload() {
            assert(img.complete, 'Image ' + name + ' could not be decoded');
            var canvas = document.createElement('canvas');
            canvas.width = img.width;
            canvas.height = img.height;
            var ctx = canvas.getContext('2d');
            ctx.drawImage(img, 0, 0);
            Module["preloadedImages"][name] = canvas;
            Browser.URLObject.revokeObjectURL(url);
            if (onload) onload(byteArray);
          };
          img.onerror = function img_onerror(event) {
            console.log('Image ' + url + ' could not be decoded');
            if (onerror) onerror();
          };
          img.src = url;
        };
        Module['preloadPlugins'].push(imagePlugin);
  
        var audioPlugin = {};
        audioPlugin['canHandle'] = function audioPlugin_canHandle(name) {
          return !Module.noAudioDecoding && name.substr(-4) in { '.ogg': 1, '.wav': 1, '.mp3': 1 };
        };
        audioPlugin['handle'] = function audioPlugin_handle(byteArray, name, onload, onerror) {
          var done = false;
          function finish(audio) {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = audio;
            if (onload) onload(byteArray);
          }
          function fail() {
            if (done) return;
            done = true;
            Module["preloadedAudios"][name] = new Audio(); // empty shim
            if (onerror) onerror();
          }
          if (Browser.hasBlobConstructor) {
            try {
              var b = new Blob([byteArray], { type: Browser.getMimetype(name) });
            } catch(e) {
              return fail();
            }
            var url = Browser.URLObject.createObjectURL(b); // XXX we never revoke this!
            assert(typeof url == 'string', 'createObjectURL must return a url as a string');
            var audio = new Audio();
            audio.addEventListener('canplaythrough', function() { finish(audio) }, false); // use addEventListener due to chromium bug 124926
            audio.onerror = function audio_onerror(event) {
              if (done) return;
              console.log('warning: browser could not fully decode audio ' + name + ', trying slower base64 approach');
              function encode64(data) {
                var BASE = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
                var PAD = '=';
                var ret = '';
                var leftchar = 0;
                var leftbits = 0;
                for (var i = 0; i < data.length; i++) {
                  leftchar = (leftchar << 8) | data[i];
                  leftbits += 8;
                  while (leftbits >= 6) {
                    var curr = (leftchar >> (leftbits-6)) & 0x3f;
                    leftbits -= 6;
                    ret += BASE[curr];
                  }
                }
                if (leftbits == 2) {
                  ret += BASE[(leftchar&3) << 4];
                  ret += PAD + PAD;
                } else if (leftbits == 4) {
                  ret += BASE[(leftchar&0xf) << 2];
                  ret += PAD;
                }
                return ret;
              }
              audio.src = 'data:audio/x-' + name.substr(-3) + ';base64,' + encode64(byteArray);
              finish(audio); // we don't wait for confirmation this worked - but it's worth trying
            };
            audio.src = url;
            // workaround for chrome bug 124926 - we do not always get oncanplaythrough or onerror
            Browser.safeSetTimeout(function() {
              finish(audio); // try to use it even though it is not necessarily ready to play
            }, 10000);
          } else {
            return fail();
          }
        };
        Module['preloadPlugins'].push(audioPlugin);
  
  
        // Canvas event setup
  
        function pointerLockChange() {
          Browser.pointerLock = document['pointerLockElement'] === Module['canvas'] ||
                                document['mozPointerLockElement'] === Module['canvas'] ||
                                document['webkitPointerLockElement'] === Module['canvas'] ||
                                document['msPointerLockElement'] === Module['canvas'];
        }
        var canvas = Module['canvas'];
        if (canvas) {
          // forced aspect ratio can be enabled by defining 'forcedAspectRatio' on Module
          // Module['forcedAspectRatio'] = 4 / 3;
  
          canvas.requestPointerLock = canvas['requestPointerLock'] ||
                                      canvas['mozRequestPointerLock'] ||
                                      canvas['webkitRequestPointerLock'] ||
                                      canvas['msRequestPointerLock'] ||
                                      function(){};
          canvas.exitPointerLock = document['exitPointerLock'] ||
                                   document['mozExitPointerLock'] ||
                                   document['webkitExitPointerLock'] ||
                                   document['msExitPointerLock'] ||
                                   function(){}; // no-op if function does not exist
          canvas.exitPointerLock = canvas.exitPointerLock.bind(document);
  
          document.addEventListener('pointerlockchange', pointerLockChange, false);
          document.addEventListener('mozpointerlockchange', pointerLockChange, false);
          document.addEventListener('webkitpointerlockchange', pointerLockChange, false);
          document.addEventListener('mspointerlockchange', pointerLockChange, false);
  
          if (Module['elementPointerLock']) {
            canvas.addEventListener("click", function(ev) {
              if (!Browser.pointerLock && Module['canvas'].requestPointerLock) {
                Module['canvas'].requestPointerLock();
                ev.preventDefault();
              }
            }, false);
          }
        }
      },createContext:function (canvas, useWebGL, setInModule, webGLContextAttributes) {
        if (useWebGL && Module.ctx && canvas == Module.canvas) return Module.ctx; // no need to recreate GL context if it's already been created for this canvas.
  
        var ctx;
        var contextHandle;
        if (useWebGL) {
          // For GLES2/desktop GL compatibility, adjust a few defaults to be different to WebGL defaults, so that they align better with the desktop defaults.
          var contextAttributes = {
            antialias: false,
            alpha: false,
            majorVersion: 1,
          };
  
          if (webGLContextAttributes) {
            for (var attribute in webGLContextAttributes) {
              contextAttributes[attribute] = webGLContextAttributes[attribute];
            }
          }
  
          // This check of existence of GL is here to satisfy Closure compiler, which yells if variable GL is referenced below but GL object is not
          // actually compiled in because application is not doing any GL operations. TODO: Ideally if GL is not being used, this function
          // Browser.createContext() should not even be emitted.
          if (typeof GL !== 'undefined') {
            contextHandle = GL.createContext(canvas, contextAttributes);
            if (contextHandle) {
              ctx = GL.getContext(contextHandle).GLctx;
            }
          }
        } else {
          ctx = canvas.getContext('2d');
        }
  
        if (!ctx) return null;
  
        if (setInModule) {
          if (!useWebGL) assert(typeof GLctx === 'undefined', 'cannot set in module if GLctx is used, but we are a non-GL context that would replace it');
  
          Module.ctx = ctx;
          if (useWebGL) GL.makeContextCurrent(contextHandle);
          Module.useWebGL = useWebGL;
          Browser.moduleContextCreatedCallbacks.forEach(function(callback) { callback() });
          Browser.init();
        }
        return ctx;
      },destroyContext:function (canvas, useWebGL, setInModule) {},fullscreenHandlersInstalled:false,lockPointer:undefined,resizeCanvas:undefined,requestFullscreen:function (lockPointer, resizeCanvas, vrDevice) {
        Browser.lockPointer = lockPointer;
        Browser.resizeCanvas = resizeCanvas;
        Browser.vrDevice = vrDevice;
        if (typeof Browser.lockPointer === 'undefined') Browser.lockPointer = true;
        if (typeof Browser.resizeCanvas === 'undefined') Browser.resizeCanvas = false;
        if (typeof Browser.vrDevice === 'undefined') Browser.vrDevice = null;
  
        var canvas = Module['canvas'];
        function fullscreenChange() {
          Browser.isFullscreen = false;
          var canvasContainer = canvas.parentNode;
          if ((document['fullscreenElement'] || document['mozFullScreenElement'] ||
               document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
               document['webkitCurrentFullScreenElement']) === canvasContainer) {
            canvas.exitFullscreen = Browser.exitFullscreen;
            if (Browser.lockPointer) canvas.requestPointerLock();
            Browser.isFullscreen = true;
            if (Browser.resizeCanvas) {
              Browser.setFullscreenCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          } else {
            // remove the full screen specific parent of the canvas again to restore the HTML structure from before going full screen
            canvasContainer.parentNode.insertBefore(canvas, canvasContainer);
            canvasContainer.parentNode.removeChild(canvasContainer);
  
            if (Browser.resizeCanvas) {
              Browser.setWindowedCanvasSize();
            } else {
              Browser.updateCanvasDimensions(canvas);
            }
          }
          if (Module['onFullScreen']) Module['onFullScreen'](Browser.isFullscreen);
          if (Module['onFullscreen']) Module['onFullscreen'](Browser.isFullscreen);
        }
  
        if (!Browser.fullscreenHandlersInstalled) {
          Browser.fullscreenHandlersInstalled = true;
          document.addEventListener('fullscreenchange', fullscreenChange, false);
          document.addEventListener('mozfullscreenchange', fullscreenChange, false);
          document.addEventListener('webkitfullscreenchange', fullscreenChange, false);
          document.addEventListener('MSFullscreenChange', fullscreenChange, false);
        }
  
        // create a new parent to ensure the canvas has no siblings. this allows browsers to optimize full screen performance when its parent is the full screen root
        var canvasContainer = document.createElement("div");
        canvas.parentNode.insertBefore(canvasContainer, canvas);
        canvasContainer.appendChild(canvas);
  
        // use parent of canvas as full screen root to allow aspect ratio correction (Firefox stretches the root to screen size)
        canvasContainer.requestFullscreen = canvasContainer['requestFullscreen'] ||
                                            canvasContainer['mozRequestFullScreen'] ||
                                            canvasContainer['msRequestFullscreen'] ||
                                           (canvasContainer['webkitRequestFullscreen'] ? function() { canvasContainer['webkitRequestFullscreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null) ||
                                           (canvasContainer['webkitRequestFullScreen'] ? function() { canvasContainer['webkitRequestFullScreen'](Element['ALLOW_KEYBOARD_INPUT']) } : null);
  
        if (vrDevice) {
          canvasContainer.requestFullscreen({ vrDisplay: vrDevice });
        } else {
          canvasContainer.requestFullscreen();
        }
      },requestFullScreen:function (lockPointer, resizeCanvas, vrDevice) {
          err('Browser.requestFullScreen() is deprecated. Please call Browser.requestFullscreen instead.');
          Browser.requestFullScreen = function(lockPointer, resizeCanvas, vrDevice) {
            return Browser.requestFullscreen(lockPointer, resizeCanvas, vrDevice);
          }
          return Browser.requestFullscreen(lockPointer, resizeCanvas, vrDevice);
      },exitFullscreen:function () {
        // This is workaround for chrome. Trying to exit from fullscreen
        // not in fullscreen state will cause "TypeError: Document not active"
        // in chrome. See https://github.com/emscripten-core/emscripten/pull/8236
        if (!Browser.isFullscreen) {
          return false;
        }
  
        var CFS = document['exitFullscreen'] ||
                  document['cancelFullScreen'] ||
                  document['mozCancelFullScreen'] ||
                  document['msExitFullscreen'] ||
                  document['webkitCancelFullScreen'] ||
            (function() {});
        CFS.apply(document, []);
        return true;
      },nextRAF:0,fakeRequestAnimationFrame:function (func) {
        // try to keep 60fps between calls to here
        var now = Date.now();
        if (Browser.nextRAF === 0) {
          Browser.nextRAF = now + 1000/60;
        } else {
          while (now + 2 >= Browser.nextRAF) { // fudge a little, to avoid timer jitter causing us to do lots of delay:0
            Browser.nextRAF += 1000/60;
          }
        }
        var delay = Math.max(Browser.nextRAF - now, 0);
        setTimeout(func, delay);
      },requestAnimationFrame:function requestAnimationFrame(func) {
        if (typeof window === 'undefined') { // Provide fallback to setTimeout if window is undefined (e.g. in Node.js)
          Browser.fakeRequestAnimationFrame(func);
        } else {
          if (!window.requestAnimationFrame) {
            window.requestAnimationFrame = window['requestAnimationFrame'] ||
                                           window['mozRequestAnimationFrame'] ||
                                           window['webkitRequestAnimationFrame'] ||
                                           window['msRequestAnimationFrame'] ||
                                           window['oRequestAnimationFrame'] ||
                                           Browser.fakeRequestAnimationFrame;
          }
          window.requestAnimationFrame(func);
        }
      },safeCallback:function (func) {
        return function() {
          if (!ABORT) return func.apply(null, arguments);
        };
      },allowAsyncCallbacks:true,queuedAsyncCallbacks:[],pauseAsyncCallbacks:function () {
        Browser.allowAsyncCallbacks = false;
      },resumeAsyncCallbacks:function () { // marks future callbacks as ok to execute, and synchronously runs any remaining ones right now
        Browser.allowAsyncCallbacks = true;
        if (Browser.queuedAsyncCallbacks.length > 0) {
          var callbacks = Browser.queuedAsyncCallbacks;
          Browser.queuedAsyncCallbacks = [];
          callbacks.forEach(function(func) {
            func();
          });
        }
      },safeRequestAnimationFrame:function (func) {
        return Browser.requestAnimationFrame(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } else {
            Browser.queuedAsyncCallbacks.push(func);
          }
        });
      },safeSetTimeout:function (func, timeout) {
        Module['noExitRuntime'] = true;
        return setTimeout(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } else {
            Browser.queuedAsyncCallbacks.push(func);
          }
        }, timeout);
      },safeSetInterval:function (func, timeout) {
        Module['noExitRuntime'] = true;
        return setInterval(function() {
          if (ABORT) return;
          if (Browser.allowAsyncCallbacks) {
            func();
          } // drop it on the floor otherwise, next interval will kick in
        }, timeout);
      },getMimetype:function (name) {
        return {
          'jpg': 'image/jpeg',
          'jpeg': 'image/jpeg',
          'png': 'image/png',
          'bmp': 'image/bmp',
          'ogg': 'audio/ogg',
          'wav': 'audio/wav',
          'mp3': 'audio/mpeg'
        }[name.substr(name.lastIndexOf('.')+1)];
      },getUserMedia:function (func) {
        if(!window.getUserMedia) {
          window.getUserMedia = navigator['getUserMedia'] ||
                                navigator['mozGetUserMedia'];
        }
        window.getUserMedia(func);
      },getMovementX:function (event) {
        return event['movementX'] ||
               event['mozMovementX'] ||
               event['webkitMovementX'] ||
               0;
      },getMovementY:function (event) {
        return event['movementY'] ||
               event['mozMovementY'] ||
               event['webkitMovementY'] ||
               0;
      },getMouseWheelDelta:function (event) {
        var delta = 0;
        switch (event.type) {
          case 'DOMMouseScroll':
            // 3 lines make up a step
            delta = event.detail / 3;
            break;
          case 'mousewheel':
            // 120 units make up a step
            delta = event.wheelDelta / 120;
            break;
          case 'wheel':
            delta = event.deltaY
            switch(event.deltaMode) {
              case 0:
                // DOM_DELTA_PIXEL: 100 pixels make up a step
                delta /= 100;
                break;
              case 1:
                // DOM_DELTA_LINE: 3 lines make up a step
                delta /= 3;
                break;
              case 2:
                // DOM_DELTA_PAGE: A page makes up 80 steps
                delta *= 80;
                break;
              default:
                throw 'unrecognized mouse wheel delta mode: ' + event.deltaMode;
            }
            break;
          default:
            throw 'unrecognized mouse wheel event: ' + event.type;
        }
        return delta;
      },mouseX:0,mouseY:0,mouseMovementX:0,mouseMovementY:0,touches:{},lastTouches:{},calculateMouseEvent:function (event) { // event should be mousemove, mousedown or mouseup
        if (Browser.pointerLock) {
          // When the pointer is locked, calculate the coordinates
          // based on the movement of the mouse.
          // Workaround for Firefox bug 764498
          if (event.type != 'mousemove' &&
              ('mozMovementX' in event)) {
            Browser.mouseMovementX = Browser.mouseMovementY = 0;
          } else {
            Browser.mouseMovementX = Browser.getMovementX(event);
            Browser.mouseMovementY = Browser.getMovementY(event);
          }
  
          // check if SDL is available
          if (typeof SDL != "undefined") {
            Browser.mouseX = SDL.mouseX + Browser.mouseMovementX;
            Browser.mouseY = SDL.mouseY + Browser.mouseMovementY;
          } else {
            // just add the mouse delta to the current absolut mouse position
            // FIXME: ideally this should be clamped against the canvas size and zero
            Browser.mouseX += Browser.mouseMovementX;
            Browser.mouseY += Browser.mouseMovementY;
          }
        } else {
          // Otherwise, calculate the movement based on the changes
          // in the coordinates.
          var rect = Module["canvas"].getBoundingClientRect();
          var cw = Module["canvas"].width;
          var ch = Module["canvas"].height;
  
          // Neither .scrollX or .pageXOffset are defined in a spec, but
          // we prefer .scrollX because it is currently in a spec draft.
          // (see: http://www.w3.org/TR/2013/WD-cssom-view-20131217/)
          var scrollX = ((typeof window.scrollX !== 'undefined') ? window.scrollX : window.pageXOffset);
          var scrollY = ((typeof window.scrollY !== 'undefined') ? window.scrollY : window.pageYOffset);
          // If this assert lands, it's likely because the browser doesn't support scrollX or pageXOffset
          // and we have no viable fallback.
          assert((typeof scrollX !== 'undefined') && (typeof scrollY !== 'undefined'), 'Unable to retrieve scroll position, mouse positions likely broken.');
  
          if (event.type === 'touchstart' || event.type === 'touchend' || event.type === 'touchmove') {
            var touch = event.touch;
            if (touch === undefined) {
              return; // the "touch" property is only defined in SDL
  
            }
            var adjustedX = touch.pageX - (scrollX + rect.left);
            var adjustedY = touch.pageY - (scrollY + rect.top);
  
            adjustedX = adjustedX * (cw / rect.width);
            adjustedY = adjustedY * (ch / rect.height);
  
            var coords = { x: adjustedX, y: adjustedY };
  
            if (event.type === 'touchstart') {
              Browser.lastTouches[touch.identifier] = coords;
              Browser.touches[touch.identifier] = coords;
            } else if (event.type === 'touchend' || event.type === 'touchmove') {
              var last = Browser.touches[touch.identifier];
              if (!last) last = coords;
              Browser.lastTouches[touch.identifier] = last;
              Browser.touches[touch.identifier] = coords;
            }
            return;
          }
  
          var x = event.pageX - (scrollX + rect.left);
          var y = event.pageY - (scrollY + rect.top);
  
          // the canvas might be CSS-scaled compared to its backbuffer;
          // SDL-using content will want mouse coordinates in terms
          // of backbuffer units.
          x = x * (cw / rect.width);
          y = y * (ch / rect.height);
  
          Browser.mouseMovementX = x - Browser.mouseX;
          Browser.mouseMovementY = y - Browser.mouseY;
          Browser.mouseX = x;
          Browser.mouseY = y;
        }
      },asyncLoad:function (url, onload, onerror, noRunDep) {
        var dep = !noRunDep ? getUniqueRunDependency('al ' + url) : '';
        Module['readAsync'](url, function(arrayBuffer) {
          assert(arrayBuffer, 'Loading data file "' + url + '" failed (no arrayBuffer).');
          onload(new Uint8Array(arrayBuffer));
          if (dep) removeRunDependency(dep);
        }, function(event) {
          if (onerror) {
            onerror();
          } else {
            throw 'Loading data file "' + url + '" failed.';
          }
        });
        if (dep) addRunDependency(dep);
      },resizeListeners:[],updateResizeListeners:function () {
        var canvas = Module['canvas'];
        Browser.resizeListeners.forEach(function(listener) {
          listener(canvas.width, canvas.height);
        });
      },setCanvasSize:function (width, height, noUpdates) {
        var canvas = Module['canvas'];
        Browser.updateCanvasDimensions(canvas, width, height);
        if (!noUpdates) Browser.updateResizeListeners();
      },windowedWidth:0,windowedHeight:0,setFullscreenCanvasSize:function () {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags | 0x00800000; // set SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)]=flags
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },setWindowedCanvasSize:function () {
        // check if SDL is available
        if (typeof SDL != "undefined") {
          var flags = HEAPU32[((SDL.screen)>>2)];
          flags = flags & ~0x00800000; // clear SDL_FULLSCREEN flag
          HEAP32[((SDL.screen)>>2)]=flags
        }
        Browser.updateCanvasDimensions(Module['canvas']);
        Browser.updateResizeListeners();
      },updateCanvasDimensions:function (canvas, wNative, hNative) {
        if (wNative && hNative) {
          canvas.widthNative = wNative;
          canvas.heightNative = hNative;
        } else {
          wNative = canvas.widthNative;
          hNative = canvas.heightNative;
        }
        var w = wNative;
        var h = hNative;
        if (Module['forcedAspectRatio'] && Module['forcedAspectRatio'] > 0) {
          if (w/h < Module['forcedAspectRatio']) {
            w = Math.round(h * Module['forcedAspectRatio']);
          } else {
            h = Math.round(w / Module['forcedAspectRatio']);
          }
        }
        if (((document['fullscreenElement'] || document['mozFullScreenElement'] ||
             document['msFullscreenElement'] || document['webkitFullscreenElement'] ||
             document['webkitCurrentFullScreenElement']) === canvas.parentNode) && (typeof screen != 'undefined')) {
           var factor = Math.min(screen.width / w, screen.height / h);
           w = Math.round(w * factor);
           h = Math.round(h * factor);
        }
        if (Browser.resizeCanvas) {
          if (canvas.width  != w) canvas.width  = w;
          if (canvas.height != h) canvas.height = h;
          if (typeof canvas.style != 'undefined') {
            canvas.style.removeProperty( "width");
            canvas.style.removeProperty("height");
          }
        } else {
          if (canvas.width  != wNative) canvas.width  = wNative;
          if (canvas.height != hNative) canvas.height = hNative;
          if (typeof canvas.style != 'undefined') {
            if (w != wNative || h != hNative) {
              canvas.style.setProperty( "width", w + "px", "important");
              canvas.style.setProperty("height", h + "px", "important");
            } else {
              canvas.style.removeProperty( "width");
              canvas.style.removeProperty("height");
            }
          }
        }
      },wgetRequests:{},nextWgetRequestHandle:0,getNextWgetRequestHandle:function () {
        var handle = Browser.nextWgetRequestHandle;
        Browser.nextWgetRequestHandle++;
        return handle;
      }};var EmterpreterAsync={initted:false,state:0,saveStack:"",yieldCallbacks:[],postAsync:null,restartFunc:null,asyncFinalizers:[],ensureInit:function () {
        if (this.initted) return;
        this.initted = true;
        abortDecorators.push(function(output, what) {
          if (EmterpreterAsync.state === 1 || EmterpreterAsync.state === 2) {
            return output + '\nThis error happened during an emterpreter-async operation. Was there non-emterpreted code on the stack during save (which is unallowed)? If so, you may want to adjust EMTERPRETIFY_BLACKLIST, EMTERPRETIFY_WHITELIST. For reference, this is what the stack looked like when we tried to save it: ' + [EmterpreterAsync.state, EmterpreterAsync.saveStack];
          }
          return output;
        });
      },setState:function (s) {
        this.ensureInit();
        this.state = s;
        Module['setAsyncState'](s);
      },handle:function (doAsyncOp, yieldDuring) {
        Module['noExitRuntime'] = true;
        if (EmterpreterAsync.state === 0) {
          // save the stack we want to resume. this lets other code run in between
          // XXX this assumes that this stack top never ever leak! exceptions might violate that
          var stack = new Int32Array(HEAP32.subarray(EMTSTACKTOP>>2, Module['emtStackSave']()>>2));
          var stacktop = Module['stackSave']();
  
          var resumedCallbacksForYield = false;
          function resumeCallbacksForYield() {
            if (resumedCallbacksForYield) return;
            resumedCallbacksForYield = true;
            // allow async callbacks, and also make sure to call the specified yield callbacks. we must
            // do this when nothing is on the stack, i.e. after it unwound
            EmterpreterAsync.yieldCallbacks.forEach(function(func) {
              func();
            });
            Browser.resumeAsyncCallbacks(); // if we were paused (e.g. we are after a sleep), then since we are now yielding, it is safe to call callbacks
          }
  
          var callingDoAsyncOp = 1; // if resume is called synchronously - during the doAsyncOp - we must make it truly async, for consistency
  
          doAsyncOp(function resume(post) {
            if (ABORT) {
              return;
            }
            if (callingDoAsyncOp) {
              assert(callingDoAsyncOp === 1); // avoid infinite recursion
              callingDoAsyncOp++;
              setTimeout(function() {
                resume(post);
              }, 0);
              return;
            }
  
            assert(EmterpreterAsync.state === 1 || EmterpreterAsync.state === 3);
            EmterpreterAsync.setState(3);
            if (yieldDuring) {
              resumeCallbacksForYield();
            }
            // copy the stack back in and resume
            HEAP32.set(stack, EMTSTACKTOP>>2);
            assert(stacktop === Module['stackSave']()); // nothing should have modified the stack meanwhile
            // we are now starting to restore the stack
            EmterpreterAsync.setState(2);
            // Resume the main loop
            if (Browser.mainLoop.func) {
              Browser.mainLoop.resume();
            }
            assert(!EmterpreterAsync.postAsync);
            EmterpreterAsync.postAsync = post || null;
            var asyncReturnValue;
            if (!EmterpreterAsync.restartFunc) {
              // pc of the first function, from which we can reconstruct the rest, is at position 0 on the stack
              Module['emterpret'](stack[0]);
            } else {
              // the restartFunc knows how to emterpret the proper function, and also returns the return value
              asyncReturnValue = EmterpreterAsync.restartFunc();
            }
            if (!yieldDuring && EmterpreterAsync.state === 0) {
              // if we did *not* do another async operation, then we know that nothing is conceptually on the stack now, and we can re-allow async callbacks as well as run the queued ones right now
              Browser.resumeAsyncCallbacks();
            }
            if (EmterpreterAsync.state === 0) {
              // All async operations have concluded.
              // In particular, if we were in an async ccall, we have
              // consumed the restartFunc and can reset it to null.
              EmterpreterAsync.restartFunc = null;
              // The async finalizers can run now, after all async operations.
              var asyncFinalizers = EmterpreterAsync.asyncFinalizers;
              EmterpreterAsync.asyncFinalizers = [];
              asyncFinalizers.forEach(function(func) {
                func(asyncReturnValue);
              });
            }
          });
  
          callingDoAsyncOp = 0;
  
          EmterpreterAsync.setState(1);
          EmterpreterAsync.saveStack = new Error().stack; // we can't call  stackTrace()  as it calls compiled code
          // Pause the main loop, until we resume
          if (Browser.mainLoop.func) {
            Browser.mainLoop.pause();
          }
          if (yieldDuring) {
            // do this when we are not on the stack, i.e., the stack unwound. we might be too late, in which case we do it in resume()
            setTimeout(function() {
              resumeCallbacksForYield();
            }, 0);
          } else {
            Browser.pauseAsyncCallbacks();
          }
        } else {
          // nothing to do here, the stack was just recreated. reset the state.
          assert(EmterpreterAsync.state === 2);
          EmterpreterAsync.setState(0);
  
          if (EmterpreterAsync.postAsync) {
            var ret = EmterpreterAsync.postAsync();
            EmterpreterAsync.postAsync = null;
            return ret;
          }
        }
      }};function _emscripten_sleep_with_yield(ms) {
      EmterpreterAsync.handle(function(resume) {
        Browser.safeSetTimeout(resume, ms);
      }, true);
    }



  function _llvm_copysign_f64(x, y) {
      return y < 0 || (y === 0 && 1/y < 0) ? -Math_abs(x) : Math_abs(x);
    }

  var _llvm_cos_f64=Math_cos;

  
  function _llvm_log10_f32(x) {
      return Math.log(x) / Math.LN10; // TODO: Math.log10, when browser support is there
    }function _llvm_log10_f64(a0
  /*``*/) {
  return _llvm_log10_f32(a0);
  }

  
  
    

  var _llvm_sin_f64=Math_sin;

  var _llvm_trunc_f64=Math_trunc;


  
  function _emscripten_memcpy_big(dest, src, num) {
      HEAPU8.set(HEAPU8.subarray(src, src+num), dest);
    }
  
   

   

   

  function _mp_js_hook() {
          if (typeof window === 'undefined') {
              var mp_interrupt_char = Module.ccall('mp_hal_get_interrupt_char', 'number', ['number'], ['null']);
              var fs = require('fs');
  
              var buf = Buffer.alloc(1);
              try {
                  var n = fs.readSync(process.stdin.fd, buf, 0, 1);
                  if (n > 0) {
                      if (buf[0] == mp_interrupt_char) {
                          Module.ccall('mp_keyboard_interrupt', 'null', ['null'], ['null']);
                      } else {
                          process.stdout.write(String.fromCharCode(buf[0]));
                      }
                  }
              } catch (e) {
                  if (e.code === 'EAGAIN') {
                  } else {
                      throw e;
                  }
              }
          }
      }

  function _mp_js_ticks_ms() {
          return (new Date()).getTime() - MP_JS_EPOCH;
      }

  function _mp_js_write(ptr, len) {
          for (var i = 0; i < len; ++i) {
              if (typeof window === 'undefined') {
                  var b = Buffer.alloc(1);
                  b.writeInt8(getValue(ptr + i, 'i8'));
                  //process.stdout.write(b);
                  global.mpjsPrintStdout(b);
              } else {
                  var c = String.fromCharCode(getValue(ptr + i, 'i8'));
                  var mp_js_stdout = document.getElementById('mp_js_stdout');
                  var print = new Event('print');
                  print.data = c;
                  mp_js_stdout.dispatchEvent(print);
              }
          }
      }


  
  function ___setErrNo(value) {
      if (Module['___errno_location']) HEAP32[((Module['___errno_location']())>>2)]=value;
      else err('failed to set errno from JS');
      return value;
    } 

  var _sqrt=Math_sqrt;

Module["requestFullScreen"] = function Module_requestFullScreen(lockPointer, resizeCanvas, vrDevice) { err("Module.requestFullScreen is deprecated. Please call Module.requestFullscreen instead."); Module["requestFullScreen"] = Module["requestFullscreen"]; Browser.requestFullScreen(lockPointer, resizeCanvas, vrDevice) };
  Module["requestFullscreen"] = function Module_requestFullscreen(lockPointer, resizeCanvas, vrDevice) { Browser.requestFullscreen(lockPointer, resizeCanvas, vrDevice) };
  Module["requestAnimationFrame"] = function Module_requestAnimationFrame(func) { Browser.requestAnimationFrame(func) };
  Module["setCanvasSize"] = function Module_setCanvasSize(width, height, noUpdates) { Browser.setCanvasSize(width, height, noUpdates) };
  Module["pauseMainLoop"] = function Module_pauseMainLoop() { Browser.mainLoop.pause() };
  Module["resumeMainLoop"] = function Module_resumeMainLoop() { Browser.mainLoop.resume() };
  Module["getUserMedia"] = function Module_getUserMedia() { Browser.getUserMedia() }
  Module["createContext"] = function Module_createContext(canvas, useWebGL, setInModule, webGLContextAttributes) { return Browser.createContext(canvas, useWebGL, setInModule, webGLContextAttributes) };
if (ENVIRONMENT_IS_NODE) {
    _emscripten_get_now = function _emscripten_get_now_actual() {
      var t = process['hrtime']();
      return t[0] * 1e3 + t[1] / 1e6;
    };
  } else if (typeof dateNow !== 'undefined') {
    _emscripten_get_now = dateNow;
  } else if (typeof performance === 'object' && performance && typeof performance['now'] === 'function') {
    _emscripten_get_now = function() { return performance['now'](); };
  } else {
    _emscripten_get_now = Date.now;
  };
var ASSERTIONS = true;

// Copyright 2017 The Emscripten Authors.  All rights reserved.
// Emscripten is available under two separate licenses, the MIT license and the
// University of Illinois/NCSA Open Source License.  Both these licenses can be
// found in the LICENSE file.

/** @type {function(string, boolean=, number=)} */
function intArrayFromString(stringy, dontAddNull, length) {
  var len = length > 0 ? length : lengthBytesUTF8(stringy)+1;
  var u8array = new Array(len);
  var numBytesWritten = stringToUTF8Array(stringy, u8array, 0, u8array.length);
  if (dontAddNull) u8array.length = numBytesWritten;
  return u8array;
}

function intArrayToString(array) {
  var ret = [];
  for (var i = 0; i < array.length; i++) {
    var chr = array[i];
    if (chr > 0xFF) {
      if (ASSERTIONS) {
        assert(false, 'Character code ' + chr + ' (' + String.fromCharCode(chr) + ')  at offset ' + i + ' not in 0x00-0xFF.');
      }
      chr &= 0xFF;
    }
    ret.push(String.fromCharCode(chr));
  }
  return ret.join('');
}


// ASM_LIBRARY EXTERN PRIMITIVES: Math_imul,Math_clz32,Math_floor,Math_ceil,Int8Array,Int32Array


function nullFunc_dd(x) { err("Invalid function pointer called with signature 'dd'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function nullFunc_ddd(x) { err("Invalid function pointer called with signature 'ddd'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function nullFunc_i(x) { err("Invalid function pointer called with signature 'i'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function nullFunc_ii(x) { err("Invalid function pointer called with signature 'ii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function nullFunc_iidiiii(x) { err("Invalid function pointer called with signature 'iidiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function nullFunc_iii(x) { err("Invalid function pointer called with signature 'iii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function nullFunc_iiii(x) { err("Invalid function pointer called with signature 'iiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function nullFunc_iiiii(x) { err("Invalid function pointer called with signature 'iiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function nullFunc_v(x) { err("Invalid function pointer called with signature 'v'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function nullFunc_vi(x) { err("Invalid function pointer called with signature 'vi'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function nullFunc_vii(x) { err("Invalid function pointer called with signature 'vii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function nullFunc_viii(x) { err("Invalid function pointer called with signature 'viii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function nullFunc_viiii(x) { err("Invalid function pointer called with signature 'viiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function nullFunc_viiiiii(x) { err("Invalid function pointer called with signature 'viiiiii'. Perhaps this is an invalid value (e.g. caused by calling a virtual method on a NULL pointer)? Or calling a function with an incorrect type, which will fail? (it is worth building your source files with -Werror (warnings are errors), as warnings can indicate undefined behavior which can cause this)");  err("Build with ASSERTIONS=2 for more info.");abort(x) }

function invoke_i(index) {
  var sp = stackSave();
  try {
    return dynCall_i(index);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_ii(index,a1) {
  var sp = stackSave();
  try {
    return dynCall_ii(index,a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_iii(index,a1,a2) {
  var sp = stackSave();
  try {
    return dynCall_iii(index,a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    return dynCall_iiii(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_iiiii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    return dynCall_iiiii(index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_v(index) {
  var sp = stackSave();
  try {
    dynCall_v(index);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_vi(index,a1) {
  var sp = stackSave();
  try {
    dynCall_vi(index,a1);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_vii(index,a1,a2) {
  var sp = stackSave();
  try {
    dynCall_vii(index,a1,a2);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_viii(index,a1,a2,a3) {
  var sp = stackSave();
  try {
    dynCall_viii(index,a1,a2,a3);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

function invoke_viiii(index,a1,a2,a3,a4) {
  var sp = stackSave();
  try {
    dynCall_viiii(index,a1,a2,a3,a4);
  } catch(e) {
    stackRestore(sp);
    if (e !== e+0 && e !== 'longjmp') throw e;
    _setThrew(1, 0);
  }
}

var asmGlobalArg = {}

var asmLibraryArg = {
  "abort": abort,
  "setTempRet0": setTempRet0,
  "getTempRet0": getTempRet0,
  "abortStackOverflow": abortStackOverflow,
  "abortStackOverflowEmterpreter": abortStackOverflowEmterpreter,
  "nullFunc_dd": nullFunc_dd,
  "nullFunc_ddd": nullFunc_ddd,
  "nullFunc_i": nullFunc_i,
  "nullFunc_ii": nullFunc_ii,
  "nullFunc_iidiiii": nullFunc_iidiiii,
  "nullFunc_iii": nullFunc_iii,
  "nullFunc_iiii": nullFunc_iiii,
  "nullFunc_iiiii": nullFunc_iiiii,
  "nullFunc_v": nullFunc_v,
  "nullFunc_vi": nullFunc_vi,
  "nullFunc_vii": nullFunc_vii,
  "nullFunc_viii": nullFunc_viii,
  "nullFunc_viiii": nullFunc_viiii,
  "nullFunc_viiiiii": nullFunc_viiiiii,
  "invoke_i": invoke_i,
  "invoke_ii": invoke_ii,
  "invoke_iii": invoke_iii,
  "invoke_iiii": invoke_iiii,
  "invoke_iiiii": invoke_iiiii,
  "invoke_v": invoke_v,
  "invoke_vi": invoke_vi,
  "invoke_vii": invoke_vii,
  "invoke_viii": invoke_viii,
  "invoke_viiii": invoke_viiii,
  "___lock": ___lock,
  "___setErrNo": ___setErrNo,
  "___syscall140": ___syscall140,
  "___syscall146": ___syscall146,
  "___syscall54": ___syscall54,
  "___syscall6": ___syscall6,
  "___unlock": ___unlock,
  "_emscripten_get_heap_size": _emscripten_get_heap_size,
  "_emscripten_get_now": _emscripten_get_now,
  "_emscripten_longjmp": _emscripten_longjmp,
  "_emscripten_memcpy_big": _emscripten_memcpy_big,
  "_emscripten_resize_heap": _emscripten_resize_heap,
  "_emscripten_run_script_string": _emscripten_run_script_string,
  "_emscripten_set_main_loop": _emscripten_set_main_loop,
  "_emscripten_set_main_loop_timing": _emscripten_set_main_loop_timing,
  "_emscripten_sleep_with_yield": _emscripten_sleep_with_yield,
  "_llvm_copysign_f64": _llvm_copysign_f64,
  "_llvm_cos_f64": _llvm_cos_f64,
  "_llvm_cttz_i32": _llvm_cttz_i32,
  "_llvm_log10_f32": _llvm_log10_f32,
  "_llvm_log10_f64": _llvm_log10_f64,
  "_llvm_sin_f64": _llvm_sin_f64,
  "_llvm_trunc_f64": _llvm_trunc_f64,
  "_longjmp": _longjmp,
  "_mp_js_hook": _mp_js_hook,
  "_mp_js_ticks_ms": _mp_js_ticks_ms,
  "_mp_js_write": _mp_js_write,
  "_sqrt": _sqrt,
  "abortOnCannotGrowMemory": abortOnCannotGrowMemory,
  "flush_NO_FILESYSTEM": flush_NO_FILESYSTEM,
  "tempDoublePtr": tempDoublePtr,
  "DYNAMICTOP_PTR": DYNAMICTOP_PTR,
  "EMTSTACKTOP": EMTSTACKTOP,
  "EMT_STACK_MAX": EMT_STACK_MAX,
  "eb": eb
}
// EMSCRIPTEN_START_ASM
var asm = (/** @suppress {uselessCode} */ function(global, env, buffer) {
'almost asm';

  var HEAP8 = new global.Int8Array(buffer);
  var HEAP16 = new global.Int16Array(buffer);
  var HEAP32 = new global.Int32Array(buffer);
  var HEAPU8 = new global.Uint8Array(buffer);
  var HEAPU16 = new global.Uint16Array(buffer);
  var HEAPU32 = new global.Uint32Array(buffer);
  var HEAPF32 = new global.Float32Array(buffer);
  var HEAPF64 = new global.Float64Array(buffer);
  var tempDoublePtr=env.tempDoublePtr|0;
  var DYNAMICTOP_PTR=env.DYNAMICTOP_PTR|0;
  var EMTSTACKTOP=env.EMTSTACKTOP|0;
  var EMT_STACK_MAX=env.EMT_STACK_MAX|0;
  var eb=env.eb|0;
var __THREW__ = 0;
var threwValue = 0;
var setjmpId = 0;
var tempInt = 0;
var tempBigInt = 0;
var tempBigIntS = 0;
var tempValue = 0;
var tempDouble = 0.0;
var nan = global.NaN;
var inf = global.Infinity;

  var Math_floor=global.Math.floor;
  var Math_abs=global.Math.abs;
  var Math_sqrt=global.Math.sqrt;
  var Math_pow=global.Math.pow;
  var Math_cos=global.Math.cos;
  var Math_sin=global.Math.sin;
  var Math_tan=global.Math.tan;
  var Math_acos=global.Math.acos;
  var Math_asin=global.Math.asin;
  var Math_atan=global.Math.atan;
  var Math_atan2=global.Math.atan2;
  var Math_exp=global.Math.exp;
  var Math_log=global.Math.log;
  var Math_ceil=global.Math.ceil;
  var Math_imul=global.Math.imul;
  var Math_min=global.Math.min;
  var Math_max=global.Math.max;
  var Math_clz32=global.Math.clz32;
  var Math_fround=global.Math.fround;
  var abort=env.abort;
  var setTempRet0=env.setTempRet0;
  var getTempRet0=env.getTempRet0;
  var abortStackOverflow=env.abortStackOverflow;
  var abortStackOverflowEmterpreter=env.abortStackOverflowEmterpreter;
  var nullFunc_dd=env.nullFunc_dd;
  var nullFunc_ddd=env.nullFunc_ddd;
  var nullFunc_i=env.nullFunc_i;
  var nullFunc_ii=env.nullFunc_ii;
  var nullFunc_iidiiii=env.nullFunc_iidiiii;
  var nullFunc_iii=env.nullFunc_iii;
  var nullFunc_iiii=env.nullFunc_iiii;
  var nullFunc_iiiii=env.nullFunc_iiiii;
  var nullFunc_v=env.nullFunc_v;
  var nullFunc_vi=env.nullFunc_vi;
  var nullFunc_vii=env.nullFunc_vii;
  var nullFunc_viii=env.nullFunc_viii;
  var nullFunc_viiii=env.nullFunc_viiii;
  var nullFunc_viiiiii=env.nullFunc_viiiiii;
  var invoke_i=env.invoke_i;
  var invoke_ii=env.invoke_ii;
  var invoke_iii=env.invoke_iii;
  var invoke_iiii=env.invoke_iiii;
  var invoke_iiiii=env.invoke_iiiii;
  var invoke_v=env.invoke_v;
  var invoke_vi=env.invoke_vi;
  var invoke_vii=env.invoke_vii;
  var invoke_viii=env.invoke_viii;
  var invoke_viiii=env.invoke_viiii;
  var ___lock=env.___lock;
  var ___setErrNo=env.___setErrNo;
  var ___syscall140=env.___syscall140;
  var ___syscall146=env.___syscall146;
  var ___syscall54=env.___syscall54;
  var ___syscall6=env.___syscall6;
  var ___unlock=env.___unlock;
  var _emscripten_get_heap_size=env._emscripten_get_heap_size;
  var _emscripten_get_now=env._emscripten_get_now;
  var _emscripten_longjmp=env._emscripten_longjmp;
  var _emscripten_memcpy_big=env._emscripten_memcpy_big;
  var _emscripten_resize_heap=env._emscripten_resize_heap;
  var _emscripten_run_script_string=env._emscripten_run_script_string;
  var _emscripten_set_main_loop=env._emscripten_set_main_loop;
  var _emscripten_set_main_loop_timing=env._emscripten_set_main_loop_timing;
  var _emscripten_sleep_with_yield=env._emscripten_sleep_with_yield;
  var _llvm_copysign_f64=env._llvm_copysign_f64;
  var _llvm_cos_f64=env._llvm_cos_f64;
  var _llvm_cttz_i32=env._llvm_cttz_i32;
  var _llvm_log10_f32=env._llvm_log10_f32;
  var _llvm_log10_f64=env._llvm_log10_f64;
  var _llvm_sin_f64=env._llvm_sin_f64;
  var _llvm_trunc_f64=env._llvm_trunc_f64;
  var _longjmp=env._longjmp;
  var _mp_js_hook=env._mp_js_hook;
  var _mp_js_ticks_ms=env._mp_js_ticks_ms;
  var _mp_js_write=env._mp_js_write;
  var _sqrt=env._sqrt;
  var abortOnCannotGrowMemory=env.abortOnCannotGrowMemory;
  var flush_NO_FILESYSTEM=env.flush_NO_FILESYSTEM;
  var STACKTOP = 42896;
  var STACK_MAX = 5285776;
  var tempFloat = Math_fround(0);
  var asyncState = 0;
  const f0 = Math_fround(0);

// EMSCRIPTEN_START_FUNCS
function _mp_execute_bytecode($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$ = 0, $$0$$0$769 = 0, $$0$$0$770 = 0, $$0$$0$7701123 = 0, $$0$$0$771 = 0, $$0$$0$772 = 0, $$0$$0$773 = 0, $$0$$0$774 = 0, $$0$$0$775 = 0, $$0$$0$776 = 0, $$0$$0$777 = 0, $$0$$0$778 = 0, $$0$$0$779 = 0, $$0$$0$7791157 = 0, $$0$$0$781 = 0, $$0$$0$781962 = 0, $$0$$0$7819621158 = 0, $$0$$0$7819621159$reg2mem$0 = 0, $$0$$0$781963$reg2mem$0 = 0, $$0$$0$782 = 0, $$0$$0$783 = 0, $$0$$0$784 = 0, $$0$$0$785 = 0, $$0$$0$786 = 0, $$0$$0$787 = 0, $$0$$0$788 = 0, $$0$$0$789 = 0, $$0$$0$790 = 0, $$0$$0$791 = 0, $$0$$0$792 = 0, $$0$$0$793 = 0, $$0$$0$794 = 0, $$0$$0$795 = 0, $$0$$0$796 = 0, $$0$$0$797 = 0, $$0$$0$798 = 0, $$0$$0$823 = 0, $$0$$0$824 = 0, $$0$$0$825 = 0, $$0$$0$826 = 0, $$0$sroa_cast$reg2mem$0 = 0, $$0$sroa_cast$reg2mem$1 = 0, $$0$sroa_cast$reg2mem$2 = 0, $$0$sroa_cast$reg2mem$2$phi = 0, $$0857$reg2mem$0 = 0, $$0858$reg2mem1403$0 = 0, $$08641150$reg2mem1409$0 = 0, $$09031149$reg2mem1407$0 = 0, $$09051148$reg2mem1405$0 = 0, $$0909$reg2mem$0 = 0, $$0910$reg2mem$0 = 0, $$0911$reg2mem$0 = 0, $$0912$reg2mem$0 = 0, $$0913$reg2mem$0 = 0, $$0914$reg2mem$0 = 0, $$0915$reg2mem$0 = 0, $$0916$reg2mem$0 = 0, $$0917$reg2mem$0 = 0, $$0918$reg2mem$0 = 0, $$0919$reg2mem$0 = 0, $$0920$reg2mem$0 = 0, $$0921$reg2mem1423$0 = 0, $$0922$reg2mem$0 = 0, $$0923$reg2mem1425$0 = 0, $$09241145$reg2mem$0 = 0, $$0927$reg2mem$0 = 0, $$0928$reg2mem$0 = 0, $$0929$reg2mem1433$0 = 0, $$0930$reg2mem1435$0 = 0, $$0931$reg2mem1437$0 = 0, $$0932$reg2mem1439$0 = 0, $$0933$reg2mem$0 = 0, $$0934$reg2mem$0 = 0, $$0935$reg2mem$0 = 0, $$0936$reg2mem$0 = 0, $$0937$lcssa$reg2mem$0 = 0, $$09371130$reg2mem$0 = 0, $$0938$reg2mem$0 = 0, $$0939$reg2mem1441$0 = 0, $$0940$reg2mem$0 = 0, $$0941$reg2mem$0 = 0, $$0942$reg2mem$0 = 0, $$0943$reg2mem$0 = 0, $$0944$reg2mem$0 = 0, $$0945$reg2mem$0 = 0, $$0946$reg2mem$0 = 0, $$10$reg2mem$0 = 0, $$10877$reg2mem1431$0 = 0, $$11$reg2mem$0 = 0, $$11878952$reg2mem$0 = 0, $$12$reg2mem$0 = 0, $$12879$reg2mem1429$0 = 0, $$13$reg2mem$0 = 0, $$14$reg2mem$0 = 0, $$14881$reg2mem1419$0 = 0, $$15$reg2mem$0 = 0, $$16$reg2mem$0 = 0, $$16883$reg2mem1415$0 = 0, $$17$reg2mem$0 = 0, $$18$reg2mem$0 = 0, $$1860$be$reg2mem1443$0 = 0, $$1860$reg2mem1461$0 = 0, $$1865 = 0, $$1868$be$reg2mem1445$0 = 0, $$1868$reg2mem1463$0 = 0, $$19$reg2mem$0 = 0, $$1904 = 0, $$1926$reg2mem$0 = 0, $$20$reg2mem$0 = 0, $$21$reg2mem$0 = 0, $$22$reg2mem$0 = 0, $$27$reg2mem1447$0 = 0, $$2866$reg2mem$0 = 0, $$29$reg2mem$0 = 0, $$30$reg2mem$0 = 0, $$31$reg2mem$0 = 0, $$32$reg2mem$0 = 0, $$33$reg2mem$0 = 0, $$34$reg2mem$0 = 0, $$35$reg2mem$0 = 0, $$36$reg2mem$0 = 0, $$37$reg2mem$0 = 0, $$38$reg2mem$0 = 0, $$3862$reg2mem$0 = 0, $$39$reg2mem$0 = 0, $$4$ph$reg2mem$0 = 0, $$40$reg2mem1427$0 = 0, $$41$reg2mem1417$0 = 0, $$43$reg2mem$0 = 0, $$44$reg2mem$0 = 0, $$45$reg2mem1413$0 = 0, $$4863$reg2mem$0 = 0, $$4888$reg2mem1453$0 = 0, $$4898$reg2mem1421$0 = 0, $$5$reg2mem1451$0 = 0, $$5872$reg2mem1449$0 = 0, $$8$reg2mem$0 = 0, $$8875$reg2mem$0 = 0, $$9$reg2mem$0 = 0, $$lcssa1044 = 0, $$lcssa1494$reg2mem1455$0 = 0, $$lcssa1495$reg2mem$0 = 0, $$neg972 = 0, $$neg975 = 0, $$pre = 0, $$pre1307 = 0, $$reg2mem1316$0 = 0, $$reg2mem1316$1 = 0, $$reg2mem1316$2 = 0, $$reg2mem1316$2$phi = 0, $$reg2mem1319$0 = 0, $$reg2mem1319$1 = 0, $$reg2mem1319$2 = 0, $$reg2mem1319$2$phi = 0, $$reg2mem1324$0 = 0, $$reg2mem1324$1 = 0, $$reg2mem1324$2 = 0, $$reg2mem1324$2$phi = 0, $$reg2mem1327$0 = 0, $$reg2mem1327$1 = 0, $$reg2mem1327$2 = 0, $$reg2mem1327$2$phi = 0, $$reg2mem1330$0 = 0, $$reg2mem1330$1 = 0, $$reg2mem1330$2 = 0, $$reg2mem1330$2$phi = 0, $$reg2mem1332$0 = 0, $$reg2mem1332$1 = 0, $$reg2mem1332$2 = 0, $$reg2mem1332$2$phi = 0, $$reg2mem1345$0 = 0, $$reg2mem1345$1 = 0, $$reg2mem1345$2 = 0, $$reg2mem1345$2$phi = 0, $$reg2mem1355$0 = 0, $$reg2mem1355$1 = 0, $$reg2mem1355$2 = 0, $$reg2mem1355$2$phi = 0, $$reg2mem1365$0 = 0, $$reg2mem1365$1 = 0, $$reg2mem1365$2 = 0, $$reg2mem1365$2$phi = 0, $$reg2mem1367$0 = 0, $$reg2mem1367$1 = 0, $$reg2mem1367$2 = 0, $$reg2mem1367$2$phi = 0, $$reg2mem1371$0 = 0, $$reg2mem1371$1 = 0, $$reg2mem1371$2 = 0, $$reg2mem1371$2$phi = 0, $$reg2mem1375$0 = 0, $$reg2mem1375$1 = 0, $$reg2mem1375$2 = 0, $$reg2mem1375$2$phi = 0, $$reg2mem1383$0 = 0, $$reg2mem1383$1 = 0, $$reg2mem1383$2 = 0, $$reg2mem1383$2$phi = 0, $$reg2mem1386$0 = 0, $$reg2mem1386$1 = 0, $$reg2mem1386$2 = 0, $$reg2mem1386$2$phi = 0, $$reg2mem1411$0 = 0, $$reg2mem1457$0 = 0, $$reg2mem1459$0 = 0, $$reg2mem1465$0 = 0, $$sink$reg2mem$0 = 0, $10 = 0, $100 = 0, $1000 = 0, $1001 = 0, $1002 = 0, $1003 = 0, $1004 = 0, $1005 = 0, $1006 = 0, $1007 = 0, $1008 = 0, $1009 = 0, $101 = 0, $1010 = 0, $1011 = 0, $1012 = 0, $1013 = 0, $1014 = 0, $1015 = 0, $1016 = 0, $1017 = 0, $1018 = 0, $1019 = 0, $102 = 0, $1020 = 0, $1021 = 0, $1022 = 0, $1023 = 0, $1024 = 0, $1025 = 0, $1026 = 0, $1027 = 0, $1028 = 0, $1029 = 0, $103 = 0, $1030 = 0, $1031 = 0, $1032 = 0, $1033 = 0, $1034 = 0, $1035 = 0, $1036 = 0, $1037 = 0, $1038 = 0, $1039 = 0, $104 = 0, $1040 = 0, $1041 = 0, $1042 = 0, $1043 = 0, $1044 = 0, $1045 = 0, $1046 = 0, $1047 = 0, $1048 = 0, $1049 = 0, $105 = 0, $1050 = 0, $1051 = 0, $1052 = 0, $1053 = 0, $1054 = 0, $1055 = 0, $1056 = 0, $1057 = 0, $1058 = 0, $1059 = 0, $106 = 0, $1060 = 0, $1061 = 0, $1062 = 0, $1063 = 0, $1064 = 0, $1065 = 0, $1066 = 0, $1067 = 0, $1068 = 0, $1069 = 0, $107 = 0, $1070 = 0, $1071 = 0, $1072 = 0, $1073 = 0, $1074 = 0, $1075 = 0, $1076 = 0, $1077 = 0, $1078 = 0, $1079 = 0, $108 = 0, $1080 = 0, $1081 = 0, $1082 = 0, $1083 = 0, $1084 = 0, $1085 = 0, $1086 = 0, $1087 = 0, $1088 = 0, $1089 = 0, $109 = 0, $1090 = 0, $1091 = 0, $1092 = 0, $1093 = 0, $1094 = 0, $1095 = 0, $1096 = 0, $1097 = 0, $1098 = 0, $1099 = 0, $11 = 0, $110 = 0, $1100 = 0, $1101 = 0, $1102 = 0, $1103 = 0, $1104 = 0, $1105 = 0, $1106 = 0, $1107 = 0, $1108 = 0, $1109 = 0, $111 = 0, $1110 = 0, $1111 = 0, $1112 = 0, $1113 = 0, $1114 = 0, $1115 = 0, $1116 = 0, $1117 = 0, $1118 = 0, $1119 = 0, $112 = 0, $1120 = 0, $1121 = 0, $1122 = 0, $1123 = 0, $1124 = 0, $1125 = 0, $1126 = 0, $1127 = 0, $1128 = 0, $1129 = 0, $113 = 0, $1130 = 0, $1131 = 0, $1132 = 0, $1133 = 0, $1134 = 0, $1135 = 0, $1136 = 0, $1137 = 0, $1138 = 0, $1139 = 0, $114 = 0, $1140 = 0, $1141 = 0, $1142 = 0, $1143 = 0, $1144 = 0, $1145 = 0, $1146 = 0, $1147 = 0, $1148 = 0, $1149 = 0, $115 = 0, $1150 = 0, $1151 = 0, $1152 = 0, $1153 = 0, $1154 = 0, $1155 = 0, $1156 = 0, $1157 = 0, $1158 = 0, $1159 = 0, $116 = 0, $1160 = 0, $1161 = 0, $1162 = 0, $1163 = 0, $1164 = 0, $1165 = 0, $1166 = 0, $1167 = 0, $1168 = 0, $1169 = 0, $117 = 0, $1170 = 0, $1171 = 0, $1172 = 0, $1173 = 0, $1174 = 0, $1175 = 0, $1176 = 0, $1177 = 0, $1178 = 0, $1179 = 0, $118 = 0, $1180 = 0, $1181 = 0, $1182 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0, $435 = 0, $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0, $472 = 0, $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0, $49 = 0, $490 = 0, $491 = 0, $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0, $503 = 0, $504 = 0, $505 = 0, $506 = 0, $507 = 0, $508 = 0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0, $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0, $539 = 0, $54 = 0, $540 = 0, $541 = 0, $542 = 0, $543 = 0, $544 = 0, $545 = 0, $546 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0, $559 = 0, $56 = 0, $560 = 0, $561 = 0, $562 = 0, $563 = 0, $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0, $569 = 0, $57 = 0, $570 = 0, $571 = 0, $572 = 0, $573 = 0, $574 = 0, $575 = 0, $576 = 0, $577 = 0, $578 = 0, $579 = 0, $58 = 0, $580 = 0, $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0, $593 = 0, $594 = 0, $595 = 0, $596 = 0, $597 = 0, $598 = 0, $599 = 0, $6 = 0, $60 = 0, $600 = 0, $601 = 0, $602 = 0, $603 = 0, $604 = 0, $605 = 0, $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0, $610 = 0, $611 = 0, $612 = 0, $613 = 0, $614 = 0, $615 = 0, $616 = 0, $617 = 0, $618 = 0, $619 = 0, $62 = 0, $620 = 0, $621 = 0, $622 = 0, $623 = 0, $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0, $630 = 0, $631 = 0, $632 = 0, $633 = 0, $634 = 0, $635 = 0, $636 = 0, $637 = 0, $638 = 0, $639 = 0, $64 = 0, $640 = 0, $641 = 0, $642 = 0, $643 = 0, $644 = 0, $645 = 0, $646 = 0, $647 = 0, $648 = 0, $649 = 0, $65 = 0, $650 = 0, $651 = 0, $652 = 0, $653 = 0, $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0, $660 = 0, $661 = 0, $662 = 0, $663 = 0, $664 = 0, $665 = 0, $666 = 0, $667 = 0, $668 = 0, $669 = 0, $67 = 0, $670 = 0, $671 = 0, $672 = 0, $673 = 0, $674 = 0, $675 = 0, $676 = 0, $677 = 0, $678 = 0, $679 = 0, $68 = 0, $680 = 0, $681 = 0, $682 = 0, $683 = 0, $684 = 0, $685 = 0, $686 = 0, $687 = 0, $688 = 0, $689 = 0, $69 = 0, $690 = 0, $691 = 0, $692 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0, $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0, $700 = 0, $701 = 0, $702 = 0, $703 = 0, $704 = 0, $705 = 0, $706 = 0, $707 = 0, $708 = 0, $709 = 0, $71 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $72 = 0, $720 = 0, $721 = 0, $722 = 0, $723 = 0, $724 = 0, $725 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0, $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0, $737 = 0, $738 = 0, $739 = 0, $74 = 0, $740 = 0, $741 = 0, $742 = 0, $743 = 0, $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0, $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0, $755 = 0, $756 = 0, $757 = 0, $758 = 0, $759 = 0, $76 = 0, $760 = 0, $761 = 0, $762 = 0, $763 = 0, $764 = 0, $765 = 0, $766 = 0, $767 = 0, $768 = 0, $769 = 0, $77 = 0, $770 = 0, $771 = 0, $772 = 0, $773 = 0, $774 = 0, $775 = 0, $776 = 0, $777 = 0, $778 = 0, $779 = 0, $78 = 0, $780 = 0, $781 = 0, $782 = 0, $783 = 0, $784 = 0, $785 = 0, $786 = 0, $787 = 0, $788 = 0, $789 = 0, $79 = 0, $790 = 0, $791 = 0, $792 = 0, $793 = 0, $794 = 0, $795 = 0, $796 = 0, $797 = 0, $798 = 0, $799 = 0, $8 = 0, $80 = 0, $800 = 0, $801 = 0, $802 = 0, $803 = 0, $804 = 0, $805 = 0, $806 = 0, $807 = 0, $808 = 0, $809 = 0, $81 = 0, $810 = 0, $811 = 0, $812 = 0, $813 = 0, $814 = 0, $815 = 0, $816 = 0, $817 = 0, $818 = 0, $819 = 0, $82 = 0, $820 = 0, $821 = 0, $822 = 0, $823 = 0, $824 = 0, $825 = 0, $826 = 0, $827 = 0, $828 = 0, $829 = 0, $83 = 0, $830 = 0, $831 = 0, $832 = 0, $833 = 0, $834 = 0, $835 = 0, $836 = 0, $837 = 0, $838 = 0, $839 = 0, $84 = 0, $840 = 0, $841 = 0, $842 = 0, $843 = 0, $844 = 0, $845 = 0, $846 = 0, $847 = 0, $848 = 0, $849 = 0, $85 = 0, $850 = 0, $851 = 0, $852 = 0, $853 = 0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0, $859 = 0, $86 = 0, $860 = 0, $861 = 0, $862 = 0, $863 = 0, $864 = 0, $865 = 0, $866 = 0, $867 = 0, $868 = 0, $869 = 0, $87 = 0, $870 = 0, $871 = 0, $872 = 0, $873 = 0, $874 = 0, $875 = 0, $876 = 0, $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0, $881 = 0, $882 = 0, $883 = 0, $884 = 0, $885 = 0, $886 = 0, $887 = 0, $888 = 0, $889 = 0, $89 = 0, $890 = 0, $891 = 0, $892 = 0, $893 = 0, $894 = 0, $895 = 0, $896 = 0, $897 = 0, $898 = 0, $899 = 0, $9 = 0, $90 = 0, $900 = 0, $901 = 0, $902 = 0, $903 = 0, $904 = 0, $905 = 0, $906 = 0, $907 = 0, $908 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0, $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0, $917 = 0, $918 = 0, $919 = 0, $92 = 0, $920 = 0, $921 = 0, $922 = 0, $923 = 0, $924 = 0, $925 = 0, $926 = 0, $927 = 0, $928 = 0, $929 = 0, $93 = 0, $930 = 0, $931 = 0, $932 = 0, $933 = 0, $934 = 0, $935 = 0, $936 = 0, $937 = 0, $938 = 0, $939 = 0, $94 = 0, $940 = 0, $941 = 0, $942 = 0, $943 = 0, $944 = 0, $945 = 0, $946 = 0, $947 = 0, $948 = 0, $949 = 0, $95 = 0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0, $955 = 0, $956 = 0, $957 = 0, $958 = 0, $959 = 0, $96 = 0, $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0, $966 = 0, $967 = 0, $968 = 0, $969 = 0, $97 = 0, $970 = 0, $971 = 0, $972 = 0, $973 = 0, $974 = 0, $975 = 0, $976 = 0, $977 = 0, $978 = 0, $979 = 0, $98 = 0, $980 = 0, $981 = 0, $982 = 0, $983 = 0, $984 = 0, $985 = 0, $986 = 0, $987 = 0, $988 = 0, $989 = 0, $99 = 0, $990 = 0, $991 = 0, $992 = 0, $993 = 0, $994 = 0, $995 = 0, $996 = 0, $997 = 0, $998 = 0, $999 = 0, $cond = 0, $cond1 = 0, $cond1470 = 0, $cond1471 = 0, $cond1472 = 0, $cond1473 = 0, $cond1474 = 0, $cond1475 = 0, $cond1476 = 0, $cond1477 = 0, $cond1478 = 0, $cond1479 = 0, $cond1480 = 0, $cond1481 = 0, $cond1482 = 0, $cond1483 = 0, $cond1484 = 0, $cond1485 = 0, $cond1486 = 0, $cond1487 = 0, $cond1488 = 0, $cond1489 = 0, $cond1490 = 0, $cond1491 = 0, $cond1492 = 0, $cond1493 = 0, $cond1494 = 0, $cond1495 = 0, $cond1496 = 0, $cond1497 = 0, $cond1498 = 0, $cond1499 = 0, $cond1500 = 0, $cond1501 = 0, $cond1502 = 0, $cond1503 = 0, $cond1504 = 0, $cond1505 = 0, $cond1506 = 0, $cond1507 = 0, $cond1508 = 0, $cond1509 = 0, $cond1510 = 0, $cond1511 = 0, $cond1512 = 0, $cond1513 = 0, $cond1514 = 0, $cond1515 = 0, $cond1516 = 0, $cond1517 = 0, $cond1518 = 0, $cond1519 = 0, $cond1520 = 0, $cond1521 = 0, $cond1522 = 0, $cond1523 = 0, $cond1524 = 0, $cond1525 = 0, $cond1526 = 0, $cond1527 = 0, $cond1528 = 0, $cond1529 = 0, $cond1530 = 0, $cond1531 = 0, $cond1532 = 0, $cond1533 = 0, $cond1534 = 0, $cond1535 = 0, $cond1536 = 0, $cond1537 = 0, $cond1538 = 0, $cond1539 = 0, $cond1540 = 0, $cond1541 = 0, $cond1542 = 0, $cond1543 = 0, $cond1544 = 0, $cond1545 = 0, $cond1546 = 0, $cond1547 = 0, $cond1548 = 0, $cond1549 = 0, $cond1550 = 0, $cond1551 = 0, $cond1552 = 0, $cond1553 = 0, $cond1554 = 0, $cond1555 = 0, $cond1556 = 0, $cond1557 = 0, $cond1558 = 0, $cond1559 = 0, $cond1560 = 0, $cond1561 = 0, $cond1562 = 0, $cond1563 = 0, $cond1564 = 0, $cond1565 = 0, $cond1566 = 0, $cond1567 = 0, $sext = 0, $spec$select = 0, $spec$select950 = 0, $spec$select968 = 0, $spec$select969 = 0, $trunc = 0, $trunc$clear = 0, $vararg_buffer = 0, _setjmpTable = 0, _setjmpTableSize = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 192 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(192 | 0);
 $vararg_buffer = sp;
 _setjmpTableSize = 4;
 _setjmpTable = _malloc(40) | 0;
 HEAP32[_setjmpTable >> 2] = 0;
 $3 = sp + 176 | 0;
 $4 = sp + 8 | 0;
 $5 = sp + 4 | 0;
 $2 = $1;
 $6 = HEAP32[$0 >> 2] | 0;
 $7 = $6 + 8 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 __THREW__ = 0;
 $9 = invoke_ii(569, $8 | 0) | 0;
 $10 = __THREW__;
 __THREW__ = 0;
 if (($10 | 0) != 0 & (threwValue | 0) != 0) {
  $11 = _testSetjmp(HEAP32[$10 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  if (($11 | 0) == 0) {
   _longjmp($10 | 0, threwValue | 0);
  }
  setTempRet0(threwValue | 0);
 } else {
  $11 = -1;
 }
 $12 = getTempRet0() | 0;
 $cond = ($11 | 0) == 1;
 if ($cond) {
  $$0$sroa_cast$reg2mem$2 = 0;
  $$reg2mem1316$2 = 0;
  $$reg2mem1319$2 = 0;
  $$reg2mem1324$2 = 0;
  $$reg2mem1327$2 = 0;
  $$reg2mem1330$2 = 0;
  $$reg2mem1332$2 = 0;
  $$reg2mem1345$2 = 0;
  $$reg2mem1355$2 = 0;
  $$reg2mem1365$2 = 0;
  $$reg2mem1367$2 = 0;
  $$reg2mem1371$2 = 0;
  $$reg2mem1375$2 = 0;
  $$reg2mem1383$2 = 0;
  $$reg2mem1386$2 = 0;
  $$reg2mem1465$0 = $12;
  label = 7;
 } else {
  $13 = $9 + -1 | 0;
  $14 = ($0 + 20 | 0) + ($13 << 2) | 0;
  $15 = $0 + 20 | 0;
  $16 = ($0 + 20 | 0) + ($9 << 2) | 0;
  $17 = $0 + 12 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = $18 & -4;
  $20 = $19;
  HEAP32[$3 >> 2] = $20;
  $21 = $4 + 8 | 0;
  $22 = $0 + 4 | 0;
  $23 = $0 + 8 | 0;
  $24 = $4 + 4 | 0;
  $$0$sroa_cast$reg2mem$0 = $3;
  $$reg2mem1316$0 = $22;
  $$reg2mem1319$0 = $24;
  $$reg2mem1324$0 = $5;
  $$reg2mem1327$0 = $5;
  $$reg2mem1330$0 = $24;
  $$reg2mem1332$0 = $24;
  $$reg2mem1345$0 = $23;
  $$reg2mem1355$0 = $22;
  $$reg2mem1365$0 = $21;
  $$reg2mem1367$0 = $4;
  $$reg2mem1371$0 = $17;
  $$reg2mem1375$0 = $16;
  $$reg2mem1383$0 = $15;
  $$reg2mem1386$0 = $14;
  label = 3;
 }
 L3 : while (1) {
  L4 : do {
   if ((label | 0) == 3) {
    label = 0;
    $$0$sroa_cast$reg2mem$1 = $$0$sroa_cast$reg2mem$0;
    $$reg2mem1316$1 = $$reg2mem1316$0;
    $$reg2mem1319$1 = $$reg2mem1319$0;
    $$reg2mem1324$1 = $$reg2mem1324$0;
    $$reg2mem1327$1 = $$reg2mem1327$0;
    $$reg2mem1330$1 = $$reg2mem1330$0;
    $$reg2mem1332$1 = $$reg2mem1332$0;
    $$reg2mem1345$1 = $$reg2mem1345$0;
    $$reg2mem1355$1 = $$reg2mem1355$0;
    $$reg2mem1365$1 = $$reg2mem1365$0;
    $$reg2mem1367$1 = $$reg2mem1367$0;
    $$reg2mem1371$1 = $$reg2mem1371$0;
    $$reg2mem1375$1 = $$reg2mem1375$0;
    $$reg2mem1383$1 = $$reg2mem1383$0;
    $$reg2mem1386$1 = $$reg2mem1386$0;
   } else if ((label | 0) == 7) {
    label = 0;
    $31 = ($$reg2mem1465$0 | 0) == 0;
    L7 : do {
     if ($31) {
      $32 = HEAP32[$$reg2mem1355$2 >> 2] | 0;
      $33 = HEAP32[$$reg2mem1345$2 >> 2] | 0;
      $$0$$0$823 = $2;
      $34 = ($$0$$0$823 | 0) == (0 | 0);
      if (!$34) {
       $35 = HEAP8[$32 >> 0] | 0;
       $36 = $35 << 24 >> 24 == 94;
       if (!$36) {
        $$0$$0$824 = $2;
        $2 = 0;
        __THREW__ = 0;
        $37 = invoke_ii(570, $$0$$0$824 | 0) | 0;
        $38 = __THREW__;
        __THREW__ = 0;
        if (($38 | 0) != 0 & (threwValue | 0) != 0) {
         $39 = _testSetjmp(HEAP32[$38 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
         if (($39 | 0) == 0) {
          _longjmp($38 | 0, threwValue | 0);
         }
         setTempRet0(threwValue | 0);
        } else {
         $39 = -1;
        }
        $40 = getTempRet0() | 0;
        $cond1483 = ($39 | 0) == 1;
        if ($cond1483) {
         $$reg2mem1386$2$phi = $$reg2mem1386$2;
         $$reg2mem1383$2$phi = $$reg2mem1383$2;
         $$reg2mem1375$2$phi = $$reg2mem1375$2;
         $$reg2mem1371$2$phi = $$reg2mem1371$2;
         $$reg2mem1367$2$phi = $$reg2mem1367$2;
         $$reg2mem1365$2$phi = $$reg2mem1365$2;
         $$reg2mem1355$2$phi = $$reg2mem1355$2;
         $$reg2mem1345$2$phi = $$reg2mem1345$2;
         $$reg2mem1332$2$phi = $$reg2mem1332$2;
         $$reg2mem1330$2$phi = $$reg2mem1330$2;
         $$reg2mem1327$2$phi = $$reg2mem1327$2;
         $$reg2mem1324$2$phi = $$reg2mem1324$2;
         $$reg2mem1319$2$phi = $$reg2mem1319$2;
         $$reg2mem1316$2$phi = $$reg2mem1316$2;
         $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
         $$reg2mem1465$0 = $40;
         $$reg2mem1386$2 = $$reg2mem1386$2$phi;
         $$reg2mem1383$2 = $$reg2mem1383$2$phi;
         $$reg2mem1375$2 = $$reg2mem1375$2$phi;
         $$reg2mem1371$2 = $$reg2mem1371$2$phi;
         $$reg2mem1367$2 = $$reg2mem1367$2$phi;
         $$reg2mem1365$2 = $$reg2mem1365$2$phi;
         $$reg2mem1355$2 = $$reg2mem1355$2$phi;
         $$reg2mem1345$2 = $$reg2mem1345$2$phi;
         $$reg2mem1332$2 = $$reg2mem1332$2$phi;
         $$reg2mem1330$2 = $$reg2mem1330$2$phi;
         $$reg2mem1327$2 = $$reg2mem1327$2$phi;
         $$reg2mem1324$2 = $$reg2mem1324$2$phi;
         $$reg2mem1319$2 = $$reg2mem1319$2$phi;
         $$reg2mem1316$2 = $$reg2mem1316$2$phi;
         $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
         label = 7;
         continue L3;
        }
        __THREW__ = 0;
        invoke_v(498);
        $41 = __THREW__;
        __THREW__ = 0;
        if (($41 | 0) != 0 & (threwValue | 0) != 0) {
         $42 = _testSetjmp(HEAP32[$41 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
         if (($42 | 0) == 0) {
          _longjmp($41 | 0, threwValue | 0);
         }
         setTempRet0(threwValue | 0);
        } else {
         $42 = -1;
        }
        $43 = getTempRet0() | 0;
        $cond1484 = ($42 | 0) == 1;
        if ($cond1484) {
         $$reg2mem1386$2$phi = $$reg2mem1386$2;
         $$reg2mem1383$2$phi = $$reg2mem1383$2;
         $$reg2mem1375$2$phi = $$reg2mem1375$2;
         $$reg2mem1371$2$phi = $$reg2mem1371$2;
         $$reg2mem1367$2$phi = $$reg2mem1367$2;
         $$reg2mem1365$2$phi = $$reg2mem1365$2;
         $$reg2mem1355$2$phi = $$reg2mem1355$2;
         $$reg2mem1345$2$phi = $$reg2mem1345$2;
         $$reg2mem1332$2$phi = $$reg2mem1332$2;
         $$reg2mem1330$2$phi = $$reg2mem1330$2;
         $$reg2mem1327$2$phi = $$reg2mem1327$2;
         $$reg2mem1324$2$phi = $$reg2mem1324$2;
         $$reg2mem1319$2$phi = $$reg2mem1319$2;
         $$reg2mem1316$2$phi = $$reg2mem1316$2;
         $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
         $$reg2mem1465$0 = $43;
         $$reg2mem1386$2 = $$reg2mem1386$2$phi;
         $$reg2mem1383$2 = $$reg2mem1383$2$phi;
         $$reg2mem1375$2 = $$reg2mem1375$2$phi;
         $$reg2mem1371$2 = $$reg2mem1371$2$phi;
         $$reg2mem1367$2 = $$reg2mem1367$2$phi;
         $$reg2mem1365$2 = $$reg2mem1365$2$phi;
         $$reg2mem1355$2 = $$reg2mem1355$2$phi;
         $$reg2mem1345$2 = $$reg2mem1345$2$phi;
         $$reg2mem1332$2 = $$reg2mem1332$2$phi;
         $$reg2mem1330$2 = $$reg2mem1330$2$phi;
         $$reg2mem1327$2 = $$reg2mem1327$2$phi;
         $$reg2mem1324$2 = $$reg2mem1324$2$phi;
         $$reg2mem1319$2 = $$reg2mem1319$2$phi;
         $$reg2mem1316$2 = $$reg2mem1316$2$phi;
         $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
         label = 7;
         continue L3;
        }
        HEAP32[$$reg2mem1332$2 >> 2] = $37;
        break;
       }
      }
      $$1860$reg2mem1461$0 = $32;
      $$1868$reg2mem1463$0 = $33;
      L15 : while (1) {
       HEAP32[$$reg2mem1355$2 >> 2] = $$1860$reg2mem1461$0;
       $44 = $$1860$reg2mem1461$0 + 1 | 0;
       $45 = HEAP8[$$1860$reg2mem1461$0 >> 0] | 0;
       L17 : do {
        switch ($45 << 24 >> 24) {
        case 92:
         {
          label = 243;
          break L15;
          break;
         }
        case 93:
         {
          $$12879$reg2mem1429$0 = $$1868$reg2mem1463$0;
          $$40$reg2mem1427$0 = $44;
          label = 258;
          break L15;
          break;
         }
        case 16:
         {
          $46 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$46 >> 2] = 13856;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $46;
          break;
         }
        case 17:
         {
          $47 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$47 >> 2] = 17668;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $47;
          break;
         }
        case 18:
         {
          $48 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$48 >> 2] = 13864;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $48;
          break;
         }
        case 20:
         {
          $49 = HEAP8[$44 >> 0] | 0;
          $50 = $49 << 1 & 255;
          $sext = $50 << 24 >> 24 >> 7;
          $spec$select = $sext << 24 >> 24;
          $51 = $spec$select << 7;
          $52 = $49 & 255;
          $53 = $52 & 127;
          $54 = $53 | $51;
          $55 = $$1860$reg2mem1461$0 + 2 | 0;
          $56 = $52 & 128;
          $57 = ($56 | 0) == 0;
          if ($57) {
           $$lcssa1494$reg2mem1455$0 = $55;
           $$lcssa1495$reg2mem$0 = $54;
          } else {
           $$reg2mem1457$0 = $54;
           $$reg2mem1459$0 = $55;
           while (1) {
            $$pre = HEAP8[$$reg2mem1459$0 >> 0] | 0;
            $58 = $$reg2mem1457$0 << 7;
            $59 = $$pre & 255;
            $60 = $59 & 127;
            $61 = $60 | $58;
            $62 = $$reg2mem1459$0 + 1 | 0;
            $63 = $59 & 128;
            $64 = ($63 | 0) == 0;
            if ($64) {
             $$lcssa1494$reg2mem1455$0 = $62;
             $$lcssa1495$reg2mem$0 = $61;
             break;
            } else {
             $$reg2mem1457$0 = $61;
             $$reg2mem1459$0 = $62;
            }
           }
          }
          $65 = $$lcssa1495$reg2mem$0 << 1;
          $66 = $65 | 1;
          $67 = $66;
          $68 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$68 >> 2] = $67;
          $$1860$be$reg2mem1443$0 = $$lcssa1494$reg2mem1455$0;
          $$1868$be$reg2mem1445$0 = $68;
          break;
         }
        case 22:
         {
          $$0909$reg2mem$0 = 0;
          $$3862$reg2mem$0 = $44;
          while (1) {
           $69 = $$0909$reg2mem$0 << 7;
           $70 = HEAP8[$$3862$reg2mem$0 >> 0] | 0;
           $71 = $70 & 255;
           $72 = $71 & 127;
           $73 = $72 | $69;
           $74 = $$3862$reg2mem$0 + 1 | 0;
           $75 = $71 & 128;
           $76 = ($75 | 0) == 0;
           if ($76) {
            break;
           } else {
            $$0909$reg2mem$0 = $73;
            $$3862$reg2mem$0 = $74;
           }
          }
          $77 = $73 << 2;
          $78 = $77 | 2;
          $79 = $78;
          $80 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$80 >> 2] = $79;
          $$1860$be$reg2mem1443$0 = $74;
          $$1868$be$reg2mem1445$0 = $80;
          break;
         }
        case 23:
         {
          $81 = $44;
          $82 = $81 + 3 | 0;
          $83 = $82 & -4;
          $84 = $83;
          $85 = $83;
          $86 = HEAP32[$85 >> 2] | 0;
          $87 = $84 + 4 | 0;
          $88 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$88 >> 2] = $86;
          $$1860$be$reg2mem1443$0 = $87;
          $$1868$be$reg2mem1445$0 = $88;
          break;
         }
        case 24:
         {
          $89 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$89 >> 2] = 0;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $89;
          break;
         }
        case 25:
         {
          $$0910$reg2mem$0 = 0;
          $$4863$reg2mem$0 = $44;
          while (1) {
           $90 = $$0910$reg2mem$0 << 7;
           $91 = HEAP8[$$4863$reg2mem$0 >> 0] | 0;
           $92 = $91 & 255;
           $93 = $92 & 127;
           $94 = $93 | $90;
           $95 = $$4863$reg2mem$0 + 1 | 0;
           $96 = $92 & 128;
           $97 = ($96 | 0) == 0;
           if ($97) {
            break;
           } else {
            $$0910$reg2mem$0 = $94;
            $$4863$reg2mem$0 = $95;
           }
          }
          $98 = 0 - $94 | 0;
          $99 = $$reg2mem1386$2 + ($98 << 2) | 0;
          $100 = HEAP32[$99 >> 2] | 0;
          $$4888$reg2mem1453$0 = $100;
          $$5$reg2mem1451$0 = $95;
          label = 58;
          break;
         }
        case 26:
         {
          $$0911$reg2mem$0 = 0;
          $$8$reg2mem$0 = $44;
          while (1) {
           $110 = $$0911$reg2mem$0 << 7;
           $111 = HEAP8[$$8$reg2mem$0 >> 0] | 0;
           $112 = $111 & 255;
           $113 = $112 & 127;
           $114 = $113 | $110;
           $115 = $$8$reg2mem$0 + 1 | 0;
           $116 = $112 & 128;
           $117 = ($116 | 0) == 0;
           if ($117) {
            break;
           } else {
            $$0911$reg2mem$0 = $114;
            $$8$reg2mem$0 = $115;
           }
          }
          $118 = 0 - $114 | 0;
          $119 = $$reg2mem1386$2 + ($118 << 2) | 0;
          $120 = HEAP32[$119 >> 2] | 0;
          __THREW__ = 0;
          $121 = invoke_ii(572, $120 | 0) | 0;
          $122 = __THREW__;
          __THREW__ = 0;
          if (($122 | 0) != 0 & (threwValue | 0) != 0) {
           $123 = _testSetjmp(HEAP32[$122 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($123 | 0) == 0) {
            _longjmp($122 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $123 = -1;
          }
          $124 = getTempRet0() | 0;
          $cond1563 = ($123 | 0) == 1;
          if ($cond1563) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $124;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $$4888$reg2mem1453$0 = $121;
          $$5$reg2mem1451$0 = $115;
          label = 58;
          break;
         }
        case 27:
         {
          $$0912$reg2mem$0 = 0;
          $$9$reg2mem$0 = $44;
          while (1) {
           $125 = $$0912$reg2mem$0 << 7;
           $126 = HEAP8[$$9$reg2mem$0 >> 0] | 0;
           $127 = $126 & 255;
           $128 = $127 & 127;
           $129 = $128 | $125;
           $130 = $$9$reg2mem$0 + 1 | 0;
           $131 = $127 & 128;
           $132 = ($131 | 0) == 0;
           if ($132) {
            break;
           } else {
            $$0912$reg2mem$0 = $129;
            $$9$reg2mem$0 = $130;
           }
          }
          __THREW__ = 0;
          $133 = invoke_ii(573, $129 | 0) | 0;
          $134 = __THREW__;
          __THREW__ = 0;
          if (($134 | 0) != 0 & (threwValue | 0) != 0) {
           $135 = _testSetjmp(HEAP32[$134 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($135 | 0) == 0) {
            _longjmp($134 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $135 = -1;
          }
          $136 = getTempRet0() | 0;
          $cond1562 = ($135 | 0) == 1;
          if ($cond1562) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $136;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $137 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$137 >> 2] = $133;
          $$1860$be$reg2mem1443$0 = $130;
          $$1868$be$reg2mem1445$0 = $137;
          break;
         }
        case 28:
         {
          $$0913$reg2mem$0 = 0;
          $$10$reg2mem$0 = $44;
          while (1) {
           $138 = $$0913$reg2mem$0 << 7;
           $139 = HEAP8[$$10$reg2mem$0 >> 0] | 0;
           $140 = $139 & 255;
           $141 = $140 & 127;
           $142 = $141 | $138;
           $143 = $$10$reg2mem$0 + 1 | 0;
           $144 = $140 & 128;
           $145 = ($144 | 0) == 0;
           if ($145) {
            break;
           } else {
            $$0913$reg2mem$0 = $142;
            $$10$reg2mem$0 = $143;
           }
          }
          __THREW__ = 0;
          $146 = invoke_ii(574, $142 | 0) | 0;
          $147 = __THREW__;
          __THREW__ = 0;
          if (($147 | 0) != 0 & (threwValue | 0) != 0) {
           $148 = _testSetjmp(HEAP32[$147 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($148 | 0) == 0) {
            _longjmp($147 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $148 = -1;
          }
          $149 = getTempRet0() | 0;
          $cond1561 = ($148 | 0) == 1;
          if ($cond1561) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $149;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $150 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$150 >> 2] = $146;
          $$1860$be$reg2mem1443$0 = $143;
          $$1868$be$reg2mem1445$0 = $150;
          break;
         }
        case 29:
         {
          $$0914$reg2mem$0 = 0;
          $$11$reg2mem$0 = $44;
          while (1) {
           $151 = $$0914$reg2mem$0 << 7;
           $152 = HEAP8[$$11$reg2mem$0 >> 0] | 0;
           $153 = $152 & 255;
           $154 = $153 & 127;
           $155 = $154 | $151;
           $156 = $$11$reg2mem$0 + 1 | 0;
           $157 = $153 & 128;
           $158 = ($157 | 0) == 0;
           if ($158) {
            break;
           } else {
            $$0914$reg2mem$0 = $155;
            $$11$reg2mem$0 = $156;
           }
          }
          $159 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          $160 = invoke_iii(575, $159 | 0, $155 | 0) | 0;
          $161 = __THREW__;
          __THREW__ = 0;
          if (($161 | 0) != 0 & (threwValue | 0) != 0) {
           $162 = _testSetjmp(HEAP32[$161 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($162 | 0) == 0) {
            _longjmp($161 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $162 = -1;
          }
          $163 = getTempRet0() | 0;
          $cond1560 = ($162 | 0) == 1;
          if ($cond1560) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $163;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$$1868$reg2mem1463$0 >> 2] = $160;
          $$1860$be$reg2mem1443$0 = $156;
          $$1868$be$reg2mem1445$0 = $$1868$reg2mem1463$0;
          break;
         }
        case 30:
         {
          $$0915$reg2mem$0 = 0;
          $$12$reg2mem$0 = $44;
          while (1) {
           $164 = $$0915$reg2mem$0 << 7;
           $165 = HEAP8[$$12$reg2mem$0 >> 0] | 0;
           $166 = $165 & 255;
           $167 = $166 & 127;
           $168 = $167 | $164;
           $169 = $$12$reg2mem$0 + 1 | 0;
           $170 = $166 & 128;
           $171 = ($170 | 0) == 0;
           if ($171) {
            break;
           } else {
            $$0915$reg2mem$0 = $168;
            $$12$reg2mem$0 = $169;
           }
          }
          $172 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          invoke_viii(542, $172 | 0, $168 | 0, $$1868$reg2mem1463$0 | 0);
          $173 = __THREW__;
          __THREW__ = 0;
          if (($173 | 0) != 0 & (threwValue | 0) != 0) {
           $174 = _testSetjmp(HEAP32[$173 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($174 | 0) == 0) {
            _longjmp($173 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $174 = -1;
          }
          $175 = getTempRet0() | 0;
          $cond1559 = ($174 | 0) == 1;
          if ($cond1559) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $175;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $176 = $$1868$reg2mem1463$0 + 4 | 0;
          $$1860$be$reg2mem1443$0 = $169;
          $$1868$be$reg2mem1445$0 = $176;
          break;
         }
        case 31:
         {
          $$0917$reg2mem$0 = 0;
          $$13$reg2mem$0 = $44;
          while (1) {
           $177 = $$0917$reg2mem$0 << 7;
           $178 = HEAP8[$$13$reg2mem$0 >> 0] | 0;
           $179 = $178 & 255;
           $180 = $179 & 127;
           $181 = $180 | $177;
           $182 = $$13$reg2mem$0 + 1 | 0;
           $183 = $179 & 128;
           $184 = ($183 | 0) == 0;
           if ($184) {
            break;
           } else {
            $$0917$reg2mem$0 = $181;
            $$13$reg2mem$0 = $182;
           }
          }
          $185 = $$1868$reg2mem1463$0 + -4 | 0;
          $186 = $$1868$reg2mem1463$0 + -8 | 0;
          __THREW__ = 0;
          invoke_vii(576, $181 | 0, $186 | 0);
          $187 = __THREW__;
          __THREW__ = 0;
          if (($187 | 0) != 0 & (threwValue | 0) != 0) {
           $188 = _testSetjmp(HEAP32[$187 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($188 | 0) == 0) {
            _longjmp($187 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $188 = -1;
          }
          $189 = getTempRet0() | 0;
          $cond1558 = ($188 | 0) == 1;
          if ($cond1558) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $189;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $$1860$be$reg2mem1443$0 = $182;
          $$1868$be$reg2mem1445$0 = $185;
          break;
         }
        case 32:
         {
          __THREW__ = 0;
          $190 = invoke_i(577) | 0;
          $191 = __THREW__;
          __THREW__ = 0;
          if (($191 | 0) != 0 & (threwValue | 0) != 0) {
           $192 = _testSetjmp(HEAP32[$191 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($192 | 0) == 0) {
            _longjmp($191 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $192 = -1;
          }
          $193 = getTempRet0() | 0;
          $cond1557 = ($192 | 0) == 1;
          if ($cond1557) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $193;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $194 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$194 >> 2] = $190;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $194;
          break;
         }
        case 33:
         {
          $195 = $$1868$reg2mem1463$0 + -4 | 0;
          $196 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $197 = HEAP32[$195 >> 2] | 0;
          __THREW__ = 0;
          $198 = invoke_iiii(578, $197 | 0, $196 | 0, 4 | 0) | 0;
          $199 = __THREW__;
          __THREW__ = 0;
          if (($199 | 0) != 0 & (threwValue | 0) != 0) {
           $200 = _testSetjmp(HEAP32[$199 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($200 | 0) == 0) {
            _longjmp($199 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $200 = -1;
          }
          $201 = getTempRet0() | 0;
          $cond1556 = ($200 | 0) == 1;
          if ($cond1556) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $201;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$195 >> 2] = $198;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $195;
          break;
         }
        case 34:
         {
          $$0919$reg2mem$0 = 0;
          $$14$reg2mem$0 = $44;
          while (1) {
           $202 = $$0919$reg2mem$0 << 7;
           $203 = HEAP8[$$14$reg2mem$0 >> 0] | 0;
           $204 = $203 & 255;
           $205 = $204 & 127;
           $206 = $205 | $202;
           $207 = $$14$reg2mem$0 + 1 | 0;
           $208 = $204 & 128;
           $209 = ($208 | 0) == 0;
           if ($209) {
            break;
           } else {
            $$0919$reg2mem$0 = $206;
            $$14$reg2mem$0 = $207;
           }
          }
          $210 = $$1868$reg2mem1463$0 + -4 | 0;
          $211 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $212 = 0 - $206 | 0;
          $213 = $$reg2mem1386$2 + ($212 << 2) | 0;
          HEAP32[$213 >> 2] = $211;
          $$1860$be$reg2mem1443$0 = $207;
          $$1868$be$reg2mem1445$0 = $210;
          break;
         }
        case 35:
         {
          $$0920$reg2mem$0 = 0;
          $$15$reg2mem$0 = $44;
          while (1) {
           $214 = $$0920$reg2mem$0 << 7;
           $215 = HEAP8[$$15$reg2mem$0 >> 0] | 0;
           $216 = $215 & 255;
           $217 = $216 & 127;
           $218 = $217 | $214;
           $219 = $$15$reg2mem$0 + 1 | 0;
           $220 = $216 & 128;
           $221 = ($220 | 0) == 0;
           if ($221) {
            break;
           } else {
            $$0920$reg2mem$0 = $218;
            $$15$reg2mem$0 = $219;
           }
          }
          $222 = 0 - $218 | 0;
          $223 = $$reg2mem1386$2 + ($222 << 2) | 0;
          $224 = HEAP32[$223 >> 2] | 0;
          $225 = $$1868$reg2mem1463$0 + -4 | 0;
          $226 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          invoke_vii(579, $224 | 0, $226 | 0);
          $227 = __THREW__;
          __THREW__ = 0;
          if (($227 | 0) != 0 & (threwValue | 0) != 0) {
           $228 = _testSetjmp(HEAP32[$227 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($228 | 0) == 0) {
            _longjmp($227 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $228 = -1;
          }
          $229 = getTempRet0() | 0;
          $cond1555 = ($228 | 0) == 1;
          if ($cond1555) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $229;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $$1860$be$reg2mem1443$0 = $219;
          $$1868$be$reg2mem1445$0 = $225;
          break;
         }
        case 36:
         {
          $$0922$reg2mem$0 = 0;
          $$16$reg2mem$0 = $44;
          while (1) {
           $230 = $$0922$reg2mem$0 << 7;
           $231 = HEAP8[$$16$reg2mem$0 >> 0] | 0;
           $232 = $231 & 255;
           $233 = $232 & 127;
           $234 = $233 | $230;
           $235 = $$16$reg2mem$0 + 1 | 0;
           $236 = $232 & 128;
           $237 = ($236 | 0) == 0;
           if ($237) {
            break;
           } else {
            $$0922$reg2mem$0 = $234;
            $$16$reg2mem$0 = $235;
           }
          }
          $238 = $$1868$reg2mem1463$0 + -4 | 0;
          $239 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          invoke_vii(580, $234 | 0, $239 | 0);
          $240 = __THREW__;
          __THREW__ = 0;
          if (($240 | 0) != 0 & (threwValue | 0) != 0) {
           $241 = _testSetjmp(HEAP32[$240 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($241 | 0) == 0) {
            _longjmp($240 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $241 = -1;
          }
          $242 = getTempRet0() | 0;
          $cond1554 = ($241 | 0) == 1;
          if ($cond1554) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $242;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $$1860$be$reg2mem1443$0 = $235;
          $$1868$be$reg2mem1445$0 = $238;
          break;
         }
        case 37:
         {
          $$0927$reg2mem$0 = 0;
          $$17$reg2mem$0 = $44;
          while (1) {
           $243 = $$0927$reg2mem$0 << 7;
           $244 = HEAP8[$$17$reg2mem$0 >> 0] | 0;
           $245 = $244 & 255;
           $246 = $245 & 127;
           $247 = $246 | $243;
           $248 = $$17$reg2mem$0 + 1 | 0;
           $249 = $245 & 128;
           $250 = ($249 | 0) == 0;
           if ($250) {
            break;
           } else {
            $$0927$reg2mem$0 = $247;
            $$17$reg2mem$0 = $248;
           }
          }
          $251 = $$1868$reg2mem1463$0 + -4 | 0;
          $252 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          invoke_vii(581, $247 | 0, $252 | 0);
          $253 = __THREW__;
          __THREW__ = 0;
          if (($253 | 0) != 0 & (threwValue | 0) != 0) {
           $254 = _testSetjmp(HEAP32[$253 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($254 | 0) == 0) {
            _longjmp($253 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $254 = -1;
          }
          $255 = getTempRet0() | 0;
          $cond1553 = ($254 | 0) == 1;
          if ($cond1553) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $255;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $$1860$be$reg2mem1443$0 = $248;
          $$1868$be$reg2mem1445$0 = $251;
          break;
         }
        case 38:
         {
          $$0928$reg2mem$0 = 0;
          $$18$reg2mem$0 = $44;
          while (1) {
           $256 = $$0928$reg2mem$0 << 7;
           $257 = HEAP8[$$18$reg2mem$0 >> 0] | 0;
           $258 = $257 & 255;
           $259 = $258 & 127;
           $260 = $259 | $256;
           $261 = $$18$reg2mem$0 + 1 | 0;
           $262 = $258 & 128;
           $263 = ($262 | 0) == 0;
           if ($263) {
            break;
           } else {
            $$0928$reg2mem$0 = $260;
            $$18$reg2mem$0 = $261;
           }
          }
          $264 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $265 = $$1868$reg2mem1463$0 + -4 | 0;
          $266 = HEAP32[$265 >> 2] | 0;
          __THREW__ = 0;
          invoke_viii(582, $264 | 0, $260 | 0, $266 | 0);
          $267 = __THREW__;
          __THREW__ = 0;
          if (($267 | 0) != 0 & (threwValue | 0) != 0) {
           $268 = _testSetjmp(HEAP32[$267 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($268 | 0) == 0) {
            _longjmp($267 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $268 = -1;
          }
          $269 = getTempRet0() | 0;
          $cond1552 = ($268 | 0) == 1;
          if ($cond1552) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $269;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $270 = $$1868$reg2mem1463$0 + -8 | 0;
          $$1860$be$reg2mem1443$0 = $261;
          $$1868$be$reg2mem1445$0 = $270;
          break;
         }
        case 39:
         {
          $271 = $$1868$reg2mem1463$0 + -4 | 0;
          $272 = HEAP32[$271 >> 2] | 0;
          $273 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $274 = $$1868$reg2mem1463$0 + -8 | 0;
          $275 = HEAP32[$274 >> 2] | 0;
          __THREW__ = 0;
          invoke_iiii(578, $272 | 0, $273 | 0, $275 | 0) | 0;
          $276 = __THREW__;
          __THREW__ = 0;
          if (($276 | 0) != 0 & (threwValue | 0) != 0) {
           $277 = _testSetjmp(HEAP32[$276 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($277 | 0) == 0) {
            _longjmp($276 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $277 = -1;
          }
          $278 = getTempRet0() | 0;
          $cond1551 = ($277 | 0) == 1;
          if ($cond1551) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $278;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $279 = $$1868$reg2mem1463$0 + -12 | 0;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $279;
          break;
         }
        case 40:
         {
          $$0933$reg2mem$0 = 0;
          $$19$reg2mem$0 = $44;
          while (1) {
           $280 = $$0933$reg2mem$0 << 7;
           $281 = HEAP8[$$19$reg2mem$0 >> 0] | 0;
           $282 = $281 & 255;
           $283 = $282 & 127;
           $284 = $283 | $280;
           $285 = $$19$reg2mem$0 + 1 | 0;
           $286 = $282 & 128;
           $287 = ($286 | 0) == 0;
           if ($287) {
            break;
           } else {
            $$0933$reg2mem$0 = $284;
            $$19$reg2mem$0 = $285;
           }
          }
          $288 = 0 - $284 | 0;
          $289 = $$reg2mem1386$2 + ($288 << 2) | 0;
          $290 = HEAP32[$289 >> 2] | 0;
          $291 = ($290 | 0) == (0 | 0);
          if ($291) {
           label = 59;
           break L15;
          }
          HEAP32[$289 >> 2] = 0;
          $$1860$be$reg2mem1443$0 = $285;
          $$1868$be$reg2mem1445$0 = $$1868$reg2mem1463$0;
          break;
         }
        case 41:
         {
          $$0934$reg2mem$0 = 0;
          $$20$reg2mem$0 = $44;
          while (1) {
           $292 = $$0934$reg2mem$0 << 7;
           $293 = HEAP8[$$20$reg2mem$0 >> 0] | 0;
           $294 = $293 & 255;
           $295 = $294 & 127;
           $296 = $295 | $292;
           $297 = $$20$reg2mem$0 + 1 | 0;
           $298 = $294 & 128;
           $299 = ($298 | 0) == 0;
           if ($299) {
            break;
           } else {
            $$0934$reg2mem$0 = $296;
            $$20$reg2mem$0 = $297;
           }
          }
          $300 = 0 - $296 | 0;
          $301 = $$reg2mem1386$2 + ($300 << 2) | 0;
          $302 = HEAP32[$301 >> 2] | 0;
          __THREW__ = 0;
          $303 = invoke_ii(572, $302 | 0) | 0;
          $304 = __THREW__;
          __THREW__ = 0;
          if (($304 | 0) != 0 & (threwValue | 0) != 0) {
           $305 = _testSetjmp(HEAP32[$304 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($305 | 0) == 0) {
            _longjmp($304 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $305 = -1;
          }
          $306 = getTempRet0() | 0;
          $cond1547 = ($305 | 0) == 1;
          if ($cond1547) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $306;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $307 = ($303 | 0) == (0 | 0);
          if ($307) {
           label = 59;
           break L15;
          }
          $308 = HEAP32[$301 >> 2] | 0;
          __THREW__ = 0;
          invoke_vii(579, $308 | 0, 0 | 0);
          $309 = __THREW__;
          __THREW__ = 0;
          if (($309 | 0) != 0 & (threwValue | 0) != 0) {
           $310 = _testSetjmp(HEAP32[$309 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($310 | 0) == 0) {
            _longjmp($309 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $310 = -1;
          }
          $311 = getTempRet0() | 0;
          $cond1548 = ($310 | 0) == 1;
          if ($cond1548) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $311;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $$1860$be$reg2mem1443$0 = $297;
          $$1868$be$reg2mem1445$0 = $$1868$reg2mem1463$0;
          break;
         }
        case 42:
         {
          $$0935$reg2mem$0 = 0;
          $$21$reg2mem$0 = $44;
          while (1) {
           $312 = $$0935$reg2mem$0 << 7;
           $313 = HEAP8[$$21$reg2mem$0 >> 0] | 0;
           $314 = $313 & 255;
           $315 = $314 & 127;
           $316 = $315 | $312;
           $317 = $$21$reg2mem$0 + 1 | 0;
           $318 = $314 & 128;
           $319 = ($318 | 0) == 0;
           if ($319) {
            break;
           } else {
            $$0935$reg2mem$0 = $316;
            $$21$reg2mem$0 = $317;
           }
          }
          __THREW__ = 0;
          invoke_vi(583, $316 | 0);
          $320 = __THREW__;
          __THREW__ = 0;
          if (($320 | 0) != 0 & (threwValue | 0) != 0) {
           $321 = _testSetjmp(HEAP32[$320 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($321 | 0) == 0) {
            _longjmp($320 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $321 = -1;
          }
          $322 = getTempRet0() | 0;
          $cond1546 = ($321 | 0) == 1;
          if ($cond1546) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $322;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $$1860$be$reg2mem1443$0 = $317;
          $$1868$be$reg2mem1445$0 = $$1868$reg2mem1463$0;
          break;
         }
        case 43:
         {
          $$0936$reg2mem$0 = 0;
          $$22$reg2mem$0 = $44;
          while (1) {
           $323 = $$0936$reg2mem$0 << 7;
           $324 = HEAP8[$$22$reg2mem$0 >> 0] | 0;
           $325 = $324 & 255;
           $326 = $325 & 127;
           $327 = $326 | $323;
           $328 = $$22$reg2mem$0 + 1 | 0;
           $329 = $325 & 128;
           $330 = ($329 | 0) == 0;
           if ($330) {
            break;
           } else {
            $$0936$reg2mem$0 = $327;
            $$22$reg2mem$0 = $328;
           }
          }
          __THREW__ = 0;
          invoke_vi(584, $327 | 0);
          $331 = __THREW__;
          __THREW__ = 0;
          if (($331 | 0) != 0 & (threwValue | 0) != 0) {
           $332 = _testSetjmp(HEAP32[$331 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($332 | 0) == 0) {
            _longjmp($331 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $332 = -1;
          }
          $333 = getTempRet0() | 0;
          $cond1545 = ($332 | 0) == 1;
          if ($cond1545) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $333;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $$1860$be$reg2mem1443$0 = $328;
          $$1868$be$reg2mem1445$0 = $$1868$reg2mem1463$0;
          break;
         }
        case 48:
         {
          $334 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $335 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$335 >> 2] = $334;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $335;
          break;
         }
        case 49:
         {
          $336 = $$1868$reg2mem1463$0 + 8 | 0;
          $337 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          HEAP32[$336 >> 2] = $337;
          $338 = $$1868$reg2mem1463$0 + -4 | 0;
          $339 = HEAP32[$338 >> 2] | 0;
          $340 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$340 >> 2] = $339;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $336;
          break;
         }
        case 50:
         {
          $341 = $$1868$reg2mem1463$0 + -4 | 0;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $341;
          break;
         }
        case 51:
         {
          $342 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $343 = $$1868$reg2mem1463$0 + -4 | 0;
          $344 = HEAP32[$343 >> 2] | 0;
          HEAP32[$$1868$reg2mem1463$0 >> 2] = $344;
          HEAP32[$343 >> 2] = $342;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $$1868$reg2mem1463$0;
          break;
         }
        case 52:
         {
          $345 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $346 = $$1868$reg2mem1463$0 + -4 | 0;
          $347 = HEAP32[$346 >> 2] | 0;
          HEAP32[$$1868$reg2mem1463$0 >> 2] = $347;
          $348 = $$1868$reg2mem1463$0 + -8 | 0;
          $349 = HEAP32[$348 >> 2] | 0;
          HEAP32[$346 >> 2] = $349;
          HEAP32[$348 >> 2] = $345;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $$1868$reg2mem1463$0;
          break;
         }
        case 53:
         {
          $350 = HEAP8[$44 >> 0] | 0;
          $351 = $350 & 255;
          $352 = $$1860$reg2mem1461$0 + 2 | 0;
          $353 = HEAP8[$352 >> 0] | 0;
          $354 = $353 & 255;
          $355 = $354 << 8;
          $356 = $355 | $351;
          $357 = $356 + -32768 | 0;
          $358 = $$1860$reg2mem1461$0 + 3 | 0;
          $359 = $358 + $357 | 0;
          $$16883$reg2mem1415$0 = $$1868$reg2mem1463$0;
          $$45$reg2mem1413$0 = $359;
          label = 309;
          break;
         }
        case 54:
         {
          $360 = HEAP8[$44 >> 0] | 0;
          $361 = $$1860$reg2mem1461$0 + 2 | 0;
          $362 = HEAP8[$361 >> 0] | 0;
          $363 = $$1860$reg2mem1461$0 + 3 | 0;
          $364 = $$1868$reg2mem1463$0 + -4 | 0;
          $365 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          $366 = invoke_ii(585, $365 | 0) | 0;
          $367 = __THREW__;
          __THREW__ = 0;
          if (($367 | 0) != 0 & (threwValue | 0) != 0) {
           $368 = _testSetjmp(HEAP32[$367 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($368 | 0) == 0) {
            _longjmp($367 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $368 = -1;
          }
          $369 = getTempRet0() | 0;
          $cond1544 = ($368 | 0) == 1;
          if ($cond1544) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $369;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $370 = $362 & 255;
          $371 = $370 << 8;
          $372 = $360 & 255;
          $373 = $371 | $372;
          $374 = $373 + -32768 | 0;
          $375 = $363 + $374 | 0;
          $spec$select968 = $366 ? $375 : $363;
          $$16883$reg2mem1415$0 = $364;
          $$45$reg2mem1413$0 = $spec$select968;
          label = 309;
          break;
         }
        case 55:
         {
          $376 = HEAP8[$44 >> 0] | 0;
          $377 = $$1860$reg2mem1461$0 + 2 | 0;
          $378 = HEAP8[$377 >> 0] | 0;
          $379 = $$1860$reg2mem1461$0 + 3 | 0;
          $380 = $$1868$reg2mem1463$0 + -4 | 0;
          $381 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          $382 = invoke_ii(585, $381 | 0) | 0;
          $383 = __THREW__;
          __THREW__ = 0;
          if (($383 | 0) != 0 & (threwValue | 0) != 0) {
           $384 = _testSetjmp(HEAP32[$383 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($384 | 0) == 0) {
            _longjmp($383 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $384 = -1;
          }
          $385 = getTempRet0() | 0;
          $cond1543 = ($384 | 0) == 1;
          if ($cond1543) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $385;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $386 = $378 & 255;
          $387 = $386 << 8;
          $388 = $376 & 255;
          $389 = $387 | $388;
          $390 = $389 + -32768 | 0;
          $391 = $379 + $390 | 0;
          $spec$select969 = $382 ? $379 : $391;
          $$16883$reg2mem1415$0 = $380;
          $$45$reg2mem1413$0 = $spec$select969;
          label = 309;
          break;
         }
        case 56:
         {
          $392 = HEAP8[$44 >> 0] | 0;
          $393 = $$1860$reg2mem1461$0 + 2 | 0;
          $394 = HEAP8[$393 >> 0] | 0;
          $395 = $$1860$reg2mem1461$0 + 3 | 0;
          $396 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          $397 = invoke_ii(585, $396 | 0) | 0;
          $398 = __THREW__;
          __THREW__ = 0;
          if (($398 | 0) != 0 & (threwValue | 0) != 0) {
           $399 = _testSetjmp(HEAP32[$398 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($399 | 0) == 0) {
            _longjmp($398 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $399 = -1;
          }
          $400 = getTempRet0() | 0;
          $cond1542 = ($399 | 0) == 1;
          if ($cond1542) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $400;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          if ($397) {
           $401 = $394 & 255;
           $402 = $401 << 8;
           $403 = $392 & 255;
           $404 = $402 | $403;
           $405 = $404 + -32768 | 0;
           $406 = $395 + $405 | 0;
           $$16883$reg2mem1415$0 = $$1868$reg2mem1463$0;
           $$45$reg2mem1413$0 = $406;
           label = 309;
           break L17;
          } else {
           $407 = $$1868$reg2mem1463$0 + -4 | 0;
           $$16883$reg2mem1415$0 = $407;
           $$45$reg2mem1413$0 = $395;
           label = 309;
           break L17;
          }
          break;
         }
        case 57:
         {
          $408 = HEAP8[$44 >> 0] | 0;
          $409 = $$1860$reg2mem1461$0 + 2 | 0;
          $410 = HEAP8[$409 >> 0] | 0;
          $411 = $$1860$reg2mem1461$0 + 3 | 0;
          $412 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          $413 = invoke_ii(585, $412 | 0) | 0;
          $414 = __THREW__;
          __THREW__ = 0;
          if (($414 | 0) != 0 & (threwValue | 0) != 0) {
           $415 = _testSetjmp(HEAP32[$414 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($415 | 0) == 0) {
            _longjmp($414 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $415 = -1;
          }
          $416 = getTempRet0() | 0;
          $cond1541 = ($415 | 0) == 1;
          if ($cond1541) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $416;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          if ($413) {
           $417 = $$1868$reg2mem1463$0 + -4 | 0;
           $$16883$reg2mem1415$0 = $417;
           $$45$reg2mem1413$0 = $411;
           label = 309;
           break L17;
          } else {
           $418 = $410 & 255;
           $419 = $418 << 8;
           $420 = $408 & 255;
           $421 = $419 | $420;
           $422 = $421 + -32768 | 0;
           $423 = $411 + $422 | 0;
           $$16883$reg2mem1415$0 = $$1868$reg2mem1463$0;
           $$45$reg2mem1413$0 = $423;
           label = 309;
           break L17;
          }
          break;
         }
        case 61:
         {
          $424 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          invoke_viii(542, $424 | 0, 13, $$1868$reg2mem1463$0 | 0);
          $425 = __THREW__;
          __THREW__ = 0;
          if (($425 | 0) != 0 & (threwValue | 0) != 0) {
           $426 = _testSetjmp(HEAP32[$425 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($426 | 0) == 0) {
            _longjmp($425 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $426 = -1;
          }
          $427 = getTempRet0() | 0;
          $cond1538 = ($426 | 0) == 1;
          if ($cond1538) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $427;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $428 = $$1868$reg2mem1463$0 + 8 | 0;
          __THREW__ = 0;
          invoke_viii(542, $424 | 0, 12, $428 | 0);
          $429 = __THREW__;
          __THREW__ = 0;
          if (($429 | 0) != 0 & (threwValue | 0) != 0) {
           $430 = _testSetjmp(HEAP32[$429 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($430 | 0) == 0) {
            _longjmp($429 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $430 = -1;
          }
          $431 = getTempRet0() | 0;
          $cond1539 = ($430 | 0) == 1;
          if ($cond1539) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $431;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          __THREW__ = 0;
          $432 = invoke_iiii(497, 0, 0, $428 | 0) | 0;
          $433 = __THREW__;
          __THREW__ = 0;
          if (($433 | 0) != 0 & (threwValue | 0) != 0) {
           $434 = _testSetjmp(HEAP32[$433 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($434 | 0) == 0) {
            _longjmp($433 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $434 = -1;
          }
          $435 = getTempRet0() | 0;
          $cond1540 = ($434 | 0) == 1;
          if ($cond1540) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $435;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $436 = $$1868$reg2mem1463$0 + 4 | 0;
          $437 = HEAP8[$44 >> 0] | 0;
          $438 = $437 & 255;
          $439 = $$1860$reg2mem1461$0 + 2 | 0;
          $440 = HEAP8[$439 >> 0] | 0;
          $441 = $440 & 255;
          $442 = $441 << 8;
          $443 = $442 | $438;
          $444 = $$1860$reg2mem1461$0 + 3 | 0;
          $$0$$0$786 = HEAP32[$3 >> 2] | 0;
          $445 = $$0$$0$786 + 12 | 0;
          HEAP32[$3 >> 2] = $445;
          $446 = $444 + $443 | 0;
          $$0$$0$787 = HEAP32[$3 >> 2] | 0;
          HEAP32[$$0$$0$787 >> 2] = $446;
          $447 = $436;
          $448 = $447 | 2;
          $449 = $448;
          $$0$$0$788 = HEAP32[$3 >> 2] | 0;
          $450 = $$0$$0$788 + 4 | 0;
          HEAP32[$450 >> 2] = $449;
          $$0$$0$789 = HEAP32[$3 >> 2] | 0;
          $451 = $$0$$0$789 + 8 | 0;
          HEAP32[$451 >> 2] = 0;
          HEAP32[$428 >> 2] = $432;
          $$1860$be$reg2mem1443$0 = $444;
          $$1868$be$reg2mem1445$0 = $428;
          break;
         }
        case 62:
         {
          $452 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $453 = ($452 | 0) == (17668 | 0);
          $454 = $452;
          if ($453) {
           $455 = $$1868$reg2mem1463$0 + 4 | 0;
           HEAP32[$455 >> 2] = 17668;
           $456 = $$1868$reg2mem1463$0 + 8 | 0;
           HEAP32[$456 >> 2] = 17668;
           $457 = $$1868$reg2mem1463$0 + -8 | 0;
           __THREW__ = 0;
           invoke_iiii(497, 3, 0, $457 | 0) | 0;
           $458 = __THREW__;
           __THREW__ = 0;
           if (($458 | 0) != 0 & (threwValue | 0) != 0) {
            $459 = _testSetjmp(HEAP32[$458 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
            if (($459 | 0) == 0) {
             _longjmp($458 | 0, threwValue | 0);
            }
            setTempRet0(threwValue | 0);
           } else {
            $459 = -1;
           }
           $460 = getTempRet0() | 0;
           $cond1537 = ($459 | 0) == 1;
           if ($cond1537) {
            $$reg2mem1386$2$phi = $$reg2mem1386$2;
            $$reg2mem1383$2$phi = $$reg2mem1383$2;
            $$reg2mem1375$2$phi = $$reg2mem1375$2;
            $$reg2mem1371$2$phi = $$reg2mem1371$2;
            $$reg2mem1367$2$phi = $$reg2mem1367$2;
            $$reg2mem1365$2$phi = $$reg2mem1365$2;
            $$reg2mem1355$2$phi = $$reg2mem1355$2;
            $$reg2mem1345$2$phi = $$reg2mem1345$2;
            $$reg2mem1332$2$phi = $$reg2mem1332$2;
            $$reg2mem1330$2$phi = $$reg2mem1330$2;
            $$reg2mem1327$2$phi = $$reg2mem1327$2;
            $$reg2mem1324$2$phi = $$reg2mem1324$2;
            $$reg2mem1319$2$phi = $$reg2mem1319$2;
            $$reg2mem1316$2$phi = $$reg2mem1316$2;
            $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
            $$reg2mem1465$0 = $460;
            $$reg2mem1386$2 = $$reg2mem1386$2$phi;
            $$reg2mem1383$2 = $$reg2mem1383$2$phi;
            $$reg2mem1375$2 = $$reg2mem1375$2$phi;
            $$reg2mem1371$2 = $$reg2mem1371$2$phi;
            $$reg2mem1367$2 = $$reg2mem1367$2$phi;
            $$reg2mem1365$2 = $$reg2mem1365$2$phi;
            $$reg2mem1355$2 = $$reg2mem1355$2$phi;
            $$reg2mem1345$2 = $$reg2mem1345$2$phi;
            $$reg2mem1332$2 = $$reg2mem1332$2$phi;
            $$reg2mem1330$2 = $$reg2mem1330$2$phi;
            $$reg2mem1327$2 = $$reg2mem1327$2$phi;
            $$reg2mem1324$2 = $$reg2mem1324$2$phi;
            $$reg2mem1319$2 = $$reg2mem1319$2$phi;
            $$reg2mem1316$2 = $$reg2mem1316$2$phi;
            $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
            label = 7;
            continue L3;
           }
           HEAP32[$457 >> 2] = 17668;
           $$1860$be$reg2mem1443$0 = $44;
           $$1868$be$reg2mem1445$0 = $457;
           break L17;
          }
          $461 = $454 & 1;
          $462 = ($461 | 0) == 0;
          if (!$462) {
           $463 = $$1868$reg2mem1463$0 + -4 | 0;
           $464 = HEAP32[$463 >> 2] | 0;
           HEAP32[$463 >> 2] = 17668;
           HEAP32[$$1868$reg2mem1463$0 >> 2] = 17668;
           $465 = $$1868$reg2mem1463$0 + 4 | 0;
           HEAP32[$465 >> 2] = 17668;
           $466 = $$1868$reg2mem1463$0 + -12 | 0;
           __THREW__ = 0;
           invoke_iiii(497, 3, 0, $466 | 0) | 0;
           $467 = __THREW__;
           __THREW__ = 0;
           if (($467 | 0) != 0 & (threwValue | 0) != 0) {
            $468 = _testSetjmp(HEAP32[$467 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
            if (($468 | 0) == 0) {
             _longjmp($467 | 0, threwValue | 0);
            }
            setTempRet0(threwValue | 0);
           } else {
            $468 = -1;
           }
           $469 = getTempRet0() | 0;
           $cond1533 = ($468 | 0) == 1;
           if ($cond1533) {
            $$reg2mem1386$2$phi = $$reg2mem1386$2;
            $$reg2mem1383$2$phi = $$reg2mem1383$2;
            $$reg2mem1375$2$phi = $$reg2mem1375$2;
            $$reg2mem1371$2$phi = $$reg2mem1371$2;
            $$reg2mem1367$2$phi = $$reg2mem1367$2;
            $$reg2mem1365$2$phi = $$reg2mem1365$2;
            $$reg2mem1355$2$phi = $$reg2mem1355$2;
            $$reg2mem1345$2$phi = $$reg2mem1345$2;
            $$reg2mem1332$2$phi = $$reg2mem1332$2;
            $$reg2mem1330$2$phi = $$reg2mem1330$2;
            $$reg2mem1327$2$phi = $$reg2mem1327$2;
            $$reg2mem1324$2$phi = $$reg2mem1324$2;
            $$reg2mem1319$2$phi = $$reg2mem1319$2;
            $$reg2mem1316$2$phi = $$reg2mem1316$2;
            $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
            $$reg2mem1465$0 = $469;
            $$reg2mem1386$2 = $$reg2mem1386$2$phi;
            $$reg2mem1383$2 = $$reg2mem1383$2$phi;
            $$reg2mem1375$2 = $$reg2mem1375$2$phi;
            $$reg2mem1371$2 = $$reg2mem1371$2$phi;
            $$reg2mem1367$2 = $$reg2mem1367$2$phi;
            $$reg2mem1365$2 = $$reg2mem1365$2$phi;
            $$reg2mem1355$2 = $$reg2mem1355$2$phi;
            $$reg2mem1345$2 = $$reg2mem1345$2$phi;
            $$reg2mem1332$2 = $$reg2mem1332$2$phi;
            $$reg2mem1330$2 = $$reg2mem1330$2$phi;
            $$reg2mem1327$2 = $$reg2mem1327$2$phi;
            $$reg2mem1324$2 = $$reg2mem1324$2$phi;
            $$reg2mem1319$2 = $$reg2mem1319$2$phi;
            $$reg2mem1316$2 = $$reg2mem1316$2$phi;
            $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
            label = 7;
            continue L3;
           }
           HEAP32[$466 >> 2] = $464;
           $470 = $$1868$reg2mem1463$0 + -8 | 0;
           HEAP32[$470 >> 2] = $454;
           $$1860$be$reg2mem1443$0 = $44;
           $$1868$be$reg2mem1445$0 = $470;
           break L17;
          }
          $471 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$471 >> 2] = $454;
          __THREW__ = 0;
          $472 = invoke_ii(494, $452 | 0) | 0;
          $473 = __THREW__;
          __THREW__ = 0;
          if (($473 | 0) != 0 & (threwValue | 0) != 0) {
           $474 = _testSetjmp(HEAP32[$473 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($474 | 0) == 0) {
            _longjmp($473 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $474 = -1;
          }
          $475 = getTempRet0() | 0;
          $cond1534 = ($474 | 0) == 1;
          if ($cond1534) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $475;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$$1868$reg2mem1463$0 >> 2] = $472;
          $476 = $$1868$reg2mem1463$0 + 8 | 0;
          HEAP32[$476 >> 2] = 17668;
          $477 = $$1868$reg2mem1463$0 + -8 | 0;
          __THREW__ = 0;
          $478 = invoke_iiii(497, 3, 0, $477 | 0) | 0;
          $479 = __THREW__;
          __THREW__ = 0;
          if (($479 | 0) != 0 & (threwValue | 0) != 0) {
           $480 = _testSetjmp(HEAP32[$479 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($480 | 0) == 0) {
            _longjmp($479 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $480 = -1;
          }
          $481 = getTempRet0() | 0;
          $cond1535 = ($480 | 0) == 1;
          if ($cond1535) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $481;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          __THREW__ = 0;
          $482 = invoke_ii(585, $478 | 0) | 0;
          $483 = __THREW__;
          __THREW__ = 0;
          if (($483 | 0) != 0 & (threwValue | 0) != 0) {
           $484 = _testSetjmp(HEAP32[$483 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($484 | 0) == 0) {
            _longjmp($483 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $484 = -1;
          }
          $485 = getTempRet0() | 0;
          $cond1536 = ($484 | 0) == 1;
          if ($cond1536) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $485;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          if ($482) {
           HEAP32[$477 >> 2] = 17668;
           $$1860$be$reg2mem1443$0 = $44;
           $$1868$be$reg2mem1445$0 = $477;
           break L17;
          } else {
           $486 = HEAP32[$471 >> 2] | 0;
           HEAP32[$477 >> 2] = $486;
           $$1860$be$reg2mem1443$0 = $44;
           $$1868$be$reg2mem1445$0 = $477;
           break L17;
          }
          break;
         }
        case 70:
         {
          $487 = HEAP8[$44 >> 0] | 0;
          $488 = $487 & 255;
          $489 = $$1860$reg2mem1461$0 + 2 | 0;
          $490 = HEAP8[$489 >> 0] | 0;
          $491 = $490 & 255;
          $492 = $491 << 8;
          $493 = $492 | $488;
          $494 = $493 + -32768 | 0;
          $495 = $$1860$reg2mem1461$0 + 3 | 0;
          $496 = $495 + $494 | 0;
          $497 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$497 >> 2] = $496;
          $498 = HEAP8[$495 >> 0] | 0;
          $499 = $498 & 255;
          $500 = $499;
          $501 = $$1868$reg2mem1463$0 + 8 | 0;
          HEAP32[$501 >> 2] = $500;
          $$27$reg2mem1447$0 = $495;
          $$5872$reg2mem1449$0 = $501;
          label = 150;
          break;
         }
        case 64:
        case 63:
         {
          $524 = HEAP8[$44 >> 0] | 0;
          $525 = $524 & 255;
          $526 = $$1860$reg2mem1461$0 + 2 | 0;
          $527 = HEAP8[$526 >> 0] | 0;
          $528 = $527 & 255;
          $529 = $528 << 8;
          $530 = $529 | $525;
          $531 = $$1860$reg2mem1461$0 + 3 | 0;
          $$0$$0$795 = HEAP32[$3 >> 2] | 0;
          $532 = $$0$$0$795 + 12 | 0;
          HEAP32[$3 >> 2] = $532;
          $533 = $531 + $530 | 0;
          $$0$$0$796 = HEAP32[$3 >> 2] | 0;
          HEAP32[$$0$$0$796 >> 2] = $533;
          $534 = $$1868$reg2mem1463$0;
          $535 = HEAP8[$$1860$reg2mem1461$0 >> 0] | 0;
          $536 = $535 << 24 >> 24 == 64;
          $537 = $536 & 1;
          $538 = $537 << 1;
          $539 = $538 | $534;
          $540 = $539;
          $$0$$0$797 = HEAP32[$3 >> 2] | 0;
          $541 = $$0$$0$797 + 4 | 0;
          HEAP32[$541 >> 2] = $540;
          $$0$$0$798 = HEAP32[$3 >> 2] | 0;
          $542 = $$0$$0$798 + 8 | 0;
          HEAP32[$542 >> 2] = 0;
          $$1860$be$reg2mem1443$0 = $531;
          $$1868$be$reg2mem1445$0 = $$1868$reg2mem1463$0;
          break;
         }
        case 65:
         {
          $543 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $544 = ($543 | 0) == (17668 | 0);
          $545 = $543;
          if ($544) {
           $$0$$0$785 = HEAP32[$3 >> 2] | 0;
           $546 = $$0$$0$785 + -12 | 0;
           HEAP32[$3 >> 2] = $546;
           $547 = $$1868$reg2mem1463$0 + -4 | 0;
           $$1860$be$reg2mem1443$0 = $44;
           $$1868$be$reg2mem1445$0 = $547;
           break L17;
          }
          $548 = $545 & 1;
          $549 = ($548 | 0) == 0;
          if ($549) {
           label = 164;
           break L15;
          }
          $550 = ($543 | 0) < (0 | 0);
          if ($550) {
           $553 = $$1868$reg2mem1463$0 + -4 | 0;
           $$10877$reg2mem1431$0 = $553;
           label = 233;
           break L17;
          } else {
           $551 = $545 >>> 1;
           $552 = $551;
           HEAP32[$$1868$reg2mem1463$0 >> 2] = $552;
           $$27$reg2mem1447$0 = $44;
           $$5872$reg2mem1449$0 = $$1868$reg2mem1463$0;
           label = 150;
           break L17;
          }
          break;
         }
        case 66:
         {
          $558 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          $559 = invoke_iii(586, $558 | 0, 0 | 0) | 0;
          $560 = __THREW__;
          __THREW__ = 0;
          if (($560 | 0) != 0 & (threwValue | 0) != 0) {
           $561 = _testSetjmp(HEAP32[$560 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($561 | 0) == 0) {
            _longjmp($560 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $561 = -1;
          }
          $562 = getTempRet0() | 0;
          $cond1531 = ($561 | 0) == 1;
          if ($cond1531) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $562;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$$1868$reg2mem1463$0 >> 2] = $559;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $$1868$reg2mem1463$0;
          break;
         }
        case 71:
         {
          $563 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $564 = $$1868$reg2mem1463$0 + 12 | 0;
          __THREW__ = 0;
          $565 = invoke_iii(586, $563 | 0, $$1868$reg2mem1463$0 | 0) | 0;
          $566 = __THREW__;
          __THREW__ = 0;
          if (($566 | 0) != 0 & (threwValue | 0) != 0) {
           $567 = _testSetjmp(HEAP32[$566 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($567 | 0) == 0) {
            _longjmp($566 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $567 = -1;
          }
          $568 = getTempRet0() | 0;
          $cond1530 = ($567 | 0) == 1;
          if ($cond1530) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $568;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $569 = ($565 | 0) == ($$1868$reg2mem1463$0 | 0);
          if ($569) {
           $$1860$be$reg2mem1443$0 = $44;
           $$1868$be$reg2mem1445$0 = $564;
          } else {
           HEAP32[$$1868$reg2mem1463$0 >> 2] = 0;
           $570 = $$1868$reg2mem1463$0 + 4 | 0;
           HEAP32[$570 >> 2] = $565;
           $$1860$be$reg2mem1443$0 = $44;
           $$1868$be$reg2mem1445$0 = $564;
          }
          break;
         }
        case 67:
         {
          $571 = HEAP8[$44 >> 0] | 0;
          $572 = $571 & 255;
          $573 = $$1860$reg2mem1461$0 + 2 | 0;
          $574 = HEAP8[$573 >> 0] | 0;
          $575 = $574 & 255;
          $576 = $575 << 8;
          $577 = $576 | $572;
          $578 = $$1860$reg2mem1461$0 + 3 | 0;
          HEAP32[$$reg2mem1345$2 >> 2] = $$1868$reg2mem1463$0;
          $579 = $$1868$reg2mem1463$0 + -12 | 0;
          $580 = HEAP32[$579 >> 2] | 0;
          $581 = ($580 | 0) == (0 | 0);
          if ($581) {
           $582 = $$1868$reg2mem1463$0 + -8 | 0;
           $583 = HEAP32[$582 >> 2] | 0;
           $$0938$reg2mem$0 = $583;
          } else {
           $$0938$reg2mem$0 = $579;
          }
          __THREW__ = 0;
          $584 = invoke_ii(587, $$0938$reg2mem$0 | 0) | 0;
          $585 = __THREW__;
          __THREW__ = 0;
          if (($585 | 0) != 0 & (threwValue | 0) != 0) {
           $586 = _testSetjmp(HEAP32[$585 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($586 | 0) == 0) {
            _longjmp($585 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $586 = -1;
          }
          $587 = getTempRet0() | 0;
          $cond1529 = ($586 | 0) == 1;
          if ($cond1529) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $587;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $588 = ($584 | 0) == (0 | 0);
          if ($588) {
           $589 = $$1868$reg2mem1463$0 + -16 | 0;
           $590 = $578 + $577 | 0;
           $$1860$be$reg2mem1443$0 = $590;
           $$1868$be$reg2mem1445$0 = $589;
           break L17;
          } else {
           $591 = $$1868$reg2mem1463$0 + 4 | 0;
           HEAP32[$591 >> 2] = $584;
           $$1860$be$reg2mem1443$0 = $578;
           $$1868$be$reg2mem1445$0 = $591;
           break L17;
          }
          break;
         }
        case 68:
         {
          $$0$$0$769 = HEAP32[$3 >> 2] | 0;
          $592 = $$0$$0$769 + -12 | 0;
          HEAP32[$3 >> 2] = $592;
          $593 = HEAP8[$44 >> 0] | 0;
          $594 = $593 & 255;
          $595 = $$1860$reg2mem1461$0 + 2 | 0;
          $596 = HEAP8[$595 >> 0] | 0;
          $597 = $596 & 255;
          $598 = $597 << 8;
          $599 = $598 | $594;
          $600 = $$1860$reg2mem1461$0 + 3 | 0;
          $601 = $600 + $599 | 0;
          $$16883$reg2mem1415$0 = $$1868$reg2mem1463$0;
          $$45$reg2mem1413$0 = $601;
          label = 309;
          break;
         }
        case 80:
         {
          $$0941$reg2mem$0 = 0;
          $$29$reg2mem$0 = $44;
          while (1) {
           $602 = $$0941$reg2mem$0 << 7;
           $603 = HEAP8[$$29$reg2mem$0 >> 0] | 0;
           $604 = $603 & 255;
           $605 = $604 & 127;
           $606 = $605 | $602;
           $607 = $$29$reg2mem$0 + 1 | 0;
           $608 = $604 & 128;
           $609 = ($608 | 0) == 0;
           if ($609) {
            break;
           } else {
            $$0941$reg2mem$0 = $606;
            $$29$reg2mem$0 = $607;
           }
          }
          $610 = 1 - $606 | 0;
          $611 = $$1868$reg2mem1463$0 + ($610 << 2) | 0;
          __THREW__ = 0;
          $612 = invoke_iii(588, $606 | 0, $611 | 0) | 0;
          $613 = __THREW__;
          __THREW__ = 0;
          if (($613 | 0) != 0 & (threwValue | 0) != 0) {
           $614 = _testSetjmp(HEAP32[$613 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($614 | 0) == 0) {
            _longjmp($613 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $614 = -1;
          }
          $615 = getTempRet0() | 0;
          $cond1525 = ($614 | 0) == 1;
          if ($cond1525) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $615;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$611 >> 2] = $612;
          $$1860$be$reg2mem1443$0 = $607;
          $$1868$be$reg2mem1445$0 = $611;
          break;
         }
        case 81:
         {
          $$0943$reg2mem$0 = 0;
          $$30$reg2mem$0 = $44;
          while (1) {
           $616 = $$0943$reg2mem$0 << 7;
           $617 = HEAP8[$$30$reg2mem$0 >> 0] | 0;
           $618 = $617 & 255;
           $619 = $618 & 127;
           $620 = $619 | $616;
           $621 = $$30$reg2mem$0 + 1 | 0;
           $622 = $618 & 128;
           $623 = ($622 | 0) == 0;
           if ($623) {
            break;
           } else {
            $$0943$reg2mem$0 = $620;
            $$30$reg2mem$0 = $621;
           }
          }
          $624 = 1 - $620 | 0;
          $625 = $$1868$reg2mem1463$0 + ($624 << 2) | 0;
          __THREW__ = 0;
          $626 = invoke_iii(589, $620 | 0, $625 | 0) | 0;
          $627 = __THREW__;
          __THREW__ = 0;
          if (($627 | 0) != 0 & (threwValue | 0) != 0) {
           $628 = _testSetjmp(HEAP32[$627 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($628 | 0) == 0) {
            _longjmp($627 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $628 = -1;
          }
          $629 = getTempRet0() | 0;
          $cond1524 = ($628 | 0) == 1;
          if ($cond1524) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $629;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$625 >> 2] = $626;
          $$1860$be$reg2mem1443$0 = $621;
          $$1868$be$reg2mem1445$0 = $625;
          break;
         }
        case 83:
         {
          $$0944$reg2mem$0 = 0;
          $$31$reg2mem$0 = $44;
          while (1) {
           $630 = $$0944$reg2mem$0 << 7;
           $631 = HEAP8[$$31$reg2mem$0 >> 0] | 0;
           $632 = $631 & 255;
           $633 = $632 & 127;
           $634 = $633 | $630;
           $635 = $$31$reg2mem$0 + 1 | 0;
           $636 = $632 & 128;
           $637 = ($636 | 0) == 0;
           if ($637) {
            break;
           } else {
            $$0944$reg2mem$0 = $634;
            $$31$reg2mem$0 = $635;
           }
          }
          __THREW__ = 0;
          $638 = invoke_ii(590, $634 | 0) | 0;
          $639 = __THREW__;
          __THREW__ = 0;
          if (($639 | 0) != 0 & (threwValue | 0) != 0) {
           $640 = _testSetjmp(HEAP32[$639 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($640 | 0) == 0) {
            _longjmp($639 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $640 = -1;
          }
          $641 = getTempRet0() | 0;
          $cond1523 = ($640 | 0) == 1;
          if ($cond1523) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $641;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $642 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$642 >> 2] = $638;
          $$1860$be$reg2mem1443$0 = $635;
          $$1868$be$reg2mem1445$0 = $642;
          break;
         }
        case 84:
         {
          $643 = $$1868$reg2mem1463$0 + -8 | 0;
          $644 = HEAP32[$643 >> 2] | 0;
          $645 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $646 = $$1868$reg2mem1463$0 + -4 | 0;
          $647 = HEAP32[$646 >> 2] | 0;
          __THREW__ = 0;
          invoke_iiii(591, $644 | 0, $645 | 0, $647 | 0) | 0;
          $648 = __THREW__;
          __THREW__ = 0;
          if (($648 | 0) != 0 & (threwValue | 0) != 0) {
           $649 = _testSetjmp(HEAP32[$648 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($649 | 0) == 0) {
            _longjmp($648 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $649 = -1;
          }
          $650 = getTempRet0() | 0;
          $cond1522 = ($649 | 0) == 1;
          if ($cond1522) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $650;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $643;
          break;
         }
        case 86:
         {
          $$0946$reg2mem$0 = 0;
          $$32$reg2mem$0 = $44;
          while (1) {
           $651 = $$0946$reg2mem$0 << 7;
           $652 = HEAP8[$$32$reg2mem$0 >> 0] | 0;
           $653 = $652 & 255;
           $654 = $653 & 127;
           $655 = $654 | $651;
           $656 = $$32$reg2mem$0 + 1 | 0;
           $657 = $653 & 128;
           $658 = ($657 | 0) == 0;
           if ($658) {
            break;
           } else {
            $$0946$reg2mem$0 = $655;
            $$32$reg2mem$0 = $656;
           }
          }
          $659 = 1 - $655 | 0;
          $660 = $$1868$reg2mem1463$0 + ($659 << 2) | 0;
          __THREW__ = 0;
          $661 = invoke_iii(592, $655 | 0, $660 | 0) | 0;
          $662 = __THREW__;
          __THREW__ = 0;
          if (($662 | 0) != 0 & (threwValue | 0) != 0) {
           $663 = _testSetjmp(HEAP32[$662 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($663 | 0) == 0) {
            _longjmp($662 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $663 = -1;
          }
          $664 = getTempRet0() | 0;
          $cond1521 = ($663 | 0) == 1;
          if ($cond1521) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $664;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$660 >> 2] = $661;
          $$1860$be$reg2mem1443$0 = $656;
          $$1868$be$reg2mem1445$0 = $660;
          break;
         }
        case 88:
         {
          $665 = $$1860$reg2mem1461$0 + 2 | 0;
          $666 = HEAP8[$44 >> 0] | 0;
          $667 = $666 << 24 >> 24 == 3;
          if ($667) {
           $668 = $$1868$reg2mem1463$0 + -4 | 0;
           $669 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
           $$0945$reg2mem$0 = $669;
           $$8875$reg2mem$0 = $668;
          } else {
           $$0945$reg2mem$0 = 17668;
           $$8875$reg2mem$0 = $$1868$reg2mem1463$0;
          }
          $670 = $$8875$reg2mem$0 + -4 | 0;
          $671 = HEAP32[$$8875$reg2mem$0 >> 2] | 0;
          $672 = HEAP32[$670 >> 2] | 0;
          __THREW__ = 0;
          $673 = invoke_iiii(593, $672 | 0, $671 | 0, $$0945$reg2mem$0 | 0) | 0;
          $674 = __THREW__;
          __THREW__ = 0;
          if (($674 | 0) != 0 & (threwValue | 0) != 0) {
           $675 = _testSetjmp(HEAP32[$674 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($675 | 0) == 0) {
            _longjmp($674 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $675 = -1;
          }
          $676 = getTempRet0() | 0;
          $cond1520 = ($675 | 0) == 1;
          if ($cond1520) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $676;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$670 >> 2] = $673;
          $$1860$be$reg2mem1443$0 = $665;
          $$1868$be$reg2mem1445$0 = $670;
          break;
         }
        case 87:
         {
          $$0942$reg2mem$0 = 0;
          $$33$reg2mem$0 = $44;
          while (1) {
           $677 = $$0942$reg2mem$0 << 7;
           $678 = HEAP8[$$33$reg2mem$0 >> 0] | 0;
           $679 = $678 & 255;
           $680 = $679 & 127;
           $681 = $680 | $677;
           $682 = $$33$reg2mem$0 + 1 | 0;
           $683 = $679 & 128;
           $684 = ($683 | 0) == 0;
           if ($684) {
            break;
           } else {
            $$0942$reg2mem$0 = $681;
            $$33$reg2mem$0 = $682;
           }
          }
          $685 = $681 >>> 2;
          $686 = 0 - $685 | 0;
          $687 = $$1868$reg2mem1463$0 + ($686 << 2) | 0;
          $688 = HEAP32[$687 >> 2] | 0;
          $689 = $678 & 3;
          $690 = $689 << 24 >> 24 == 0;
          if ($690) {
           $691 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
           __THREW__ = 0;
           invoke_iii(145, $688 | 0, $691 | 0) | 0;
           $692 = __THREW__;
           __THREW__ = 0;
           if (($692 | 0) != 0 & (threwValue | 0) != 0) {
            $693 = _testSetjmp(HEAP32[$692 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
            if (($693 | 0) == 0) {
             _longjmp($692 | 0, threwValue | 0);
            }
            setTempRet0(threwValue | 0);
           } else {
            $693 = -1;
           }
           $694 = getTempRet0() | 0;
           $cond1519 = ($693 | 0) == 1;
           if ($cond1519) {
            $$reg2mem1386$2$phi = $$reg2mem1386$2;
            $$reg2mem1383$2$phi = $$reg2mem1383$2;
            $$reg2mem1375$2$phi = $$reg2mem1375$2;
            $$reg2mem1371$2$phi = $$reg2mem1371$2;
            $$reg2mem1367$2$phi = $$reg2mem1367$2;
            $$reg2mem1365$2$phi = $$reg2mem1365$2;
            $$reg2mem1355$2$phi = $$reg2mem1355$2;
            $$reg2mem1345$2$phi = $$reg2mem1345$2;
            $$reg2mem1332$2$phi = $$reg2mem1332$2;
            $$reg2mem1330$2$phi = $$reg2mem1330$2;
            $$reg2mem1327$2$phi = $$reg2mem1327$2;
            $$reg2mem1324$2$phi = $$reg2mem1324$2;
            $$reg2mem1319$2$phi = $$reg2mem1319$2;
            $$reg2mem1316$2$phi = $$reg2mem1316$2;
            $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
            $$reg2mem1465$0 = $694;
            $$reg2mem1386$2 = $$reg2mem1386$2$phi;
            $$reg2mem1383$2 = $$reg2mem1383$2$phi;
            $$reg2mem1375$2 = $$reg2mem1375$2$phi;
            $$reg2mem1371$2 = $$reg2mem1371$2$phi;
            $$reg2mem1367$2 = $$reg2mem1367$2$phi;
            $$reg2mem1365$2 = $$reg2mem1365$2$phi;
            $$reg2mem1355$2 = $$reg2mem1355$2$phi;
            $$reg2mem1345$2 = $$reg2mem1345$2$phi;
            $$reg2mem1332$2 = $$reg2mem1332$2$phi;
            $$reg2mem1330$2 = $$reg2mem1330$2$phi;
            $$reg2mem1327$2 = $$reg2mem1327$2$phi;
            $$reg2mem1324$2 = $$reg2mem1324$2$phi;
            $$reg2mem1319$2 = $$reg2mem1319$2$phi;
            $$reg2mem1316$2 = $$reg2mem1316$2$phi;
            $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
            label = 7;
            continue L3;
           }
           $695 = $$1868$reg2mem1463$0 + -4 | 0;
           $$1860$be$reg2mem1443$0 = $682;
           $$1868$be$reg2mem1445$0 = $695;
           break L17;
          }
          $696 = $689 << 24 >> 24 == 1;
          $697 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          if ($696) {
           $698 = $$1868$reg2mem1463$0 + -4 | 0;
           $699 = HEAP32[$698 >> 2] | 0;
           __THREW__ = 0;
           invoke_iiii(591, $688 | 0, $697 | 0, $699 | 0) | 0;
           $700 = __THREW__;
           __THREW__ = 0;
           if (($700 | 0) != 0 & (threwValue | 0) != 0) {
            $701 = _testSetjmp(HEAP32[$700 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
            if (($701 | 0) == 0) {
             _longjmp($700 | 0, threwValue | 0);
            }
            setTempRet0(threwValue | 0);
           } else {
            $701 = -1;
           }
           $702 = getTempRet0() | 0;
           $cond1518 = ($701 | 0) == 1;
           if ($cond1518) {
            $$reg2mem1386$2$phi = $$reg2mem1386$2;
            $$reg2mem1383$2$phi = $$reg2mem1383$2;
            $$reg2mem1375$2$phi = $$reg2mem1375$2;
            $$reg2mem1371$2$phi = $$reg2mem1371$2;
            $$reg2mem1367$2$phi = $$reg2mem1367$2;
            $$reg2mem1365$2$phi = $$reg2mem1365$2;
            $$reg2mem1355$2$phi = $$reg2mem1355$2;
            $$reg2mem1345$2$phi = $$reg2mem1345$2;
            $$reg2mem1332$2$phi = $$reg2mem1332$2;
            $$reg2mem1330$2$phi = $$reg2mem1330$2;
            $$reg2mem1327$2$phi = $$reg2mem1327$2;
            $$reg2mem1324$2$phi = $$reg2mem1324$2;
            $$reg2mem1319$2$phi = $$reg2mem1319$2;
            $$reg2mem1316$2$phi = $$reg2mem1316$2;
            $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
            $$reg2mem1465$0 = $702;
            $$reg2mem1386$2 = $$reg2mem1386$2$phi;
            $$reg2mem1383$2 = $$reg2mem1383$2$phi;
            $$reg2mem1375$2 = $$reg2mem1375$2$phi;
            $$reg2mem1371$2 = $$reg2mem1371$2$phi;
            $$reg2mem1367$2 = $$reg2mem1367$2$phi;
            $$reg2mem1365$2 = $$reg2mem1365$2$phi;
            $$reg2mem1355$2 = $$reg2mem1355$2$phi;
            $$reg2mem1345$2 = $$reg2mem1345$2$phi;
            $$reg2mem1332$2 = $$reg2mem1332$2$phi;
            $$reg2mem1330$2 = $$reg2mem1330$2$phi;
            $$reg2mem1327$2 = $$reg2mem1327$2$phi;
            $$reg2mem1324$2 = $$reg2mem1324$2$phi;
            $$reg2mem1319$2 = $$reg2mem1319$2$phi;
            $$reg2mem1316$2 = $$reg2mem1316$2$phi;
            $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
            label = 7;
            continue L3;
           }
           $703 = $$1868$reg2mem1463$0 + -8 | 0;
           $$1860$be$reg2mem1443$0 = $682;
           $$1868$be$reg2mem1445$0 = $703;
           break L17;
          } else {
           __THREW__ = 0;
           invoke_vii(594, $688 | 0, $697 | 0);
           $704 = __THREW__;
           __THREW__ = 0;
           if (($704 | 0) != 0 & (threwValue | 0) != 0) {
            $705 = _testSetjmp(HEAP32[$704 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
            if (($705 | 0) == 0) {
             _longjmp($704 | 0, threwValue | 0);
            }
            setTempRet0(threwValue | 0);
           } else {
            $705 = -1;
           }
           $706 = getTempRet0() | 0;
           $cond1517 = ($705 | 0) == 1;
           if ($cond1517) {
            $$reg2mem1386$2$phi = $$reg2mem1386$2;
            $$reg2mem1383$2$phi = $$reg2mem1383$2;
            $$reg2mem1375$2$phi = $$reg2mem1375$2;
            $$reg2mem1371$2$phi = $$reg2mem1371$2;
            $$reg2mem1367$2$phi = $$reg2mem1367$2;
            $$reg2mem1365$2$phi = $$reg2mem1365$2;
            $$reg2mem1355$2$phi = $$reg2mem1355$2;
            $$reg2mem1345$2$phi = $$reg2mem1345$2;
            $$reg2mem1332$2$phi = $$reg2mem1332$2;
            $$reg2mem1330$2$phi = $$reg2mem1330$2;
            $$reg2mem1327$2$phi = $$reg2mem1327$2;
            $$reg2mem1324$2$phi = $$reg2mem1324$2;
            $$reg2mem1319$2$phi = $$reg2mem1319$2;
            $$reg2mem1316$2$phi = $$reg2mem1316$2;
            $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
            $$reg2mem1465$0 = $706;
            $$reg2mem1386$2 = $$reg2mem1386$2$phi;
            $$reg2mem1383$2 = $$reg2mem1383$2$phi;
            $$reg2mem1375$2 = $$reg2mem1375$2$phi;
            $$reg2mem1371$2 = $$reg2mem1371$2$phi;
            $$reg2mem1367$2 = $$reg2mem1367$2$phi;
            $$reg2mem1365$2 = $$reg2mem1365$2$phi;
            $$reg2mem1355$2 = $$reg2mem1355$2$phi;
            $$reg2mem1345$2 = $$reg2mem1345$2$phi;
            $$reg2mem1332$2 = $$reg2mem1332$2$phi;
            $$reg2mem1330$2 = $$reg2mem1330$2$phi;
            $$reg2mem1327$2 = $$reg2mem1327$2$phi;
            $$reg2mem1324$2 = $$reg2mem1324$2$phi;
            $$reg2mem1319$2 = $$reg2mem1319$2$phi;
            $$reg2mem1316$2 = $$reg2mem1316$2$phi;
            $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
            label = 7;
            continue L3;
           }
           $707 = $$1868$reg2mem1463$0 + -4 | 0;
           $$1860$be$reg2mem1443$0 = $682;
           $$1868$be$reg2mem1445$0 = $707;
           break L17;
          }
          break;
         }
        case 89:
         {
          $$0940$reg2mem$0 = 0;
          $$34$reg2mem$0 = $44;
          while (1) {
           $708 = $$0940$reg2mem$0 << 7;
           $709 = HEAP8[$$34$reg2mem$0 >> 0] | 0;
           $710 = $709 & 255;
           $711 = $710 & 127;
           $712 = $711 | $708;
           $713 = $$34$reg2mem$0 + 1 | 0;
           $714 = $710 & 128;
           $715 = ($714 | 0) == 0;
           if ($715) {
            break;
           } else {
            $$0940$reg2mem$0 = $712;
            $$34$reg2mem$0 = $713;
           }
          }
          $716 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          invoke_viii(595, $716 | 0, $712 | 0, $$1868$reg2mem1463$0 | 0);
          $717 = __THREW__;
          __THREW__ = 0;
          if (($717 | 0) != 0 & (threwValue | 0) != 0) {
           $718 = _testSetjmp(HEAP32[$717 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($718 | 0) == 0) {
            _longjmp($717 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $718 = -1;
          }
          $719 = getTempRet0() | 0;
          $cond1516 = ($718 | 0) == 1;
          if ($cond1516) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $719;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $720 = $712 + -1 | 0;
          $721 = $$1868$reg2mem1463$0 + ($720 << 2) | 0;
          $$1860$be$reg2mem1443$0 = $713;
          $$1868$be$reg2mem1445$0 = $721;
          break;
         }
        case 90:
         {
          $$0939$reg2mem1441$0 = 0;
          $$35$reg2mem$0 = $44;
          while (1) {
           $722 = $$0939$reg2mem1441$0 << 7;
           $723 = HEAP8[$$35$reg2mem$0 >> 0] | 0;
           $724 = $723 & 255;
           $725 = $724 & 127;
           $726 = $725 | $722;
           $727 = $$35$reg2mem$0 + 1 | 0;
           $728 = $724 & 128;
           $729 = ($728 | 0) == 0;
           if ($729) {
            break;
           } else {
            $$0939$reg2mem1441$0 = $726;
            $$35$reg2mem$0 = $727;
           }
          }
          $730 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          invoke_viii(596, $730 | 0, $726 | 0, $$1868$reg2mem1463$0 | 0);
          $731 = __THREW__;
          __THREW__ = 0;
          if (($731 | 0) != 0 & (threwValue | 0) != 0) {
           $732 = _testSetjmp(HEAP32[$731 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($732 | 0) == 0) {
            _longjmp($731 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $732 = -1;
          }
          $733 = getTempRet0() | 0;
          $cond1515 = ($732 | 0) == 1;
          if ($cond1515) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $733;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $734 = $726 & 255;
          $735 = $$0939$reg2mem1441$0 >>> 1;
          $736 = $735 & 255;
          $737 = $734 + $736 | 0;
          $738 = $$1868$reg2mem1463$0 + ($737 << 2) | 0;
          $$1860$be$reg2mem1443$0 = $727;
          $$1868$be$reg2mem1445$0 = $738;
          break;
         }
        case 96:
         {
          $739 = $44;
          $740 = $739 + 3 | 0;
          $741 = $740 & -4;
          $742 = $741;
          $743 = $741;
          $744 = HEAP32[$743 >> 2] | 0;
          $745 = $742 + 4 | 0;
          __THREW__ = 0;
          $746 = invoke_iiii(597, $744 | 0, 0 | 0, 0 | 0) | 0;
          $747 = __THREW__;
          __THREW__ = 0;
          if (($747 | 0) != 0 & (threwValue | 0) != 0) {
           $748 = _testSetjmp(HEAP32[$747 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($748 | 0) == 0) {
            _longjmp($747 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $748 = -1;
          }
          $749 = getTempRet0() | 0;
          $cond1514 = ($748 | 0) == 1;
          if ($cond1514) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $749;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $750 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$750 >> 2] = $746;
          $$1860$be$reg2mem1443$0 = $745;
          $$1868$be$reg2mem1445$0 = $750;
          break;
         }
        case 97:
         {
          $751 = $44;
          $752 = $751 + 3 | 0;
          $753 = $752 & -4;
          $754 = $753;
          $755 = $753;
          $756 = HEAP32[$755 >> 2] | 0;
          $757 = $754 + 4 | 0;
          $758 = $$1868$reg2mem1463$0 + -4 | 0;
          $759 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $760 = HEAP32[$758 >> 2] | 0;
          __THREW__ = 0;
          $761 = invoke_iiii(597, $756 | 0, $760 | 0, $759 | 0) | 0;
          $762 = __THREW__;
          __THREW__ = 0;
          if (($762 | 0) != 0 & (threwValue | 0) != 0) {
           $763 = _testSetjmp(HEAP32[$762 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($763 | 0) == 0) {
            _longjmp($762 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $763 = -1;
          }
          $764 = getTempRet0() | 0;
          $cond1513 = ($763 | 0) == 1;
          if ($cond1513) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $764;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$758 >> 2] = $761;
          $$1860$be$reg2mem1443$0 = $757;
          $$1868$be$reg2mem1445$0 = $758;
          break;
         }
        case 98:
         {
          $765 = $44;
          $766 = $765 + 3 | 0;
          $767 = $766 & -4;
          $768 = $767;
          $769 = $767;
          $770 = HEAP32[$769 >> 2] | 0;
          $771 = $768 + 4 | 0;
          $772 = $768 + 5 | 0;
          $773 = HEAP8[$771 >> 0] | 0;
          $774 = $773 & 255;
          $775 = 1 - $774 | 0;
          $776 = $$1868$reg2mem1463$0 + ($775 << 2) | 0;
          __THREW__ = 0;
          $777 = invoke_iiii(598, $770 | 0, $774 | 0, $776 | 0) | 0;
          $778 = __THREW__;
          __THREW__ = 0;
          if (($778 | 0) != 0 & (threwValue | 0) != 0) {
           $779 = _testSetjmp(HEAP32[$778 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($779 | 0) == 0) {
            _longjmp($778 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $779 = -1;
          }
          $780 = getTempRet0() | 0;
          $cond1512 = ($779 | 0) == 1;
          if ($cond1512) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $780;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$776 >> 2] = $777;
          $$1860$be$reg2mem1443$0 = $772;
          $$1868$be$reg2mem1445$0 = $776;
          break;
         }
        case 99:
         {
          $781 = $44;
          $782 = $781 + 3 | 0;
          $783 = $782 & -4;
          $784 = $783;
          $785 = $783;
          $786 = HEAP32[$785 >> 2] | 0;
          $787 = $784 + 4 | 0;
          $788 = $784 + 5 | 0;
          $789 = HEAP8[$787 >> 0] | 0;
          $790 = $789 & 255;
          $791 = $790 ^ -1;
          $792 = $$1868$reg2mem1463$0 + ($791 << 2) | 0;
          $793 = $790 | 256;
          __THREW__ = 0;
          $794 = invoke_iiii(598, $786 | 0, $793 | 0, $792 | 0) | 0;
          $795 = __THREW__;
          __THREW__ = 0;
          if (($795 | 0) != 0 & (threwValue | 0) != 0) {
           $796 = _testSetjmp(HEAP32[$795 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($796 | 0) == 0) {
            _longjmp($795 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $796 = -1;
          }
          $797 = getTempRet0() | 0;
          $cond1511 = ($796 | 0) == 1;
          if ($cond1511) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $797;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$792 >> 2] = $794;
          $$1860$be$reg2mem1443$0 = $788;
          $$1868$be$reg2mem1445$0 = $792;
          break;
         }
        case 100:
         {
          $$0932$reg2mem1439$0 = 0;
          $$36$reg2mem$0 = $44;
          while (1) {
           $798 = $$0932$reg2mem1439$0 << 7;
           $799 = HEAP8[$$36$reg2mem$0 >> 0] | 0;
           $800 = $799 & 255;
           $801 = $800 & 127;
           $802 = $801 | $798;
           $803 = $$36$reg2mem$0 + 1 | 0;
           $804 = $800 & 128;
           $805 = ($804 | 0) == 0;
           if ($805) {
            break;
           } else {
            $$0932$reg2mem1439$0 = $802;
            $$36$reg2mem$0 = $803;
           }
          }
          $806 = $802 & 255;
          $807 = $$0932$reg2mem1439$0 & 510;
          $808 = $807 + $806 | 0;
          $809 = 0 - $808 | 0;
          $810 = $$1868$reg2mem1463$0 + ($809 << 2) | 0;
          $811 = HEAP32[$810 >> 2] | 0;
          $812 = $$0932$reg2mem1439$0 >>> 1;
          $813 = $812 & 255;
          $814 = $810 + 4 | 0;
          __THREW__ = 0;
          $815 = invoke_iiiii(599, $811 | 0, $806 | 0, $813 | 0, $814 | 0) | 0;
          $816 = __THREW__;
          __THREW__ = 0;
          if (($816 | 0) != 0 & (threwValue | 0) != 0) {
           $817 = _testSetjmp(HEAP32[$816 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($817 | 0) == 0) {
            _longjmp($816 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $817 = -1;
          }
          $818 = getTempRet0() | 0;
          $cond1510 = ($817 | 0) == 1;
          if ($cond1510) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $818;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$810 >> 2] = $815;
          $$1860$be$reg2mem1443$0 = $803;
          $$1868$be$reg2mem1445$0 = $810;
          break;
         }
        case 101:
         {
          $$0931$reg2mem1437$0 = 0;
          $$37$reg2mem$0 = $44;
          while (1) {
           $819 = $$0931$reg2mem1437$0 << 7;
           $820 = HEAP8[$$37$reg2mem$0 >> 0] | 0;
           $821 = $820 & 255;
           $822 = $821 & 127;
           $823 = $822 | $819;
           $824 = $$37$reg2mem$0 + 1 | 0;
           $825 = $821 & 128;
           $826 = ($825 | 0) == 0;
           if ($826) {
            break;
           } else {
            $$0931$reg2mem1437$0 = $823;
            $$37$reg2mem$0 = $824;
           }
          }
          $827 = $823 & 255;
          $828 = $$0931$reg2mem1437$0 & 510;
          $$neg975 = -2 - $828 | 0;
          $829 = $$neg975 - $827 | 0;
          $830 = $$1868$reg2mem1463$0 + ($829 << 2) | 0;
          __THREW__ = 0;
          $831 = invoke_iiii(600, 0, $823 | 0, $830 | 0) | 0;
          $832 = __THREW__;
          __THREW__ = 0;
          if (($832 | 0) != 0 & (threwValue | 0) != 0) {
           $833 = _testSetjmp(HEAP32[$832 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($833 | 0) == 0) {
            _longjmp($832 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $833 = -1;
          }
          $834 = getTempRet0() | 0;
          $cond1509 = ($833 | 0) == 1;
          if ($cond1509) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $834;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$830 >> 2] = $831;
          $$1860$be$reg2mem1443$0 = $824;
          $$1868$be$reg2mem1445$0 = $830;
          break;
         }
        case 102:
         {
          $$0930$reg2mem1435$0 = 0;
          $$38$reg2mem$0 = $44;
          while (1) {
           $835 = $$0930$reg2mem1435$0 << 7;
           $836 = HEAP8[$$38$reg2mem$0 >> 0] | 0;
           $837 = $836 & 255;
           $838 = $837 & 127;
           $839 = $838 | $835;
           $840 = $$38$reg2mem$0 + 1 | 0;
           $841 = $837 & 128;
           $842 = ($841 | 0) == 0;
           if ($842) {
            break;
           } else {
            $$0930$reg2mem1435$0 = $839;
            $$38$reg2mem$0 = $840;
           }
          }
          $843 = $839 & 255;
          $844 = $$0930$reg2mem1435$0 & 510;
          $845 = $843 + $844 | 0;
          $846 = $845 ^ -1;
          $847 = $$1868$reg2mem1463$0 + ($846 << 2) | 0;
          $848 = $$0930$reg2mem1435$0 >>> 1;
          $849 = $848 & 255;
          __THREW__ = 0;
          $850 = invoke_iiii(497, $843 | 0, $849 | 0, $847 | 0) | 0;
          $851 = __THREW__;
          __THREW__ = 0;
          if (($851 | 0) != 0 & (threwValue | 0) != 0) {
           $852 = _testSetjmp(HEAP32[$851 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($852 | 0) == 0) {
            _longjmp($851 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $852 = -1;
          }
          $853 = getTempRet0() | 0;
          $cond1508 = ($852 | 0) == 1;
          if ($cond1508) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $853;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$847 >> 2] = $850;
          $$1860$be$reg2mem1443$0 = $840;
          $$1868$be$reg2mem1445$0 = $847;
          break;
         }
        case 103:
         {
          $$0929$reg2mem1433$0 = 0;
          $$39$reg2mem$0 = $44;
          while (1) {
           $854 = $$0929$reg2mem1433$0 << 7;
           $855 = HEAP8[$$39$reg2mem$0 >> 0] | 0;
           $856 = $855 & 255;
           $857 = $856 & 127;
           $858 = $857 | $854;
           $859 = $$39$reg2mem$0 + 1 | 0;
           $860 = $856 & 128;
           $861 = ($860 | 0) == 0;
           if ($861) {
            break;
           } else {
            $$0929$reg2mem1433$0 = $858;
            $$39$reg2mem$0 = $859;
           }
          }
          $862 = $858 & 255;
          $863 = $$0929$reg2mem1433$0 & 510;
          $$neg972 = -3 - $863 | 0;
          $864 = $$neg972 - $862 | 0;
          $865 = $$1868$reg2mem1463$0 + ($864 << 2) | 0;
          __THREW__ = 0;
          $866 = invoke_iiii(600, 1, $858 | 0, $865 | 0) | 0;
          $867 = __THREW__;
          __THREW__ = 0;
          if (($867 | 0) != 0 & (threwValue | 0) != 0) {
           $868 = _testSetjmp(HEAP32[$867 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($868 | 0) == 0) {
            _longjmp($867 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $868 = -1;
          }
          $869 = getTempRet0() | 0;
          $cond1507 = ($868 | 0) == 1;
          if ($cond1507) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $869;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$865 >> 2] = $866;
          $$1860$be$reg2mem1443$0 = $859;
          $$1868$be$reg2mem1445$0 = $865;
          break;
         }
        case 91:
         {
          $$10877$reg2mem1431$0 = $$1868$reg2mem1463$0;
          label = 233;
          break;
         }
        case 94:
         {
          $926 = $$1868$reg2mem1463$0 + -4 | 0;
          $927 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          HEAP32[$$reg2mem1345$2 >> 2] = $926;
          $$0$$0$825 = $2;
          $928 = ($$0$$0$825 | 0) == (0 | 0);
          if ($928) {
           $934 = HEAP32[$926 >> 2] | 0;
           __THREW__ = 0;
           $935 = invoke_iiiii(603, $934 | 0, $927 | 0, 0 | 0, $5 | 0) | 0;
           $936 = __THREW__;
           __THREW__ = 0;
           if (($936 | 0) != 0 & (threwValue | 0) != 0) {
            $937 = _testSetjmp(HEAP32[$936 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
            if (($937 | 0) == 0) {
             _longjmp($936 | 0, threwValue | 0);
            }
            setTempRet0(threwValue | 0);
           } else {
            $937 = -1;
           }
           $938 = getTempRet0() | 0;
           $cond1498 = ($937 | 0) == 1;
           if ($cond1498) {
            $$reg2mem1386$2$phi = $$reg2mem1386$2;
            $$reg2mem1383$2$phi = $$reg2mem1383$2;
            $$reg2mem1375$2$phi = $$reg2mem1375$2;
            $$reg2mem1371$2$phi = $$reg2mem1371$2;
            $$reg2mem1367$2$phi = $$reg2mem1367$2;
            $$reg2mem1365$2$phi = $$reg2mem1365$2;
            $$reg2mem1355$2$phi = $$reg2mem1355$2;
            $$reg2mem1345$2$phi = $$reg2mem1345$2;
            $$reg2mem1332$2$phi = $$reg2mem1332$2;
            $$reg2mem1330$2$phi = $$reg2mem1330$2;
            $$reg2mem1327$2$phi = $$reg2mem1327$2;
            $$reg2mem1324$2$phi = $$reg2mem1324$2;
            $$reg2mem1319$2$phi = $$reg2mem1319$2;
            $$reg2mem1316$2$phi = $$reg2mem1316$2;
            $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
            $$reg2mem1465$0 = $938;
            $$reg2mem1386$2 = $$reg2mem1386$2$phi;
            $$reg2mem1383$2 = $$reg2mem1383$2$phi;
            $$reg2mem1375$2 = $$reg2mem1375$2$phi;
            $$reg2mem1371$2 = $$reg2mem1371$2$phi;
            $$reg2mem1367$2 = $$reg2mem1367$2$phi;
            $$reg2mem1365$2 = $$reg2mem1365$2$phi;
            $$reg2mem1355$2 = $$reg2mem1355$2$phi;
            $$reg2mem1345$2 = $$reg2mem1345$2$phi;
            $$reg2mem1332$2 = $$reg2mem1332$2$phi;
            $$reg2mem1330$2 = $$reg2mem1330$2$phi;
            $$reg2mem1327$2 = $$reg2mem1327$2$phi;
            $$reg2mem1324$2 = $$reg2mem1324$2$phi;
            $$reg2mem1319$2 = $$reg2mem1319$2$phi;
            $$reg2mem1316$2 = $$reg2mem1316$2$phi;
            $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
            label = 7;
            continue L3;
           }
           $$0921$reg2mem1423$0 = 0;
           $$0923$reg2mem1425$0 = $935;
          } else {
           $$0$$0$826 = $2;
           $2 = 0;
           $929 = HEAP32[$926 >> 2] | 0;
           __THREW__ = 0;
           $930 = invoke_iiiii(603, $929 | 0, 0 | 0, $$0$$0$826 | 0, $5 | 0) | 0;
           $931 = __THREW__;
           __THREW__ = 0;
           if (($931 | 0) != 0 & (threwValue | 0) != 0) {
            $932 = _testSetjmp(HEAP32[$931 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
            if (($932 | 0) == 0) {
             _longjmp($931 | 0, threwValue | 0);
            }
            setTempRet0(threwValue | 0);
           } else {
            $932 = -1;
           }
           $933 = getTempRet0() | 0;
           $cond1488 = ($932 | 0) == 1;
           if ($cond1488) {
            $$reg2mem1386$2$phi = $$reg2mem1386$2;
            $$reg2mem1383$2$phi = $$reg2mem1383$2;
            $$reg2mem1375$2$phi = $$reg2mem1375$2;
            $$reg2mem1371$2$phi = $$reg2mem1371$2;
            $$reg2mem1367$2$phi = $$reg2mem1367$2;
            $$reg2mem1365$2$phi = $$reg2mem1365$2;
            $$reg2mem1355$2$phi = $$reg2mem1355$2;
            $$reg2mem1345$2$phi = $$reg2mem1345$2;
            $$reg2mem1332$2$phi = $$reg2mem1332$2;
            $$reg2mem1330$2$phi = $$reg2mem1330$2;
            $$reg2mem1327$2$phi = $$reg2mem1327$2;
            $$reg2mem1324$2$phi = $$reg2mem1324$2;
            $$reg2mem1319$2$phi = $$reg2mem1319$2;
            $$reg2mem1316$2$phi = $$reg2mem1316$2;
            $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
            $$reg2mem1465$0 = $933;
            $$reg2mem1386$2 = $$reg2mem1386$2$phi;
            $$reg2mem1383$2 = $$reg2mem1383$2$phi;
            $$reg2mem1375$2 = $$reg2mem1375$2$phi;
            $$reg2mem1371$2 = $$reg2mem1371$2$phi;
            $$reg2mem1367$2 = $$reg2mem1367$2$phi;
            $$reg2mem1365$2 = $$reg2mem1365$2$phi;
            $$reg2mem1355$2 = $$reg2mem1355$2$phi;
            $$reg2mem1345$2 = $$reg2mem1345$2$phi;
            $$reg2mem1332$2 = $$reg2mem1332$2$phi;
            $$reg2mem1330$2 = $$reg2mem1330$2$phi;
            $$reg2mem1327$2 = $$reg2mem1327$2$phi;
            $$reg2mem1324$2 = $$reg2mem1324$2$phi;
            $$reg2mem1319$2 = $$reg2mem1319$2$phi;
            $$reg2mem1316$2 = $$reg2mem1316$2$phi;
            $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
            label = 7;
            continue L3;
           }
           $$0921$reg2mem1423$0 = $$0$$0$826;
           $$0923$reg2mem1425$0 = $930;
          }
          $939 = ($$0923$reg2mem1425$0 | 0) == 1;
          do {
           if ($939) {
            $940 = HEAP32[$$reg2mem1324$2 >> 2] | 0;
            HEAP32[$$1868$reg2mem1463$0 >> 2] = $940;
            $$14881$reg2mem1419$0 = $$1868$reg2mem1463$0;
            $$41$reg2mem1417$0 = $$1860$reg2mem1461$0;
            $$4898$reg2mem1421$0 = 94;
           } else {
            $941 = ($$0923$reg2mem1425$0 | 0) == 0;
            $942 = $$1868$reg2mem1463$0 + -8 | 0;
            $943 = HEAP32[$5 >> 2] | 0;
            if ($941) {
             $944 = ($943 | 0) == (0 | 0);
             $$ = $944 ? 17668 : $943;
             HEAP32[$926 >> 2] = $$;
             $945 = ($$0921$reg2mem1423$0 | 0) == (0 | 0);
             if ($945) {
              $$14881$reg2mem1419$0 = $926;
              $$41$reg2mem1417$0 = $44;
              $$4898$reg2mem1421$0 = 10;
              break;
             }
             __THREW__ = 0;
             $946 = invoke_iii(604, $$0921$reg2mem1423$0 | 0, 14556 | 0) | 0;
             $947 = __THREW__;
             __THREW__ = 0;
             if (($947 | 0) != 0 & (threwValue | 0) != 0) {
              $948 = _testSetjmp(HEAP32[$947 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
              if (($948 | 0) == 0) {
               _longjmp($947 | 0, threwValue | 0);
              }
              setTempRet0(threwValue | 0);
             } else {
              $948 = -1;
             }
             $949 = getTempRet0() | 0;
             $cond1495 = ($948 | 0) == 1;
             if ($cond1495) {
              $$reg2mem1386$2$phi = $$reg2mem1386$2;
              $$reg2mem1383$2$phi = $$reg2mem1383$2;
              $$reg2mem1375$2$phi = $$reg2mem1375$2;
              $$reg2mem1371$2$phi = $$reg2mem1371$2;
              $$reg2mem1367$2$phi = $$reg2mem1367$2;
              $$reg2mem1365$2$phi = $$reg2mem1365$2;
              $$reg2mem1355$2$phi = $$reg2mem1355$2;
              $$reg2mem1345$2$phi = $$reg2mem1345$2;
              $$reg2mem1332$2$phi = $$reg2mem1332$2;
              $$reg2mem1330$2$phi = $$reg2mem1330$2;
              $$reg2mem1327$2$phi = $$reg2mem1327$2;
              $$reg2mem1324$2$phi = $$reg2mem1324$2;
              $$reg2mem1319$2$phi = $$reg2mem1319$2;
              $$reg2mem1316$2$phi = $$reg2mem1316$2;
              $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
              $$reg2mem1465$0 = $949;
              $$reg2mem1386$2 = $$reg2mem1386$2$phi;
              $$reg2mem1383$2 = $$reg2mem1383$2$phi;
              $$reg2mem1375$2 = $$reg2mem1375$2$phi;
              $$reg2mem1371$2 = $$reg2mem1371$2$phi;
              $$reg2mem1367$2 = $$reg2mem1367$2$phi;
              $$reg2mem1365$2 = $$reg2mem1365$2$phi;
              $$reg2mem1355$2 = $$reg2mem1355$2$phi;
              $$reg2mem1345$2 = $$reg2mem1345$2$phi;
              $$reg2mem1332$2 = $$reg2mem1332$2$phi;
              $$reg2mem1330$2 = $$reg2mem1330$2$phi;
              $$reg2mem1327$2 = $$reg2mem1327$2$phi;
              $$reg2mem1324$2 = $$reg2mem1324$2$phi;
              $$reg2mem1319$2 = $$reg2mem1319$2$phi;
              $$reg2mem1316$2 = $$reg2mem1316$2$phi;
              $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
              label = 7;
              continue L3;
             }
             if (!$946) {
              $$14881$reg2mem1419$0 = $926;
              $$41$reg2mem1417$0 = $44;
              $$4898$reg2mem1421$0 = 10;
              break;
             }
             __THREW__ = 0;
             $950 = invoke_ii(570, $$0921$reg2mem1423$0 | 0) | 0;
             $951 = __THREW__;
             __THREW__ = 0;
             if (($951 | 0) != 0 & (threwValue | 0) != 0) {
              $952 = _testSetjmp(HEAP32[$951 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
              if (($952 | 0) == 0) {
               _longjmp($951 | 0, threwValue | 0);
              }
              setTempRet0(threwValue | 0);
             } else {
              $952 = -1;
             }
             $953 = getTempRet0() | 0;
             $cond1496 = ($952 | 0) == 1;
             if ($cond1496) {
              $$reg2mem1386$2$phi = $$reg2mem1386$2;
              $$reg2mem1383$2$phi = $$reg2mem1383$2;
              $$reg2mem1375$2$phi = $$reg2mem1375$2;
              $$reg2mem1371$2$phi = $$reg2mem1371$2;
              $$reg2mem1367$2$phi = $$reg2mem1367$2;
              $$reg2mem1365$2$phi = $$reg2mem1365$2;
              $$reg2mem1355$2$phi = $$reg2mem1355$2;
              $$reg2mem1345$2$phi = $$reg2mem1345$2;
              $$reg2mem1332$2$phi = $$reg2mem1332$2;
              $$reg2mem1330$2$phi = $$reg2mem1330$2;
              $$reg2mem1327$2$phi = $$reg2mem1327$2;
              $$reg2mem1324$2$phi = $$reg2mem1324$2;
              $$reg2mem1319$2$phi = $$reg2mem1319$2;
              $$reg2mem1316$2$phi = $$reg2mem1316$2;
              $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
              $$reg2mem1465$0 = $953;
              $$reg2mem1386$2 = $$reg2mem1386$2$phi;
              $$reg2mem1383$2 = $$reg2mem1383$2$phi;
              $$reg2mem1375$2 = $$reg2mem1375$2$phi;
              $$reg2mem1371$2 = $$reg2mem1371$2$phi;
              $$reg2mem1367$2 = $$reg2mem1367$2$phi;
              $$reg2mem1365$2 = $$reg2mem1365$2$phi;
              $$reg2mem1355$2 = $$reg2mem1355$2$phi;
              $$reg2mem1345$2 = $$reg2mem1345$2$phi;
              $$reg2mem1332$2 = $$reg2mem1332$2$phi;
              $$reg2mem1330$2 = $$reg2mem1330$2$phi;
              $$reg2mem1327$2 = $$reg2mem1327$2$phi;
              $$reg2mem1324$2 = $$reg2mem1324$2$phi;
              $$reg2mem1319$2 = $$reg2mem1319$2$phi;
              $$reg2mem1316$2 = $$reg2mem1316$2$phi;
              $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
              label = 7;
              continue L3;
             }
             __THREW__ = 0;
             invoke_v(498);
             $954 = __THREW__;
             __THREW__ = 0;
             if (($954 | 0) != 0 & (threwValue | 0) != 0) {
              $955 = _testSetjmp(HEAP32[$954 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
              if (($955 | 0) == 0) {
               _longjmp($954 | 0, threwValue | 0);
              }
              setTempRet0(threwValue | 0);
             } else {
              $955 = -1;
             }
             $956 = getTempRet0() | 0;
             $cond1497 = ($955 | 0) == 1;
             if ($cond1497) {
              $$reg2mem1386$2$phi = $$reg2mem1386$2;
              $$reg2mem1383$2$phi = $$reg2mem1383$2;
              $$reg2mem1375$2$phi = $$reg2mem1375$2;
              $$reg2mem1371$2$phi = $$reg2mem1371$2;
              $$reg2mem1367$2$phi = $$reg2mem1367$2;
              $$reg2mem1365$2$phi = $$reg2mem1365$2;
              $$reg2mem1355$2$phi = $$reg2mem1355$2;
              $$reg2mem1345$2$phi = $$reg2mem1345$2;
              $$reg2mem1332$2$phi = $$reg2mem1332$2;
              $$reg2mem1330$2$phi = $$reg2mem1330$2;
              $$reg2mem1327$2$phi = $$reg2mem1327$2;
              $$reg2mem1324$2$phi = $$reg2mem1324$2;
              $$reg2mem1319$2$phi = $$reg2mem1319$2;
              $$reg2mem1316$2$phi = $$reg2mem1316$2;
              $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
              $$reg2mem1465$0 = $956;
              $$reg2mem1386$2 = $$reg2mem1386$2$phi;
              $$reg2mem1383$2 = $$reg2mem1383$2$phi;
              $$reg2mem1375$2 = $$reg2mem1375$2$phi;
              $$reg2mem1371$2 = $$reg2mem1371$2$phi;
              $$reg2mem1367$2 = $$reg2mem1367$2$phi;
              $$reg2mem1365$2 = $$reg2mem1365$2$phi;
              $$reg2mem1355$2 = $$reg2mem1355$2$phi;
              $$reg2mem1345$2 = $$reg2mem1345$2$phi;
              $$reg2mem1332$2 = $$reg2mem1332$2$phi;
              $$reg2mem1330$2 = $$reg2mem1330$2$phi;
              $$reg2mem1327$2 = $$reg2mem1327$2$phi;
              $$reg2mem1324$2 = $$reg2mem1324$2$phi;
              $$reg2mem1319$2 = $$reg2mem1319$2$phi;
              $$reg2mem1316$2 = $$reg2mem1316$2$phi;
              $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
              label = 7;
              continue L3;
             }
             HEAP32[$$reg2mem1332$2 >> 2] = $950;
             $$14881$reg2mem1419$0 = $926;
             $$41$reg2mem1417$0 = $44;
             $$4898$reg2mem1421$0 = 7;
             break;
            }
            __THREW__ = 0;
            $957 = invoke_iii(604, $943 | 0, 14676 | 0) | 0;
            $958 = __THREW__;
            __THREW__ = 0;
            if (($958 | 0) != 0 & (threwValue | 0) != 0) {
             $959 = _testSetjmp(HEAP32[$958 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
             if (($959 | 0) == 0) {
              _longjmp($958 | 0, threwValue | 0);
             }
             setTempRet0(threwValue | 0);
            } else {
             $959 = -1;
            }
            $960 = getTempRet0() | 0;
            $cond1489 = ($959 | 0) == 1;
            if ($cond1489) {
             $$reg2mem1386$2$phi = $$reg2mem1386$2;
             $$reg2mem1383$2$phi = $$reg2mem1383$2;
             $$reg2mem1375$2$phi = $$reg2mem1375$2;
             $$reg2mem1371$2$phi = $$reg2mem1371$2;
             $$reg2mem1367$2$phi = $$reg2mem1367$2;
             $$reg2mem1365$2$phi = $$reg2mem1365$2;
             $$reg2mem1355$2$phi = $$reg2mem1355$2;
             $$reg2mem1345$2$phi = $$reg2mem1345$2;
             $$reg2mem1332$2$phi = $$reg2mem1332$2;
             $$reg2mem1330$2$phi = $$reg2mem1330$2;
             $$reg2mem1327$2$phi = $$reg2mem1327$2;
             $$reg2mem1324$2$phi = $$reg2mem1324$2;
             $$reg2mem1319$2$phi = $$reg2mem1319$2;
             $$reg2mem1316$2$phi = $$reg2mem1316$2;
             $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
             $$reg2mem1465$0 = $960;
             $$reg2mem1386$2 = $$reg2mem1386$2$phi;
             $$reg2mem1383$2 = $$reg2mem1383$2$phi;
             $$reg2mem1375$2 = $$reg2mem1375$2$phi;
             $$reg2mem1371$2 = $$reg2mem1371$2$phi;
             $$reg2mem1367$2 = $$reg2mem1367$2$phi;
             $$reg2mem1365$2 = $$reg2mem1365$2$phi;
             $$reg2mem1355$2 = $$reg2mem1355$2$phi;
             $$reg2mem1345$2 = $$reg2mem1345$2$phi;
             $$reg2mem1332$2 = $$reg2mem1332$2$phi;
             $$reg2mem1330$2 = $$reg2mem1330$2$phi;
             $$reg2mem1327$2 = $$reg2mem1327$2$phi;
             $$reg2mem1324$2 = $$reg2mem1324$2$phi;
             $$reg2mem1319$2 = $$reg2mem1319$2$phi;
             $$reg2mem1316$2 = $$reg2mem1316$2$phi;
             $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
             label = 7;
             continue L3;
            }
            if (!$957) {
             __THREW__ = 0;
             invoke_v(498);
             $978 = __THREW__;
             __THREW__ = 0;
             if (($978 | 0) != 0 & (threwValue | 0) != 0) {
              $979 = _testSetjmp(HEAP32[$978 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
              if (($979 | 0) == 0) {
               _longjmp($978 | 0, threwValue | 0);
              }
              setTempRet0(threwValue | 0);
             } else {
              $979 = -1;
             }
             $980 = getTempRet0() | 0;
             $cond1490 = ($979 | 0) == 1;
             if ($cond1490) {
              $$reg2mem1386$2$phi = $$reg2mem1386$2;
              $$reg2mem1383$2$phi = $$reg2mem1383$2;
              $$reg2mem1375$2$phi = $$reg2mem1375$2;
              $$reg2mem1371$2$phi = $$reg2mem1371$2;
              $$reg2mem1367$2$phi = $$reg2mem1367$2;
              $$reg2mem1365$2$phi = $$reg2mem1365$2;
              $$reg2mem1355$2$phi = $$reg2mem1355$2;
              $$reg2mem1345$2$phi = $$reg2mem1345$2;
              $$reg2mem1332$2$phi = $$reg2mem1332$2;
              $$reg2mem1330$2$phi = $$reg2mem1330$2;
              $$reg2mem1327$2$phi = $$reg2mem1327$2;
              $$reg2mem1324$2$phi = $$reg2mem1324$2;
              $$reg2mem1319$2$phi = $$reg2mem1319$2;
              $$reg2mem1316$2$phi = $$reg2mem1316$2;
              $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
              $$reg2mem1465$0 = $980;
              $$reg2mem1386$2 = $$reg2mem1386$2$phi;
              $$reg2mem1383$2 = $$reg2mem1383$2$phi;
              $$reg2mem1375$2 = $$reg2mem1375$2$phi;
              $$reg2mem1371$2 = $$reg2mem1371$2$phi;
              $$reg2mem1367$2 = $$reg2mem1367$2$phi;
              $$reg2mem1365$2 = $$reg2mem1365$2$phi;
              $$reg2mem1355$2 = $$reg2mem1355$2$phi;
              $$reg2mem1345$2 = $$reg2mem1345$2$phi;
              $$reg2mem1332$2 = $$reg2mem1332$2$phi;
              $$reg2mem1330$2 = $$reg2mem1330$2$phi;
              $$reg2mem1327$2 = $$reg2mem1327$2$phi;
              $$reg2mem1324$2 = $$reg2mem1324$2$phi;
              $$reg2mem1319$2 = $$reg2mem1319$2$phi;
              $$reg2mem1316$2 = $$reg2mem1316$2$phi;
              $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
              label = 7;
              continue L3;
             }
             $981 = HEAP32[$$reg2mem1324$2 >> 2] | 0;
             HEAP32[$$reg2mem1319$2 >> 2] = $981;
             $$14881$reg2mem1419$0 = $942;
             $$41$reg2mem1417$0 = $44;
             $$4898$reg2mem1421$0 = 7;
             break;
            }
            $961 = HEAP32[$5 >> 2] | 0;
            __THREW__ = 0;
            $962 = invoke_ii(605, $961 | 0) | 0;
            $963 = __THREW__;
            __THREW__ = 0;
            if (($963 | 0) != 0 & (threwValue | 0) != 0) {
             $964 = _testSetjmp(HEAP32[$963 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
             if (($964 | 0) == 0) {
              _longjmp($963 | 0, threwValue | 0);
             }
             setTempRet0(threwValue | 0);
            } else {
             $964 = -1;
            }
            $965 = getTempRet0() | 0;
            $cond1491 = ($964 | 0) == 1;
            if ($cond1491) {
             $$reg2mem1386$2$phi = $$reg2mem1386$2;
             $$reg2mem1383$2$phi = $$reg2mem1383$2;
             $$reg2mem1375$2$phi = $$reg2mem1375$2;
             $$reg2mem1371$2$phi = $$reg2mem1371$2;
             $$reg2mem1367$2$phi = $$reg2mem1367$2;
             $$reg2mem1365$2$phi = $$reg2mem1365$2;
             $$reg2mem1355$2$phi = $$reg2mem1355$2;
             $$reg2mem1345$2$phi = $$reg2mem1345$2;
             $$reg2mem1332$2$phi = $$reg2mem1332$2;
             $$reg2mem1330$2$phi = $$reg2mem1330$2;
             $$reg2mem1327$2$phi = $$reg2mem1327$2;
             $$reg2mem1324$2$phi = $$reg2mem1324$2;
             $$reg2mem1319$2$phi = $$reg2mem1319$2;
             $$reg2mem1316$2$phi = $$reg2mem1316$2;
             $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
             $$reg2mem1465$0 = $965;
             $$reg2mem1386$2 = $$reg2mem1386$2$phi;
             $$reg2mem1383$2 = $$reg2mem1383$2$phi;
             $$reg2mem1375$2 = $$reg2mem1375$2$phi;
             $$reg2mem1371$2 = $$reg2mem1371$2$phi;
             $$reg2mem1367$2 = $$reg2mem1367$2$phi;
             $$reg2mem1365$2 = $$reg2mem1365$2$phi;
             $$reg2mem1355$2 = $$reg2mem1355$2$phi;
             $$reg2mem1345$2 = $$reg2mem1345$2$phi;
             $$reg2mem1332$2 = $$reg2mem1332$2$phi;
             $$reg2mem1330$2 = $$reg2mem1330$2$phi;
             $$reg2mem1327$2 = $$reg2mem1327$2$phi;
             $$reg2mem1324$2 = $$reg2mem1324$2$phi;
             $$reg2mem1319$2 = $$reg2mem1319$2$phi;
             $$reg2mem1316$2 = $$reg2mem1316$2$phi;
             $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
             label = 7;
             continue L3;
            }
            HEAP32[$926 >> 2] = $962;
            $966 = ($$0921$reg2mem1423$0 | 0) == (0 | 0);
            if ($966) {
             $$14881$reg2mem1419$0 = $926;
             $$41$reg2mem1417$0 = $44;
             $$4898$reg2mem1421$0 = 10;
            } else {
             __THREW__ = 0;
             $967 = invoke_iii(604, $$0921$reg2mem1423$0 | 0, 14556 | 0) | 0;
             $968 = __THREW__;
             __THREW__ = 0;
             if (($968 | 0) != 0 & (threwValue | 0) != 0) {
              $969 = _testSetjmp(HEAP32[$968 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
              if (($969 | 0) == 0) {
               _longjmp($968 | 0, threwValue | 0);
              }
              setTempRet0(threwValue | 0);
             } else {
              $969 = -1;
             }
             $970 = getTempRet0() | 0;
             $cond1492 = ($969 | 0) == 1;
             if ($cond1492) {
              $$reg2mem1386$2$phi = $$reg2mem1386$2;
              $$reg2mem1383$2$phi = $$reg2mem1383$2;
              $$reg2mem1375$2$phi = $$reg2mem1375$2;
              $$reg2mem1371$2$phi = $$reg2mem1371$2;
              $$reg2mem1367$2$phi = $$reg2mem1367$2;
              $$reg2mem1365$2$phi = $$reg2mem1365$2;
              $$reg2mem1355$2$phi = $$reg2mem1355$2;
              $$reg2mem1345$2$phi = $$reg2mem1345$2;
              $$reg2mem1332$2$phi = $$reg2mem1332$2;
              $$reg2mem1330$2$phi = $$reg2mem1330$2;
              $$reg2mem1327$2$phi = $$reg2mem1327$2;
              $$reg2mem1324$2$phi = $$reg2mem1324$2;
              $$reg2mem1319$2$phi = $$reg2mem1319$2;
              $$reg2mem1316$2$phi = $$reg2mem1316$2;
              $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
              $$reg2mem1465$0 = $970;
              $$reg2mem1386$2 = $$reg2mem1386$2$phi;
              $$reg2mem1383$2 = $$reg2mem1383$2$phi;
              $$reg2mem1375$2 = $$reg2mem1375$2$phi;
              $$reg2mem1371$2 = $$reg2mem1371$2$phi;
              $$reg2mem1367$2 = $$reg2mem1367$2$phi;
              $$reg2mem1365$2 = $$reg2mem1365$2$phi;
              $$reg2mem1355$2 = $$reg2mem1355$2$phi;
              $$reg2mem1345$2 = $$reg2mem1345$2$phi;
              $$reg2mem1332$2 = $$reg2mem1332$2$phi;
              $$reg2mem1330$2 = $$reg2mem1330$2$phi;
              $$reg2mem1327$2 = $$reg2mem1327$2$phi;
              $$reg2mem1324$2 = $$reg2mem1324$2$phi;
              $$reg2mem1319$2 = $$reg2mem1319$2$phi;
              $$reg2mem1316$2 = $$reg2mem1316$2$phi;
              $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
              label = 7;
              continue L3;
             }
             if ($967) {
              __THREW__ = 0;
              $971 = invoke_ii(570, $$0921$reg2mem1423$0 | 0) | 0;
              $972 = __THREW__;
              __THREW__ = 0;
              if (($972 | 0) != 0 & (threwValue | 0) != 0) {
               $973 = _testSetjmp(HEAP32[$972 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
               if (($973 | 0) == 0) {
                _longjmp($972 | 0, threwValue | 0);
               }
               setTempRet0(threwValue | 0);
              } else {
               $973 = -1;
              }
              $974 = getTempRet0() | 0;
              $cond1493 = ($973 | 0) == 1;
              if ($cond1493) {
               $$reg2mem1386$2$phi = $$reg2mem1386$2;
               $$reg2mem1383$2$phi = $$reg2mem1383$2;
               $$reg2mem1375$2$phi = $$reg2mem1375$2;
               $$reg2mem1371$2$phi = $$reg2mem1371$2;
               $$reg2mem1367$2$phi = $$reg2mem1367$2;
               $$reg2mem1365$2$phi = $$reg2mem1365$2;
               $$reg2mem1355$2$phi = $$reg2mem1355$2;
               $$reg2mem1345$2$phi = $$reg2mem1345$2;
               $$reg2mem1332$2$phi = $$reg2mem1332$2;
               $$reg2mem1330$2$phi = $$reg2mem1330$2;
               $$reg2mem1327$2$phi = $$reg2mem1327$2;
               $$reg2mem1324$2$phi = $$reg2mem1324$2;
               $$reg2mem1319$2$phi = $$reg2mem1319$2;
               $$reg2mem1316$2$phi = $$reg2mem1316$2;
               $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
               $$reg2mem1465$0 = $974;
               $$reg2mem1386$2 = $$reg2mem1386$2$phi;
               $$reg2mem1383$2 = $$reg2mem1383$2$phi;
               $$reg2mem1375$2 = $$reg2mem1375$2$phi;
               $$reg2mem1371$2 = $$reg2mem1371$2$phi;
               $$reg2mem1367$2 = $$reg2mem1367$2$phi;
               $$reg2mem1365$2 = $$reg2mem1365$2$phi;
               $$reg2mem1355$2 = $$reg2mem1355$2$phi;
               $$reg2mem1345$2 = $$reg2mem1345$2$phi;
               $$reg2mem1332$2 = $$reg2mem1332$2$phi;
               $$reg2mem1330$2 = $$reg2mem1330$2$phi;
               $$reg2mem1327$2 = $$reg2mem1327$2$phi;
               $$reg2mem1324$2 = $$reg2mem1324$2$phi;
               $$reg2mem1319$2 = $$reg2mem1319$2$phi;
               $$reg2mem1316$2 = $$reg2mem1316$2$phi;
               $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
               label = 7;
               continue L3;
              }
              __THREW__ = 0;
              invoke_v(498);
              $975 = __THREW__;
              __THREW__ = 0;
              if (($975 | 0) != 0 & (threwValue | 0) != 0) {
               $976 = _testSetjmp(HEAP32[$975 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
               if (($976 | 0) == 0) {
                _longjmp($975 | 0, threwValue | 0);
               }
               setTempRet0(threwValue | 0);
              } else {
               $976 = -1;
              }
              $977 = getTempRet0() | 0;
              $cond1494 = ($976 | 0) == 1;
              if ($cond1494) {
               $$reg2mem1386$2$phi = $$reg2mem1386$2;
               $$reg2mem1383$2$phi = $$reg2mem1383$2;
               $$reg2mem1375$2$phi = $$reg2mem1375$2;
               $$reg2mem1371$2$phi = $$reg2mem1371$2;
               $$reg2mem1367$2$phi = $$reg2mem1367$2;
               $$reg2mem1365$2$phi = $$reg2mem1365$2;
               $$reg2mem1355$2$phi = $$reg2mem1355$2;
               $$reg2mem1345$2$phi = $$reg2mem1345$2;
               $$reg2mem1332$2$phi = $$reg2mem1332$2;
               $$reg2mem1330$2$phi = $$reg2mem1330$2;
               $$reg2mem1327$2$phi = $$reg2mem1327$2;
               $$reg2mem1324$2$phi = $$reg2mem1324$2;
               $$reg2mem1319$2$phi = $$reg2mem1319$2;
               $$reg2mem1316$2$phi = $$reg2mem1316$2;
               $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
               $$reg2mem1465$0 = $977;
               $$reg2mem1386$2 = $$reg2mem1386$2$phi;
               $$reg2mem1383$2 = $$reg2mem1383$2$phi;
               $$reg2mem1375$2 = $$reg2mem1375$2$phi;
               $$reg2mem1371$2 = $$reg2mem1371$2$phi;
               $$reg2mem1367$2 = $$reg2mem1367$2$phi;
               $$reg2mem1365$2 = $$reg2mem1365$2$phi;
               $$reg2mem1355$2 = $$reg2mem1355$2$phi;
               $$reg2mem1345$2 = $$reg2mem1345$2$phi;
               $$reg2mem1332$2 = $$reg2mem1332$2$phi;
               $$reg2mem1330$2 = $$reg2mem1330$2$phi;
               $$reg2mem1327$2 = $$reg2mem1327$2$phi;
               $$reg2mem1324$2 = $$reg2mem1324$2$phi;
               $$reg2mem1319$2 = $$reg2mem1319$2$phi;
               $$reg2mem1316$2 = $$reg2mem1316$2$phi;
               $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
               label = 7;
               continue L3;
              }
              HEAP32[$$reg2mem1332$2 >> 2] = $971;
              $$14881$reg2mem1419$0 = $926;
              $$41$reg2mem1417$0 = $44;
              $$4898$reg2mem1421$0 = 7;
             } else {
              $$14881$reg2mem1419$0 = $926;
              $$41$reg2mem1417$0 = $44;
              $$4898$reg2mem1421$0 = 10;
             }
            }
           }
          } while (0);
          $trunc = $$4898$reg2mem1421$0 & 255;
          $trunc$clear = $trunc & 127;
          switch ($trunc$clear << 24 >> 24) {
          case 94:
           {
            $$12879$reg2mem1429$0 = $$14881$reg2mem1419$0;
            $$40$reg2mem1427$0 = $$41$reg2mem1417$0;
            label = 258;
            break L15;
            break;
           }
          case 10:
           {
            $$1860$be$reg2mem1443$0 = $$41$reg2mem1417$0;
            $$1868$be$reg2mem1445$0 = $$14881$reg2mem1419$0;
            break;
           }
          default:
           {
            label = 320;
            break L15;
           }
          }
          break;
         }
        case 104:
         {
          $$0918$reg2mem$0 = 0;
          $$43$reg2mem$0 = $44;
          while (1) {
           $982 = $$0918$reg2mem$0 << 7;
           $983 = HEAP8[$$43$reg2mem$0 >> 0] | 0;
           $984 = $983 & 255;
           $985 = $984 & 127;
           $986 = $985 | $982;
           $987 = $$43$reg2mem$0 + 1 | 0;
           $988 = $984 & 128;
           $989 = ($988 | 0) == 0;
           if ($989) {
            break;
           } else {
            $$0918$reg2mem$0 = $986;
            $$43$reg2mem$0 = $987;
           }
          }
          $990 = $$1868$reg2mem1463$0 + -4 | 0;
          $991 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $992 = HEAP32[$990 >> 2] | 0;
          __THREW__ = 0;
          $993 = invoke_iiii(606, $986 | 0, $991 | 0, $992 | 0) | 0;
          $994 = __THREW__;
          __THREW__ = 0;
          if (($994 | 0) != 0 & (threwValue | 0) != 0) {
           $995 = _testSetjmp(HEAP32[$994 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($995 | 0) == 0) {
            _longjmp($994 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $995 = -1;
          }
          $996 = getTempRet0() | 0;
          $cond1487 = ($995 | 0) == 1;
          if ($cond1487) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $996;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$990 >> 2] = $993;
          $$1860$be$reg2mem1443$0 = $987;
          $$1868$be$reg2mem1445$0 = $990;
          break;
         }
        case 105:
         {
          $$0916$reg2mem$0 = 0;
          $$44$reg2mem$0 = $44;
          while (1) {
           $997 = $$0916$reg2mem$0 << 7;
           $998 = HEAP8[$$44$reg2mem$0 >> 0] | 0;
           $999 = $998 & 255;
           $1000 = $999 & 127;
           $1001 = $1000 | $997;
           $1002 = $$44$reg2mem$0 + 1 | 0;
           $1003 = $999 & 128;
           $1004 = ($1003 | 0) == 0;
           if ($1004) {
            break;
           } else {
            $$0916$reg2mem$0 = $1001;
            $$44$reg2mem$0 = $1002;
           }
          }
          $1005 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          $1006 = invoke_iii(607, $1005 | 0, $1001 | 0) | 0;
          $1007 = __THREW__;
          __THREW__ = 0;
          if (($1007 | 0) != 0 & (threwValue | 0) != 0) {
           $1008 = _testSetjmp(HEAP32[$1007 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($1008 | 0) == 0) {
            _longjmp($1007 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $1008 = -1;
          }
          $1009 = getTempRet0() | 0;
          $cond1486 = ($1008 | 0) == 1;
          if ($cond1486) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $1009;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $1010 = $$1868$reg2mem1463$0 + 4 | 0;
          HEAP32[$1010 >> 2] = $1006;
          $$1860$be$reg2mem1443$0 = $1002;
          $$1868$be$reg2mem1445$0 = $1010;
          break;
         }
        case 106:
         {
          $1011 = $$1868$reg2mem1463$0 + -4 | 0;
          $1012 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          __THREW__ = 0;
          invoke_vi(608, $1012 | 0);
          $1013 = __THREW__;
          __THREW__ = 0;
          if (($1013 | 0) != 0 & (threwValue | 0) != 0) {
           $1014 = _testSetjmp(HEAP32[$1013 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($1014 | 0) == 0) {
            _longjmp($1013 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $1014 = -1;
          }
          $1015 = getTempRet0() | 0;
          $cond1485 = ($1014 | 0) == 1;
          if ($cond1485) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $1015;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $1011;
          break;
         }
        default:
         {
          $1016 = $45 & 255;
          $1017 = ($45 & 255) < 176;
          if ($1017) {
           $1018 = $1016 << 1;
           $1019 = $1018 + -256 | 0;
           $1020 = $1019 | 1;
           $1021 = $1020;
           $1022 = $$1868$reg2mem1463$0 + 4 | 0;
           HEAP32[$1022 >> 2] = $1021;
           $$1860$be$reg2mem1443$0 = $44;
           $$1868$be$reg2mem1445$0 = $1022;
           break L17;
          }
          $1023 = ($45 & 255) < 192;
          if ($1023) {
           $1024 = 176 - $1016 | 0;
           $1025 = $$reg2mem1386$2 + ($1024 << 2) | 0;
           $1026 = HEAP32[$1025 >> 2] | 0;
           $$4888$reg2mem1453$0 = $1026;
           $$5$reg2mem1451$0 = $44;
           label = 58;
           break L17;
          }
          $1027 = ($45 & 255) < 208;
          if ($1027) {
           $1028 = $$1868$reg2mem1463$0 + -4 | 0;
           $1029 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
           $1030 = 192 - $1016 | 0;
           $1031 = $$reg2mem1386$2 + ($1030 << 2) | 0;
           HEAP32[$1031 >> 2] = $1029;
           $$1860$be$reg2mem1443$0 = $44;
           $$1868$be$reg2mem1445$0 = $1028;
           break L17;
          }
          $1032 = ($45 & 255) < 212;
          if ($1032) {
           $1033 = $1016 + -208 | 0;
           $1034 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
           __THREW__ = 0;
           $1035 = invoke_iii(609, $1033 | 0, $1034 | 0) | 0;
           $1036 = __THREW__;
           __THREW__ = 0;
           if (($1036 | 0) != 0 & (threwValue | 0) != 0) {
            $1037 = _testSetjmp(HEAP32[$1036 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
            if (($1037 | 0) == 0) {
             _longjmp($1036 | 0, threwValue | 0);
            }
            setTempRet0(threwValue | 0);
           } else {
            $1037 = -1;
           }
           $1038 = getTempRet0() | 0;
           $cond1567 = ($1037 | 0) == 1;
           if ($cond1567) {
            $$reg2mem1386$2$phi = $$reg2mem1386$2;
            $$reg2mem1383$2$phi = $$reg2mem1383$2;
            $$reg2mem1375$2$phi = $$reg2mem1375$2;
            $$reg2mem1371$2$phi = $$reg2mem1371$2;
            $$reg2mem1367$2$phi = $$reg2mem1367$2;
            $$reg2mem1365$2$phi = $$reg2mem1365$2;
            $$reg2mem1355$2$phi = $$reg2mem1355$2;
            $$reg2mem1345$2$phi = $$reg2mem1345$2;
            $$reg2mem1332$2$phi = $$reg2mem1332$2;
            $$reg2mem1330$2$phi = $$reg2mem1330$2;
            $$reg2mem1327$2$phi = $$reg2mem1327$2;
            $$reg2mem1324$2$phi = $$reg2mem1324$2;
            $$reg2mem1319$2$phi = $$reg2mem1319$2;
            $$reg2mem1316$2$phi = $$reg2mem1316$2;
            $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
            $$reg2mem1465$0 = $1038;
            $$reg2mem1386$2 = $$reg2mem1386$2$phi;
            $$reg2mem1383$2 = $$reg2mem1383$2$phi;
            $$reg2mem1375$2 = $$reg2mem1375$2$phi;
            $$reg2mem1371$2 = $$reg2mem1371$2$phi;
            $$reg2mem1367$2 = $$reg2mem1367$2$phi;
            $$reg2mem1365$2 = $$reg2mem1365$2$phi;
            $$reg2mem1355$2 = $$reg2mem1355$2$phi;
            $$reg2mem1345$2 = $$reg2mem1345$2$phi;
            $$reg2mem1332$2 = $$reg2mem1332$2$phi;
            $$reg2mem1330$2 = $$reg2mem1330$2$phi;
            $$reg2mem1327$2 = $$reg2mem1327$2$phi;
            $$reg2mem1324$2 = $$reg2mem1324$2$phi;
            $$reg2mem1319$2 = $$reg2mem1319$2$phi;
            $$reg2mem1316$2 = $$reg2mem1316$2$phi;
            $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
            label = 7;
            continue L3;
           }
           HEAP32[$$1868$reg2mem1463$0 >> 2] = $1035;
           $$1860$be$reg2mem1443$0 = $44;
           $$1868$be$reg2mem1445$0 = $$1868$reg2mem1463$0;
           break L17;
          }
          $1039 = ($45 & 255) < 248;
          if (!$1039) {
           label = 306;
           break L15;
          }
          $1040 = $$1868$reg2mem1463$0 + -4 | 0;
          $1041 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
          $1042 = HEAP32[$1040 >> 2] | 0;
          $1043 = $1016 + -215 | 0;
          __THREW__ = 0;
          $1044 = invoke_iiii(610, $1043 | 0, $1042 | 0, $1041 | 0) | 0;
          $1045 = __THREW__;
          __THREW__ = 0;
          if (($1045 | 0) != 0 & (threwValue | 0) != 0) {
           $1046 = _testSetjmp(HEAP32[$1045 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($1046 | 0) == 0) {
            _longjmp($1045 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $1046 = -1;
          }
          $1047 = getTempRet0() | 0;
          $cond1566 = ($1046 | 0) == 1;
          if ($cond1566) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $1047;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$1040 >> 2] = $1044;
          $$1860$be$reg2mem1443$0 = $44;
          $$1868$be$reg2mem1445$0 = $1040;
         }
        }
       } while (0);
       L319 : do {
        if ((label | 0) == 58) {
         label = 0;
         $101 = ($$4888$reg2mem1453$0 | 0) == (0 | 0);
         if ($101) {
          label = 59;
          break L15;
         }
         $109 = $$1868$reg2mem1463$0 + 4 | 0;
         HEAP32[$109 >> 2] = $$4888$reg2mem1453$0;
         $$1860$be$reg2mem1443$0 = $$5$reg2mem1451$0;
         $$1868$be$reg2mem1445$0 = $109;
        } else if ((label | 0) == 150) {
         label = 0;
         $502 = HEAP32[$$5872$reg2mem1449$0 >> 2] | 0;
         $503 = $502 & 127;
         $504 = ($503 | 0) == 0;
         L323 : do {
          if ($504) {
           $$0937$lcssa$reg2mem$0 = $502;
          } else {
           $$09371130$reg2mem$0 = $502;
           while (1) {
            $505 = $$09371130$reg2mem$0 + -1 | 0;
            $$0$$0$790 = HEAP32[$3 >> 2] | 0;
            $506 = $$0$$0$790 + 4 | 0;
            $507 = HEAP32[$506 >> 2] | 0;
            $508 = $507 & 2;
            $509 = ($508 | 0) == 0;
            if (!$509) {
             $$0$$0$791 = HEAP32[$3 >> 2] | 0;
             $510 = HEAP32[$$0$$0$791 >> 2] | 0;
             $511 = $510 >>> 0 > $$27$reg2mem1447$0 >>> 0;
             if ($511) {
              break;
             }
            }
            $$0$$0$794 = HEAP32[$3 >> 2] | 0;
            $517 = $$0$$0$794 + -12 | 0;
            HEAP32[$3 >> 2] = $517;
            $518 = $505 & 127;
            $519 = ($518 | 0) == 0;
            if ($519) {
             $$0937$lcssa$reg2mem$0 = $505;
             break L323;
            } else {
             $$09371130$reg2mem$0 = $505;
            }
           }
           $512 = $505 << 1;
           $513 = $512 | 1;
           $514 = $513;
           HEAP32[$$5872$reg2mem1449$0 >> 2] = $514;
           $$0$$0$792 = HEAP32[$3 >> 2] | 0;
           $515 = HEAP32[$$0$$0$792 >> 2] | 0;
           $$0$$0$793 = HEAP32[$3 >> 2] | 0;
           $516 = $$0$$0$793 + -12 | 0;
           HEAP32[$3 >> 2] = $516;
           $$1860$be$reg2mem1443$0 = $515;
           $$1868$be$reg2mem1445$0 = $$5872$reg2mem1449$0;
           break L319;
          }
         } while (0);
         $$lcssa1044 = $$5872$reg2mem1449$0 + -4 | 0;
         $520 = $$5872$reg2mem1449$0 + -8 | 0;
         $521 = HEAP32[$$lcssa1044 >> 2] | 0;
         $522 = ($$0937$lcssa$reg2mem$0 | 0) == 0;
         $523 = $$5872$reg2mem1449$0 + -24 | 0;
         $spec$select950 = $522 ? $520 : $523;
         $$16883$reg2mem1415$0 = $spec$select950;
         $$45$reg2mem1413$0 = $521;
         label = 309;
        } else if ((label | 0) == 233) {
         label = 0;
         $$0$$0$7701123 = HEAP32[$3 >> 2] | 0;
         $870 = $$0$$0$7701123 >>> 0 < $$reg2mem1375$2 >>> 0;
         if ($870) {
          label = 239;
          break L15;
         }
         while (1) {
          $$0$$0$771 = HEAP32[$3 >> 2] | 0;
          $871 = $$0$$0$771 + 4 | 0;
          $872 = HEAP32[$871 >> 2] | 0;
          $873 = $872 & 2;
          $874 = ($873 | 0) == 0;
          if (!$874) {
           $$0$$0$772 = HEAP32[$3 >> 2] | 0;
           $875 = HEAP32[$$0$$0$772 >> 2] | 0;
           $876 = $875 >>> 0 > $44 >>> 0;
           if ($876) {
            break;
           }
          }
          $$0$$0$776 = HEAP32[$3 >> 2] | 0;
          $886 = $$0$$0$776 + -12 | 0;
          HEAP32[$3 >> 2] = $886;
          $$0$$0$770 = HEAP32[$3 >> 2] | 0;
          $887 = $$0$$0$770 >>> 0 < $$reg2mem1375$2 >>> 0;
          if ($887) {
           label = 239;
           break L15;
          }
         }
         $$0$$0$773 = HEAP32[$3 >> 2] | 0;
         $877 = $$0$$0$773 + 4 | 0;
         $878 = HEAP32[$877 >> 2] | 0;
         $879 = $878 & -4;
         $880 = $879;
         $881 = HEAP32[$$10877$reg2mem1431$0 >> 2] | 0;
         $882 = $880 + 4 | 0;
         HEAP32[$882 >> 2] = $881;
         $883 = $880 + 8 | 0;
         HEAP32[$883 >> 2] = -1;
         $$0$$0$774 = HEAP32[$3 >> 2] | 0;
         $884 = HEAP32[$$0$$0$774 >> 2] | 0;
         $$0$$0$775 = HEAP32[$3 >> 2] | 0;
         $885 = $$0$$0$775 + -12 | 0;
         HEAP32[$3 >> 2] = $885;
         $$1860$be$reg2mem1443$0 = $884;
         $$1868$be$reg2mem1445$0 = $883;
        }
       } while (0);
       if ((label | 0) == 309) {
        label = 0;
        $1055 = HEAP32[5224] | 0;
        $1056 = $1055 + -1 | 0;
        HEAP32[5224] = $1056;
        $1057 = ($1056 | 0) == 0;
        if ($1057) {
         HEAP32[5224] = 10;
         __THREW__ = 0;
         invoke_v(601);
         $1058 = __THREW__;
         __THREW__ = 0;
         if (($1058 | 0) != 0 & (threwValue | 0) != 0) {
          $1059 = _testSetjmp(HEAP32[$1058 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
          if (($1059 | 0) == 0) {
           _longjmp($1058 | 0, threwValue | 0);
          }
          setTempRet0(threwValue | 0);
         } else {
          $1059 = -1;
         }
         $1060 = getTempRet0() | 0;
         $cond1528 = ($1059 | 0) == 1;
         if ($cond1528) {
          $$reg2mem1386$2$phi = $$reg2mem1386$2;
          $$reg2mem1383$2$phi = $$reg2mem1383$2;
          $$reg2mem1375$2$phi = $$reg2mem1375$2;
          $$reg2mem1371$2$phi = $$reg2mem1371$2;
          $$reg2mem1367$2$phi = $$reg2mem1367$2;
          $$reg2mem1365$2$phi = $$reg2mem1365$2;
          $$reg2mem1355$2$phi = $$reg2mem1355$2;
          $$reg2mem1345$2$phi = $$reg2mem1345$2;
          $$reg2mem1332$2$phi = $$reg2mem1332$2;
          $$reg2mem1330$2$phi = $$reg2mem1330$2;
          $$reg2mem1327$2$phi = $$reg2mem1327$2;
          $$reg2mem1324$2$phi = $$reg2mem1324$2;
          $$reg2mem1319$2$phi = $$reg2mem1319$2;
          $$reg2mem1316$2$phi = $$reg2mem1316$2;
          $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
          $$reg2mem1465$0 = $1060;
          $$reg2mem1386$2 = $$reg2mem1386$2$phi;
          $$reg2mem1383$2 = $$reg2mem1383$2$phi;
          $$reg2mem1375$2 = $$reg2mem1375$2$phi;
          $$reg2mem1371$2 = $$reg2mem1371$2$phi;
          $$reg2mem1367$2 = $$reg2mem1367$2$phi;
          $$reg2mem1365$2 = $$reg2mem1365$2$phi;
          $$reg2mem1355$2 = $$reg2mem1355$2$phi;
          $$reg2mem1345$2 = $$reg2mem1345$2$phi;
          $$reg2mem1332$2 = $$reg2mem1332$2$phi;
          $$reg2mem1330$2 = $$reg2mem1330$2$phi;
          $$reg2mem1327$2 = $$reg2mem1327$2$phi;
          $$reg2mem1324$2 = $$reg2mem1324$2$phi;
          $$reg2mem1319$2 = $$reg2mem1319$2$phi;
          $$reg2mem1316$2 = $$reg2mem1316$2$phi;
          $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
          label = 7;
          continue L3;
         }
        }
        $1061 = HEAP16[40740 >> 1] | 0;
        $1062 = $1061 << 16 >> 16 == 0;
        if ($1062) {
         $1063 = HEAP32[40624 >> 2] | 0;
         $1064 = ($1063 | 0) == (0 | 0);
         if (!$1064) {
          label = 314;
          break;
         }
         __THREW__ = 0;
         invoke_vi(611, 0);
         $1067 = __THREW__;
         __THREW__ = 0;
         if (($1067 | 0) != 0 & (threwValue | 0) != 0) {
          $1068 = _testSetjmp(HEAP32[$1067 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
          if (($1068 | 0) == 0) {
           _longjmp($1067 | 0, threwValue | 0);
          }
          setTempRet0(threwValue | 0);
         } else {
          $1068 = -1;
         }
         $1069 = getTempRet0() | 0;
         $cond1527 = ($1068 | 0) == 1;
         if ($cond1527) {
          $$reg2mem1386$2$phi = $$reg2mem1386$2;
          $$reg2mem1383$2$phi = $$reg2mem1383$2;
          $$reg2mem1375$2$phi = $$reg2mem1375$2;
          $$reg2mem1371$2$phi = $$reg2mem1371$2;
          $$reg2mem1367$2$phi = $$reg2mem1367$2;
          $$reg2mem1365$2$phi = $$reg2mem1365$2;
          $$reg2mem1355$2$phi = $$reg2mem1355$2;
          $$reg2mem1345$2$phi = $$reg2mem1345$2;
          $$reg2mem1332$2$phi = $$reg2mem1332$2;
          $$reg2mem1330$2$phi = $$reg2mem1330$2;
          $$reg2mem1327$2$phi = $$reg2mem1327$2;
          $$reg2mem1324$2$phi = $$reg2mem1324$2;
          $$reg2mem1319$2$phi = $$reg2mem1319$2;
          $$reg2mem1316$2$phi = $$reg2mem1316$2;
          $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
          $$reg2mem1465$0 = $1069;
          $$reg2mem1386$2 = $$reg2mem1386$2$phi;
          $$reg2mem1383$2 = $$reg2mem1383$2$phi;
          $$reg2mem1375$2 = $$reg2mem1375$2$phi;
          $$reg2mem1371$2 = $$reg2mem1371$2$phi;
          $$reg2mem1367$2 = $$reg2mem1367$2$phi;
          $$reg2mem1365$2 = $$reg2mem1365$2$phi;
          $$reg2mem1355$2 = $$reg2mem1355$2$phi;
          $$reg2mem1345$2 = $$reg2mem1345$2$phi;
          $$reg2mem1332$2 = $$reg2mem1332$2$phi;
          $$reg2mem1330$2 = $$reg2mem1330$2$phi;
          $$reg2mem1327$2 = $$reg2mem1327$2$phi;
          $$reg2mem1324$2 = $$reg2mem1324$2$phi;
          $$reg2mem1319$2 = $$reg2mem1319$2$phi;
          $$reg2mem1316$2 = $$reg2mem1316$2$phi;
          $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
          label = 7;
          continue L3;
         }
         $$1860$be$reg2mem1443$0 = $$45$reg2mem1413$0;
         $$1868$be$reg2mem1445$0 = $$16883$reg2mem1415$0;
        } else {
         $$1860$be$reg2mem1443$0 = $$45$reg2mem1413$0;
         $$1868$be$reg2mem1445$0 = $$16883$reg2mem1415$0;
        }
       }
       $$1860$reg2mem1461$0 = $$1860$be$reg2mem1443$0;
       $$1868$reg2mem1463$0 = $$1868$be$reg2mem1445$0;
      }
      if ((label | 0) == 59) {
       label = 0;
       __THREW__ = 0;
       $102 = invoke_iii(571, 15712 | 0, 33997 | 0) | 0;
       $103 = __THREW__;
       __THREW__ = 0;
       if (($103 | 0) != 0 & (threwValue | 0) != 0) {
        $104 = _testSetjmp(HEAP32[$103 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (($104 | 0) == 0) {
         _longjmp($103 | 0, threwValue | 0);
        }
        setTempRet0(threwValue | 0);
       } else {
        $104 = -1;
       }
       $105 = getTempRet0() | 0;
       $cond1549 = ($104 | 0) == 1;
       if ($cond1549) {
        $$reg2mem1386$2$phi = $$reg2mem1386$2;
        $$reg2mem1383$2$phi = $$reg2mem1383$2;
        $$reg2mem1375$2$phi = $$reg2mem1375$2;
        $$reg2mem1371$2$phi = $$reg2mem1371$2;
        $$reg2mem1367$2$phi = $$reg2mem1367$2;
        $$reg2mem1365$2$phi = $$reg2mem1365$2;
        $$reg2mem1355$2$phi = $$reg2mem1355$2;
        $$reg2mem1345$2$phi = $$reg2mem1345$2;
        $$reg2mem1332$2$phi = $$reg2mem1332$2;
        $$reg2mem1330$2$phi = $$reg2mem1330$2;
        $$reg2mem1327$2$phi = $$reg2mem1327$2;
        $$reg2mem1324$2$phi = $$reg2mem1324$2;
        $$reg2mem1319$2$phi = $$reg2mem1319$2;
        $$reg2mem1316$2$phi = $$reg2mem1316$2;
        $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
        $$reg2mem1465$0 = $105;
        $$reg2mem1386$2 = $$reg2mem1386$2$phi;
        $$reg2mem1383$2 = $$reg2mem1383$2$phi;
        $$reg2mem1375$2 = $$reg2mem1375$2$phi;
        $$reg2mem1371$2 = $$reg2mem1371$2$phi;
        $$reg2mem1367$2 = $$reg2mem1367$2$phi;
        $$reg2mem1365$2 = $$reg2mem1365$2$phi;
        $$reg2mem1355$2 = $$reg2mem1355$2$phi;
        $$reg2mem1345$2 = $$reg2mem1345$2$phi;
        $$reg2mem1332$2 = $$reg2mem1332$2$phi;
        $$reg2mem1330$2 = $$reg2mem1330$2$phi;
        $$reg2mem1327$2 = $$reg2mem1327$2$phi;
        $$reg2mem1324$2 = $$reg2mem1324$2$phi;
        $$reg2mem1319$2 = $$reg2mem1319$2$phi;
        $$reg2mem1316$2 = $$reg2mem1316$2$phi;
        $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
        label = 7;
        continue L3;
       }
       __THREW__ = 0;
       invoke_v(498);
       $106 = __THREW__;
       __THREW__ = 0;
       if (($106 | 0) != 0 & (threwValue | 0) != 0) {
        $107 = _testSetjmp(HEAP32[$106 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (($107 | 0) == 0) {
         _longjmp($106 | 0, threwValue | 0);
        }
        setTempRet0(threwValue | 0);
       } else {
        $107 = -1;
       }
       $108 = getTempRet0() | 0;
       $cond1550 = ($107 | 0) == 1;
       if ($cond1550) {
        $$reg2mem1386$2$phi = $$reg2mem1386$2;
        $$reg2mem1383$2$phi = $$reg2mem1383$2;
        $$reg2mem1375$2$phi = $$reg2mem1375$2;
        $$reg2mem1371$2$phi = $$reg2mem1371$2;
        $$reg2mem1367$2$phi = $$reg2mem1367$2;
        $$reg2mem1365$2$phi = $$reg2mem1365$2;
        $$reg2mem1355$2$phi = $$reg2mem1355$2;
        $$reg2mem1345$2$phi = $$reg2mem1345$2;
        $$reg2mem1332$2$phi = $$reg2mem1332$2;
        $$reg2mem1330$2$phi = $$reg2mem1330$2;
        $$reg2mem1327$2$phi = $$reg2mem1327$2;
        $$reg2mem1324$2$phi = $$reg2mem1324$2;
        $$reg2mem1319$2$phi = $$reg2mem1319$2;
        $$reg2mem1316$2$phi = $$reg2mem1316$2;
        $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
        $$reg2mem1465$0 = $108;
        $$reg2mem1386$2 = $$reg2mem1386$2$phi;
        $$reg2mem1383$2 = $$reg2mem1383$2$phi;
        $$reg2mem1375$2 = $$reg2mem1375$2$phi;
        $$reg2mem1371$2 = $$reg2mem1371$2$phi;
        $$reg2mem1367$2 = $$reg2mem1367$2$phi;
        $$reg2mem1365$2 = $$reg2mem1365$2$phi;
        $$reg2mem1355$2 = $$reg2mem1355$2$phi;
        $$reg2mem1345$2 = $$reg2mem1345$2$phi;
        $$reg2mem1332$2 = $$reg2mem1332$2$phi;
        $$reg2mem1330$2 = $$reg2mem1330$2$phi;
        $$reg2mem1327$2 = $$reg2mem1327$2$phi;
        $$reg2mem1324$2 = $$reg2mem1324$2$phi;
        $$reg2mem1319$2 = $$reg2mem1319$2$phi;
        $$reg2mem1316$2 = $$reg2mem1316$2$phi;
        $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
        label = 7;
        continue L3;
       }
       HEAP32[$$reg2mem1332$2 >> 2] = $102;
       break;
      } else if ((label | 0) == 164) {
       label = 0;
       __THREW__ = 0;
       invoke_v(498);
       $554 = __THREW__;
       __THREW__ = 0;
       if (($554 | 0) != 0 & (threwValue | 0) != 0) {
        $555 = _testSetjmp(HEAP32[$554 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (($555 | 0) == 0) {
         _longjmp($554 | 0, threwValue | 0);
        }
        setTempRet0(threwValue | 0);
       } else {
        $555 = -1;
       }
       $556 = getTempRet0() | 0;
       $cond1532 = ($555 | 0) == 1;
       if ($cond1532) {
        $$reg2mem1386$2$phi = $$reg2mem1386$2;
        $$reg2mem1383$2$phi = $$reg2mem1383$2;
        $$reg2mem1375$2$phi = $$reg2mem1375$2;
        $$reg2mem1371$2$phi = $$reg2mem1371$2;
        $$reg2mem1367$2$phi = $$reg2mem1367$2;
        $$reg2mem1365$2$phi = $$reg2mem1365$2;
        $$reg2mem1355$2$phi = $$reg2mem1355$2;
        $$reg2mem1345$2$phi = $$reg2mem1345$2;
        $$reg2mem1332$2$phi = $$reg2mem1332$2;
        $$reg2mem1330$2$phi = $$reg2mem1330$2;
        $$reg2mem1327$2$phi = $$reg2mem1327$2;
        $$reg2mem1324$2$phi = $$reg2mem1324$2;
        $$reg2mem1319$2$phi = $$reg2mem1319$2;
        $$reg2mem1316$2$phi = $$reg2mem1316$2;
        $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
        $$reg2mem1465$0 = $556;
        $$reg2mem1386$2 = $$reg2mem1386$2$phi;
        $$reg2mem1383$2 = $$reg2mem1383$2$phi;
        $$reg2mem1375$2 = $$reg2mem1375$2$phi;
        $$reg2mem1371$2 = $$reg2mem1371$2$phi;
        $$reg2mem1367$2 = $$reg2mem1367$2$phi;
        $$reg2mem1365$2 = $$reg2mem1365$2$phi;
        $$reg2mem1355$2 = $$reg2mem1355$2$phi;
        $$reg2mem1345$2 = $$reg2mem1345$2$phi;
        $$reg2mem1332$2 = $$reg2mem1332$2$phi;
        $$reg2mem1330$2 = $$reg2mem1330$2$phi;
        $$reg2mem1327$2 = $$reg2mem1327$2$phi;
        $$reg2mem1324$2 = $$reg2mem1324$2$phi;
        $$reg2mem1319$2 = $$reg2mem1319$2$phi;
        $$reg2mem1316$2 = $$reg2mem1316$2$phi;
        $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
        label = 7;
        continue L3;
       }
       $557 = HEAP32[$$1868$reg2mem1463$0 >> 2] | 0;
       HEAP32[$$reg2mem1319$2 >> 2] = $557;
       break;
      } else if ((label | 0) == 239) {
       label = 0;
       __THREW__ = 0;
       invoke_v(498);
       $888 = __THREW__;
       __THREW__ = 0;
       if (($888 | 0) != 0 & (threwValue | 0) != 0) {
        $889 = _testSetjmp(HEAP32[$888 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (($889 | 0) == 0) {
         _longjmp($888 | 0, threwValue | 0);
        }
        setTempRet0(threwValue | 0);
       } else {
        $889 = -1;
       }
       $890 = getTempRet0() | 0;
       $cond1505 = ($889 | 0) == 1;
       if ($cond1505) {
        $$reg2mem1386$2$phi = $$reg2mem1386$2;
        $$reg2mem1383$2$phi = $$reg2mem1383$2;
        $$reg2mem1375$2$phi = $$reg2mem1375$2;
        $$reg2mem1371$2$phi = $$reg2mem1371$2;
        $$reg2mem1367$2$phi = $$reg2mem1367$2;
        $$reg2mem1365$2$phi = $$reg2mem1365$2;
        $$reg2mem1355$2$phi = $$reg2mem1355$2;
        $$reg2mem1345$2$phi = $$reg2mem1345$2;
        $$reg2mem1332$2$phi = $$reg2mem1332$2;
        $$reg2mem1330$2$phi = $$reg2mem1330$2;
        $$reg2mem1327$2$phi = $$reg2mem1327$2;
        $$reg2mem1324$2$phi = $$reg2mem1324$2;
        $$reg2mem1319$2$phi = $$reg2mem1319$2;
        $$reg2mem1316$2$phi = $$reg2mem1316$2;
        $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
        $$reg2mem1465$0 = $890;
        $$reg2mem1386$2 = $$reg2mem1386$2$phi;
        $$reg2mem1383$2 = $$reg2mem1383$2$phi;
        $$reg2mem1375$2 = $$reg2mem1375$2$phi;
        $$reg2mem1371$2 = $$reg2mem1371$2$phi;
        $$reg2mem1367$2 = $$reg2mem1367$2$phi;
        $$reg2mem1365$2 = $$reg2mem1365$2$phi;
        $$reg2mem1355$2 = $$reg2mem1355$2$phi;
        $$reg2mem1345$2 = $$reg2mem1345$2$phi;
        $$reg2mem1332$2 = $$reg2mem1332$2$phi;
        $$reg2mem1330$2 = $$reg2mem1330$2$phi;
        $$reg2mem1327$2 = $$reg2mem1327$2$phi;
        $$reg2mem1324$2 = $$reg2mem1324$2$phi;
        $$reg2mem1319$2 = $$reg2mem1319$2$phi;
        $$reg2mem1316$2 = $$reg2mem1316$2$phi;
        $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
        label = 7;
        continue L3;
       }
       HEAP32[$$reg2mem1345$2 >> 2] = $$10877$reg2mem1431$0;
       $891 = HEAP32[5224] | 0;
       $892 = $891 + -1 | 0;
       HEAP32[5224] = $892;
       $893 = ($892 | 0) == 0;
       if (!$893) {
        $$4$ph$reg2mem$0 = 0;
        label = 354;
        break L3;
       }
       HEAP32[5224] = 10;
       __THREW__ = 0;
       invoke_v(601);
       $894 = __THREW__;
       __THREW__ = 0;
       if (($894 | 0) != 0 & (threwValue | 0) != 0) {
        $895 = _testSetjmp(HEAP32[$894 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (($895 | 0) == 0) {
         _longjmp($894 | 0, threwValue | 0);
        }
        setTempRet0(threwValue | 0);
       } else {
        $895 = -1;
       }
       $896 = getTempRet0() | 0;
       $cond1506 = ($895 | 0) == 1;
       if ($cond1506) {
        $$reg2mem1386$2$phi = $$reg2mem1386$2;
        $$reg2mem1383$2$phi = $$reg2mem1383$2;
        $$reg2mem1375$2$phi = $$reg2mem1375$2;
        $$reg2mem1371$2$phi = $$reg2mem1371$2;
        $$reg2mem1367$2$phi = $$reg2mem1367$2;
        $$reg2mem1365$2$phi = $$reg2mem1365$2;
        $$reg2mem1355$2$phi = $$reg2mem1355$2;
        $$reg2mem1345$2$phi = $$reg2mem1345$2;
        $$reg2mem1332$2$phi = $$reg2mem1332$2;
        $$reg2mem1330$2$phi = $$reg2mem1330$2;
        $$reg2mem1327$2$phi = $$reg2mem1327$2;
        $$reg2mem1324$2$phi = $$reg2mem1324$2;
        $$reg2mem1319$2$phi = $$reg2mem1319$2;
        $$reg2mem1316$2$phi = $$reg2mem1316$2;
        $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
        $$reg2mem1465$0 = $896;
        $$reg2mem1386$2 = $$reg2mem1386$2$phi;
        $$reg2mem1383$2 = $$reg2mem1383$2$phi;
        $$reg2mem1375$2 = $$reg2mem1375$2$phi;
        $$reg2mem1371$2 = $$reg2mem1371$2$phi;
        $$reg2mem1367$2 = $$reg2mem1367$2$phi;
        $$reg2mem1365$2 = $$reg2mem1365$2$phi;
        $$reg2mem1355$2 = $$reg2mem1355$2$phi;
        $$reg2mem1345$2 = $$reg2mem1345$2$phi;
        $$reg2mem1332$2 = $$reg2mem1332$2$phi;
        $$reg2mem1330$2 = $$reg2mem1330$2$phi;
        $$reg2mem1327$2 = $$reg2mem1327$2$phi;
        $$reg2mem1324$2 = $$reg2mem1324$2$phi;
        $$reg2mem1319$2 = $$reg2mem1319$2$phi;
        $$reg2mem1316$2 = $$reg2mem1316$2$phi;
        $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
        label = 7;
        continue L3;
       } else {
        label = 242;
        break L3;
       }
      } else if ((label | 0) == 243) {
       label = 0;
       $897 = HEAP8[$44 >> 0] | 0;
       L352 : do {
        switch ($897 << 24 >> 24) {
        case 2:
         {
          __THREW__ = 0;
          invoke_viii(602, 0 | 0, 34041 | 0, $vararg_buffer | 0);
          $898 = __THREW__;
          __THREW__ = 0;
          if (($898 | 0) != 0 & (threwValue | 0) != 0) {
           $899 = _testSetjmp(HEAP32[$898 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($899 | 0) == 0) {
            _longjmp($898 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $899 = -1;
          }
          $900 = getTempRet0() | 0;
          $cond1504 = ($899 | 0) == 1;
          if ($cond1504) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $900;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          $901 = $$1868$reg2mem1463$0 + -4 | 0;
          $$11878952$reg2mem$0 = $901;
          label = 254;
          break;
         }
        case 0:
         {
          $$0$$0$777 = HEAP32[$3 >> 2] | 0;
          $902 = $$0$$0$777 >>> 0 < $$reg2mem1375$2 >>> 0;
          L356 : do {
           if (!$902) {
            $$09241145$reg2mem$0 = $$0$$0$777;
            while (1) {
             $905 = $$09241145$reg2mem$0 + 8 | 0;
             $906 = HEAP32[$905 >> 2] | 0;
             $907 = ($906 | 0) == (0 | 0);
             $903 = $$09241145$reg2mem$0 + -12 | 0;
             if (!$907) {
              break;
             }
             $904 = $903 >>> 0 < $$reg2mem1375$2 >>> 0;
             if ($904) {
              break L356;
             } else {
              $$09241145$reg2mem$0 = $903;
             }
            }
            $$1926$reg2mem$0 = $906;
            break L352;
           }
          } while (0);
          __THREW__ = 0;
          $908 = invoke_iii(571, 15772 | 0, 34074 | 0) | 0;
          $909 = __THREW__;
          __THREW__ = 0;
          if (($909 | 0) != 0 & (threwValue | 0) != 0) {
           $910 = _testSetjmp(HEAP32[$909 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($910 | 0) == 0) {
            _longjmp($909 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $910 = -1;
          }
          $911 = getTempRet0() | 0;
          $cond1502 = ($910 | 0) == 1;
          if ($cond1502) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $911;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          __THREW__ = 0;
          invoke_v(498);
          $912 = __THREW__;
          __THREW__ = 0;
          if (($912 | 0) != 0 & (threwValue | 0) != 0) {
           $913 = _testSetjmp(HEAP32[$912 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
           if (($913 | 0) == 0) {
            _longjmp($912 | 0, threwValue | 0);
           }
           setTempRet0(threwValue | 0);
          } else {
           $913 = -1;
          }
          $914 = getTempRet0() | 0;
          $cond1503 = ($913 | 0) == 1;
          if ($cond1503) {
           $$reg2mem1386$2$phi = $$reg2mem1386$2;
           $$reg2mem1383$2$phi = $$reg2mem1383$2;
           $$reg2mem1375$2$phi = $$reg2mem1375$2;
           $$reg2mem1371$2$phi = $$reg2mem1371$2;
           $$reg2mem1367$2$phi = $$reg2mem1367$2;
           $$reg2mem1365$2$phi = $$reg2mem1365$2;
           $$reg2mem1355$2$phi = $$reg2mem1355$2;
           $$reg2mem1345$2$phi = $$reg2mem1345$2;
           $$reg2mem1332$2$phi = $$reg2mem1332$2;
           $$reg2mem1330$2$phi = $$reg2mem1330$2;
           $$reg2mem1327$2$phi = $$reg2mem1327$2;
           $$reg2mem1324$2$phi = $$reg2mem1324$2;
           $$reg2mem1319$2$phi = $$reg2mem1319$2;
           $$reg2mem1316$2$phi = $$reg2mem1316$2;
           $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
           $$reg2mem1465$0 = $914;
           $$reg2mem1386$2 = $$reg2mem1386$2$phi;
           $$reg2mem1383$2 = $$reg2mem1383$2$phi;
           $$reg2mem1375$2 = $$reg2mem1375$2$phi;
           $$reg2mem1371$2 = $$reg2mem1371$2$phi;
           $$reg2mem1367$2 = $$reg2mem1367$2$phi;
           $$reg2mem1365$2 = $$reg2mem1365$2$phi;
           $$reg2mem1355$2 = $$reg2mem1355$2$phi;
           $$reg2mem1345$2 = $$reg2mem1345$2$phi;
           $$reg2mem1332$2 = $$reg2mem1332$2$phi;
           $$reg2mem1330$2 = $$reg2mem1330$2$phi;
           $$reg2mem1327$2 = $$reg2mem1327$2$phi;
           $$reg2mem1324$2 = $$reg2mem1324$2$phi;
           $$reg2mem1319$2 = $$reg2mem1319$2$phi;
           $$reg2mem1316$2 = $$reg2mem1316$2$phi;
           $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
           label = 7;
           continue L3;
          }
          HEAP32[$$reg2mem1332$2 >> 2] = $908;
          break L7;
          break;
         }
        default:
         {
          $$11878952$reg2mem$0 = $$1868$reg2mem1463$0;
          label = 254;
         }
        }
       } while (0);
       if ((label | 0) == 254) {
        label = 0;
        $915 = HEAP32[$$11878952$reg2mem$0 >> 2] | 0;
        $$1926$reg2mem$0 = $915;
       }
       __THREW__ = 0;
       $916 = invoke_ii(570, $$1926$reg2mem$0 | 0) | 0;
       $917 = __THREW__;
       __THREW__ = 0;
       if (($917 | 0) != 0 & (threwValue | 0) != 0) {
        $918 = _testSetjmp(HEAP32[$917 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (($918 | 0) == 0) {
         _longjmp($917 | 0, threwValue | 0);
        }
        setTempRet0(threwValue | 0);
       } else {
        $918 = -1;
       }
       $919 = getTempRet0() | 0;
       $cond1500 = ($918 | 0) == 1;
       if ($cond1500) {
        $$reg2mem1386$2$phi = $$reg2mem1386$2;
        $$reg2mem1383$2$phi = $$reg2mem1383$2;
        $$reg2mem1375$2$phi = $$reg2mem1375$2;
        $$reg2mem1371$2$phi = $$reg2mem1371$2;
        $$reg2mem1367$2$phi = $$reg2mem1367$2;
        $$reg2mem1365$2$phi = $$reg2mem1365$2;
        $$reg2mem1355$2$phi = $$reg2mem1355$2;
        $$reg2mem1345$2$phi = $$reg2mem1345$2;
        $$reg2mem1332$2$phi = $$reg2mem1332$2;
        $$reg2mem1330$2$phi = $$reg2mem1330$2;
        $$reg2mem1327$2$phi = $$reg2mem1327$2;
        $$reg2mem1324$2$phi = $$reg2mem1324$2;
        $$reg2mem1319$2$phi = $$reg2mem1319$2;
        $$reg2mem1316$2$phi = $$reg2mem1316$2;
        $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
        $$reg2mem1465$0 = $919;
        $$reg2mem1386$2 = $$reg2mem1386$2$phi;
        $$reg2mem1383$2 = $$reg2mem1383$2$phi;
        $$reg2mem1375$2 = $$reg2mem1375$2$phi;
        $$reg2mem1371$2 = $$reg2mem1371$2$phi;
        $$reg2mem1367$2 = $$reg2mem1367$2$phi;
        $$reg2mem1365$2 = $$reg2mem1365$2$phi;
        $$reg2mem1355$2 = $$reg2mem1355$2$phi;
        $$reg2mem1345$2 = $$reg2mem1345$2$phi;
        $$reg2mem1332$2 = $$reg2mem1332$2$phi;
        $$reg2mem1330$2 = $$reg2mem1330$2$phi;
        $$reg2mem1327$2 = $$reg2mem1327$2$phi;
        $$reg2mem1324$2 = $$reg2mem1324$2$phi;
        $$reg2mem1319$2 = $$reg2mem1319$2$phi;
        $$reg2mem1316$2 = $$reg2mem1316$2$phi;
        $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
        label = 7;
        continue L3;
       }
       __THREW__ = 0;
       invoke_v(498);
       $920 = __THREW__;
       __THREW__ = 0;
       if (($920 | 0) != 0 & (threwValue | 0) != 0) {
        $921 = _testSetjmp(HEAP32[$920 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (($921 | 0) == 0) {
         _longjmp($920 | 0, threwValue | 0);
        }
        setTempRet0(threwValue | 0);
       } else {
        $921 = -1;
       }
       $922 = getTempRet0() | 0;
       $cond1501 = ($921 | 0) == 1;
       if ($cond1501) {
        $$reg2mem1386$2$phi = $$reg2mem1386$2;
        $$reg2mem1383$2$phi = $$reg2mem1383$2;
        $$reg2mem1375$2$phi = $$reg2mem1375$2;
        $$reg2mem1371$2$phi = $$reg2mem1371$2;
        $$reg2mem1367$2$phi = $$reg2mem1367$2;
        $$reg2mem1365$2$phi = $$reg2mem1365$2;
        $$reg2mem1355$2$phi = $$reg2mem1355$2;
        $$reg2mem1345$2$phi = $$reg2mem1345$2;
        $$reg2mem1332$2$phi = $$reg2mem1332$2;
        $$reg2mem1330$2$phi = $$reg2mem1330$2;
        $$reg2mem1327$2$phi = $$reg2mem1327$2;
        $$reg2mem1324$2$phi = $$reg2mem1324$2;
        $$reg2mem1319$2$phi = $$reg2mem1319$2;
        $$reg2mem1316$2$phi = $$reg2mem1316$2;
        $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
        $$reg2mem1465$0 = $922;
        $$reg2mem1386$2 = $$reg2mem1386$2$phi;
        $$reg2mem1383$2 = $$reg2mem1383$2$phi;
        $$reg2mem1375$2 = $$reg2mem1375$2$phi;
        $$reg2mem1371$2 = $$reg2mem1371$2$phi;
        $$reg2mem1367$2 = $$reg2mem1367$2$phi;
        $$reg2mem1365$2 = $$reg2mem1365$2$phi;
        $$reg2mem1355$2 = $$reg2mem1355$2$phi;
        $$reg2mem1345$2 = $$reg2mem1345$2$phi;
        $$reg2mem1332$2 = $$reg2mem1332$2$phi;
        $$reg2mem1330$2 = $$reg2mem1330$2$phi;
        $$reg2mem1327$2 = $$reg2mem1327$2$phi;
        $$reg2mem1324$2 = $$reg2mem1324$2$phi;
        $$reg2mem1319$2 = $$reg2mem1319$2$phi;
        $$reg2mem1316$2 = $$reg2mem1316$2$phi;
        $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
        label = 7;
        continue L3;
       }
       HEAP32[$$reg2mem1332$2 >> 2] = $916;
       break;
      } else if ((label | 0) == 258) {
       label = 0;
       __THREW__ = 0;
       invoke_v(498);
       $923 = __THREW__;
       __THREW__ = 0;
       if (($923 | 0) != 0 & (threwValue | 0) != 0) {
        $924 = _testSetjmp(HEAP32[$923 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (($924 | 0) == 0) {
         _longjmp($923 | 0, threwValue | 0);
        }
        setTempRet0(threwValue | 0);
       } else {
        $924 = -1;
       }
       $925 = getTempRet0() | 0;
       $cond1499 = ($924 | 0) == 1;
       if ($cond1499) {
        $$reg2mem1386$2$phi = $$reg2mem1386$2;
        $$reg2mem1383$2$phi = $$reg2mem1383$2;
        $$reg2mem1375$2$phi = $$reg2mem1375$2;
        $$reg2mem1371$2$phi = $$reg2mem1371$2;
        $$reg2mem1367$2$phi = $$reg2mem1367$2;
        $$reg2mem1365$2$phi = $$reg2mem1365$2;
        $$reg2mem1355$2$phi = $$reg2mem1355$2;
        $$reg2mem1345$2$phi = $$reg2mem1345$2;
        $$reg2mem1332$2$phi = $$reg2mem1332$2;
        $$reg2mem1330$2$phi = $$reg2mem1330$2;
        $$reg2mem1327$2$phi = $$reg2mem1327$2;
        $$reg2mem1324$2$phi = $$reg2mem1324$2;
        $$reg2mem1319$2$phi = $$reg2mem1319$2;
        $$reg2mem1316$2$phi = $$reg2mem1316$2;
        $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
        $$reg2mem1465$0 = $925;
        $$reg2mem1386$2 = $$reg2mem1386$2$phi;
        $$reg2mem1383$2 = $$reg2mem1383$2$phi;
        $$reg2mem1375$2 = $$reg2mem1375$2$phi;
        $$reg2mem1371$2 = $$reg2mem1371$2$phi;
        $$reg2mem1367$2 = $$reg2mem1367$2$phi;
        $$reg2mem1365$2 = $$reg2mem1365$2$phi;
        $$reg2mem1355$2 = $$reg2mem1355$2$phi;
        $$reg2mem1345$2 = $$reg2mem1345$2$phi;
        $$reg2mem1332$2 = $$reg2mem1332$2$phi;
        $$reg2mem1330$2 = $$reg2mem1330$2$phi;
        $$reg2mem1327$2 = $$reg2mem1327$2$phi;
        $$reg2mem1324$2 = $$reg2mem1324$2$phi;
        $$reg2mem1319$2 = $$reg2mem1319$2$phi;
        $$reg2mem1316$2 = $$reg2mem1316$2$phi;
        $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
        label = 7;
        continue L3;
       } else {
        label = 259;
        break L3;
       }
      } else if ((label | 0) == 306) {
       label = 0;
       __THREW__ = 0;
       $1048 = invoke_iii(571, 15832 | 0, 34105 | 0) | 0;
       $1049 = __THREW__;
       __THREW__ = 0;
       if (($1049 | 0) != 0 & (threwValue | 0) != 0) {
        $1050 = _testSetjmp(HEAP32[$1049 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (($1050 | 0) == 0) {
         _longjmp($1049 | 0, threwValue | 0);
        }
        setTempRet0(threwValue | 0);
       } else {
        $1050 = -1;
       }
       $1051 = getTempRet0() | 0;
       $cond1564 = ($1050 | 0) == 1;
       if ($cond1564) {
        $$reg2mem1386$2$phi = $$reg2mem1386$2;
        $$reg2mem1383$2$phi = $$reg2mem1383$2;
        $$reg2mem1375$2$phi = $$reg2mem1375$2;
        $$reg2mem1371$2$phi = $$reg2mem1371$2;
        $$reg2mem1367$2$phi = $$reg2mem1367$2;
        $$reg2mem1365$2$phi = $$reg2mem1365$2;
        $$reg2mem1355$2$phi = $$reg2mem1355$2;
        $$reg2mem1345$2$phi = $$reg2mem1345$2;
        $$reg2mem1332$2$phi = $$reg2mem1332$2;
        $$reg2mem1330$2$phi = $$reg2mem1330$2;
        $$reg2mem1327$2$phi = $$reg2mem1327$2;
        $$reg2mem1324$2$phi = $$reg2mem1324$2;
        $$reg2mem1319$2$phi = $$reg2mem1319$2;
        $$reg2mem1316$2$phi = $$reg2mem1316$2;
        $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
        $$reg2mem1465$0 = $1051;
        $$reg2mem1386$2 = $$reg2mem1386$2$phi;
        $$reg2mem1383$2 = $$reg2mem1383$2$phi;
        $$reg2mem1375$2 = $$reg2mem1375$2$phi;
        $$reg2mem1371$2 = $$reg2mem1371$2$phi;
        $$reg2mem1367$2 = $$reg2mem1367$2$phi;
        $$reg2mem1365$2 = $$reg2mem1365$2$phi;
        $$reg2mem1355$2 = $$reg2mem1355$2$phi;
        $$reg2mem1345$2 = $$reg2mem1345$2$phi;
        $$reg2mem1332$2 = $$reg2mem1332$2$phi;
        $$reg2mem1330$2 = $$reg2mem1330$2$phi;
        $$reg2mem1327$2 = $$reg2mem1327$2$phi;
        $$reg2mem1324$2 = $$reg2mem1324$2$phi;
        $$reg2mem1319$2 = $$reg2mem1319$2$phi;
        $$reg2mem1316$2 = $$reg2mem1316$2$phi;
        $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
        label = 7;
        continue L3;
       }
       __THREW__ = 0;
       invoke_v(498);
       $1052 = __THREW__;
       __THREW__ = 0;
       if (($1052 | 0) != 0 & (threwValue | 0) != 0) {
        $1053 = _testSetjmp(HEAP32[$1052 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (($1053 | 0) == 0) {
         _longjmp($1052 | 0, threwValue | 0);
        }
        setTempRet0(threwValue | 0);
       } else {
        $1053 = -1;
       }
       $1054 = getTempRet0() | 0;
       $cond1565 = ($1053 | 0) == 1;
       if ($cond1565) {
        $$reg2mem1386$2$phi = $$reg2mem1386$2;
        $$reg2mem1383$2$phi = $$reg2mem1383$2;
        $$reg2mem1375$2$phi = $$reg2mem1375$2;
        $$reg2mem1371$2$phi = $$reg2mem1371$2;
        $$reg2mem1367$2$phi = $$reg2mem1367$2;
        $$reg2mem1365$2$phi = $$reg2mem1365$2;
        $$reg2mem1355$2$phi = $$reg2mem1355$2;
        $$reg2mem1345$2$phi = $$reg2mem1345$2;
        $$reg2mem1332$2$phi = $$reg2mem1332$2;
        $$reg2mem1330$2$phi = $$reg2mem1330$2;
        $$reg2mem1327$2$phi = $$reg2mem1327$2;
        $$reg2mem1324$2$phi = $$reg2mem1324$2;
        $$reg2mem1319$2$phi = $$reg2mem1319$2;
        $$reg2mem1316$2$phi = $$reg2mem1316$2;
        $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
        $$reg2mem1465$0 = $1054;
        $$reg2mem1386$2 = $$reg2mem1386$2$phi;
        $$reg2mem1383$2 = $$reg2mem1383$2$phi;
        $$reg2mem1375$2 = $$reg2mem1375$2$phi;
        $$reg2mem1371$2 = $$reg2mem1371$2$phi;
        $$reg2mem1367$2 = $$reg2mem1367$2$phi;
        $$reg2mem1365$2 = $$reg2mem1365$2$phi;
        $$reg2mem1355$2 = $$reg2mem1355$2$phi;
        $$reg2mem1345$2 = $$reg2mem1345$2$phi;
        $$reg2mem1332$2 = $$reg2mem1332$2$phi;
        $$reg2mem1330$2 = $$reg2mem1330$2$phi;
        $$reg2mem1327$2 = $$reg2mem1327$2$phi;
        $$reg2mem1324$2 = $$reg2mem1324$2$phi;
        $$reg2mem1319$2 = $$reg2mem1319$2$phi;
        $$reg2mem1316$2 = $$reg2mem1316$2$phi;
        $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
        label = 7;
        continue L3;
       } else {
        label = 308;
        break L3;
       }
      } else if ((label | 0) == 314) {
       label = 0;
       HEAP32[40624 >> 2] = 0;
       $1065 = HEAP8[40742 >> 0] | 0;
       $1066 = $1065 << 24 >> 24 == 0;
       if ($1066) {
        HEAP16[40740 >> 1] = 1;
       }
       __THREW__ = 0;
       invoke_v(498);
       $1070 = __THREW__;
       __THREW__ = 0;
       if (($1070 | 0) != 0 & (threwValue | 0) != 0) {
        $1071 = _testSetjmp(HEAP32[$1070 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (($1071 | 0) == 0) {
         _longjmp($1070 | 0, threwValue | 0);
        }
        setTempRet0(threwValue | 0);
       } else {
        $1071 = -1;
       }
       $1072 = getTempRet0() | 0;
       $cond1526 = ($1071 | 0) == 1;
       if ($cond1526) {
        $$reg2mem1386$2$phi = $$reg2mem1386$2;
        $$reg2mem1383$2$phi = $$reg2mem1383$2;
        $$reg2mem1375$2$phi = $$reg2mem1375$2;
        $$reg2mem1371$2$phi = $$reg2mem1371$2;
        $$reg2mem1367$2$phi = $$reg2mem1367$2;
        $$reg2mem1365$2$phi = $$reg2mem1365$2;
        $$reg2mem1355$2$phi = $$reg2mem1355$2;
        $$reg2mem1345$2$phi = $$reg2mem1345$2;
        $$reg2mem1332$2$phi = $$reg2mem1332$2;
        $$reg2mem1330$2$phi = $$reg2mem1330$2;
        $$reg2mem1327$2$phi = $$reg2mem1327$2;
        $$reg2mem1324$2$phi = $$reg2mem1324$2;
        $$reg2mem1319$2$phi = $$reg2mem1319$2;
        $$reg2mem1316$2$phi = $$reg2mem1316$2;
        $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
        $$reg2mem1465$0 = $1072;
        $$reg2mem1386$2 = $$reg2mem1386$2$phi;
        $$reg2mem1383$2 = $$reg2mem1383$2$phi;
        $$reg2mem1375$2 = $$reg2mem1375$2$phi;
        $$reg2mem1371$2 = $$reg2mem1371$2$phi;
        $$reg2mem1367$2 = $$reg2mem1367$2$phi;
        $$reg2mem1365$2 = $$reg2mem1365$2$phi;
        $$reg2mem1355$2 = $$reg2mem1355$2$phi;
        $$reg2mem1345$2 = $$reg2mem1345$2$phi;
        $$reg2mem1332$2 = $$reg2mem1332$2$phi;
        $$reg2mem1330$2 = $$reg2mem1330$2$phi;
        $$reg2mem1327$2 = $$reg2mem1327$2$phi;
        $$reg2mem1324$2 = $$reg2mem1324$2$phi;
        $$reg2mem1319$2 = $$reg2mem1319$2$phi;
        $$reg2mem1316$2 = $$reg2mem1316$2$phi;
        $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
        label = 7;
        continue L3;
       }
       HEAP32[$$reg2mem1332$2 >> 2] = $1063;
       break;
      } else if ((label | 0) == 320) {
       label = 0;
       $cond1 = ($$4898$reg2mem1421$0 | 0) == 7;
       if ($cond1) {
        break;
       } else {
        $$4$ph$reg2mem$0 = 0;
        label = 354;
        break L3;
       }
      }
     }
    } while (0);
    $1073 = HEAP32[$$reg2mem1330$2 >> 2] | 0;
    $1074 = HEAP32[$1073 >> 2] | 0;
    __THREW__ = 0;
    $1075 = invoke_iii(499, $1074 | 0, 14676 | 0) | 0;
    $1076 = __THREW__;
    __THREW__ = 0;
    if (($1076 | 0) != 0 & (threwValue | 0) != 0) {
     $1077 = _testSetjmp(HEAP32[$1076 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($1077 | 0) == 0) {
      _longjmp($1076 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $1077 = -1;
    }
    $1078 = getTempRet0() | 0;
    $cond1472 = ($1077 | 0) == 1;
    if ($cond1472) {
     $$reg2mem1386$2$phi = $$reg2mem1386$2;
     $$reg2mem1383$2$phi = $$reg2mem1383$2;
     $$reg2mem1375$2$phi = $$reg2mem1375$2;
     $$reg2mem1371$2$phi = $$reg2mem1371$2;
     $$reg2mem1367$2$phi = $$reg2mem1367$2;
     $$reg2mem1365$2$phi = $$reg2mem1365$2;
     $$reg2mem1355$2$phi = $$reg2mem1355$2;
     $$reg2mem1345$2$phi = $$reg2mem1345$2;
     $$reg2mem1332$2$phi = $$reg2mem1332$2;
     $$reg2mem1330$2$phi = $$reg2mem1330$2;
     $$reg2mem1327$2$phi = $$reg2mem1327$2;
     $$reg2mem1324$2$phi = $$reg2mem1324$2;
     $$reg2mem1319$2$phi = $$reg2mem1319$2;
     $$reg2mem1316$2$phi = $$reg2mem1316$2;
     $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
     $$reg2mem1465$0 = $1078;
     $$reg2mem1386$2 = $$reg2mem1386$2$phi;
     $$reg2mem1383$2 = $$reg2mem1383$2$phi;
     $$reg2mem1375$2 = $$reg2mem1375$2$phi;
     $$reg2mem1371$2 = $$reg2mem1371$2$phi;
     $$reg2mem1367$2 = $$reg2mem1367$2$phi;
     $$reg2mem1365$2 = $$reg2mem1365$2$phi;
     $$reg2mem1355$2 = $$reg2mem1355$2$phi;
     $$reg2mem1345$2 = $$reg2mem1345$2$phi;
     $$reg2mem1332$2 = $$reg2mem1332$2$phi;
     $$reg2mem1330$2 = $$reg2mem1330$2$phi;
     $$reg2mem1327$2 = $$reg2mem1327$2$phi;
     $$reg2mem1324$2 = $$reg2mem1324$2$phi;
     $$reg2mem1319$2 = $$reg2mem1319$2$phi;
     $$reg2mem1316$2 = $$reg2mem1316$2$phi;
     $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
     label = 7;
     continue L3;
    }
    L389 : do {
     if ($1075) {
      $1079 = HEAP32[$$reg2mem1355$2 >> 2] | 0;
      $1080 = ($1079 | 0) == (0 | 0);
      if (!$1080) {
       $1081 = HEAP8[$1079 >> 0] | 0;
       switch ($1081 << 24 >> 24) {
       case 67:
        {
         $1082 = $1079 + 1 | 0;
         $1083 = HEAP8[$1082 >> 0] | 0;
         $1084 = $1083 & 255;
         $1085 = $1079 + 2 | 0;
         $1086 = HEAP8[$1085 >> 0] | 0;
         $1087 = $1086 & 255;
         $1088 = $1087 << 8;
         $1089 = $1088 | $1084;
         $1090 = $1079 + 3 | 0;
         $1091 = $1090 + $1089 | 0;
         HEAP32[$$reg2mem1355$2 >> 2] = $1091;
         $1092 = HEAP32[$$reg2mem1345$2 >> 2] | 0;
         $1093 = $1092 + -16 | 0;
         HEAP32[$$reg2mem1345$2 >> 2] = $1093;
         break;
        }
       case 94:
        {
         $1094 = HEAP32[$$reg2mem1332$2 >> 2] | 0;
         __THREW__ = 0;
         $1095 = invoke_ii(605, $1094 | 0) | 0;
         $1096 = __THREW__;
         __THREW__ = 0;
         if (($1096 | 0) != 0 & (threwValue | 0) != 0) {
          $1097 = _testSetjmp(HEAP32[$1096 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
          if (($1097 | 0) == 0) {
           _longjmp($1096 | 0, threwValue | 0);
          }
          setTempRet0(threwValue | 0);
         } else {
          $1097 = -1;
         }
         $1098 = getTempRet0() | 0;
         $cond1482 = ($1097 | 0) == 1;
         if ($cond1482) {
          $$reg2mem1386$2$phi = $$reg2mem1386$2;
          $$reg2mem1383$2$phi = $$reg2mem1383$2;
          $$reg2mem1375$2$phi = $$reg2mem1375$2;
          $$reg2mem1371$2$phi = $$reg2mem1371$2;
          $$reg2mem1367$2$phi = $$reg2mem1367$2;
          $$reg2mem1365$2$phi = $$reg2mem1365$2;
          $$reg2mem1355$2$phi = $$reg2mem1355$2;
          $$reg2mem1345$2$phi = $$reg2mem1345$2;
          $$reg2mem1332$2$phi = $$reg2mem1332$2;
          $$reg2mem1330$2$phi = $$reg2mem1330$2;
          $$reg2mem1327$2$phi = $$reg2mem1327$2;
          $$reg2mem1324$2$phi = $$reg2mem1324$2;
          $$reg2mem1319$2$phi = $$reg2mem1319$2;
          $$reg2mem1316$2$phi = $$reg2mem1316$2;
          $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
          $$reg2mem1465$0 = $1098;
          $$reg2mem1386$2 = $$reg2mem1386$2$phi;
          $$reg2mem1383$2 = $$reg2mem1383$2$phi;
          $$reg2mem1375$2 = $$reg2mem1375$2$phi;
          $$reg2mem1371$2 = $$reg2mem1371$2$phi;
          $$reg2mem1367$2 = $$reg2mem1367$2$phi;
          $$reg2mem1365$2 = $$reg2mem1365$2$phi;
          $$reg2mem1355$2 = $$reg2mem1355$2$phi;
          $$reg2mem1345$2 = $$reg2mem1345$2$phi;
          $$reg2mem1332$2 = $$reg2mem1332$2$phi;
          $$reg2mem1330$2 = $$reg2mem1330$2$phi;
          $$reg2mem1327$2 = $$reg2mem1327$2$phi;
          $$reg2mem1324$2 = $$reg2mem1324$2$phi;
          $$reg2mem1319$2 = $$reg2mem1319$2$phi;
          $$reg2mem1316$2 = $$reg2mem1316$2$phi;
          $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
          label = 7;
          continue L3;
         }
         $1099 = HEAP32[$$reg2mem1345$2 >> 2] | 0;
         HEAP32[$1099 >> 2] = $1095;
         $1100 = HEAP32[$$reg2mem1355$2 >> 2] | 0;
         $1101 = $1100 + 1 | 0;
         HEAP32[$$reg2mem1355$2 >> 2] = $1101;
         break;
        }
       default:
        {
         break L389;
        }
       }
       $$0$sroa_cast$reg2mem$1 = $$0$sroa_cast$reg2mem$2;
       $$reg2mem1316$1 = $$reg2mem1316$2;
       $$reg2mem1319$1 = $$reg2mem1319$2;
       $$reg2mem1324$1 = $$reg2mem1324$2;
       $$reg2mem1327$1 = $$reg2mem1327$2;
       $$reg2mem1330$1 = $$reg2mem1330$2;
       $$reg2mem1332$1 = $$reg2mem1332$2;
       $$reg2mem1345$1 = $$reg2mem1345$2;
       $$reg2mem1355$1 = $$reg2mem1355$2;
       $$reg2mem1365$1 = $$reg2mem1365$2;
       $$reg2mem1367$1 = $$reg2mem1367$2;
       $$reg2mem1371$1 = $$reg2mem1371$2;
       $$reg2mem1375$1 = $$reg2mem1375$2;
       $$reg2mem1383$1 = $$reg2mem1383$2;
       $$reg2mem1386$1 = $$reg2mem1386$2;
       break L4;
      }
     }
    } while (0);
    $1102 = HEAP32[$$reg2mem1332$2 >> 2] | 0;
    $1103 = ($1102 | 0) == (14856 | 0);
    if (!$1103) {
     $1104 = HEAP32[$0 >> 2] | 0;
     $1105 = $1104 + 8 | 0;
     $1106 = HEAP32[$1105 >> 2] | 0;
     __THREW__ = 0;
     $1107 = invoke_ii(612, $1106 | 0) | 0;
     $1108 = __THREW__;
     __THREW__ = 0;
     if (($1108 | 0) != 0 & (threwValue | 0) != 0) {
      $1109 = _testSetjmp(HEAP32[$1108 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($1109 | 0) == 0) {
       _longjmp($1108 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $1109 = -1;
     }
     $1110 = getTempRet0() | 0;
     $cond1473 = ($1109 | 0) == 1;
     if ($cond1473) {
      $$reg2mem1386$2$phi = $$reg2mem1386$2;
      $$reg2mem1383$2$phi = $$reg2mem1383$2;
      $$reg2mem1375$2$phi = $$reg2mem1375$2;
      $$reg2mem1371$2$phi = $$reg2mem1371$2;
      $$reg2mem1367$2$phi = $$reg2mem1367$2;
      $$reg2mem1365$2$phi = $$reg2mem1365$2;
      $$reg2mem1355$2$phi = $$reg2mem1355$2;
      $$reg2mem1345$2$phi = $$reg2mem1345$2;
      $$reg2mem1332$2$phi = $$reg2mem1332$2;
      $$reg2mem1330$2$phi = $$reg2mem1330$2;
      $$reg2mem1327$2$phi = $$reg2mem1327$2;
      $$reg2mem1324$2$phi = $$reg2mem1324$2;
      $$reg2mem1319$2$phi = $$reg2mem1319$2;
      $$reg2mem1316$2$phi = $$reg2mem1316$2;
      $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
      $$reg2mem1465$0 = $1110;
      $$reg2mem1386$2 = $$reg2mem1386$2$phi;
      $$reg2mem1383$2 = $$reg2mem1383$2$phi;
      $$reg2mem1375$2 = $$reg2mem1375$2$phi;
      $$reg2mem1371$2 = $$reg2mem1371$2$phi;
      $$reg2mem1367$2 = $$reg2mem1367$2$phi;
      $$reg2mem1365$2 = $$reg2mem1365$2$phi;
      $$reg2mem1355$2 = $$reg2mem1355$2$phi;
      $$reg2mem1345$2 = $$reg2mem1345$2$phi;
      $$reg2mem1332$2 = $$reg2mem1332$2$phi;
      $$reg2mem1330$2 = $$reg2mem1330$2$phi;
      $$reg2mem1327$2 = $$reg2mem1327$2$phi;
      $$reg2mem1324$2 = $$reg2mem1324$2$phi;
      $$reg2mem1319$2 = $$reg2mem1319$2$phi;
      $$reg2mem1316$2 = $$reg2mem1316$2$phi;
      $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
      label = 7;
      continue L3;
     }
     __THREW__ = 0;
     $1111 = invoke_ii(612, $1107 | 0) | 0;
     $1112 = __THREW__;
     __THREW__ = 0;
     if (($1112 | 0) != 0 & (threwValue | 0) != 0) {
      $1113 = _testSetjmp(HEAP32[$1112 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($1113 | 0) == 0) {
       _longjmp($1112 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $1113 = -1;
     }
     $1114 = getTempRet0() | 0;
     $cond1474 = ($1113 | 0) == 1;
     if ($cond1474) {
      $$reg2mem1386$2$phi = $$reg2mem1386$2;
      $$reg2mem1383$2$phi = $$reg2mem1383$2;
      $$reg2mem1375$2$phi = $$reg2mem1375$2;
      $$reg2mem1371$2$phi = $$reg2mem1371$2;
      $$reg2mem1367$2$phi = $$reg2mem1367$2;
      $$reg2mem1365$2$phi = $$reg2mem1365$2;
      $$reg2mem1355$2$phi = $$reg2mem1355$2;
      $$reg2mem1345$2$phi = $$reg2mem1345$2;
      $$reg2mem1332$2$phi = $$reg2mem1332$2;
      $$reg2mem1330$2$phi = $$reg2mem1330$2;
      $$reg2mem1327$2$phi = $$reg2mem1327$2;
      $$reg2mem1324$2$phi = $$reg2mem1324$2;
      $$reg2mem1319$2$phi = $$reg2mem1319$2;
      $$reg2mem1316$2$phi = $$reg2mem1316$2;
      $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
      $$reg2mem1465$0 = $1114;
      $$reg2mem1386$2 = $$reg2mem1386$2$phi;
      $$reg2mem1383$2 = $$reg2mem1383$2$phi;
      $$reg2mem1375$2 = $$reg2mem1375$2$phi;
      $$reg2mem1371$2 = $$reg2mem1371$2$phi;
      $$reg2mem1367$2 = $$reg2mem1367$2$phi;
      $$reg2mem1365$2 = $$reg2mem1365$2$phi;
      $$reg2mem1355$2 = $$reg2mem1355$2$phi;
      $$reg2mem1345$2 = $$reg2mem1345$2$phi;
      $$reg2mem1332$2 = $$reg2mem1332$2$phi;
      $$reg2mem1330$2 = $$reg2mem1330$2$phi;
      $$reg2mem1327$2 = $$reg2mem1327$2$phi;
      $$reg2mem1324$2 = $$reg2mem1324$2$phi;
      $$reg2mem1319$2 = $$reg2mem1319$2$phi;
      $$reg2mem1316$2 = $$reg2mem1316$2$phi;
      $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
      label = 7;
      continue L3;
     }
     $1115 = $1111 + 4 | 0;
     $1116 = HEAP32[$$reg2mem1316$2 >> 2] | 0;
     __THREW__ = 0;
     $1117 = invoke_ii(569, $1115 | 0) | 0;
     $1118 = __THREW__;
     __THREW__ = 0;
     if (($1118 | 0) != 0 & (threwValue | 0) != 0) {
      $1119 = _testSetjmp(HEAP32[$1118 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($1119 | 0) == 0) {
       _longjmp($1118 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $1119 = -1;
     }
     $1120 = getTempRet0() | 0;
     $cond1475 = ($1119 | 0) == 1;
     if ($cond1475) {
      $$reg2mem1386$2$phi = $$reg2mem1386$2;
      $$reg2mem1383$2$phi = $$reg2mem1383$2;
      $$reg2mem1375$2$phi = $$reg2mem1375$2;
      $$reg2mem1371$2$phi = $$reg2mem1371$2;
      $$reg2mem1367$2$phi = $$reg2mem1367$2;
      $$reg2mem1365$2$phi = $$reg2mem1365$2;
      $$reg2mem1355$2$phi = $$reg2mem1355$2;
      $$reg2mem1345$2$phi = $$reg2mem1345$2;
      $$reg2mem1332$2$phi = $$reg2mem1332$2;
      $$reg2mem1330$2$phi = $$reg2mem1330$2;
      $$reg2mem1327$2$phi = $$reg2mem1327$2;
      $$reg2mem1324$2$phi = $$reg2mem1324$2;
      $$reg2mem1319$2$phi = $$reg2mem1319$2;
      $$reg2mem1316$2$phi = $$reg2mem1316$2;
      $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
      $$reg2mem1465$0 = $1120;
      $$reg2mem1386$2 = $$reg2mem1386$2$phi;
      $$reg2mem1383$2 = $$reg2mem1383$2$phi;
      $$reg2mem1375$2 = $$reg2mem1375$2$phi;
      $$reg2mem1371$2 = $$reg2mem1371$2$phi;
      $$reg2mem1367$2 = $$reg2mem1367$2$phi;
      $$reg2mem1365$2 = $$reg2mem1365$2$phi;
      $$reg2mem1355$2 = $$reg2mem1355$2$phi;
      $$reg2mem1345$2 = $$reg2mem1345$2$phi;
      $$reg2mem1332$2 = $$reg2mem1332$2$phi;
      $$reg2mem1330$2 = $$reg2mem1330$2$phi;
      $$reg2mem1327$2 = $$reg2mem1327$2$phi;
      $$reg2mem1324$2 = $$reg2mem1324$2$phi;
      $$reg2mem1319$2 = $$reg2mem1319$2$phi;
      $$reg2mem1316$2 = $$reg2mem1316$2$phi;
      $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
      label = 7;
      continue L3;
     }
     __THREW__ = 0;
     $1121 = invoke_ii(612, $1115 | 0) | 0;
     $1122 = __THREW__;
     __THREW__ = 0;
     if (($1122 | 0) != 0 & (threwValue | 0) != 0) {
      $1123 = _testSetjmp(HEAP32[$1122 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($1123 | 0) == 0) {
       _longjmp($1122 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $1123 = -1;
     }
     $1124 = getTempRet0() | 0;
     $cond1476 = ($1123 | 0) == 1;
     if ($cond1476) {
      $$reg2mem1386$2$phi = $$reg2mem1386$2;
      $$reg2mem1383$2$phi = $$reg2mem1383$2;
      $$reg2mem1375$2$phi = $$reg2mem1375$2;
      $$reg2mem1371$2$phi = $$reg2mem1371$2;
      $$reg2mem1367$2$phi = $$reg2mem1367$2;
      $$reg2mem1365$2$phi = $$reg2mem1365$2;
      $$reg2mem1355$2$phi = $$reg2mem1355$2;
      $$reg2mem1345$2$phi = $$reg2mem1345$2;
      $$reg2mem1332$2$phi = $$reg2mem1332$2;
      $$reg2mem1330$2$phi = $$reg2mem1330$2;
      $$reg2mem1327$2$phi = $$reg2mem1327$2;
      $$reg2mem1324$2$phi = $$reg2mem1324$2;
      $$reg2mem1319$2$phi = $$reg2mem1319$2;
      $$reg2mem1316$2$phi = $$reg2mem1316$2;
      $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
      $$reg2mem1465$0 = $1124;
      $$reg2mem1386$2 = $$reg2mem1386$2$phi;
      $$reg2mem1383$2 = $$reg2mem1383$2$phi;
      $$reg2mem1375$2 = $$reg2mem1375$2$phi;
      $$reg2mem1371$2 = $$reg2mem1371$2$phi;
      $$reg2mem1367$2 = $$reg2mem1367$2$phi;
      $$reg2mem1365$2 = $$reg2mem1365$2$phi;
      $$reg2mem1355$2 = $$reg2mem1355$2$phi;
      $$reg2mem1345$2 = $$reg2mem1345$2$phi;
      $$reg2mem1332$2 = $$reg2mem1332$2$phi;
      $$reg2mem1330$2 = $$reg2mem1330$2$phi;
      $$reg2mem1327$2 = $$reg2mem1327$2$phi;
      $$reg2mem1324$2 = $$reg2mem1324$2$phi;
      $$reg2mem1319$2 = $$reg2mem1319$2$phi;
      $$reg2mem1316$2 = $$reg2mem1316$2$phi;
      $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
      label = 7;
      continue L3;
     }
     __THREW__ = 0;
     $1125 = invoke_ii(569, $1121 | 0) | 0;
     $1126 = __THREW__;
     __THREW__ = 0;
     if (($1126 | 0) != 0 & (threwValue | 0) != 0) {
      $1127 = _testSetjmp(HEAP32[$1126 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($1127 | 0) == 0) {
       _longjmp($1126 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $1127 = -1;
     }
     $1128 = getTempRet0() | 0;
     $cond1477 = ($1127 | 0) == 1;
     if ($cond1477) {
      $$reg2mem1386$2$phi = $$reg2mem1386$2;
      $$reg2mem1383$2$phi = $$reg2mem1383$2;
      $$reg2mem1375$2$phi = $$reg2mem1375$2;
      $$reg2mem1371$2$phi = $$reg2mem1371$2;
      $$reg2mem1367$2$phi = $$reg2mem1367$2;
      $$reg2mem1365$2$phi = $$reg2mem1365$2;
      $$reg2mem1355$2$phi = $$reg2mem1355$2;
      $$reg2mem1345$2$phi = $$reg2mem1345$2;
      $$reg2mem1332$2$phi = $$reg2mem1332$2;
      $$reg2mem1330$2$phi = $$reg2mem1330$2;
      $$reg2mem1327$2$phi = $$reg2mem1327$2;
      $$reg2mem1324$2$phi = $$reg2mem1324$2;
      $$reg2mem1319$2$phi = $$reg2mem1319$2;
      $$reg2mem1316$2$phi = $$reg2mem1316$2;
      $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
      $$reg2mem1465$0 = $1128;
      $$reg2mem1386$2 = $$reg2mem1386$2$phi;
      $$reg2mem1383$2 = $$reg2mem1383$2$phi;
      $$reg2mem1375$2 = $$reg2mem1375$2$phi;
      $$reg2mem1371$2 = $$reg2mem1371$2$phi;
      $$reg2mem1367$2 = $$reg2mem1367$2$phi;
      $$reg2mem1365$2 = $$reg2mem1365$2$phi;
      $$reg2mem1355$2 = $$reg2mem1355$2$phi;
      $$reg2mem1345$2 = $$reg2mem1345$2$phi;
      $$reg2mem1332$2 = $$reg2mem1332$2$phi;
      $$reg2mem1330$2 = $$reg2mem1330$2$phi;
      $$reg2mem1327$2 = $$reg2mem1327$2$phi;
      $$reg2mem1324$2 = $$reg2mem1324$2$phi;
      $$reg2mem1319$2 = $$reg2mem1319$2$phi;
      $$reg2mem1316$2 = $$reg2mem1316$2$phi;
      $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
      label = 7;
      continue L3;
     }
     __THREW__ = 0;
     $1129 = invoke_ii(612, $1121 | 0) | 0;
     $1130 = __THREW__;
     __THREW__ = 0;
     if (($1130 | 0) != 0 & (threwValue | 0) != 0) {
      $1131 = _testSetjmp(HEAP32[$1130 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($1131 | 0) == 0) {
       _longjmp($1130 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $1131 = -1;
     }
     $1132 = getTempRet0() | 0;
     $cond1478 = ($1131 | 0) == 1;
     if ($cond1478) {
      $$reg2mem1386$2$phi = $$reg2mem1386$2;
      $$reg2mem1383$2$phi = $$reg2mem1383$2;
      $$reg2mem1375$2$phi = $$reg2mem1375$2;
      $$reg2mem1371$2$phi = $$reg2mem1371$2;
      $$reg2mem1367$2$phi = $$reg2mem1367$2;
      $$reg2mem1365$2$phi = $$reg2mem1365$2;
      $$reg2mem1355$2$phi = $$reg2mem1355$2;
      $$reg2mem1345$2$phi = $$reg2mem1345$2;
      $$reg2mem1332$2$phi = $$reg2mem1332$2;
      $$reg2mem1330$2$phi = $$reg2mem1330$2;
      $$reg2mem1327$2$phi = $$reg2mem1327$2;
      $$reg2mem1324$2$phi = $$reg2mem1324$2;
      $$reg2mem1319$2$phi = $$reg2mem1319$2;
      $$reg2mem1316$2$phi = $$reg2mem1316$2;
      $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
      $$reg2mem1465$0 = $1132;
      $$reg2mem1386$2 = $$reg2mem1386$2$phi;
      $$reg2mem1383$2 = $$reg2mem1383$2$phi;
      $$reg2mem1375$2 = $$reg2mem1375$2$phi;
      $$reg2mem1371$2 = $$reg2mem1371$2$phi;
      $$reg2mem1367$2 = $$reg2mem1367$2$phi;
      $$reg2mem1365$2 = $$reg2mem1365$2$phi;
      $$reg2mem1355$2 = $$reg2mem1355$2$phi;
      $$reg2mem1345$2 = $$reg2mem1345$2$phi;
      $$reg2mem1332$2 = $$reg2mem1332$2$phi;
      $$reg2mem1330$2 = $$reg2mem1330$2$phi;
      $$reg2mem1327$2 = $$reg2mem1327$2$phi;
      $$reg2mem1324$2 = $$reg2mem1324$2$phi;
      $$reg2mem1319$2 = $$reg2mem1319$2$phi;
      $$reg2mem1316$2 = $$reg2mem1316$2$phi;
      $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
      label = 7;
      continue L3;
     }
     __THREW__ = 0;
     $1133 = invoke_ii(569, $1129 | 0) | 0;
     $1134 = __THREW__;
     __THREW__ = 0;
     if (($1134 | 0) != 0 & (threwValue | 0) != 0) {
      $1135 = _testSetjmp(HEAP32[$1134 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($1135 | 0) == 0) {
       _longjmp($1134 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $1135 = -1;
     }
     $1136 = getTempRet0() | 0;
     $cond1479 = ($1135 | 0) == 1;
     if ($cond1479) {
      $$reg2mem1386$2$phi = $$reg2mem1386$2;
      $$reg2mem1383$2$phi = $$reg2mem1383$2;
      $$reg2mem1375$2$phi = $$reg2mem1375$2;
      $$reg2mem1371$2$phi = $$reg2mem1371$2;
      $$reg2mem1367$2$phi = $$reg2mem1367$2;
      $$reg2mem1365$2$phi = $$reg2mem1365$2;
      $$reg2mem1355$2$phi = $$reg2mem1355$2;
      $$reg2mem1345$2$phi = $$reg2mem1345$2;
      $$reg2mem1332$2$phi = $$reg2mem1332$2;
      $$reg2mem1330$2$phi = $$reg2mem1330$2;
      $$reg2mem1327$2$phi = $$reg2mem1327$2;
      $$reg2mem1324$2$phi = $$reg2mem1324$2;
      $$reg2mem1319$2$phi = $$reg2mem1319$2;
      $$reg2mem1316$2$phi = $$reg2mem1316$2;
      $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
      $$reg2mem1465$0 = $1136;
      $$reg2mem1386$2 = $$reg2mem1386$2$phi;
      $$reg2mem1383$2 = $$reg2mem1383$2$phi;
      $$reg2mem1375$2 = $$reg2mem1375$2$phi;
      $$reg2mem1371$2 = $$reg2mem1371$2$phi;
      $$reg2mem1367$2 = $$reg2mem1367$2$phi;
      $$reg2mem1365$2 = $$reg2mem1365$2$phi;
      $$reg2mem1355$2 = $$reg2mem1355$2$phi;
      $$reg2mem1345$2 = $$reg2mem1345$2$phi;
      $$reg2mem1332$2 = $$reg2mem1332$2$phi;
      $$reg2mem1330$2 = $$reg2mem1330$2$phi;
      $$reg2mem1327$2 = $$reg2mem1327$2$phi;
      $$reg2mem1324$2 = $$reg2mem1324$2$phi;
      $$reg2mem1319$2 = $$reg2mem1319$2$phi;
      $$reg2mem1316$2 = $$reg2mem1316$2$phi;
      $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
      label = 7;
      continue L3;
     }
     __THREW__ = 0;
     $1137 = invoke_ii(612, $1129 | 0) | 0;
     $1138 = __THREW__;
     __THREW__ = 0;
     if (($1138 | 0) != 0 & (threwValue | 0) != 0) {
      $1139 = _testSetjmp(HEAP32[$1138 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($1139 | 0) == 0) {
       _longjmp($1138 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $1139 = -1;
     }
     $1140 = getTempRet0() | 0;
     $cond1480 = ($1139 | 0) == 1;
     if ($cond1480) {
      $$reg2mem1386$2$phi = $$reg2mem1386$2;
      $$reg2mem1383$2$phi = $$reg2mem1383$2;
      $$reg2mem1375$2$phi = $$reg2mem1375$2;
      $$reg2mem1371$2$phi = $$reg2mem1371$2;
      $$reg2mem1367$2$phi = $$reg2mem1367$2;
      $$reg2mem1365$2$phi = $$reg2mem1365$2;
      $$reg2mem1355$2$phi = $$reg2mem1355$2;
      $$reg2mem1345$2$phi = $$reg2mem1345$2;
      $$reg2mem1332$2$phi = $$reg2mem1332$2;
      $$reg2mem1330$2$phi = $$reg2mem1330$2;
      $$reg2mem1327$2$phi = $$reg2mem1327$2;
      $$reg2mem1324$2$phi = $$reg2mem1324$2;
      $$reg2mem1319$2$phi = $$reg2mem1319$2;
      $$reg2mem1316$2$phi = $$reg2mem1316$2;
      $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
      $$reg2mem1465$0 = $1140;
      $$reg2mem1386$2 = $$reg2mem1386$2$phi;
      $$reg2mem1383$2 = $$reg2mem1383$2$phi;
      $$reg2mem1375$2 = $$reg2mem1375$2$phi;
      $$reg2mem1371$2 = $$reg2mem1371$2$phi;
      $$reg2mem1367$2 = $$reg2mem1367$2$phi;
      $$reg2mem1365$2 = $$reg2mem1365$2$phi;
      $$reg2mem1355$2 = $$reg2mem1355$2$phi;
      $$reg2mem1345$2 = $$reg2mem1345$2$phi;
      $$reg2mem1332$2 = $$reg2mem1332$2$phi;
      $$reg2mem1330$2 = $$reg2mem1330$2$phi;
      $$reg2mem1327$2 = $$reg2mem1327$2$phi;
      $$reg2mem1324$2 = $$reg2mem1324$2$phi;
      $$reg2mem1319$2 = $$reg2mem1319$2$phi;
      $$reg2mem1316$2 = $$reg2mem1316$2$phi;
      $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
      label = 7;
      continue L3;
     }
     $1141 = HEAP8[$1137 >> 0] | 0;
     $1142 = $1141 << 24 >> 24 == 0;
     L408 : do {
      if ($1142) {
       $$2866$reg2mem$0 = 1;
      } else {
       $1143 = $1141 & 255;
       $1144 = $1115;
       $1145 = $1116 - $1144 | 0;
       $1146 = $1145 - $1117 | 0;
       $$08641150$reg2mem1409$0 = 1;
       $$09031149$reg2mem1407$0 = $1146;
       $$09051148$reg2mem1405$0 = $1137;
       $$reg2mem1411$0 = $1143;
       while (1) {
        $1151 = $$reg2mem1411$0 & 128;
        $1152 = ($1151 | 0) == 0;
        if ($1152) {
         $1153 = $$reg2mem1411$0 & 31;
         $1154 = $$reg2mem1411$0 >>> 5;
         $$0857$reg2mem$0 = $1154;
         $$0858$reg2mem1403$0 = $1153;
         $$sink$reg2mem$0 = 1;
        } else {
         $1155 = $$reg2mem1411$0 & 15;
         $1156 = $$reg2mem1411$0 << 4;
         $1157 = $1156 & 1792;
         $1158 = $$09051148$reg2mem1405$0 + 1 | 0;
         $1159 = HEAP8[$1158 >> 0] | 0;
         $1160 = $1159 & 255;
         $1161 = $1157 | $1160;
         $$0857$reg2mem$0 = $1161;
         $$0858$reg2mem1403$0 = $1155;
         $$sink$reg2mem$0 = 2;
        }
        $1148 = $$09051148$reg2mem1405$0 + $$sink$reg2mem$0 | 0;
        $1162 = $$09031149$reg2mem1407$0 >>> 0 < $$0858$reg2mem1403$0 >>> 0;
        $1163 = $1162 ? 0 : $$0857$reg2mem$0;
        $$1865 = $1163 + $$08641150$reg2mem1409$0 | 0;
        if ($1162) {
         $$2866$reg2mem$0 = $$1865;
         break L408;
        }
        $$1904 = $$09031149$reg2mem1407$0 - $$0858$reg2mem1403$0 | 0;
        $1147 = HEAP8[$1148 >> 0] | 0;
        $1149 = $1147 & 255;
        $1150 = $1147 << 24 >> 24 == 0;
        if ($1150) {
         $$2866$reg2mem$0 = $$1865;
         break;
        } else {
         $$08641150$reg2mem1409$0 = $$1865;
         $$09031149$reg2mem1407$0 = $$1904;
         $$09051148$reg2mem1405$0 = $1148;
         $$reg2mem1411$0 = $1149;
        }
       }
      }
     } while (0);
     $1164 = HEAP32[$$reg2mem1332$2 >> 2] | 0;
     __THREW__ = 0;
     invoke_viiii(613, $1164 | 0, $1133 | 0, $$2866$reg2mem$0 | 0, $1125 | 0);
     $1165 = __THREW__;
     __THREW__ = 0;
     if (($1165 | 0) != 0 & (threwValue | 0) != 0) {
      $1166 = _testSetjmp(HEAP32[$1165 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($1166 | 0) == 0) {
       _longjmp($1165 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $1166 = -1;
     }
     $1167 = getTempRet0() | 0;
     $cond1481 = ($1166 | 0) == 1;
     if ($cond1481) {
      $$reg2mem1386$2$phi = $$reg2mem1386$2;
      $$reg2mem1383$2$phi = $$reg2mem1383$2;
      $$reg2mem1375$2$phi = $$reg2mem1375$2;
      $$reg2mem1371$2$phi = $$reg2mem1371$2;
      $$reg2mem1367$2$phi = $$reg2mem1367$2;
      $$reg2mem1365$2$phi = $$reg2mem1365$2;
      $$reg2mem1355$2$phi = $$reg2mem1355$2;
      $$reg2mem1345$2$phi = $$reg2mem1345$2;
      $$reg2mem1332$2$phi = $$reg2mem1332$2;
      $$reg2mem1330$2$phi = $$reg2mem1330$2;
      $$reg2mem1327$2$phi = $$reg2mem1327$2;
      $$reg2mem1324$2$phi = $$reg2mem1324$2;
      $$reg2mem1319$2$phi = $$reg2mem1319$2;
      $$reg2mem1316$2$phi = $$reg2mem1316$2;
      $$0$sroa_cast$reg2mem$2$phi = $$0$sroa_cast$reg2mem$2;
      $$reg2mem1465$0 = $1167;
      $$reg2mem1386$2 = $$reg2mem1386$2$phi;
      $$reg2mem1383$2 = $$reg2mem1383$2$phi;
      $$reg2mem1375$2 = $$reg2mem1375$2$phi;
      $$reg2mem1371$2 = $$reg2mem1371$2$phi;
      $$reg2mem1367$2 = $$reg2mem1367$2$phi;
      $$reg2mem1365$2 = $$reg2mem1365$2$phi;
      $$reg2mem1355$2 = $$reg2mem1355$2$phi;
      $$reg2mem1345$2 = $$reg2mem1345$2$phi;
      $$reg2mem1332$2 = $$reg2mem1332$2$phi;
      $$reg2mem1330$2 = $$reg2mem1330$2$phi;
      $$reg2mem1327$2 = $$reg2mem1327$2$phi;
      $$reg2mem1324$2 = $$reg2mem1324$2$phi;
      $$reg2mem1319$2 = $$reg2mem1319$2$phi;
      $$reg2mem1316$2 = $$reg2mem1316$2$phi;
      $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$2$phi;
      label = 7;
      continue L3;
     }
    }
    $$0$$0$7791157 = HEAP32[$3 >> 2] | 0;
    $1168 = $$0$$0$7791157 >>> 0 < $$reg2mem1375$2 >>> 0;
    $$0$$0$7819621158 = HEAP32[$3 >> 2] | 0;
    L420 : do {
     if ($1168) {
      $$0$$0$781963$reg2mem$0 = $$0$$0$7819621158;
     } else {
      $$pre1307 = HEAP32[$$reg2mem1355$2 >> 2] | 0;
      $$0$$0$7819621159$reg2mem$0 = $$0$$0$7819621158;
      while (1) {
       $1169 = HEAP32[$$0$$0$7819621159$reg2mem$0 >> 2] | 0;
       $1170 = $1169 >>> 0 > $$pre1307 >>> 0;
       $$0$$0$781 = HEAP32[$3 >> 2] | 0;
       if ($1170) {
        $$0$$0$781963$reg2mem$0 = $$0$$0$781;
        break L420;
       }
       $1171 = $$0$$0$781 + -12 | 0;
       HEAP32[$3 >> 2] = $1171;
       $$0$$0$779 = HEAP32[$3 >> 2] | 0;
       $1172 = $$0$$0$779 >>> 0 < $$reg2mem1375$2 >>> 0;
       $$0$$0$781962 = HEAP32[$3 >> 2] | 0;
       if ($1172) {
        $$0$$0$781963$reg2mem$0 = $$0$$0$781962;
        break;
       } else {
        $$0$$0$7819621159$reg2mem$0 = $$0$$0$781962;
       }
      }
     }
    } while (0);
    $1173 = $$0$$0$781963$reg2mem$0 >>> 0 < $$reg2mem1375$2 >>> 0;
    if ($1173) {
     label = 352;
     break L3;
    }
    $$0$$0$782 = HEAP32[$3 >> 2] | 0;
    $1175 = HEAP32[$$0$$0$782 >> 2] | 0;
    HEAP32[$$reg2mem1316$2 >> 2] = $1175;
    $$0$$0$783 = HEAP32[$3 >> 2] | 0;
    $1176 = $$0$$0$783 + 4 | 0;
    $1177 = HEAP32[$1176 >> 2] | 0;
    $1178 = $1177 & -4;
    $1179 = $1178;
    $1180 = HEAP32[$$reg2mem1319$2 >> 2] | 0;
    $$0$$0$784 = HEAP32[$3 >> 2] | 0;
    $1181 = $$0$$0$784 + 8 | 0;
    HEAP32[$1181 >> 2] = $1180;
    $1182 = $1179 + 4 | 0;
    HEAP32[$1182 >> 2] = $1180;
    HEAP32[$$reg2mem1345$2 >> 2] = $1182;
    $$0$sroa_cast$reg2mem$0 = $$0$sroa_cast$reg2mem$2;
    $$reg2mem1316$0 = $$reg2mem1316$2;
    $$reg2mem1319$0 = $$reg2mem1319$2;
    $$reg2mem1324$0 = $$reg2mem1324$2;
    $$reg2mem1327$0 = $$reg2mem1327$2;
    $$reg2mem1330$0 = $$reg2mem1330$2;
    $$reg2mem1332$0 = $$reg2mem1332$2;
    $$reg2mem1345$0 = $$reg2mem1345$2;
    $$reg2mem1355$0 = $$reg2mem1355$2;
    $$reg2mem1365$0 = $$reg2mem1365$2;
    $$reg2mem1367$0 = $$reg2mem1367$2;
    $$reg2mem1371$0 = $$reg2mem1371$2;
    $$reg2mem1375$0 = $$reg2mem1375$2;
    $$reg2mem1383$0 = $$reg2mem1383$2;
    $$reg2mem1386$0 = $$reg2mem1386$2;
    label = 3;
    continue L3;
   }
  } while (0);
  __THREW__ = 0;
  invoke_ii(496, $4 | 0) | 0;
  $25 = __THREW__;
  __THREW__ = 0;
  if (($25 | 0) != 0 & (threwValue | 0) != 0) {
   $26 = _testSetjmp(HEAP32[$25 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($26 | 0) == 0) {
    _longjmp($25 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $26 = -1;
  }
  $27 = getTempRet0() | 0;
  $cond1470 = ($26 | 0) == 1;
  if ($cond1470) {
   $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$1;
   $$reg2mem1316$2 = $$reg2mem1316$1;
   $$reg2mem1319$2 = $$reg2mem1319$1;
   $$reg2mem1324$2 = $$reg2mem1324$1;
   $$reg2mem1327$2 = $$reg2mem1327$1;
   $$reg2mem1330$2 = $$reg2mem1330$1;
   $$reg2mem1332$2 = $$reg2mem1332$1;
   $$reg2mem1345$2 = $$reg2mem1345$1;
   $$reg2mem1355$2 = $$reg2mem1355$1;
   $$reg2mem1365$2 = $$reg2mem1365$1;
   $$reg2mem1367$2 = $$reg2mem1367$1;
   $$reg2mem1371$2 = $$reg2mem1371$1;
   $$reg2mem1375$2 = $$reg2mem1375$1;
   $$reg2mem1383$2 = $$reg2mem1383$1;
   $$reg2mem1386$2 = $$reg2mem1386$1;
   $$reg2mem1465$0 = $27;
   label = 7;
   continue;
  }
  _setjmpTable = _saveSetjmp($$reg2mem1365$1, 1, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  _setjmpTableSize = getTempRet0() | 0;
  __THREW__ = 0;
  $28 = __THREW__;
  __THREW__ = 0;
  if (($28 | 0) != 0 & (threwValue | 0) != 0) {
   $29 = _testSetjmp(HEAP32[$28 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($29 | 0) == 0) {
    _longjmp($28 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $29 = -1;
  }
  $30 = getTempRet0() | 0;
  $cond1471 = ($29 | 0) == 1;
  if ($cond1471) {
   $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$1;
   $$reg2mem1316$2 = $$reg2mem1316$1;
   $$reg2mem1319$2 = $$reg2mem1319$1;
   $$reg2mem1324$2 = $$reg2mem1324$1;
   $$reg2mem1327$2 = $$reg2mem1327$1;
   $$reg2mem1330$2 = $$reg2mem1330$1;
   $$reg2mem1332$2 = $$reg2mem1332$1;
   $$reg2mem1345$2 = $$reg2mem1345$1;
   $$reg2mem1355$2 = $$reg2mem1355$1;
   $$reg2mem1365$2 = $$reg2mem1365$1;
   $$reg2mem1367$2 = $$reg2mem1367$1;
   $$reg2mem1371$2 = $$reg2mem1371$1;
   $$reg2mem1375$2 = $$reg2mem1375$1;
   $$reg2mem1383$2 = $$reg2mem1383$1;
   $$reg2mem1386$2 = $$reg2mem1386$1;
   $$reg2mem1465$0 = $30;
   label = 7;
   continue;
  }
  $$0$sroa_cast$reg2mem$2 = $$0$sroa_cast$reg2mem$1;
  $$reg2mem1316$2 = $$reg2mem1316$1;
  $$reg2mem1319$2 = $$reg2mem1319$1;
  $$reg2mem1324$2 = $$reg2mem1324$1;
  $$reg2mem1327$2 = $$reg2mem1327$1;
  $$reg2mem1330$2 = $$reg2mem1330$1;
  $$reg2mem1332$2 = $$reg2mem1332$1;
  $$reg2mem1345$2 = $$reg2mem1345$1;
  $$reg2mem1355$2 = $$reg2mem1355$1;
  $$reg2mem1365$2 = $$reg2mem1365$1;
  $$reg2mem1367$2 = $$reg2mem1367$1;
  $$reg2mem1371$2 = $$reg2mem1371$1;
  $$reg2mem1375$2 = $$reg2mem1375$1;
  $$reg2mem1383$2 = $$reg2mem1383$1;
  $$reg2mem1386$2 = $$reg2mem1386$1;
  $$reg2mem1465$0 = 0;
  label = 7;
 }
 if ((label | 0) == 242) {
  $$4$ph$reg2mem$0 = 0;
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$4$ph$reg2mem$0 | 0;
 } else if ((label | 0) == 259) {
  HEAP32[$$reg2mem1355$2 >> 2] = $$40$reg2mem1427$0;
  HEAP32[$$reg2mem1345$2 >> 2] = $$12879$reg2mem1429$0;
  $$0$$0$778 = HEAP32[$3 >> 2] | 0;
  HEAP32[$$reg2mem1371$2 >> 2] = $$0$$0$778;
  $$4$ph$reg2mem$0 = 1;
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$4$ph$reg2mem$0 | 0;
 } else if ((label | 0) == 308) {
  HEAP32[$$reg2mem1383$2 >> 2] = $1048;
  $$4$ph$reg2mem$0 = 2;
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$4$ph$reg2mem$0 | 0;
 } else if ((label | 0) == 352) {
  $1174 = HEAP32[$$reg2mem1319$2 >> 2] | 0;
  HEAP32[$$reg2mem1383$2 >> 2] = $1174;
  $$4$ph$reg2mem$0 = 2;
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$4$ph$reg2mem$0 | 0;
 } else if ((label | 0) == 354) {
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$4$ph$reg2mem$0 | 0;
 }
 return 0 | 0;
}

function _malloc($0) {
 $0 = $0 | 0;
 var $$0 = 0, $$0$i = 0, $$0$i$i = 0, $$0$i$i$i = 0, $$0$i20$i = 0, $$0169$i = 0, $$0170$i = 0, $$0171$i = 0, $$0192 = 0, $$0194 = 0, $$02014$i$i = 0, $$0202$lcssa$i$i = 0, $$02023$i$i = 0, $$0206$i$i = 0, $$0207$i$i = 0, $$024372$i = 0, $$0259$i$i = 0, $$02604$i$i = 0, $$0261$lcssa$i$i = 0, $$02613$i$i = 0, $$0267$i$i = 0, $$0268$i$i = 0, $$0318$i = 0, $$032012$i = 0, $$0321$lcssa$i = 0, $$032111$i = 0, $$0323$i = 0, $$0329$i = 0, $$0335$i = 0, $$0336$i = 0, $$0338$i = 0, $$0339$i = 0, $$0344$i = 0, $$1174$i = 0, $$1174$i$be = 0, $$1174$i$ph = 0, $$1176$i = 0, $$1176$i$be = 0, $$1176$i$ph = 0, $$124471$i = 0, $$1263$i$i = 0, $$1263$i$i$be = 0, $$1263$i$i$ph = 0, $$1265$i$i = 0, $$1265$i$i$be = 0, $$1265$i$i$ph = 0, $$1319$i = 0, $$1324$i = 0, $$1340$i = 0, $$1346$i = 0, $$1346$i$be = 0, $$1346$i$ph = 0, $$1350$i = 0, $$1350$i$be = 0, $$1350$i$ph = 0, $$2234243136$i = 0, $$2247$ph$i = 0, $$2253$ph$i = 0, $$2331$i = 0, $$3$i = 0, $$3$i$i = 0, $$3$i198 = 0, $$3$i198211 = 0, $$3326$i = 0, $$3348$i = 0, $$4$lcssa$i = 0, $$415$i = 0, $$415$i$ph = 0, $$4236$i = 0, $$4327$lcssa$i = 0, $$432714$i = 0, $$432714$i$ph = 0, $$4333$i = 0, $$533413$i = 0, $$533413$i$ph = 0, $$723947$i = 0, $$748$i = 0, $$pre = 0, $$pre$i = 0, $$pre$i$i = 0, $$pre$i16$i = 0, $$pre$i195 = 0, $$pre$i204 = 0, $$pre$phi$i$iZ2D = 0, $$pre$phi$i17$iZ2D = 0, $$pre$phi$i205Z2D = 0, $$pre$phi$iZ2D = 0, $$pre$phiZ2D = 0, $$sink = 0, $$sink320 = 0, $$sink321 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0, $435 = 0, $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0, $472 = 0, $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0, $49 = 0, $490 = 0, $491 = 0, $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0, $503 = 0, $504 = 0, $505 = 0, $506 = 0, $507 = 0, $508 = 0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0, $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0, $539 = 0, $54 = 0, $540 = 0, $541 = 0, $542 = 0, $543 = 0, $544 = 0, $545 = 0, $546 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0, $559 = 0, $56 = 0, $560 = 0, $561 = 0, $562 = 0, $563 = 0, $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0, $569 = 0, $57 = 0, $570 = 0, $571 = 0, $572 = 0, $573 = 0, $574 = 0, $575 = 0, $576 = 0, $577 = 0, $578 = 0, $579 = 0, $58 = 0, $580 = 0, $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0, $593 = 0, $594 = 0, $595 = 0, $596 = 0, $597 = 0, $598 = 0, $599 = 0, $6 = 0, $60 = 0, $600 = 0, $601 = 0, $602 = 0, $603 = 0, $604 = 0, $605 = 0, $606 = 0, $607 = 0, $608 = 0, $609 = 0, $61 = 0, $610 = 0, $611 = 0, $612 = 0, $613 = 0, $614 = 0, $615 = 0, $616 = 0, $617 = 0, $618 = 0, $619 = 0, $62 = 0, $620 = 0, $621 = 0, $622 = 0, $623 = 0, $624 = 0, $625 = 0, $626 = 0, $627 = 0, $628 = 0, $629 = 0, $63 = 0, $630 = 0, $631 = 0, $632 = 0, $633 = 0, $634 = 0, $635 = 0, $636 = 0, $637 = 0, $638 = 0, $639 = 0, $64 = 0, $640 = 0, $641 = 0, $642 = 0, $643 = 0, $644 = 0, $645 = 0, $646 = 0, $647 = 0, $648 = 0, $649 = 0, $65 = 0, $650 = 0, $651 = 0, $652 = 0, $653 = 0, $654 = 0, $655 = 0, $656 = 0, $657 = 0, $658 = 0, $659 = 0, $66 = 0, $660 = 0, $661 = 0, $662 = 0, $663 = 0, $664 = 0, $665 = 0, $666 = 0, $667 = 0, $668 = 0, $669 = 0, $67 = 0, $670 = 0, $671 = 0, $672 = 0, $673 = 0, $674 = 0, $675 = 0, $676 = 0, $677 = 0, $678 = 0, $679 = 0, $68 = 0, $680 = 0, $681 = 0, $682 = 0, $683 = 0, $684 = 0, $685 = 0, $686 = 0, $687 = 0, $688 = 0, $689 = 0, $69 = 0, $690 = 0, $691 = 0, $692 = 0, $693 = 0, $694 = 0, $695 = 0, $696 = 0, $697 = 0, $698 = 0, $699 = 0, $7 = 0, $70 = 0, $700 = 0, $701 = 0, $702 = 0, $703 = 0, $704 = 0, $705 = 0, $706 = 0, $707 = 0, $708 = 0, $709 = 0, $71 = 0, $710 = 0, $711 = 0, $712 = 0, $713 = 0, $714 = 0, $715 = 0, $716 = 0, $717 = 0, $718 = 0, $719 = 0, $72 = 0, $720 = 0, $721 = 0, $722 = 0, $723 = 0, $724 = 0, $725 = 0, $726 = 0, $727 = 0, $728 = 0, $729 = 0, $73 = 0, $730 = 0, $731 = 0, $732 = 0, $733 = 0, $734 = 0, $735 = 0, $736 = 0, $737 = 0, $738 = 0, $739 = 0, $74 = 0, $740 = 0, $741 = 0, $742 = 0, $743 = 0, $744 = 0, $745 = 0, $746 = 0, $747 = 0, $748 = 0, $749 = 0, $75 = 0, $750 = 0, $751 = 0, $752 = 0, $753 = 0, $754 = 0, $755 = 0, $756 = 0, $757 = 0, $758 = 0, $759 = 0, $76 = 0, $760 = 0, $761 = 0, $762 = 0, $763 = 0, $764 = 0, $765 = 0, $766 = 0, $767 = 0, $768 = 0, $769 = 0, $77 = 0, $770 = 0, $771 = 0, $772 = 0, $773 = 0, $774 = 0, $775 = 0, $776 = 0, $777 = 0, $778 = 0, $779 = 0, $78 = 0, $780 = 0, $781 = 0, $782 = 0, $783 = 0, $784 = 0, $785 = 0, $786 = 0, $787 = 0, $788 = 0, $789 = 0, $79 = 0, $790 = 0, $791 = 0, $792 = 0, $793 = 0, $794 = 0, $795 = 0, $796 = 0, $797 = 0, $798 = 0, $799 = 0, $8 = 0, $80 = 0, $800 = 0, $801 = 0, $802 = 0, $803 = 0, $804 = 0, $805 = 0, $806 = 0, $807 = 0, $808 = 0, $809 = 0, $81 = 0, $810 = 0, $811 = 0, $812 = 0, $813 = 0, $814 = 0, $815 = 0, $816 = 0, $817 = 0, $818 = 0, $819 = 0, $82 = 0, $820 = 0, $821 = 0, $822 = 0, $823 = 0, $824 = 0, $825 = 0, $826 = 0, $827 = 0, $828 = 0, $829 = 0, $83 = 0, $830 = 0, $831 = 0, $832 = 0, $833 = 0, $834 = 0, $835 = 0, $836 = 0, $837 = 0, $838 = 0, $839 = 0, $84 = 0, $840 = 0, $841 = 0, $842 = 0, $843 = 0, $844 = 0, $845 = 0, $846 = 0, $847 = 0, $848 = 0, $849 = 0, $85 = 0, $850 = 0, $851 = 0, $852 = 0, $853 = 0, $854 = 0, $855 = 0, $856 = 0, $857 = 0, $858 = 0, $859 = 0, $86 = 0, $860 = 0, $861 = 0, $862 = 0, $863 = 0, $864 = 0, $865 = 0, $866 = 0, $867 = 0, $868 = 0, $869 = 0, $87 = 0, $870 = 0, $871 = 0, $872 = 0, $873 = 0, $874 = 0, $875 = 0, $876 = 0, $877 = 0, $878 = 0, $879 = 0, $88 = 0, $880 = 0, $881 = 0, $882 = 0, $883 = 0, $884 = 0, $885 = 0, $886 = 0, $887 = 0, $888 = 0, $889 = 0, $89 = 0, $890 = 0, $891 = 0, $892 = 0, $893 = 0, $894 = 0, $895 = 0, $896 = 0, $897 = 0, $898 = 0, $899 = 0, $9 = 0, $90 = 0, $900 = 0, $901 = 0, $902 = 0, $903 = 0, $904 = 0, $905 = 0, $906 = 0, $907 = 0, $908 = 0, $909 = 0, $91 = 0, $910 = 0, $911 = 0, $912 = 0, $913 = 0, $914 = 0, $915 = 0, $916 = 0, $917 = 0, $918 = 0, $919 = 0, $92 = 0, $920 = 0, $921 = 0, $922 = 0, $923 = 0, $924 = 0, $925 = 0, $926 = 0, $927 = 0, $928 = 0, $929 = 0, $93 = 0, $930 = 0, $931 = 0, $932 = 0, $933 = 0, $934 = 0, $935 = 0, $936 = 0, $937 = 0, $938 = 0, $939 = 0, $94 = 0, $940 = 0, $941 = 0, $942 = 0, $943 = 0, $944 = 0, $945 = 0, $946 = 0, $947 = 0, $948 = 0, $949 = 0, $95 = 0, $950 = 0, $951 = 0, $952 = 0, $953 = 0, $954 = 0, $955 = 0, $956 = 0, $957 = 0, $958 = 0, $959 = 0, $96 = 0, $960 = 0, $961 = 0, $962 = 0, $963 = 0, $964 = 0, $965 = 0, $966 = 0, $967 = 0, $968 = 0, $969 = 0, $97 = 0, $970 = 0, $971 = 0, $972 = 0, $973 = 0, $974 = 0, $975 = 0, $976 = 0, $977 = 0, $978 = 0, $979 = 0, $98 = 0, $99 = 0, $cond$i = 0, $cond$i$i = 0, $cond$i203 = 0, $not$$i = 0, $or$cond$i = 0, $or$cond$i199 = 0, $or$cond1$i = 0, $or$cond1$i197 = 0, $or$cond11$i = 0, $or$cond2$i = 0, $or$cond5$i = 0, $or$cond50$i = 0, $or$cond51$i = 0, $or$cond6$i = 0, $or$cond7$i = 0, $or$cond8$i = 0, $or$cond8$not$i = 0, $spec$select$i = 0, $spec$select$i201 = 0, $spec$select1$i = 0, $spec$select2$i = 0, $spec$select4$i = 0, $spec$select49$i = 0, $spec$select9$i = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = sp;
 $2 = $0 >>> 0 < 245;
 do {
  if ($2) {
   $3 = $0 >>> 0 < 11;
   $4 = $0 + 11 | 0;
   $5 = $4 & -8;
   $6 = $3 ? 16 : $5;
   $7 = $6 >>> 3;
   $8 = HEAP32[10260] | 0;
   $9 = $8 >>> $7;
   $10 = $9 & 3;
   $11 = ($10 | 0) == 0;
   if (!$11) {
    $12 = $9 & 1;
    $13 = $12 ^ 1;
    $14 = $13 + $7 | 0;
    $15 = $14 << 1;
    $16 = 41080 + ($15 << 2) | 0;
    $17 = $16 + 8 | 0;
    $18 = HEAP32[$17 >> 2] | 0;
    $19 = $18 + 8 | 0;
    $20 = HEAP32[$19 >> 2] | 0;
    $21 = ($20 | 0) == ($16 | 0);
    if ($21) {
     $22 = 1 << $14;
     $23 = $22 ^ -1;
     $24 = $8 & $23;
     HEAP32[10260] = $24;
    } else {
     $25 = $20 + 12 | 0;
     HEAP32[$25 >> 2] = $16;
     HEAP32[$17 >> 2] = $20;
    }
    $26 = $14 << 3;
    $27 = $26 | 3;
    $28 = $18 + 4 | 0;
    HEAP32[$28 >> 2] = $27;
    $29 = $18 + $26 | 0;
    $30 = $29 + 4 | 0;
    $31 = HEAP32[$30 >> 2] | 0;
    $32 = $31 | 1;
    HEAP32[$30 >> 2] = $32;
    $$0 = $19;
    STACKTOP = sp;
    return $$0 | 0;
   }
   $33 = HEAP32[41048 >> 2] | 0;
   $34 = $6 >>> 0 > $33 >>> 0;
   if ($34) {
    $35 = ($9 | 0) == 0;
    if (!$35) {
     $36 = $9 << $7;
     $37 = 2 << $7;
     $38 = 0 - $37 | 0;
     $39 = $37 | $38;
     $40 = $36 & $39;
     $41 = 0 - $40 | 0;
     $42 = $40 & $41;
     $43 = $42 + -1 | 0;
     $44 = $43 >>> 12;
     $45 = $44 & 16;
     $46 = $43 >>> $45;
     $47 = $46 >>> 5;
     $48 = $47 & 8;
     $49 = $48 | $45;
     $50 = $46 >>> $48;
     $51 = $50 >>> 2;
     $52 = $51 & 4;
     $53 = $49 | $52;
     $54 = $50 >>> $52;
     $55 = $54 >>> 1;
     $56 = $55 & 2;
     $57 = $53 | $56;
     $58 = $54 >>> $56;
     $59 = $58 >>> 1;
     $60 = $59 & 1;
     $61 = $57 | $60;
     $62 = $58 >>> $60;
     $63 = $61 + $62 | 0;
     $64 = $63 << 1;
     $65 = 41080 + ($64 << 2) | 0;
     $66 = $65 + 8 | 0;
     $67 = HEAP32[$66 >> 2] | 0;
     $68 = $67 + 8 | 0;
     $69 = HEAP32[$68 >> 2] | 0;
     $70 = ($69 | 0) == ($65 | 0);
     if ($70) {
      $71 = 1 << $63;
      $72 = $71 ^ -1;
      $73 = $8 & $72;
      HEAP32[10260] = $73;
      $90 = $73;
     } else {
      $74 = $69 + 12 | 0;
      HEAP32[$74 >> 2] = $65;
      HEAP32[$66 >> 2] = $69;
      $90 = $8;
     }
     $75 = $63 << 3;
     $76 = $75 - $6 | 0;
     $77 = $6 | 3;
     $78 = $67 + 4 | 0;
     HEAP32[$78 >> 2] = $77;
     $79 = $67 + $6 | 0;
     $80 = $76 | 1;
     $81 = $79 + 4 | 0;
     HEAP32[$81 >> 2] = $80;
     $82 = $67 + $75 | 0;
     HEAP32[$82 >> 2] = $76;
     $83 = ($33 | 0) == 0;
     if (!$83) {
      $84 = HEAP32[41060 >> 2] | 0;
      $85 = $33 >>> 3;
      $86 = $85 << 1;
      $87 = 41080 + ($86 << 2) | 0;
      $88 = 1 << $85;
      $89 = $90 & $88;
      $91 = ($89 | 0) == 0;
      if ($91) {
       $92 = $90 | $88;
       HEAP32[10260] = $92;
       $$pre = $87 + 8 | 0;
       $$0194 = $87;
       $$pre$phiZ2D = $$pre;
      } else {
       $93 = $87 + 8 | 0;
       $94 = HEAP32[$93 >> 2] | 0;
       $$0194 = $94;
       $$pre$phiZ2D = $93;
      }
      HEAP32[$$pre$phiZ2D >> 2] = $84;
      $95 = $$0194 + 12 | 0;
      HEAP32[$95 >> 2] = $84;
      $96 = $84 + 8 | 0;
      HEAP32[$96 >> 2] = $$0194;
      $97 = $84 + 12 | 0;
      HEAP32[$97 >> 2] = $87;
     }
     HEAP32[41048 >> 2] = $76;
     HEAP32[41060 >> 2] = $79;
     $$0 = $68;
     STACKTOP = sp;
     return $$0 | 0;
    }
    $98 = HEAP32[41044 >> 2] | 0;
    $99 = ($98 | 0) == 0;
    if ($99) {
     $$0192 = $6;
    } else {
     $100 = 0 - $98 | 0;
     $101 = $98 & $100;
     $102 = $101 + -1 | 0;
     $103 = $102 >>> 12;
     $104 = $103 & 16;
     $105 = $102 >>> $104;
     $106 = $105 >>> 5;
     $107 = $106 & 8;
     $108 = $107 | $104;
     $109 = $105 >>> $107;
     $110 = $109 >>> 2;
     $111 = $110 & 4;
     $112 = $108 | $111;
     $113 = $109 >>> $111;
     $114 = $113 >>> 1;
     $115 = $114 & 2;
     $116 = $112 | $115;
     $117 = $113 >>> $115;
     $118 = $117 >>> 1;
     $119 = $118 & 1;
     $120 = $116 | $119;
     $121 = $117 >>> $119;
     $122 = $120 + $121 | 0;
     $123 = 41344 + ($122 << 2) | 0;
     $124 = HEAP32[$123 >> 2] | 0;
     $125 = $124 + 4 | 0;
     $126 = HEAP32[$125 >> 2] | 0;
     $127 = $126 & -8;
     $128 = $127 - $6 | 0;
     $$0169$i = $124;
     $$0170$i = $124;
     $$0171$i = $128;
     while (1) {
      $129 = $$0169$i + 16 | 0;
      $130 = HEAP32[$129 >> 2] | 0;
      $131 = ($130 | 0) == (0 | 0);
      if ($131) {
       $132 = $$0169$i + 20 | 0;
       $133 = HEAP32[$132 >> 2] | 0;
       $134 = ($133 | 0) == (0 | 0);
       if ($134) {
        break;
       } else {
        $136 = $133;
       }
      } else {
       $136 = $130;
      }
      $135 = $136 + 4 | 0;
      $137 = HEAP32[$135 >> 2] | 0;
      $138 = $137 & -8;
      $139 = $138 - $6 | 0;
      $140 = $139 >>> 0 < $$0171$i >>> 0;
      $spec$select$i = $140 ? $139 : $$0171$i;
      $spec$select1$i = $140 ? $136 : $$0170$i;
      $$0169$i = $136;
      $$0170$i = $spec$select1$i;
      $$0171$i = $spec$select$i;
     }
     $141 = $$0170$i + $6 | 0;
     $142 = $141 >>> 0 > $$0170$i >>> 0;
     if ($142) {
      $143 = $$0170$i + 24 | 0;
      $144 = HEAP32[$143 >> 2] | 0;
      $145 = $$0170$i + 12 | 0;
      $146 = HEAP32[$145 >> 2] | 0;
      $147 = ($146 | 0) == ($$0170$i | 0);
      do {
       if ($147) {
        $152 = $$0170$i + 20 | 0;
        $153 = HEAP32[$152 >> 2] | 0;
        $154 = ($153 | 0) == (0 | 0);
        if ($154) {
         $155 = $$0170$i + 16 | 0;
         $156 = HEAP32[$155 >> 2] | 0;
         $157 = ($156 | 0) == (0 | 0);
         if ($157) {
          $$3$i = 0;
          break;
         } else {
          $$1174$i$ph = $156;
          $$1176$i$ph = $155;
         }
        } else {
         $$1174$i$ph = $153;
         $$1176$i$ph = $152;
        }
        $$1174$i = $$1174$i$ph;
        $$1176$i = $$1176$i$ph;
        while (1) {
         $158 = $$1174$i + 20 | 0;
         $159 = HEAP32[$158 >> 2] | 0;
         $160 = ($159 | 0) == (0 | 0);
         if ($160) {
          $161 = $$1174$i + 16 | 0;
          $162 = HEAP32[$161 >> 2] | 0;
          $163 = ($162 | 0) == (0 | 0);
          if ($163) {
           break;
          } else {
           $$1174$i$be = $162;
           $$1176$i$be = $161;
          }
         } else {
          $$1174$i$be = $159;
          $$1176$i$be = $158;
         }
         $$1174$i = $$1174$i$be;
         $$1176$i = $$1176$i$be;
        }
        HEAP32[$$1176$i >> 2] = 0;
        $$3$i = $$1174$i;
       } else {
        $148 = $$0170$i + 8 | 0;
        $149 = HEAP32[$148 >> 2] | 0;
        $150 = $149 + 12 | 0;
        HEAP32[$150 >> 2] = $146;
        $151 = $146 + 8 | 0;
        HEAP32[$151 >> 2] = $149;
        $$3$i = $146;
       }
      } while (0);
      $164 = ($144 | 0) == (0 | 0);
      do {
       if (!$164) {
        $165 = $$0170$i + 28 | 0;
        $166 = HEAP32[$165 >> 2] | 0;
        $167 = 41344 + ($166 << 2) | 0;
        $168 = HEAP32[$167 >> 2] | 0;
        $169 = ($$0170$i | 0) == ($168 | 0);
        if ($169) {
         HEAP32[$167 >> 2] = $$3$i;
         $cond$i = ($$3$i | 0) == (0 | 0);
         if ($cond$i) {
          $170 = 1 << $166;
          $171 = $170 ^ -1;
          $172 = $98 & $171;
          HEAP32[41044 >> 2] = $172;
          break;
         }
        } else {
         $173 = $144 + 16 | 0;
         $174 = HEAP32[$173 >> 2] | 0;
         $175 = ($174 | 0) == ($$0170$i | 0);
         $176 = $144 + 20 | 0;
         $$sink = $175 ? $173 : $176;
         HEAP32[$$sink >> 2] = $$3$i;
         $177 = ($$3$i | 0) == (0 | 0);
         if ($177) {
          break;
         }
        }
        $178 = $$3$i + 24 | 0;
        HEAP32[$178 >> 2] = $144;
        $179 = $$0170$i + 16 | 0;
        $180 = HEAP32[$179 >> 2] | 0;
        $181 = ($180 | 0) == (0 | 0);
        if (!$181) {
         $182 = $$3$i + 16 | 0;
         HEAP32[$182 >> 2] = $180;
         $183 = $180 + 24 | 0;
         HEAP32[$183 >> 2] = $$3$i;
        }
        $184 = $$0170$i + 20 | 0;
        $185 = HEAP32[$184 >> 2] | 0;
        $186 = ($185 | 0) == (0 | 0);
        if (!$186) {
         $187 = $$3$i + 20 | 0;
         HEAP32[$187 >> 2] = $185;
         $188 = $185 + 24 | 0;
         HEAP32[$188 >> 2] = $$3$i;
        }
       }
      } while (0);
      $189 = $$0171$i >>> 0 < 16;
      if ($189) {
       $190 = $$0171$i + $6 | 0;
       $191 = $190 | 3;
       $192 = $$0170$i + 4 | 0;
       HEAP32[$192 >> 2] = $191;
       $193 = $$0170$i + $190 | 0;
       $194 = $193 + 4 | 0;
       $195 = HEAP32[$194 >> 2] | 0;
       $196 = $195 | 1;
       HEAP32[$194 >> 2] = $196;
      } else {
       $197 = $6 | 3;
       $198 = $$0170$i + 4 | 0;
       HEAP32[$198 >> 2] = $197;
       $199 = $$0171$i | 1;
       $200 = $141 + 4 | 0;
       HEAP32[$200 >> 2] = $199;
       $201 = $141 + $$0171$i | 0;
       HEAP32[$201 >> 2] = $$0171$i;
       $202 = ($33 | 0) == 0;
       if (!$202) {
        $203 = HEAP32[41060 >> 2] | 0;
        $204 = $33 >>> 3;
        $205 = $204 << 1;
        $206 = 41080 + ($205 << 2) | 0;
        $207 = 1 << $204;
        $208 = $207 & $8;
        $209 = ($208 | 0) == 0;
        if ($209) {
         $210 = $207 | $8;
         HEAP32[10260] = $210;
         $$pre$i = $206 + 8 | 0;
         $$0$i = $206;
         $$pre$phi$iZ2D = $$pre$i;
        } else {
         $211 = $206 + 8 | 0;
         $212 = HEAP32[$211 >> 2] | 0;
         $$0$i = $212;
         $$pre$phi$iZ2D = $211;
        }
        HEAP32[$$pre$phi$iZ2D >> 2] = $203;
        $213 = $$0$i + 12 | 0;
        HEAP32[$213 >> 2] = $203;
        $214 = $203 + 8 | 0;
        HEAP32[$214 >> 2] = $$0$i;
        $215 = $203 + 12 | 0;
        HEAP32[$215 >> 2] = $206;
       }
       HEAP32[41048 >> 2] = $$0171$i;
       HEAP32[41060 >> 2] = $141;
      }
      $216 = $$0170$i + 8 | 0;
      $$0 = $216;
      STACKTOP = sp;
      return $$0 | 0;
     } else {
      $$0192 = $6;
     }
    }
   } else {
    $$0192 = $6;
   }
  } else {
   $217 = $0 >>> 0 > 4294967231;
   if ($217) {
    $$0192 = -1;
   } else {
    $218 = $0 + 11 | 0;
    $219 = $218 & -8;
    $220 = HEAP32[41044 >> 2] | 0;
    $221 = ($220 | 0) == 0;
    if ($221) {
     $$0192 = $219;
    } else {
     $222 = 0 - $219 | 0;
     $223 = $218 >>> 8;
     $224 = ($223 | 0) == 0;
     if ($224) {
      $$0335$i = 0;
     } else {
      $225 = $219 >>> 0 > 16777215;
      if ($225) {
       $$0335$i = 31;
      } else {
       $226 = $223 + 1048320 | 0;
       $227 = $226 >>> 16;
       $228 = $227 & 8;
       $229 = $223 << $228;
       $230 = $229 + 520192 | 0;
       $231 = $230 >>> 16;
       $232 = $231 & 4;
       $233 = $232 | $228;
       $234 = $229 << $232;
       $235 = $234 + 245760 | 0;
       $236 = $235 >>> 16;
       $237 = $236 & 2;
       $238 = $233 | $237;
       $239 = 14 - $238 | 0;
       $240 = $234 << $237;
       $241 = $240 >>> 15;
       $242 = $239 + $241 | 0;
       $243 = $242 << 1;
       $244 = $242 + 7 | 0;
       $245 = $219 >>> $244;
       $246 = $245 & 1;
       $247 = $246 | $243;
       $$0335$i = $247;
      }
     }
     $248 = 41344 + ($$0335$i << 2) | 0;
     $249 = HEAP32[$248 >> 2] | 0;
     $250 = ($249 | 0) == (0 | 0);
     L79 : do {
      if ($250) {
       $$2331$i = 0;
       $$3$i198 = 0;
       $$3326$i = $222;
       label = 61;
      } else {
       $251 = ($$0335$i | 0) == 31;
       $252 = $$0335$i >>> 1;
       $253 = 25 - $252 | 0;
       $254 = $251 ? 0 : $253;
       $255 = $219 << $254;
       $$0318$i = 0;
       $$0323$i = $222;
       $$0329$i = $249;
       $$0336$i = $255;
       $$0339$i = 0;
       while (1) {
        $256 = $$0329$i + 4 | 0;
        $257 = HEAP32[$256 >> 2] | 0;
        $258 = $257 & -8;
        $259 = $258 - $219 | 0;
        $260 = $259 >>> 0 < $$0323$i >>> 0;
        if ($260) {
         $261 = ($259 | 0) == 0;
         if ($261) {
          $$415$i$ph = $$0329$i;
          $$432714$i$ph = 0;
          $$533413$i$ph = $$0329$i;
          label = 65;
          break L79;
         } else {
          $$1319$i = $$0329$i;
          $$1324$i = $259;
         }
        } else {
         $$1319$i = $$0318$i;
         $$1324$i = $$0323$i;
        }
        $262 = $$0329$i + 20 | 0;
        $263 = HEAP32[$262 >> 2] | 0;
        $264 = $$0336$i >>> 31;
        $265 = ($$0329$i + 16 | 0) + ($264 << 2) | 0;
        $266 = HEAP32[$265 >> 2] | 0;
        $267 = ($263 | 0) == (0 | 0);
        $268 = ($263 | 0) == ($266 | 0);
        $or$cond1$i197 = $267 | $268;
        $$1340$i = $or$cond1$i197 ? $$0339$i : $263;
        $269 = ($266 | 0) == (0 | 0);
        $spec$select4$i = $$0336$i << 1;
        if ($269) {
         $$2331$i = $$1340$i;
         $$3$i198 = $$1319$i;
         $$3326$i = $$1324$i;
         label = 61;
         break;
        } else {
         $$0318$i = $$1319$i;
         $$0323$i = $$1324$i;
         $$0329$i = $266;
         $$0336$i = $spec$select4$i;
         $$0339$i = $$1340$i;
        }
       }
      }
     } while (0);
     if ((label | 0) == 61) {
      $270 = ($$2331$i | 0) == (0 | 0);
      $271 = ($$3$i198 | 0) == (0 | 0);
      $or$cond$i199 = $270 & $271;
      if ($or$cond$i199) {
       $272 = 2 << $$0335$i;
       $273 = 0 - $272 | 0;
       $274 = $272 | $273;
       $275 = $274 & $220;
       $276 = ($275 | 0) == 0;
       if ($276) {
        $$0192 = $219;
        break;
       }
       $277 = 0 - $275 | 0;
       $278 = $275 & $277;
       $279 = $278 + -1 | 0;
       $280 = $279 >>> 12;
       $281 = $280 & 16;
       $282 = $279 >>> $281;
       $283 = $282 >>> 5;
       $284 = $283 & 8;
       $285 = $284 | $281;
       $286 = $282 >>> $284;
       $287 = $286 >>> 2;
       $288 = $287 & 4;
       $289 = $285 | $288;
       $290 = $286 >>> $288;
       $291 = $290 >>> 1;
       $292 = $291 & 2;
       $293 = $289 | $292;
       $294 = $290 >>> $292;
       $295 = $294 >>> 1;
       $296 = $295 & 1;
       $297 = $293 | $296;
       $298 = $294 >>> $296;
       $299 = $297 + $298 | 0;
       $300 = 41344 + ($299 << 2) | 0;
       $301 = HEAP32[$300 >> 2] | 0;
       $$3$i198211 = 0;
       $$4333$i = $301;
      } else {
       $$3$i198211 = $$3$i198;
       $$4333$i = $$2331$i;
      }
      $302 = ($$4333$i | 0) == (0 | 0);
      if ($302) {
       $$4$lcssa$i = $$3$i198211;
       $$4327$lcssa$i = $$3326$i;
      } else {
       $$415$i$ph = $$3$i198211;
       $$432714$i$ph = $$3326$i;
       $$533413$i$ph = $$4333$i;
       label = 65;
      }
     }
     if ((label | 0) == 65) {
      $$415$i = $$415$i$ph;
      $$432714$i = $$432714$i$ph;
      $$533413$i = $$533413$i$ph;
      while (1) {
       $303 = $$533413$i + 4 | 0;
       $304 = HEAP32[$303 >> 2] | 0;
       $305 = $304 & -8;
       $306 = $305 - $219 | 0;
       $307 = $306 >>> 0 < $$432714$i >>> 0;
       $spec$select$i201 = $307 ? $306 : $$432714$i;
       $spec$select2$i = $307 ? $$533413$i : $$415$i;
       $308 = $$533413$i + 16 | 0;
       $309 = HEAP32[$308 >> 2] | 0;
       $310 = ($309 | 0) == (0 | 0);
       if ($310) {
        $311 = $$533413$i + 20 | 0;
        $312 = HEAP32[$311 >> 2] | 0;
        $313 = $312;
       } else {
        $313 = $309;
       }
       $314 = ($313 | 0) == (0 | 0);
       if ($314) {
        $$4$lcssa$i = $spec$select2$i;
        $$4327$lcssa$i = $spec$select$i201;
        break;
       } else {
        $$415$i = $spec$select2$i;
        $$432714$i = $spec$select$i201;
        $$533413$i = $313;
       }
      }
     }
     $315 = ($$4$lcssa$i | 0) == (0 | 0);
     if ($315) {
      $$0192 = $219;
     } else {
      $316 = HEAP32[41048 >> 2] | 0;
      $317 = $316 - $219 | 0;
      $318 = $$4327$lcssa$i >>> 0 < $317 >>> 0;
      if ($318) {
       $319 = $$4$lcssa$i + $219 | 0;
       $320 = $319 >>> 0 > $$4$lcssa$i >>> 0;
       if ($320) {
        $321 = $$4$lcssa$i + 24 | 0;
        $322 = HEAP32[$321 >> 2] | 0;
        $323 = $$4$lcssa$i + 12 | 0;
        $324 = HEAP32[$323 >> 2] | 0;
        $325 = ($324 | 0) == ($$4$lcssa$i | 0);
        do {
         if ($325) {
          $330 = $$4$lcssa$i + 20 | 0;
          $331 = HEAP32[$330 >> 2] | 0;
          $332 = ($331 | 0) == (0 | 0);
          if ($332) {
           $333 = $$4$lcssa$i + 16 | 0;
           $334 = HEAP32[$333 >> 2] | 0;
           $335 = ($334 | 0) == (0 | 0);
           if ($335) {
            $$3348$i = 0;
            break;
           } else {
            $$1346$i$ph = $334;
            $$1350$i$ph = $333;
           }
          } else {
           $$1346$i$ph = $331;
           $$1350$i$ph = $330;
          }
          $$1346$i = $$1346$i$ph;
          $$1350$i = $$1350$i$ph;
          while (1) {
           $336 = $$1346$i + 20 | 0;
           $337 = HEAP32[$336 >> 2] | 0;
           $338 = ($337 | 0) == (0 | 0);
           if ($338) {
            $339 = $$1346$i + 16 | 0;
            $340 = HEAP32[$339 >> 2] | 0;
            $341 = ($340 | 0) == (0 | 0);
            if ($341) {
             break;
            } else {
             $$1346$i$be = $340;
             $$1350$i$be = $339;
            }
           } else {
            $$1346$i$be = $337;
            $$1350$i$be = $336;
           }
           $$1346$i = $$1346$i$be;
           $$1350$i = $$1350$i$be;
          }
          HEAP32[$$1350$i >> 2] = 0;
          $$3348$i = $$1346$i;
         } else {
          $326 = $$4$lcssa$i + 8 | 0;
          $327 = HEAP32[$326 >> 2] | 0;
          $328 = $327 + 12 | 0;
          HEAP32[$328 >> 2] = $324;
          $329 = $324 + 8 | 0;
          HEAP32[$329 >> 2] = $327;
          $$3348$i = $324;
         }
        } while (0);
        $342 = ($322 | 0) == (0 | 0);
        do {
         if ($342) {
          $425 = $220;
         } else {
          $343 = $$4$lcssa$i + 28 | 0;
          $344 = HEAP32[$343 >> 2] | 0;
          $345 = 41344 + ($344 << 2) | 0;
          $346 = HEAP32[$345 >> 2] | 0;
          $347 = ($$4$lcssa$i | 0) == ($346 | 0);
          if ($347) {
           HEAP32[$345 >> 2] = $$3348$i;
           $cond$i203 = ($$3348$i | 0) == (0 | 0);
           if ($cond$i203) {
            $348 = 1 << $344;
            $349 = $348 ^ -1;
            $350 = $220 & $349;
            HEAP32[41044 >> 2] = $350;
            $425 = $350;
            break;
           }
          } else {
           $351 = $322 + 16 | 0;
           $352 = HEAP32[$351 >> 2] | 0;
           $353 = ($352 | 0) == ($$4$lcssa$i | 0);
           $354 = $322 + 20 | 0;
           $$sink320 = $353 ? $351 : $354;
           HEAP32[$$sink320 >> 2] = $$3348$i;
           $355 = ($$3348$i | 0) == (0 | 0);
           if ($355) {
            $425 = $220;
            break;
           }
          }
          $356 = $$3348$i + 24 | 0;
          HEAP32[$356 >> 2] = $322;
          $357 = $$4$lcssa$i + 16 | 0;
          $358 = HEAP32[$357 >> 2] | 0;
          $359 = ($358 | 0) == (0 | 0);
          if (!$359) {
           $360 = $$3348$i + 16 | 0;
           HEAP32[$360 >> 2] = $358;
           $361 = $358 + 24 | 0;
           HEAP32[$361 >> 2] = $$3348$i;
          }
          $362 = $$4$lcssa$i + 20 | 0;
          $363 = HEAP32[$362 >> 2] | 0;
          $364 = ($363 | 0) == (0 | 0);
          if ($364) {
           $425 = $220;
          } else {
           $365 = $$3348$i + 20 | 0;
           HEAP32[$365 >> 2] = $363;
           $366 = $363 + 24 | 0;
           HEAP32[$366 >> 2] = $$3348$i;
           $425 = $220;
          }
         }
        } while (0);
        $367 = $$4327$lcssa$i >>> 0 < 16;
        L128 : do {
         if ($367) {
          $368 = $$4327$lcssa$i + $219 | 0;
          $369 = $368 | 3;
          $370 = $$4$lcssa$i + 4 | 0;
          HEAP32[$370 >> 2] = $369;
          $371 = $$4$lcssa$i + $368 | 0;
          $372 = $371 + 4 | 0;
          $373 = HEAP32[$372 >> 2] | 0;
          $374 = $373 | 1;
          HEAP32[$372 >> 2] = $374;
         } else {
          $375 = $219 | 3;
          $376 = $$4$lcssa$i + 4 | 0;
          HEAP32[$376 >> 2] = $375;
          $377 = $$4327$lcssa$i | 1;
          $378 = $319 + 4 | 0;
          HEAP32[$378 >> 2] = $377;
          $379 = $319 + $$4327$lcssa$i | 0;
          HEAP32[$379 >> 2] = $$4327$lcssa$i;
          $380 = $$4327$lcssa$i >>> 3;
          $381 = $$4327$lcssa$i >>> 0 < 256;
          if ($381) {
           $382 = $380 << 1;
           $383 = 41080 + ($382 << 2) | 0;
           $384 = HEAP32[10260] | 0;
           $385 = 1 << $380;
           $386 = $384 & $385;
           $387 = ($386 | 0) == 0;
           if ($387) {
            $388 = $384 | $385;
            HEAP32[10260] = $388;
            $$pre$i204 = $383 + 8 | 0;
            $$0344$i = $383;
            $$pre$phi$i205Z2D = $$pre$i204;
           } else {
            $389 = $383 + 8 | 0;
            $390 = HEAP32[$389 >> 2] | 0;
            $$0344$i = $390;
            $$pre$phi$i205Z2D = $389;
           }
           HEAP32[$$pre$phi$i205Z2D >> 2] = $319;
           $391 = $$0344$i + 12 | 0;
           HEAP32[$391 >> 2] = $319;
           $392 = $319 + 8 | 0;
           HEAP32[$392 >> 2] = $$0344$i;
           $393 = $319 + 12 | 0;
           HEAP32[$393 >> 2] = $383;
           break;
          }
          $394 = $$4327$lcssa$i >>> 8;
          $395 = ($394 | 0) == 0;
          if ($395) {
           $$0338$i = 0;
          } else {
           $396 = $$4327$lcssa$i >>> 0 > 16777215;
           if ($396) {
            $$0338$i = 31;
           } else {
            $397 = $394 + 1048320 | 0;
            $398 = $397 >>> 16;
            $399 = $398 & 8;
            $400 = $394 << $399;
            $401 = $400 + 520192 | 0;
            $402 = $401 >>> 16;
            $403 = $402 & 4;
            $404 = $403 | $399;
            $405 = $400 << $403;
            $406 = $405 + 245760 | 0;
            $407 = $406 >>> 16;
            $408 = $407 & 2;
            $409 = $404 | $408;
            $410 = 14 - $409 | 0;
            $411 = $405 << $408;
            $412 = $411 >>> 15;
            $413 = $410 + $412 | 0;
            $414 = $413 << 1;
            $415 = $413 + 7 | 0;
            $416 = $$4327$lcssa$i >>> $415;
            $417 = $416 & 1;
            $418 = $417 | $414;
            $$0338$i = $418;
           }
          }
          $419 = 41344 + ($$0338$i << 2) | 0;
          $420 = $319 + 28 | 0;
          HEAP32[$420 >> 2] = $$0338$i;
          $421 = $319 + 16 | 0;
          $422 = $421 + 4 | 0;
          HEAP32[$422 >> 2] = 0;
          HEAP32[$421 >> 2] = 0;
          $423 = 1 << $$0338$i;
          $424 = $425 & $423;
          $426 = ($424 | 0) == 0;
          if ($426) {
           $427 = $425 | $423;
           HEAP32[41044 >> 2] = $427;
           HEAP32[$419 >> 2] = $319;
           $428 = $319 + 24 | 0;
           HEAP32[$428 >> 2] = $419;
           $429 = $319 + 12 | 0;
           HEAP32[$429 >> 2] = $319;
           $430 = $319 + 8 | 0;
           HEAP32[$430 >> 2] = $319;
           break;
          }
          $431 = HEAP32[$419 >> 2] | 0;
          $432 = $431 + 4 | 0;
          $433 = HEAP32[$432 >> 2] | 0;
          $434 = $433 & -8;
          $435 = ($434 | 0) == ($$4327$lcssa$i | 0);
          L145 : do {
           if ($435) {
            $$0321$lcssa$i = $431;
           } else {
            $436 = ($$0338$i | 0) == 31;
            $437 = $$0338$i >>> 1;
            $438 = 25 - $437 | 0;
            $439 = $436 ? 0 : $438;
            $440 = $$4327$lcssa$i << $439;
            $$032012$i = $440;
            $$032111$i = $431;
            while (1) {
             $447 = $$032012$i >>> 31;
             $448 = ($$032111$i + 16 | 0) + ($447 << 2) | 0;
             $443 = HEAP32[$448 >> 2] | 0;
             $449 = ($443 | 0) == (0 | 0);
             if ($449) {
              break;
             }
             $441 = $$032012$i << 1;
             $442 = $443 + 4 | 0;
             $444 = HEAP32[$442 >> 2] | 0;
             $445 = $444 & -8;
             $446 = ($445 | 0) == ($$4327$lcssa$i | 0);
             if ($446) {
              $$0321$lcssa$i = $443;
              break L145;
             } else {
              $$032012$i = $441;
              $$032111$i = $443;
             }
            }
            HEAP32[$448 >> 2] = $319;
            $450 = $319 + 24 | 0;
            HEAP32[$450 >> 2] = $$032111$i;
            $451 = $319 + 12 | 0;
            HEAP32[$451 >> 2] = $319;
            $452 = $319 + 8 | 0;
            HEAP32[$452 >> 2] = $319;
            break L128;
           }
          } while (0);
          $453 = $$0321$lcssa$i + 8 | 0;
          $454 = HEAP32[$453 >> 2] | 0;
          $455 = $454 + 12 | 0;
          HEAP32[$455 >> 2] = $319;
          HEAP32[$453 >> 2] = $319;
          $456 = $319 + 8 | 0;
          HEAP32[$456 >> 2] = $454;
          $457 = $319 + 12 | 0;
          HEAP32[$457 >> 2] = $$0321$lcssa$i;
          $458 = $319 + 24 | 0;
          HEAP32[$458 >> 2] = 0;
         }
        } while (0);
        $459 = $$4$lcssa$i + 8 | 0;
        $$0 = $459;
        STACKTOP = sp;
        return $$0 | 0;
       } else {
        $$0192 = $219;
       }
      } else {
       $$0192 = $219;
      }
     }
    }
   }
  }
 } while (0);
 $460 = HEAP32[41048 >> 2] | 0;
 $461 = $460 >>> 0 < $$0192 >>> 0;
 if (!$461) {
  $462 = $460 - $$0192 | 0;
  $463 = HEAP32[41060 >> 2] | 0;
  $464 = $462 >>> 0 > 15;
  if ($464) {
   $465 = $463 + $$0192 | 0;
   HEAP32[41060 >> 2] = $465;
   HEAP32[41048 >> 2] = $462;
   $466 = $462 | 1;
   $467 = $465 + 4 | 0;
   HEAP32[$467 >> 2] = $466;
   $468 = $463 + $460 | 0;
   HEAP32[$468 >> 2] = $462;
   $469 = $$0192 | 3;
   $470 = $463 + 4 | 0;
   HEAP32[$470 >> 2] = $469;
  } else {
   HEAP32[41048 >> 2] = 0;
   HEAP32[41060 >> 2] = 0;
   $471 = $460 | 3;
   $472 = $463 + 4 | 0;
   HEAP32[$472 >> 2] = $471;
   $473 = $463 + $460 | 0;
   $474 = $473 + 4 | 0;
   $475 = HEAP32[$474 >> 2] | 0;
   $476 = $475 | 1;
   HEAP32[$474 >> 2] = $476;
  }
  $477 = $463 + 8 | 0;
  $$0 = $477;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $478 = HEAP32[41052 >> 2] | 0;
 $479 = $478 >>> 0 > $$0192 >>> 0;
 if ($479) {
  $480 = $478 - $$0192 | 0;
  HEAP32[41052 >> 2] = $480;
  $481 = HEAP32[41064 >> 2] | 0;
  $482 = $481 + $$0192 | 0;
  HEAP32[41064 >> 2] = $482;
  $483 = $480 | 1;
  $484 = $482 + 4 | 0;
  HEAP32[$484 >> 2] = $483;
  $485 = $$0192 | 3;
  $486 = $481 + 4 | 0;
  HEAP32[$486 >> 2] = $485;
  $487 = $481 + 8 | 0;
  $$0 = $487;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $488 = HEAP32[10378] | 0;
 $489 = ($488 | 0) == 0;
 if ($489) {
  HEAP32[41520 >> 2] = 4096;
  HEAP32[41516 >> 2] = 4096;
  HEAP32[41524 >> 2] = -1;
  HEAP32[41528 >> 2] = -1;
  HEAP32[41532 >> 2] = 0;
  HEAP32[41484 >> 2] = 0;
  $490 = $1;
  $491 = $490 & -16;
  $492 = $491 ^ 1431655768;
  HEAP32[10378] = $492;
  $496 = 4096;
 } else {
  $$pre$i195 = HEAP32[41520 >> 2] | 0;
  $496 = $$pre$i195;
 }
 $493 = $$0192 + 48 | 0;
 $494 = $$0192 + 47 | 0;
 $495 = $496 + $494 | 0;
 $497 = 0 - $496 | 0;
 $498 = $495 & $497;
 $499 = $498 >>> 0 > $$0192 >>> 0;
 if (!$499) {
  $$0 = 0;
  STACKTOP = sp;
  return $$0 | 0;
 }
 $500 = HEAP32[41480 >> 2] | 0;
 $501 = ($500 | 0) == 0;
 if (!$501) {
  $502 = HEAP32[41472 >> 2] | 0;
  $503 = $502 + $498 | 0;
  $504 = $503 >>> 0 <= $502 >>> 0;
  $505 = $503 >>> 0 > $500 >>> 0;
  $or$cond1$i = $504 | $505;
  if ($or$cond1$i) {
   $$0 = 0;
   STACKTOP = sp;
   return $$0 | 0;
  }
 }
 $506 = HEAP32[41484 >> 2] | 0;
 $507 = $506 & 4;
 $508 = ($507 | 0) == 0;
 L178 : do {
  if ($508) {
   $509 = HEAP32[41064 >> 2] | 0;
   $510 = ($509 | 0) == (0 | 0);
   L180 : do {
    if ($510) {
     label = 128;
    } else {
     $$0$i20$i = 41488;
     while (1) {
      $511 = HEAP32[$$0$i20$i >> 2] | 0;
      $512 = $511 >>> 0 > $509 >>> 0;
      if (!$512) {
       $513 = $$0$i20$i + 4 | 0;
       $514 = HEAP32[$513 >> 2] | 0;
       $515 = $511 + $514 | 0;
       $516 = $515 >>> 0 > $509 >>> 0;
       if ($516) {
        break;
       }
      }
      $517 = $$0$i20$i + 8 | 0;
      $518 = HEAP32[$517 >> 2] | 0;
      $519 = ($518 | 0) == (0 | 0);
      if ($519) {
       label = 128;
       break L180;
      } else {
       $$0$i20$i = $518;
      }
     }
     $542 = $495 - $478 | 0;
     $543 = $542 & $497;
     $544 = $543 >>> 0 < 2147483647;
     if ($544) {
      $545 = $$0$i20$i + 4 | 0;
      $546 = _sbrk($543 | 0) | 0;
      $547 = HEAP32[$$0$i20$i >> 2] | 0;
      $548 = HEAP32[$545 >> 2] | 0;
      $549 = $547 + $548 | 0;
      $550 = ($546 | 0) == ($549 | 0);
      if ($550) {
       $551 = ($546 | 0) == (-1 | 0);
       if ($551) {
        $$2234243136$i = $543;
       } else {
        $$723947$i = $543;
        $$748$i = $546;
        label = 145;
        break L178;
       }
      } else {
       $$2247$ph$i = $546;
       $$2253$ph$i = $543;
       label = 136;
      }
     } else {
      $$2234243136$i = 0;
     }
    }
   } while (0);
   do {
    if ((label | 0) == 128) {
     $520 = _sbrk(0) | 0;
     $521 = ($520 | 0) == (-1 | 0);
     if ($521) {
      $$2234243136$i = 0;
     } else {
      $522 = $520;
      $523 = HEAP32[41516 >> 2] | 0;
      $524 = $523 + -1 | 0;
      $525 = $524 & $522;
      $526 = ($525 | 0) == 0;
      $527 = $524 + $522 | 0;
      $528 = 0 - $523 | 0;
      $529 = $527 & $528;
      $530 = $529 - $522 | 0;
      $531 = $526 ? 0 : $530;
      $spec$select49$i = $531 + $498 | 0;
      $532 = HEAP32[41472 >> 2] | 0;
      $533 = $spec$select49$i + $532 | 0;
      $534 = $spec$select49$i >>> 0 > $$0192 >>> 0;
      $535 = $spec$select49$i >>> 0 < 2147483647;
      $or$cond$i = $534 & $535;
      if ($or$cond$i) {
       $536 = HEAP32[41480 >> 2] | 0;
       $537 = ($536 | 0) == 0;
       if (!$537) {
        $538 = $533 >>> 0 <= $532 >>> 0;
        $539 = $533 >>> 0 > $536 >>> 0;
        $or$cond2$i = $538 | $539;
        if ($or$cond2$i) {
         $$2234243136$i = 0;
         break;
        }
       }
       $540 = _sbrk($spec$select49$i | 0) | 0;
       $541 = ($540 | 0) == ($520 | 0);
       if ($541) {
        $$723947$i = $spec$select49$i;
        $$748$i = $520;
        label = 145;
        break L178;
       } else {
        $$2247$ph$i = $540;
        $$2253$ph$i = $spec$select49$i;
        label = 136;
       }
      } else {
       $$2234243136$i = 0;
      }
     }
    }
   } while (0);
   do {
    if ((label | 0) == 136) {
     $552 = 0 - $$2253$ph$i | 0;
     $553 = ($$2247$ph$i | 0) != (-1 | 0);
     $554 = $$2253$ph$i >>> 0 < 2147483647;
     $or$cond7$i = $554 & $553;
     $555 = $493 >>> 0 > $$2253$ph$i >>> 0;
     $or$cond6$i = $555 & $or$cond7$i;
     if (!$or$cond6$i) {
      $565 = ($$2247$ph$i | 0) == (-1 | 0);
      if ($565) {
       $$2234243136$i = 0;
       break;
      } else {
       $$723947$i = $$2253$ph$i;
       $$748$i = $$2247$ph$i;
       label = 145;
       break L178;
      }
     }
     $556 = HEAP32[41520 >> 2] | 0;
     $557 = $494 - $$2253$ph$i | 0;
     $558 = $557 + $556 | 0;
     $559 = 0 - $556 | 0;
     $560 = $558 & $559;
     $561 = $560 >>> 0 < 2147483647;
     if (!$561) {
      $$723947$i = $$2253$ph$i;
      $$748$i = $$2247$ph$i;
      label = 145;
      break L178;
     }
     $562 = _sbrk($560 | 0) | 0;
     $563 = ($562 | 0) == (-1 | 0);
     if ($563) {
      _sbrk($552 | 0) | 0;
      $$2234243136$i = 0;
      break;
     } else {
      $564 = $560 + $$2253$ph$i | 0;
      $$723947$i = $564;
      $$748$i = $$2247$ph$i;
      label = 145;
      break L178;
     }
    }
   } while (0);
   $566 = HEAP32[41484 >> 2] | 0;
   $567 = $566 | 4;
   HEAP32[41484 >> 2] = $567;
   $$4236$i = $$2234243136$i;
   label = 143;
  } else {
   $$4236$i = 0;
   label = 143;
  }
 } while (0);
 if ((label | 0) == 143) {
  $568 = $498 >>> 0 < 2147483647;
  if ($568) {
   $569 = _sbrk($498 | 0) | 0;
   $570 = _sbrk(0) | 0;
   $571 = ($569 | 0) != (-1 | 0);
   $572 = ($570 | 0) != (-1 | 0);
   $or$cond5$i = $571 & $572;
   $573 = $569 >>> 0 < $570 >>> 0;
   $or$cond8$i = $573 & $or$cond5$i;
   $574 = $570;
   $575 = $569;
   $576 = $574 - $575 | 0;
   $577 = $$0192 + 40 | 0;
   $578 = $576 >>> 0 > $577 >>> 0;
   $spec$select9$i = $578 ? $576 : $$4236$i;
   $or$cond8$not$i = $or$cond8$i ^ 1;
   $579 = ($569 | 0) == (-1 | 0);
   $not$$i = $578 ^ 1;
   $580 = $579 | $not$$i;
   $or$cond50$i = $580 | $or$cond8$not$i;
   if (!$or$cond50$i) {
    $$723947$i = $spec$select9$i;
    $$748$i = $569;
    label = 145;
   }
  }
 }
 if ((label | 0) == 145) {
  $581 = HEAP32[41472 >> 2] | 0;
  $582 = $581 + $$723947$i | 0;
  HEAP32[41472 >> 2] = $582;
  $583 = HEAP32[41476 >> 2] | 0;
  $584 = $582 >>> 0 > $583 >>> 0;
  if ($584) {
   HEAP32[41476 >> 2] = $582;
  }
  $585 = HEAP32[41064 >> 2] | 0;
  $586 = ($585 | 0) == (0 | 0);
  L215 : do {
   if ($586) {
    $587 = HEAP32[41056 >> 2] | 0;
    $588 = ($587 | 0) == (0 | 0);
    $589 = $$748$i >>> 0 < $587 >>> 0;
    $or$cond11$i = $588 | $589;
    if ($or$cond11$i) {
     HEAP32[41056 >> 2] = $$748$i;
    }
    HEAP32[41488 >> 2] = $$748$i;
    HEAP32[41492 >> 2] = $$723947$i;
    HEAP32[41500 >> 2] = 0;
    $590 = HEAP32[10378] | 0;
    HEAP32[41076 >> 2] = $590;
    HEAP32[41072 >> 2] = -1;
    HEAP32[41092 >> 2] = 41080;
    HEAP32[41088 >> 2] = 41080;
    HEAP32[41100 >> 2] = 41088;
    HEAP32[41096 >> 2] = 41088;
    HEAP32[41108 >> 2] = 41096;
    HEAP32[41104 >> 2] = 41096;
    HEAP32[41116 >> 2] = 41104;
    HEAP32[41112 >> 2] = 41104;
    HEAP32[41124 >> 2] = 41112;
    HEAP32[41120 >> 2] = 41112;
    HEAP32[41132 >> 2] = 41120;
    HEAP32[41128 >> 2] = 41120;
    HEAP32[41140 >> 2] = 41128;
    HEAP32[41136 >> 2] = 41128;
    HEAP32[41148 >> 2] = 41136;
    HEAP32[41144 >> 2] = 41136;
    HEAP32[41156 >> 2] = 41144;
    HEAP32[41152 >> 2] = 41144;
    HEAP32[41164 >> 2] = 41152;
    HEAP32[41160 >> 2] = 41152;
    HEAP32[41172 >> 2] = 41160;
    HEAP32[41168 >> 2] = 41160;
    HEAP32[41180 >> 2] = 41168;
    HEAP32[41176 >> 2] = 41168;
    HEAP32[41188 >> 2] = 41176;
    HEAP32[41184 >> 2] = 41176;
    HEAP32[41196 >> 2] = 41184;
    HEAP32[41192 >> 2] = 41184;
    HEAP32[41204 >> 2] = 41192;
    HEAP32[41200 >> 2] = 41192;
    HEAP32[41212 >> 2] = 41200;
    HEAP32[41208 >> 2] = 41200;
    HEAP32[41220 >> 2] = 41208;
    HEAP32[41216 >> 2] = 41208;
    HEAP32[41228 >> 2] = 41216;
    HEAP32[41224 >> 2] = 41216;
    HEAP32[41236 >> 2] = 41224;
    HEAP32[41232 >> 2] = 41224;
    HEAP32[41244 >> 2] = 41232;
    HEAP32[41240 >> 2] = 41232;
    HEAP32[41252 >> 2] = 41240;
    HEAP32[41248 >> 2] = 41240;
    HEAP32[41260 >> 2] = 41248;
    HEAP32[41256 >> 2] = 41248;
    HEAP32[41268 >> 2] = 41256;
    HEAP32[41264 >> 2] = 41256;
    HEAP32[41276 >> 2] = 41264;
    HEAP32[41272 >> 2] = 41264;
    HEAP32[41284 >> 2] = 41272;
    HEAP32[41280 >> 2] = 41272;
    HEAP32[41292 >> 2] = 41280;
    HEAP32[41288 >> 2] = 41280;
    HEAP32[41300 >> 2] = 41288;
    HEAP32[41296 >> 2] = 41288;
    HEAP32[41308 >> 2] = 41296;
    HEAP32[41304 >> 2] = 41296;
    HEAP32[41316 >> 2] = 41304;
    HEAP32[41312 >> 2] = 41304;
    HEAP32[41324 >> 2] = 41312;
    HEAP32[41320 >> 2] = 41312;
    HEAP32[41332 >> 2] = 41320;
    HEAP32[41328 >> 2] = 41320;
    HEAP32[41340 >> 2] = 41328;
    HEAP32[41336 >> 2] = 41328;
    $591 = $$723947$i + -40 | 0;
    $592 = $$748$i + 8 | 0;
    $593 = $592;
    $594 = $593 & 7;
    $595 = ($594 | 0) == 0;
    $596 = 0 - $593 | 0;
    $597 = $596 & 7;
    $598 = $595 ? 0 : $597;
    $599 = $$748$i + $598 | 0;
    $600 = $591 - $598 | 0;
    HEAP32[41064 >> 2] = $599;
    HEAP32[41052 >> 2] = $600;
    $601 = $600 | 1;
    $602 = $599 + 4 | 0;
    HEAP32[$602 >> 2] = $601;
    $603 = $$748$i + $591 | 0;
    $604 = $603 + 4 | 0;
    HEAP32[$604 >> 2] = 40;
    $605 = HEAP32[41528 >> 2] | 0;
    HEAP32[41068 >> 2] = $605;
   } else {
    $$024372$i = 41488;
    while (1) {
     $606 = HEAP32[$$024372$i >> 2] | 0;
     $607 = $$024372$i + 4 | 0;
     $608 = HEAP32[$607 >> 2] | 0;
     $609 = $606 + $608 | 0;
     $610 = ($$748$i | 0) == ($609 | 0);
     if ($610) {
      label = 154;
      break;
     }
     $611 = $$024372$i + 8 | 0;
     $612 = HEAP32[$611 >> 2] | 0;
     $613 = ($612 | 0) == (0 | 0);
     if ($613) {
      break;
     } else {
      $$024372$i = $612;
     }
    }
    if ((label | 0) == 154) {
     $614 = $$024372$i + 4 | 0;
     $615 = $$024372$i + 12 | 0;
     $616 = HEAP32[$615 >> 2] | 0;
     $617 = $616 & 8;
     $618 = ($617 | 0) == 0;
     if ($618) {
      $619 = $606 >>> 0 <= $585 >>> 0;
      $620 = $$748$i >>> 0 > $585 >>> 0;
      $or$cond51$i = $620 & $619;
      if ($or$cond51$i) {
       $621 = $608 + $$723947$i | 0;
       HEAP32[$614 >> 2] = $621;
       $622 = HEAP32[41052 >> 2] | 0;
       $623 = $622 + $$723947$i | 0;
       $624 = $585 + 8 | 0;
       $625 = $624;
       $626 = $625 & 7;
       $627 = ($626 | 0) == 0;
       $628 = 0 - $625 | 0;
       $629 = $628 & 7;
       $630 = $627 ? 0 : $629;
       $631 = $585 + $630 | 0;
       $632 = $623 - $630 | 0;
       HEAP32[41064 >> 2] = $631;
       HEAP32[41052 >> 2] = $632;
       $633 = $632 | 1;
       $634 = $631 + 4 | 0;
       HEAP32[$634 >> 2] = $633;
       $635 = $585 + $623 | 0;
       $636 = $635 + 4 | 0;
       HEAP32[$636 >> 2] = 40;
       $637 = HEAP32[41528 >> 2] | 0;
       HEAP32[41068 >> 2] = $637;
       break;
      }
     }
    }
    $638 = HEAP32[41056 >> 2] | 0;
    $639 = $$748$i >>> 0 < $638 >>> 0;
    if ($639) {
     HEAP32[41056 >> 2] = $$748$i;
    }
    $640 = $$748$i + $$723947$i | 0;
    $$124471$i = 41488;
    while (1) {
     $641 = HEAP32[$$124471$i >> 2] | 0;
     $642 = ($641 | 0) == ($640 | 0);
     if ($642) {
      label = 162;
      break;
     }
     $643 = $$124471$i + 8 | 0;
     $644 = HEAP32[$643 >> 2] | 0;
     $645 = ($644 | 0) == (0 | 0);
     if ($645) {
      break;
     } else {
      $$124471$i = $644;
     }
    }
    if ((label | 0) == 162) {
     $646 = $$124471$i + 12 | 0;
     $647 = HEAP32[$646 >> 2] | 0;
     $648 = $647 & 8;
     $649 = ($648 | 0) == 0;
     if ($649) {
      HEAP32[$$124471$i >> 2] = $$748$i;
      $650 = $$124471$i + 4 | 0;
      $651 = HEAP32[$650 >> 2] | 0;
      $652 = $651 + $$723947$i | 0;
      HEAP32[$650 >> 2] = $652;
      $653 = $$748$i + 8 | 0;
      $654 = $653;
      $655 = $654 & 7;
      $656 = ($655 | 0) == 0;
      $657 = 0 - $654 | 0;
      $658 = $657 & 7;
      $659 = $656 ? 0 : $658;
      $660 = $$748$i + $659 | 0;
      $661 = $640 + 8 | 0;
      $662 = $661;
      $663 = $662 & 7;
      $664 = ($663 | 0) == 0;
      $665 = 0 - $662 | 0;
      $666 = $665 & 7;
      $667 = $664 ? 0 : $666;
      $668 = $640 + $667 | 0;
      $669 = $668;
      $670 = $660;
      $671 = $669 - $670 | 0;
      $672 = $660 + $$0192 | 0;
      $673 = $671 - $$0192 | 0;
      $674 = $$0192 | 3;
      $675 = $660 + 4 | 0;
      HEAP32[$675 >> 2] = $674;
      $676 = ($585 | 0) == ($668 | 0);
      L238 : do {
       if ($676) {
        $677 = HEAP32[41052 >> 2] | 0;
        $678 = $677 + $673 | 0;
        HEAP32[41052 >> 2] = $678;
        HEAP32[41064 >> 2] = $672;
        $679 = $678 | 1;
        $680 = $672 + 4 | 0;
        HEAP32[$680 >> 2] = $679;
       } else {
        $681 = HEAP32[41060 >> 2] | 0;
        $682 = ($681 | 0) == ($668 | 0);
        if ($682) {
         $683 = HEAP32[41048 >> 2] | 0;
         $684 = $683 + $673 | 0;
         HEAP32[41048 >> 2] = $684;
         HEAP32[41060 >> 2] = $672;
         $685 = $684 | 1;
         $686 = $672 + 4 | 0;
         HEAP32[$686 >> 2] = $685;
         $687 = $672 + $684 | 0;
         HEAP32[$687 >> 2] = $684;
         break;
        }
        $688 = $668 + 4 | 0;
        $689 = HEAP32[$688 >> 2] | 0;
        $690 = $689 & 3;
        $691 = ($690 | 0) == 1;
        if ($691) {
         $692 = $689 & -8;
         $693 = $689 >>> 3;
         $694 = $689 >>> 0 < 256;
         L246 : do {
          if ($694) {
           $695 = $668 + 8 | 0;
           $696 = HEAP32[$695 >> 2] | 0;
           $697 = $668 + 12 | 0;
           $698 = HEAP32[$697 >> 2] | 0;
           $699 = ($698 | 0) == ($696 | 0);
           if ($699) {
            $700 = 1 << $693;
            $701 = $700 ^ -1;
            $702 = HEAP32[10260] | 0;
            $703 = $702 & $701;
            HEAP32[10260] = $703;
            break;
           } else {
            $704 = $696 + 12 | 0;
            HEAP32[$704 >> 2] = $698;
            $705 = $698 + 8 | 0;
            HEAP32[$705 >> 2] = $696;
            break;
           }
          } else {
           $706 = $668 + 24 | 0;
           $707 = HEAP32[$706 >> 2] | 0;
           $708 = $668 + 12 | 0;
           $709 = HEAP32[$708 >> 2] | 0;
           $710 = ($709 | 0) == ($668 | 0);
           do {
            if ($710) {
             $715 = $668 + 16 | 0;
             $716 = $715 + 4 | 0;
             $717 = HEAP32[$716 >> 2] | 0;
             $718 = ($717 | 0) == (0 | 0);
             if ($718) {
              $719 = HEAP32[$715 >> 2] | 0;
              $720 = ($719 | 0) == (0 | 0);
              if ($720) {
               $$3$i$i = 0;
               break;
              } else {
               $$1263$i$i$ph = $719;
               $$1265$i$i$ph = $715;
              }
             } else {
              $$1263$i$i$ph = $717;
              $$1265$i$i$ph = $716;
             }
             $$1263$i$i = $$1263$i$i$ph;
             $$1265$i$i = $$1265$i$i$ph;
             while (1) {
              $721 = $$1263$i$i + 20 | 0;
              $722 = HEAP32[$721 >> 2] | 0;
              $723 = ($722 | 0) == (0 | 0);
              if ($723) {
               $724 = $$1263$i$i + 16 | 0;
               $725 = HEAP32[$724 >> 2] | 0;
               $726 = ($725 | 0) == (0 | 0);
               if ($726) {
                break;
               } else {
                $$1263$i$i$be = $725;
                $$1265$i$i$be = $724;
               }
              } else {
               $$1263$i$i$be = $722;
               $$1265$i$i$be = $721;
              }
              $$1263$i$i = $$1263$i$i$be;
              $$1265$i$i = $$1265$i$i$be;
             }
             HEAP32[$$1265$i$i >> 2] = 0;
             $$3$i$i = $$1263$i$i;
            } else {
             $711 = $668 + 8 | 0;
             $712 = HEAP32[$711 >> 2] | 0;
             $713 = $712 + 12 | 0;
             HEAP32[$713 >> 2] = $709;
             $714 = $709 + 8 | 0;
             HEAP32[$714 >> 2] = $712;
             $$3$i$i = $709;
            }
           } while (0);
           $727 = ($707 | 0) == (0 | 0);
           if ($727) {
            break;
           }
           $728 = $668 + 28 | 0;
           $729 = HEAP32[$728 >> 2] | 0;
           $730 = 41344 + ($729 << 2) | 0;
           $731 = HEAP32[$730 >> 2] | 0;
           $732 = ($731 | 0) == ($668 | 0);
           do {
            if ($732) {
             HEAP32[$730 >> 2] = $$3$i$i;
             $cond$i$i = ($$3$i$i | 0) == (0 | 0);
             if (!$cond$i$i) {
              break;
             }
             $733 = 1 << $729;
             $734 = $733 ^ -1;
             $735 = HEAP32[41044 >> 2] | 0;
             $736 = $735 & $734;
             HEAP32[41044 >> 2] = $736;
             break L246;
            } else {
             $737 = $707 + 16 | 0;
             $738 = HEAP32[$737 >> 2] | 0;
             $739 = ($738 | 0) == ($668 | 0);
             $740 = $707 + 20 | 0;
             $$sink321 = $739 ? $737 : $740;
             HEAP32[$$sink321 >> 2] = $$3$i$i;
             $741 = ($$3$i$i | 0) == (0 | 0);
             if ($741) {
              break L246;
             }
            }
           } while (0);
           $742 = $$3$i$i + 24 | 0;
           HEAP32[$742 >> 2] = $707;
           $743 = $668 + 16 | 0;
           $744 = HEAP32[$743 >> 2] | 0;
           $745 = ($744 | 0) == (0 | 0);
           if (!$745) {
            $746 = $$3$i$i + 16 | 0;
            HEAP32[$746 >> 2] = $744;
            $747 = $744 + 24 | 0;
            HEAP32[$747 >> 2] = $$3$i$i;
           }
           $748 = $743 + 4 | 0;
           $749 = HEAP32[$748 >> 2] | 0;
           $750 = ($749 | 0) == (0 | 0);
           if ($750) {
            break;
           }
           $751 = $$3$i$i + 20 | 0;
           HEAP32[$751 >> 2] = $749;
           $752 = $749 + 24 | 0;
           HEAP32[$752 >> 2] = $$3$i$i;
          }
         } while (0);
         $753 = $668 + $692 | 0;
         $754 = $692 + $673 | 0;
         $$0$i$i = $753;
         $$0259$i$i = $754;
        } else {
         $$0$i$i = $668;
         $$0259$i$i = $673;
        }
        $755 = $$0$i$i + 4 | 0;
        $756 = HEAP32[$755 >> 2] | 0;
        $757 = $756 & -2;
        HEAP32[$755 >> 2] = $757;
        $758 = $$0259$i$i | 1;
        $759 = $672 + 4 | 0;
        HEAP32[$759 >> 2] = $758;
        $760 = $672 + $$0259$i$i | 0;
        HEAP32[$760 >> 2] = $$0259$i$i;
        $761 = $$0259$i$i >>> 3;
        $762 = $$0259$i$i >>> 0 < 256;
        if ($762) {
         $763 = $761 << 1;
         $764 = 41080 + ($763 << 2) | 0;
         $765 = HEAP32[10260] | 0;
         $766 = 1 << $761;
         $767 = $765 & $766;
         $768 = ($767 | 0) == 0;
         if ($768) {
          $769 = $765 | $766;
          HEAP32[10260] = $769;
          $$pre$i16$i = $764 + 8 | 0;
          $$0267$i$i = $764;
          $$pre$phi$i17$iZ2D = $$pre$i16$i;
         } else {
          $770 = $764 + 8 | 0;
          $771 = HEAP32[$770 >> 2] | 0;
          $$0267$i$i = $771;
          $$pre$phi$i17$iZ2D = $770;
         }
         HEAP32[$$pre$phi$i17$iZ2D >> 2] = $672;
         $772 = $$0267$i$i + 12 | 0;
         HEAP32[$772 >> 2] = $672;
         $773 = $672 + 8 | 0;
         HEAP32[$773 >> 2] = $$0267$i$i;
         $774 = $672 + 12 | 0;
         HEAP32[$774 >> 2] = $764;
         break;
        }
        $775 = $$0259$i$i >>> 8;
        $776 = ($775 | 0) == 0;
        do {
         if ($776) {
          $$0268$i$i = 0;
         } else {
          $777 = $$0259$i$i >>> 0 > 16777215;
          if ($777) {
           $$0268$i$i = 31;
           break;
          }
          $778 = $775 + 1048320 | 0;
          $779 = $778 >>> 16;
          $780 = $779 & 8;
          $781 = $775 << $780;
          $782 = $781 + 520192 | 0;
          $783 = $782 >>> 16;
          $784 = $783 & 4;
          $785 = $784 | $780;
          $786 = $781 << $784;
          $787 = $786 + 245760 | 0;
          $788 = $787 >>> 16;
          $789 = $788 & 2;
          $790 = $785 | $789;
          $791 = 14 - $790 | 0;
          $792 = $786 << $789;
          $793 = $792 >>> 15;
          $794 = $791 + $793 | 0;
          $795 = $794 << 1;
          $796 = $794 + 7 | 0;
          $797 = $$0259$i$i >>> $796;
          $798 = $797 & 1;
          $799 = $798 | $795;
          $$0268$i$i = $799;
         }
        } while (0);
        $800 = 41344 + ($$0268$i$i << 2) | 0;
        $801 = $672 + 28 | 0;
        HEAP32[$801 >> 2] = $$0268$i$i;
        $802 = $672 + 16 | 0;
        $803 = $802 + 4 | 0;
        HEAP32[$803 >> 2] = 0;
        HEAP32[$802 >> 2] = 0;
        $804 = HEAP32[41044 >> 2] | 0;
        $805 = 1 << $$0268$i$i;
        $806 = $804 & $805;
        $807 = ($806 | 0) == 0;
        if ($807) {
         $808 = $804 | $805;
         HEAP32[41044 >> 2] = $808;
         HEAP32[$800 >> 2] = $672;
         $809 = $672 + 24 | 0;
         HEAP32[$809 >> 2] = $800;
         $810 = $672 + 12 | 0;
         HEAP32[$810 >> 2] = $672;
         $811 = $672 + 8 | 0;
         HEAP32[$811 >> 2] = $672;
         break;
        }
        $812 = HEAP32[$800 >> 2] | 0;
        $813 = $812 + 4 | 0;
        $814 = HEAP32[$813 >> 2] | 0;
        $815 = $814 & -8;
        $816 = ($815 | 0) == ($$0259$i$i | 0);
        L291 : do {
         if ($816) {
          $$0261$lcssa$i$i = $812;
         } else {
          $817 = ($$0268$i$i | 0) == 31;
          $818 = $$0268$i$i >>> 1;
          $819 = 25 - $818 | 0;
          $820 = $817 ? 0 : $819;
          $821 = $$0259$i$i << $820;
          $$02604$i$i = $821;
          $$02613$i$i = $812;
          while (1) {
           $828 = $$02604$i$i >>> 31;
           $829 = ($$02613$i$i + 16 | 0) + ($828 << 2) | 0;
           $824 = HEAP32[$829 >> 2] | 0;
           $830 = ($824 | 0) == (0 | 0);
           if ($830) {
            break;
           }
           $822 = $$02604$i$i << 1;
           $823 = $824 + 4 | 0;
           $825 = HEAP32[$823 >> 2] | 0;
           $826 = $825 & -8;
           $827 = ($826 | 0) == ($$0259$i$i | 0);
           if ($827) {
            $$0261$lcssa$i$i = $824;
            break L291;
           } else {
            $$02604$i$i = $822;
            $$02613$i$i = $824;
           }
          }
          HEAP32[$829 >> 2] = $672;
          $831 = $672 + 24 | 0;
          HEAP32[$831 >> 2] = $$02613$i$i;
          $832 = $672 + 12 | 0;
          HEAP32[$832 >> 2] = $672;
          $833 = $672 + 8 | 0;
          HEAP32[$833 >> 2] = $672;
          break L238;
         }
        } while (0);
        $834 = $$0261$lcssa$i$i + 8 | 0;
        $835 = HEAP32[$834 >> 2] | 0;
        $836 = $835 + 12 | 0;
        HEAP32[$836 >> 2] = $672;
        HEAP32[$834 >> 2] = $672;
        $837 = $672 + 8 | 0;
        HEAP32[$837 >> 2] = $835;
        $838 = $672 + 12 | 0;
        HEAP32[$838 >> 2] = $$0261$lcssa$i$i;
        $839 = $672 + 24 | 0;
        HEAP32[$839 >> 2] = 0;
       }
      } while (0);
      $968 = $660 + 8 | 0;
      $$0 = $968;
      STACKTOP = sp;
      return $$0 | 0;
     }
    }
    $$0$i$i$i = 41488;
    while (1) {
     $840 = HEAP32[$$0$i$i$i >> 2] | 0;
     $841 = $840 >>> 0 > $585 >>> 0;
     if (!$841) {
      $842 = $$0$i$i$i + 4 | 0;
      $843 = HEAP32[$842 >> 2] | 0;
      $844 = $840 + $843 | 0;
      $845 = $844 >>> 0 > $585 >>> 0;
      if ($845) {
       break;
      }
     }
     $846 = $$0$i$i$i + 8 | 0;
     $847 = HEAP32[$846 >> 2] | 0;
     $$0$i$i$i = $847;
    }
    $848 = $844 + -47 | 0;
    $849 = $848 + 8 | 0;
    $850 = $849;
    $851 = $850 & 7;
    $852 = ($851 | 0) == 0;
    $853 = 0 - $850 | 0;
    $854 = $853 & 7;
    $855 = $852 ? 0 : $854;
    $856 = $848 + $855 | 0;
    $857 = $585 + 16 | 0;
    $858 = $856 >>> 0 < $857 >>> 0;
    $859 = $858 ? $585 : $856;
    $860 = $859 + 8 | 0;
    $861 = $859 + 24 | 0;
    $862 = $$723947$i + -40 | 0;
    $863 = $$748$i + 8 | 0;
    $864 = $863;
    $865 = $864 & 7;
    $866 = ($865 | 0) == 0;
    $867 = 0 - $864 | 0;
    $868 = $867 & 7;
    $869 = $866 ? 0 : $868;
    $870 = $$748$i + $869 | 0;
    $871 = $862 - $869 | 0;
    HEAP32[41064 >> 2] = $870;
    HEAP32[41052 >> 2] = $871;
    $872 = $871 | 1;
    $873 = $870 + 4 | 0;
    HEAP32[$873 >> 2] = $872;
    $874 = $$748$i + $862 | 0;
    $875 = $874 + 4 | 0;
    HEAP32[$875 >> 2] = 40;
    $876 = HEAP32[41528 >> 2] | 0;
    HEAP32[41068 >> 2] = $876;
    $877 = $859 + 4 | 0;
    HEAP32[$877 >> 2] = 27;
    HEAP32[$860 >> 2] = HEAP32[41488 >> 2] | 0;
    HEAP32[$860 + 4 >> 2] = HEAP32[41488 + 4 >> 2] | 0;
    HEAP32[$860 + 8 >> 2] = HEAP32[41488 + 8 >> 2] | 0;
    HEAP32[$860 + 12 >> 2] = HEAP32[41488 + 12 >> 2] | 0;
    HEAP32[41488 >> 2] = $$748$i;
    HEAP32[41492 >> 2] = $$723947$i;
    HEAP32[41500 >> 2] = 0;
    HEAP32[41496 >> 2] = $860;
    $879 = $861;
    while (1) {
     $878 = $879 + 4 | 0;
     HEAP32[$878 >> 2] = 7;
     $880 = $879 + 8 | 0;
     $881 = $880 >>> 0 < $844 >>> 0;
     if ($881) {
      $879 = $878;
     } else {
      break;
     }
    }
    $882 = ($859 | 0) == ($585 | 0);
    if (!$882) {
     $883 = $859;
     $884 = $585;
     $885 = $883 - $884 | 0;
     $886 = HEAP32[$877 >> 2] | 0;
     $887 = $886 & -2;
     HEAP32[$877 >> 2] = $887;
     $888 = $885 | 1;
     $889 = $585 + 4 | 0;
     HEAP32[$889 >> 2] = $888;
     HEAP32[$859 >> 2] = $885;
     $890 = $885 >>> 3;
     $891 = $885 >>> 0 < 256;
     if ($891) {
      $892 = $890 << 1;
      $893 = 41080 + ($892 << 2) | 0;
      $894 = HEAP32[10260] | 0;
      $895 = 1 << $890;
      $896 = $894 & $895;
      $897 = ($896 | 0) == 0;
      if ($897) {
       $898 = $894 | $895;
       HEAP32[10260] = $898;
       $$pre$i$i = $893 + 8 | 0;
       $$0206$i$i = $893;
       $$pre$phi$i$iZ2D = $$pre$i$i;
      } else {
       $899 = $893 + 8 | 0;
       $900 = HEAP32[$899 >> 2] | 0;
       $$0206$i$i = $900;
       $$pre$phi$i$iZ2D = $899;
      }
      HEAP32[$$pre$phi$i$iZ2D >> 2] = $585;
      $901 = $$0206$i$i + 12 | 0;
      HEAP32[$901 >> 2] = $585;
      $902 = $585 + 8 | 0;
      HEAP32[$902 >> 2] = $$0206$i$i;
      $903 = $585 + 12 | 0;
      HEAP32[$903 >> 2] = $893;
      break;
     }
     $904 = $885 >>> 8;
     $905 = ($904 | 0) == 0;
     if ($905) {
      $$0207$i$i = 0;
     } else {
      $906 = $885 >>> 0 > 16777215;
      if ($906) {
       $$0207$i$i = 31;
      } else {
       $907 = $904 + 1048320 | 0;
       $908 = $907 >>> 16;
       $909 = $908 & 8;
       $910 = $904 << $909;
       $911 = $910 + 520192 | 0;
       $912 = $911 >>> 16;
       $913 = $912 & 4;
       $914 = $913 | $909;
       $915 = $910 << $913;
       $916 = $915 + 245760 | 0;
       $917 = $916 >>> 16;
       $918 = $917 & 2;
       $919 = $914 | $918;
       $920 = 14 - $919 | 0;
       $921 = $915 << $918;
       $922 = $921 >>> 15;
       $923 = $920 + $922 | 0;
       $924 = $923 << 1;
       $925 = $923 + 7 | 0;
       $926 = $885 >>> $925;
       $927 = $926 & 1;
       $928 = $927 | $924;
       $$0207$i$i = $928;
      }
     }
     $929 = 41344 + ($$0207$i$i << 2) | 0;
     $930 = $585 + 28 | 0;
     HEAP32[$930 >> 2] = $$0207$i$i;
     $931 = $585 + 20 | 0;
     HEAP32[$931 >> 2] = 0;
     HEAP32[$857 >> 2] = 0;
     $932 = HEAP32[41044 >> 2] | 0;
     $933 = 1 << $$0207$i$i;
     $934 = $932 & $933;
     $935 = ($934 | 0) == 0;
     if ($935) {
      $936 = $932 | $933;
      HEAP32[41044 >> 2] = $936;
      HEAP32[$929 >> 2] = $585;
      $937 = $585 + 24 | 0;
      HEAP32[$937 >> 2] = $929;
      $938 = $585 + 12 | 0;
      HEAP32[$938 >> 2] = $585;
      $939 = $585 + 8 | 0;
      HEAP32[$939 >> 2] = $585;
      break;
     }
     $940 = HEAP32[$929 >> 2] | 0;
     $941 = $940 + 4 | 0;
     $942 = HEAP32[$941 >> 2] | 0;
     $943 = $942 & -8;
     $944 = ($943 | 0) == ($885 | 0);
     L325 : do {
      if ($944) {
       $$0202$lcssa$i$i = $940;
      } else {
       $945 = ($$0207$i$i | 0) == 31;
       $946 = $$0207$i$i >>> 1;
       $947 = 25 - $946 | 0;
       $948 = $945 ? 0 : $947;
       $949 = $885 << $948;
       $$02014$i$i = $949;
       $$02023$i$i = $940;
       while (1) {
        $956 = $$02014$i$i >>> 31;
        $957 = ($$02023$i$i + 16 | 0) + ($956 << 2) | 0;
        $952 = HEAP32[$957 >> 2] | 0;
        $958 = ($952 | 0) == (0 | 0);
        if ($958) {
         break;
        }
        $950 = $$02014$i$i << 1;
        $951 = $952 + 4 | 0;
        $953 = HEAP32[$951 >> 2] | 0;
        $954 = $953 & -8;
        $955 = ($954 | 0) == ($885 | 0);
        if ($955) {
         $$0202$lcssa$i$i = $952;
         break L325;
        } else {
         $$02014$i$i = $950;
         $$02023$i$i = $952;
        }
       }
       HEAP32[$957 >> 2] = $585;
       $959 = $585 + 24 | 0;
       HEAP32[$959 >> 2] = $$02023$i$i;
       $960 = $585 + 12 | 0;
       HEAP32[$960 >> 2] = $585;
       $961 = $585 + 8 | 0;
       HEAP32[$961 >> 2] = $585;
       break L215;
      }
     } while (0);
     $962 = $$0202$lcssa$i$i + 8 | 0;
     $963 = HEAP32[$962 >> 2] | 0;
     $964 = $963 + 12 | 0;
     HEAP32[$964 >> 2] = $585;
     HEAP32[$962 >> 2] = $585;
     $965 = $585 + 8 | 0;
     HEAP32[$965 >> 2] = $963;
     $966 = $585 + 12 | 0;
     HEAP32[$966 >> 2] = $$0202$lcssa$i$i;
     $967 = $585 + 24 | 0;
     HEAP32[$967 >> 2] = 0;
    }
   }
  } while (0);
  $969 = HEAP32[41052 >> 2] | 0;
  $970 = $969 >>> 0 > $$0192 >>> 0;
  if ($970) {
   $971 = $969 - $$0192 | 0;
   HEAP32[41052 >> 2] = $971;
   $972 = HEAP32[41064 >> 2] | 0;
   $973 = $972 + $$0192 | 0;
   HEAP32[41064 >> 2] = $973;
   $974 = $971 | 1;
   $975 = $973 + 4 | 0;
   HEAP32[$975 >> 2] = $974;
   $976 = $$0192 | 3;
   $977 = $972 + 4 | 0;
   HEAP32[$977 >> 2] = $976;
   $978 = $972 + 8 | 0;
   $$0 = $978;
   STACKTOP = sp;
   return $$0 | 0;
  }
 }
 $979 = ___errno_location() | 0;
 HEAP32[$979 >> 2] = 12;
 $$0 = 0;
 STACKTOP = sp;
 return $$0 | 0;
}

function _fmt_fp($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $$ = 0, $$0 = 0, $$0463$lcssa = 0, $$0463588 = 0, $$0464599 = 0, $$0471 = 0.0, $$0479 = 0, $$0487657 = 0, $$0488 = 0, $$0488669 = 0, $$0488671 = 0, $$0497670 = 0, $$0498 = 0, $$0511586 = 0.0, $$0512 = 0, $$0513 = 0, $$0516652 = 0, $$0522 = 0, $$0523 = 0, $$0525 = 0, $$0527 = 0, $$0529 = 0, $$0529$in646 = 0, $$0532651 = 0, $$1465 = 0, $$1467 = 0.0, $$1469 = 0.0, $$1472 = 0.0, $$1480 = 0, $$1482$lcssa = 0, $$1482683 = 0, $$1489656 = 0, $$1499 = 0, $$1510587 = 0, $$1514$lcssa = 0, $$1514614 = 0, $$1517 = 0, $$1526 = 0, $$1528 = 0, $$1530621 = 0, $$1533$lcssa = 0, $$1533645 = 0, $$1604 = 0, $$2 = 0, $$2473 = 0.0, $$2476 = 0, $$2483 = 0, $$2490$lcssa = 0, $$2490638 = 0, $$2500$lcssa = 0, $$2500682 = 0, $$2515 = 0, $$2518634 = 0, $$2531 = 0, $$2534633 = 0, $$3 = 0.0, $$3477 = 0, $$3484$lcssa = 0, $$3484663 = 0, $$3501$lcssa = 0, $$3501676 = 0, $$3535620 = 0, $$4 = 0.0, $$4478$lcssa = 0, $$4478594 = 0, $$4492 = 0, $$4502$lcssa = 0, $$4502662 = 0, $$4520 = 0, $$5$lcssa = 0, $$5486$lcssa = 0, $$5486639 = 0, $$5493603 = 0, $$5503 = 0, $$5521 = 0, $$560 = 0, $$5609 = 0, $$6 = 0, $$6494593 = 0, $$7495608 = 0, $$8 = 0, $$8506 = 0, $$9 = 0, $$9507$lcssa = 0, $$9507625 = 0, $$lcssa583 = 0, $$lobit = 0, $$neg = 0, $$neg571 = 0, $$not = 0, $$pn = 0, $$pr = 0, $$pr564 = 0, $$pre = 0, $$pre$phi717Z2D = 0, $$pre$phi718Z2D = 0, $$pre720 = 0, $$sink757 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0.0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0.0, $129 = 0.0, $13 = 0, $130 = 0.0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0.0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0.0, $247 = 0.0, $248 = 0, $249 = 0.0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0.0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0.0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0.0, $54 = 0, $55 = 0, $56 = 0, $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0, $60 = 0.0, $61 = 0.0, $62 = 0.0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0.0, $91 = 0.0, $92 = 0.0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $not$ = 0, $or$cond = 0, $or$cond3$not = 0, $or$cond543 = 0, $or$cond546 = 0, $or$cond556 = 0, $or$cond559 = 0, $or$cond6 = 0, $scevgep711 = 0, $scevgep711712 = 0, $spec$select = 0, $spec$select539 = 0, $spec$select540 = 0, $spec$select540722 = 0, $spec$select540723 = 0, $spec$select541 = 0, $spec$select544 = 0.0, $spec$select547 = 0, $spec$select548 = 0, $spec$select549 = 0, $spec$select551 = 0, $spec$select554 = 0, $spec$select557 = 0, $spec$select561 = 0.0, $spec$select562 = 0, $spec$select563 = 0, $spec$select565 = 0, $spec$select566 = 0, $spec$select567 = 0.0, $spec$select568 = 0.0, $spec$select569 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 560 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(560 | 0);
 $6 = sp + 32 | 0;
 $7 = sp + 536 | 0;
 $8 = sp;
 $9 = $8;
 $10 = sp + 540 | 0;
 HEAP32[$7 >> 2] = 0;
 $11 = $10 + 12 | 0;
 $12 = ___DOUBLE_BITS_378($1) | 0;
 $13 = getTempRet0() | 0;
 $14 = ($13 | 0) < 0;
 if ($14) {
  $15 = -$1;
  $16 = ___DOUBLE_BITS_378($15) | 0;
  $17 = getTempRet0() | 0;
  $$0471 = $15;
  $$0522 = 1;
  $$0523 = 35364;
  $25 = $17;
  $412 = $16;
 } else {
  $18 = $4 & 2048;
  $19 = ($18 | 0) == 0;
  $20 = $4 & 1;
  $21 = ($20 | 0) == 0;
  $$ = $21 ? 35365 : 35370;
  $spec$select565 = $19 ? $$ : 35367;
  $22 = $4 & 2049;
  $23 = ($22 | 0) != 0;
  $spec$select566 = $23 & 1;
  $$0471 = $1;
  $$0522 = $spec$select566;
  $$0523 = $spec$select565;
  $25 = $13;
  $412 = $12;
 }
 $24 = $25 & 2146435072;
 $26 = 0 == 0;
 $27 = ($24 | 0) == 2146435072;
 $28 = $26 & $27;
 do {
  if ($28) {
   $29 = $5 & 32;
   $30 = ($29 | 0) != 0;
   $31 = $30 ? 35383 : 35387;
   $32 = $$0471 != $$0471 | 0.0 != 0.0;
   $33 = $30 ? 35391 : 35395;
   $$0512 = $32 ? $33 : $31;
   $34 = $$0522 + 3 | 0;
   $35 = $4 & -65537;
   _pad($0, 32, $2, $34, $35);
   _out($0, $$0523, $$0522);
   _out($0, $$0512, 3);
   $36 = $4 ^ 8192;
   _pad($0, 32, $2, $34, $36);
   $$sink757 = $34;
  } else {
   $37 = +_frexp($$0471, $7);
   $38 = $37 * 2.0;
   $39 = $38 != 0.0;
   if ($39) {
    $40 = HEAP32[$7 >> 2] | 0;
    $41 = $40 + -1 | 0;
    HEAP32[$7 >> 2] = $41;
   }
   $42 = $5 | 32;
   $43 = ($42 | 0) == 97;
   if ($43) {
    $44 = $5 & 32;
    $45 = ($44 | 0) == 0;
    $46 = $$0523 + 9 | 0;
    $spec$select = $45 ? $$0523 : $46;
    $47 = $$0522 | 2;
    $48 = $3 >>> 0 > 11;
    $49 = 12 - $3 | 0;
    $50 = ($49 | 0) == 0;
    $51 = $48 | $50;
    do {
     if ($51) {
      $$1472 = $38;
     } else {
      $$0511586 = 8.0;
      $$1510587 = $49;
      while (1) {
       $52 = $$1510587 + -1 | 0;
       $53 = $$0511586 * 16.0;
       $54 = ($52 | 0) == 0;
       if ($54) {
        break;
       } else {
        $$0511586 = $53;
        $$1510587 = $52;
       }
      }
      $55 = HEAP8[$spec$select >> 0] | 0;
      $56 = $55 << 24 >> 24 == 45;
      if ($56) {
       $57 = -$38;
       $58 = $57 - $53;
       $59 = $53 + $58;
       $60 = -$59;
       $$1472 = $60;
       break;
      } else {
       $61 = $38 + $53;
       $62 = $61 - $53;
       $$1472 = $62;
       break;
      }
     }
    } while (0);
    $63 = HEAP32[$7 >> 2] | 0;
    $64 = ($63 | 0) < 0;
    $65 = 0 - $63 | 0;
    $66 = $64 ? $65 : $63;
    $67 = ($66 | 0) < 0;
    $68 = $67 << 31 >> 31;
    $69 = _fmt_u($66, $68, $11) | 0;
    $70 = ($69 | 0) == ($11 | 0);
    if ($70) {
     $71 = $10 + 11 | 0;
     HEAP8[$71 >> 0] = 48;
     $$0513 = $71;
    } else {
     $$0513 = $69;
    }
    $72 = $63 >> 31;
    $73 = $72 & 2;
    $74 = $73 + 43 | 0;
    $75 = $74 & 255;
    $76 = $$0513 + -1 | 0;
    HEAP8[$76 >> 0] = $75;
    $77 = $5 + 15 | 0;
    $78 = $77 & 255;
    $79 = $$0513 + -2 | 0;
    HEAP8[$79 >> 0] = $78;
    $80 = ($3 | 0) < 1;
    $81 = $4 & 8;
    $82 = ($81 | 0) == 0;
    $$0525 = $8;
    $$2473 = $$1472;
    while (1) {
     $83 = ~~$$2473;
     $84 = 10816 + $83 | 0;
     $85 = HEAP8[$84 >> 0] | 0;
     $86 = $85 & 255;
     $87 = $44 | $86;
     $88 = $87 & 255;
     $89 = $$0525 + 1 | 0;
     HEAP8[$$0525 >> 0] = $88;
     $90 = +($83 | 0);
     $91 = $$2473 - $90;
     $92 = $91 * 16.0;
     $93 = $89;
     $94 = $93 - $9 | 0;
     $95 = ($94 | 0) == 1;
     if ($95) {
      $96 = $92 == 0.0;
      $or$cond3$not = $80 & $96;
      $or$cond = $82 & $or$cond3$not;
      if ($or$cond) {
       $$1526 = $89;
      } else {
       $97 = $$0525 + 2 | 0;
       HEAP8[$89 >> 0] = 46;
       $$1526 = $97;
      }
     } else {
      $$1526 = $89;
     }
     $98 = $92 != 0.0;
     if ($98) {
      $$0525 = $$1526;
      $$2473 = $92;
     } else {
      break;
     }
    }
    $99 = ($3 | 0) == 0;
    $$pre720 = $$1526;
    if ($99) {
     label = 25;
    } else {
     $100 = -2 - $9 | 0;
     $101 = $100 + $$pre720 | 0;
     $102 = ($101 | 0) < ($3 | 0);
     if ($102) {
      $103 = $11;
      $104 = $79;
      $105 = $3 + 2 | 0;
      $106 = $105 + $103 | 0;
      $107 = $106 - $104 | 0;
      $$0527 = $107;
      $$pre$phi717Z2D = $103;
      $$pre$phi718Z2D = $104;
     } else {
      label = 25;
     }
    }
    if ((label | 0) == 25) {
     $108 = $11;
     $109 = $79;
     $110 = $108 - $9 | 0;
     $111 = $110 - $109 | 0;
     $112 = $111 + $$pre720 | 0;
     $$0527 = $112;
     $$pre$phi717Z2D = $108;
     $$pre$phi718Z2D = $109;
    }
    $113 = $$0527 + $47 | 0;
    _pad($0, 32, $2, $113, $4);
    _out($0, $spec$select, $47);
    $114 = $4 ^ 65536;
    _pad($0, 48, $2, $113, $114);
    $115 = $$pre720 - $9 | 0;
    _out($0, $8, $115);
    $116 = $$pre$phi717Z2D - $$pre$phi718Z2D | 0;
    $117 = $115 + $116 | 0;
    $118 = $$0527 - $117 | 0;
    _pad($0, 48, $118, 0, 0);
    _out($0, $79, $116);
    $119 = $4 ^ 8192;
    _pad($0, 32, $2, $113, $119);
    $$sink757 = $113;
    break;
   }
   $120 = ($3 | 0) < 0;
   $spec$select539 = $120 ? 6 : $3;
   if ($39) {
    $121 = $38 * 268435456.0;
    $122 = HEAP32[$7 >> 2] | 0;
    $123 = $122 + -28 | 0;
    HEAP32[$7 >> 2] = $123;
    $$3 = $121;
    $$pr = $123;
   } else {
    $$pre = HEAP32[$7 >> 2] | 0;
    $$3 = $38;
    $$pr = $$pre;
   }
   $124 = ($$pr | 0) < 0;
   $125 = $6 + 288 | 0;
   $$0498 = $124 ? $6 : $125;
   $$1499 = $$0498;
   $$4 = $$3;
   while (1) {
    $126 = ~~$$4 >>> 0;
    HEAP32[$$1499 >> 2] = $126;
    $127 = $$1499 + 4 | 0;
    $128 = +($126 >>> 0);
    $129 = $$4 - $128;
    $130 = $129 * 1.0e9;
    $131 = $130 != 0.0;
    if ($131) {
     $$1499 = $127;
     $$4 = $130;
    } else {
     break;
    }
   }
   $132 = $$0498;
   $133 = ($$pr | 0) > 0;
   if ($133) {
    $$1482683 = $$0498;
    $$2500682 = $127;
    $134 = $$pr;
    while (1) {
     $135 = ($134 | 0) < 29;
     $136 = $135 ? $134 : 29;
     $$0488669 = $$2500682 + -4 | 0;
     $137 = $$0488669 >>> 0 < $$1482683 >>> 0;
     if ($137) {
      $$2483 = $$1482683;
     } else {
      $$0488671 = $$0488669;
      $$0497670 = 0;
      while (1) {
       $138 = HEAP32[$$0488671 >> 2] | 0;
       $139 = _bitshift64Shl($138 | 0, 0, $136 | 0) | 0;
       $140 = getTempRet0() | 0;
       $141 = _i64Add($139 | 0, $140 | 0, $$0497670 | 0, 0) | 0;
       $142 = getTempRet0() | 0;
       $143 = ___udivdi3($141 | 0, $142 | 0, 1e9, 0) | 0;
       $144 = getTempRet0() | 0;
       $145 = ___muldi3($143 | 0, $144 | 0, 1e9, 0) | 0;
       $146 = getTempRet0() | 0;
       $147 = _i64Subtract($141 | 0, $142 | 0, $145 | 0, $146 | 0) | 0;
       $148 = getTempRet0() | 0;
       HEAP32[$$0488671 >> 2] = $147;
       $$0488 = $$0488671 + -4 | 0;
       $149 = $$0488 >>> 0 < $$1482683 >>> 0;
       if ($149) {
        break;
       } else {
        $$0488671 = $$0488;
        $$0497670 = $143;
       }
      }
      $150 = ($143 | 0) == 0;
      if ($150) {
       $$2483 = $$1482683;
      } else {
       $151 = $$1482683 + -4 | 0;
       HEAP32[$151 >> 2] = $143;
       $$2483 = $151;
      }
     }
     $152 = $$2500682 >>> 0 > $$2483 >>> 0;
     L57 : do {
      if ($152) {
       $$3501676 = $$2500682;
       while (1) {
        $153 = $$3501676 + -4 | 0;
        $155 = HEAP32[$153 >> 2] | 0;
        $156 = ($155 | 0) == 0;
        if (!$156) {
         $$3501$lcssa = $$3501676;
         break L57;
        }
        $154 = $153 >>> 0 > $$2483 >>> 0;
        if ($154) {
         $$3501676 = $153;
        } else {
         $$3501$lcssa = $153;
         break;
        }
       }
      } else {
       $$3501$lcssa = $$2500682;
      }
     } while (0);
     $157 = HEAP32[$7 >> 2] | 0;
     $158 = $157 - $136 | 0;
     HEAP32[$7 >> 2] = $158;
     $159 = ($158 | 0) > 0;
     if ($159) {
      $$1482683 = $$2483;
      $$2500682 = $$3501$lcssa;
      $134 = $158;
     } else {
      $$1482$lcssa = $$2483;
      $$2500$lcssa = $$3501$lcssa;
      $$pr564 = $158;
      break;
     }
    }
   } else {
    $$1482$lcssa = $$0498;
    $$2500$lcssa = $127;
    $$pr564 = $$pr;
   }
   $160 = ($$pr564 | 0) < 0;
   if ($160) {
    $161 = $spec$select539 + 25 | 0;
    $162 = ($161 | 0) / 9 & -1;
    $163 = $162 + 1 | 0;
    $164 = ($42 | 0) == 102;
    $$3484663 = $$1482$lcssa;
    $$4502662 = $$2500$lcssa;
    $166 = $$pr564;
    while (1) {
     $165 = 0 - $166 | 0;
     $167 = ($165 | 0) < 9;
     $168 = $167 ? $165 : 9;
     $169 = $$3484663 >>> 0 < $$4502662 >>> 0;
     if ($169) {
      $173 = 1 << $168;
      $174 = $173 + -1 | 0;
      $175 = 1e9 >>> $168;
      $$0487657 = 0;
      $$1489656 = $$3484663;
      while (1) {
       $176 = HEAP32[$$1489656 >> 2] | 0;
       $177 = $176 & $174;
       $178 = $176 >>> $168;
       $179 = $178 + $$0487657 | 0;
       HEAP32[$$1489656 >> 2] = $179;
       $180 = Math_imul($177, $175) | 0;
       $181 = $$1489656 + 4 | 0;
       $182 = $181 >>> 0 < $$4502662 >>> 0;
       if ($182) {
        $$0487657 = $180;
        $$1489656 = $181;
       } else {
        break;
       }
      }
      $183 = HEAP32[$$3484663 >> 2] | 0;
      $184 = ($183 | 0) == 0;
      $185 = $$3484663 + 4 | 0;
      $spec$select540 = $184 ? $185 : $$3484663;
      $186 = ($180 | 0) == 0;
      if ($186) {
       $$5503 = $$4502662;
       $spec$select540723 = $spec$select540;
      } else {
       $187 = $$4502662 + 4 | 0;
       HEAP32[$$4502662 >> 2] = $180;
       $$5503 = $187;
       $spec$select540723 = $spec$select540;
      }
     } else {
      $170 = HEAP32[$$3484663 >> 2] | 0;
      $171 = ($170 | 0) == 0;
      $172 = $$3484663 + 4 | 0;
      $spec$select540722 = $171 ? $172 : $$3484663;
      $$5503 = $$4502662;
      $spec$select540723 = $spec$select540722;
     }
     $188 = $164 ? $$0498 : $spec$select540723;
     $189 = $$5503;
     $190 = $188;
     $191 = $189 - $190 | 0;
     $192 = $191 >> 2;
     $193 = ($192 | 0) > ($163 | 0);
     $194 = $188 + ($163 << 2) | 0;
     $spec$select541 = $193 ? $194 : $$5503;
     $195 = HEAP32[$7 >> 2] | 0;
     $196 = $195 + $168 | 0;
     HEAP32[$7 >> 2] = $196;
     $197 = ($196 | 0) < 0;
     if ($197) {
      $$3484663 = $spec$select540723;
      $$4502662 = $spec$select541;
      $166 = $196;
     } else {
      $$3484$lcssa = $spec$select540723;
      $$4502$lcssa = $spec$select541;
      break;
     }
    }
   } else {
    $$3484$lcssa = $$1482$lcssa;
    $$4502$lcssa = $$2500$lcssa;
   }
   $198 = $$3484$lcssa >>> 0 < $$4502$lcssa >>> 0;
   if ($198) {
    $199 = $$3484$lcssa;
    $200 = $132 - $199 | 0;
    $201 = $200 >> 2;
    $202 = $201 * 9 | 0;
    $203 = HEAP32[$$3484$lcssa >> 2] | 0;
    $204 = $203 >>> 0 < 10;
    if ($204) {
     $$1517 = $202;
    } else {
     $$0516652 = $202;
     $$0532651 = 10;
     while (1) {
      $205 = $$0532651 * 10 | 0;
      $206 = $$0516652 + 1 | 0;
      $207 = $203 >>> 0 < $205 >>> 0;
      if ($207) {
       $$1517 = $206;
       break;
      } else {
       $$0516652 = $206;
       $$0532651 = $205;
      }
     }
    }
   } else {
    $$1517 = 0;
   }
   $208 = ($42 | 0) == 102;
   $209 = $208 ? 0 : $$1517;
   $210 = $spec$select539 - $209 | 0;
   $211 = ($42 | 0) == 103;
   $212 = ($spec$select539 | 0) != 0;
   $213 = $212 & $211;
   $$neg = $213 << 31 >> 31;
   $214 = $210 + $$neg | 0;
   $215 = $$4502$lcssa;
   $216 = $215 - $132 | 0;
   $217 = $216 >> 2;
   $218 = $217 * 9 | 0;
   $219 = $218 + -9 | 0;
   $220 = ($214 | 0) < ($219 | 0);
   if ($220) {
    $221 = $$0498 + 4 | 0;
    $222 = $214 + 9216 | 0;
    $223 = ($222 | 0) / 9 & -1;
    $224 = $223 + -1024 | 0;
    $225 = $221 + ($224 << 2) | 0;
    $226 = $223 * 9 | 0;
    $227 = $222 - $226 | 0;
    $228 = ($227 | 0) < 8;
    if ($228) {
     $$0529$in646 = $227;
     $$1533645 = 10;
     while (1) {
      $$0529 = $$0529$in646 + 1 | 0;
      $229 = $$1533645 * 10 | 0;
      $230 = ($$0529$in646 | 0) < 7;
      if ($230) {
       $$0529$in646 = $$0529;
       $$1533645 = $229;
      } else {
       $$1533$lcssa = $229;
       break;
      }
     }
    } else {
     $$1533$lcssa = 10;
    }
    $231 = HEAP32[$225 >> 2] | 0;
    $232 = ($231 >>> 0) / ($$1533$lcssa >>> 0) & -1;
    $233 = Math_imul($232, $$1533$lcssa) | 0;
    $234 = $231 - $233 | 0;
    $235 = ($234 | 0) == 0;
    $236 = $225 + 4 | 0;
    $237 = ($236 | 0) == ($$4502$lcssa | 0);
    $or$cond543 = $237 & $235;
    if ($or$cond543) {
     $$4492 = $225;
     $$4520 = $$1517;
     $$8 = $$3484$lcssa;
    } else {
     $238 = $232 & 1;
     $239 = ($238 | 0) == 0;
     $spec$select544 = $239 ? 9007199254740992.0 : 9007199254740994.0;
     $240 = $$1533$lcssa >>> 1;
     $241 = $234 >>> 0 < $240 >>> 0;
     $242 = ($234 | 0) == ($240 | 0);
     $or$cond546 = $237 & $242;
     $spec$select561 = $or$cond546 ? 1.0 : 1.5;
     $spec$select567 = $241 ? .5 : $spec$select561;
     $243 = ($$0522 | 0) == 0;
     if ($243) {
      $$1467 = $spec$select567;
      $$1469 = $spec$select544;
     } else {
      $244 = HEAP8[$$0523 >> 0] | 0;
      $245 = $244 << 24 >> 24 == 45;
      $246 = -$spec$select544;
      $247 = -$spec$select567;
      $spec$select568 = $245 ? $246 : $spec$select544;
      $spec$select569 = $245 ? $247 : $spec$select567;
      $$1467 = $spec$select569;
      $$1469 = $spec$select568;
     }
     $248 = $231 - $234 | 0;
     HEAP32[$225 >> 2] = $248;
     $249 = $$1469 + $$1467;
     $250 = $249 != $$1469;
     if ($250) {
      $251 = $248 + $$1533$lcssa | 0;
      HEAP32[$225 >> 2] = $251;
      $252 = $251 >>> 0 > 999999999;
      if ($252) {
       $$2490638 = $225;
       $$5486639 = $$3484$lcssa;
       while (1) {
        $253 = $$2490638 + -4 | 0;
        HEAP32[$$2490638 >> 2] = 0;
        $254 = $253 >>> 0 < $$5486639 >>> 0;
        if ($254) {
         $255 = $$5486639 + -4 | 0;
         HEAP32[$255 >> 2] = 0;
         $$6 = $255;
        } else {
         $$6 = $$5486639;
        }
        $256 = HEAP32[$253 >> 2] | 0;
        $257 = $256 + 1 | 0;
        HEAP32[$253 >> 2] = $257;
        $258 = $257 >>> 0 > 999999999;
        if ($258) {
         $$2490638 = $253;
         $$5486639 = $$6;
        } else {
         $$2490$lcssa = $253;
         $$5486$lcssa = $$6;
         break;
        }
       }
      } else {
       $$2490$lcssa = $225;
       $$5486$lcssa = $$3484$lcssa;
      }
      $259 = $$5486$lcssa;
      $260 = $132 - $259 | 0;
      $261 = $260 >> 2;
      $262 = $261 * 9 | 0;
      $263 = HEAP32[$$5486$lcssa >> 2] | 0;
      $264 = $263 >>> 0 < 10;
      if ($264) {
       $$4492 = $$2490$lcssa;
       $$4520 = $262;
       $$8 = $$5486$lcssa;
      } else {
       $$2518634 = $262;
       $$2534633 = 10;
       while (1) {
        $265 = $$2534633 * 10 | 0;
        $266 = $$2518634 + 1 | 0;
        $267 = $263 >>> 0 < $265 >>> 0;
        if ($267) {
         $$4492 = $$2490$lcssa;
         $$4520 = $266;
         $$8 = $$5486$lcssa;
         break;
        } else {
         $$2518634 = $266;
         $$2534633 = $265;
        }
       }
      }
     } else {
      $$4492 = $225;
      $$4520 = $$1517;
      $$8 = $$3484$lcssa;
     }
    }
    $268 = $$4492 + 4 | 0;
    $269 = $$4502$lcssa >>> 0 > $268 >>> 0;
    $spec$select547 = $269 ? $268 : $$4502$lcssa;
    $$5521 = $$4520;
    $$8506 = $spec$select547;
    $$9 = $$8;
   } else {
    $$5521 = $$1517;
    $$8506 = $$4502$lcssa;
    $$9 = $$3484$lcssa;
   }
   $270 = 0 - $$5521 | 0;
   $271 = $$8506 >>> 0 > $$9 >>> 0;
   L109 : do {
    if ($271) {
     $$9507625 = $$8506;
     while (1) {
      $272 = $$9507625 + -4 | 0;
      $274 = HEAP32[$272 >> 2] | 0;
      $275 = ($274 | 0) == 0;
      if (!$275) {
       $$9507$lcssa = $$9507625;
       $$lcssa583 = 1;
       break L109;
      }
      $273 = $272 >>> 0 > $$9 >>> 0;
      if ($273) {
       $$9507625 = $272;
      } else {
       $$9507$lcssa = $272;
       $$lcssa583 = 0;
       break;
      }
     }
    } else {
     $$9507$lcssa = $$8506;
     $$lcssa583 = 0;
    }
   } while (0);
   do {
    if ($211) {
     $not$ = $212 ^ 1;
     $276 = $not$ & 1;
     $spec$select548 = $spec$select539 + $276 | 0;
     $277 = ($spec$select548 | 0) > ($$5521 | 0);
     $278 = ($$5521 | 0) > -5;
     $or$cond6 = $277 & $278;
     if ($or$cond6) {
      $279 = $5 + -1 | 0;
      $$neg571 = $spec$select548 + -1 | 0;
      $280 = $$neg571 - $$5521 | 0;
      $$0479 = $279;
      $$2476 = $280;
     } else {
      $281 = $5 + -2 | 0;
      $282 = $spec$select548 + -1 | 0;
      $$0479 = $281;
      $$2476 = $282;
     }
     $283 = $4 & 8;
     $284 = ($283 | 0) == 0;
     if ($284) {
      if ($$lcssa583) {
       $285 = $$9507$lcssa + -4 | 0;
       $286 = HEAP32[$285 >> 2] | 0;
       $287 = ($286 | 0) == 0;
       if ($287) {
        $$2531 = 9;
       } else {
        $288 = ($286 >>> 0) % 10 & -1;
        $289 = ($288 | 0) == 0;
        if ($289) {
         $$1530621 = 0;
         $$3535620 = 10;
         while (1) {
          $290 = $$3535620 * 10 | 0;
          $291 = $$1530621 + 1 | 0;
          $292 = ($286 >>> 0) % ($290 >>> 0) & -1;
          $293 = ($292 | 0) == 0;
          if ($293) {
           $$1530621 = $291;
           $$3535620 = $290;
          } else {
           $$2531 = $291;
           break;
          }
         }
        } else {
         $$2531 = 0;
        }
       }
      } else {
       $$2531 = 9;
      }
      $294 = $$0479 | 32;
      $295 = ($294 | 0) == 102;
      $296 = $$9507$lcssa;
      $297 = $296 - $132 | 0;
      $298 = $297 >> 2;
      $299 = $298 * 9 | 0;
      $300 = $299 + -9 | 0;
      if ($295) {
       $301 = $300 - $$2531 | 0;
       $302 = ($301 | 0) > 0;
       $spec$select549 = $302 ? $301 : 0;
       $303 = ($$2476 | 0) < ($spec$select549 | 0);
       $spec$select562 = $303 ? $$2476 : $spec$select549;
       $$1480 = $$0479;
       $$3477 = $spec$select562;
       break;
      } else {
       $304 = $300 + $$5521 | 0;
       $305 = $304 - $$2531 | 0;
       $306 = ($305 | 0) > 0;
       $spec$select551 = $306 ? $305 : 0;
       $307 = ($$2476 | 0) < ($spec$select551 | 0);
       $spec$select563 = $307 ? $$2476 : $spec$select551;
       $$1480 = $$0479;
       $$3477 = $spec$select563;
       break;
      }
     } else {
      $$1480 = $$0479;
      $$3477 = $$2476;
     }
    } else {
     $$1480 = $5;
     $$3477 = $spec$select539;
    }
   } while (0);
   $308 = ($$3477 | 0) != 0;
   $309 = $4 >>> 3;
   $$lobit = $309 & 1;
   $310 = $308 ? 1 : $$lobit;
   $311 = $$1480 | 32;
   $312 = ($311 | 0) == 102;
   if ($312) {
    $313 = ($$5521 | 0) > 0;
    $314 = $313 ? $$5521 : 0;
    $$2515 = 0;
    $$pn = $314;
   } else {
    $315 = ($$5521 | 0) < 0;
    $316 = $315 ? $270 : $$5521;
    $317 = ($316 | 0) < 0;
    $318 = $317 << 31 >> 31;
    $319 = _fmt_u($316, $318, $11) | 0;
    $320 = $11;
    $321 = $319;
    $322 = $320 - $321 | 0;
    $323 = ($322 | 0) < 2;
    if ($323) {
     $$1514614 = $319;
     while (1) {
      $324 = $$1514614 + -1 | 0;
      HEAP8[$324 >> 0] = 48;
      $325 = $324;
      $326 = $320 - $325 | 0;
      $327 = ($326 | 0) < 2;
      if ($327) {
       $$1514614 = $324;
      } else {
       $$1514$lcssa = $324;
       break;
      }
     }
    } else {
     $$1514$lcssa = $319;
    }
    $328 = $$5521 >> 31;
    $329 = $328 & 2;
    $330 = $329 + 43 | 0;
    $331 = $330 & 255;
    $332 = $$1514$lcssa + -1 | 0;
    HEAP8[$332 >> 0] = $331;
    $333 = $$1480 & 255;
    $334 = $$1514$lcssa + -2 | 0;
    HEAP8[$334 >> 0] = $333;
    $335 = $334;
    $336 = $320 - $335 | 0;
    $$2515 = $334;
    $$pn = $336;
   }
   $337 = $$0522 + 1 | 0;
   $338 = $337 + $$3477 | 0;
   $$1528 = $338 + $310 | 0;
   $339 = $$1528 + $$pn | 0;
   _pad($0, 32, $2, $339, $4);
   _out($0, $$0523, $$0522);
   $340 = $4 ^ 65536;
   _pad($0, 48, $2, $339, $340);
   if ($312) {
    $341 = $$9 >>> 0 > $$0498 >>> 0;
    $spec$select554 = $341 ? $$0498 : $$9;
    $342 = $8 + 9 | 0;
    $343 = $342;
    $344 = $8 + 8 | 0;
    $$5493603 = $spec$select554;
    while (1) {
     $345 = HEAP32[$$5493603 >> 2] | 0;
     $346 = _fmt_u($345, 0, $342) | 0;
     $347 = ($$5493603 | 0) == ($spec$select554 | 0);
     if ($347) {
      $353 = ($346 | 0) == ($342 | 0);
      if ($353) {
       HEAP8[$344 >> 0] = 48;
       $$1465 = $344;
      } else {
       $$1465 = $346;
      }
     } else {
      $348 = $346 >>> 0 > $8 >>> 0;
      if ($348) {
       $349 = $346;
       $350 = $349 - $9 | 0;
       _memset($8 | 0, 48, $350 | 0) | 0;
       $$0464599 = $346;
       while (1) {
        $351 = $$0464599 + -1 | 0;
        $352 = $351 >>> 0 > $8 >>> 0;
        if ($352) {
         $$0464599 = $351;
        } else {
         $$1465 = $351;
         break;
        }
       }
      } else {
       $$1465 = $346;
      }
     }
     $354 = $$1465;
     $355 = $343 - $354 | 0;
     _out($0, $$1465, $355);
     $356 = $$5493603 + 4 | 0;
     $357 = $356 >>> 0 > $$0498 >>> 0;
     if ($357) {
      break;
     } else {
      $$5493603 = $356;
     }
    }
    $$not = $308 ^ 1;
    $358 = $4 & 8;
    $359 = ($358 | 0) == 0;
    $or$cond556 = $359 & $$not;
    if (!$or$cond556) {
     _out($0, 35399, 1);
    }
    $360 = $356 >>> 0 < $$9507$lcssa >>> 0;
    $361 = ($$3477 | 0) > 0;
    $362 = $360 & $361;
    if ($362) {
     $$4478594 = $$3477;
     $$6494593 = $356;
     while (1) {
      $363 = HEAP32[$$6494593 >> 2] | 0;
      $364 = _fmt_u($363, 0, $342) | 0;
      $365 = $364 >>> 0 > $8 >>> 0;
      if ($365) {
       $366 = $364;
       $367 = $366 - $9 | 0;
       _memset($8 | 0, 48, $367 | 0) | 0;
       $$0463588 = $364;
       while (1) {
        $368 = $$0463588 + -1 | 0;
        $369 = $368 >>> 0 > $8 >>> 0;
        if ($369) {
         $$0463588 = $368;
        } else {
         $$0463$lcssa = $368;
         break;
        }
       }
      } else {
       $$0463$lcssa = $364;
      }
      $370 = ($$4478594 | 0) < 9;
      $371 = $370 ? $$4478594 : 9;
      _out($0, $$0463$lcssa, $371);
      $372 = $$6494593 + 4 | 0;
      $373 = $$4478594 + -9 | 0;
      $374 = $372 >>> 0 < $$9507$lcssa >>> 0;
      $375 = ($$4478594 | 0) > 9;
      $376 = $374 & $375;
      if ($376) {
       $$4478594 = $373;
       $$6494593 = $372;
      } else {
       $$4478$lcssa = $373;
       break;
      }
     }
    } else {
     $$4478$lcssa = $$3477;
    }
    $377 = $$4478$lcssa + 9 | 0;
    _pad($0, 48, $377, 9, 0);
   } else {
    $378 = $$9 + 4 | 0;
    $spec$select557 = $$lcssa583 ? $$9507$lcssa : $378;
    $379 = $$9 >>> 0 < $spec$select557 >>> 0;
    $380 = ($$3477 | 0) > -1;
    $381 = $379 & $380;
    if ($381) {
     $382 = $8 + 9 | 0;
     $383 = $4 & 8;
     $384 = ($383 | 0) == 0;
     $385 = $382;
     $386 = 0 - $9 | 0;
     $387 = $8 + 8 | 0;
     $$5609 = $$3477;
     $$7495608 = $$9;
     while (1) {
      $388 = HEAP32[$$7495608 >> 2] | 0;
      $389 = _fmt_u($388, 0, $382) | 0;
      $390 = ($389 | 0) == ($382 | 0);
      if ($390) {
       HEAP8[$387 >> 0] = 48;
       $$0 = $387;
      } else {
       $$0 = $389;
      }
      $391 = ($$7495608 | 0) == ($$9 | 0);
      do {
       if ($391) {
        $395 = $$0 + 1 | 0;
        _out($0, $$0, 1);
        $396 = ($$5609 | 0) < 1;
        $or$cond559 = $384 & $396;
        if ($or$cond559) {
         $$2 = $395;
         break;
        }
        _out($0, 35399, 1);
        $$2 = $395;
       } else {
        $392 = $$0 >>> 0 > $8 >>> 0;
        if (!$392) {
         $$2 = $$0;
         break;
        }
        $scevgep711 = $$0 + $386 | 0;
        $scevgep711712 = $scevgep711;
        _memset($8 | 0, 48, $scevgep711712 | 0) | 0;
        $$1604 = $$0;
        while (1) {
         $393 = $$1604 + -1 | 0;
         $394 = $393 >>> 0 > $8 >>> 0;
         if ($394) {
          $$1604 = $393;
         } else {
          $$2 = $393;
          break;
         }
        }
       }
      } while (0);
      $397 = $$2;
      $398 = $385 - $397 | 0;
      $399 = ($$5609 | 0) > ($398 | 0);
      $400 = $399 ? $398 : $$5609;
      _out($0, $$2, $400);
      $401 = $$5609 - $398 | 0;
      $402 = $$7495608 + 4 | 0;
      $403 = $402 >>> 0 < $spec$select557 >>> 0;
      $404 = ($401 | 0) > -1;
      $405 = $403 & $404;
      if ($405) {
       $$5609 = $401;
       $$7495608 = $402;
      } else {
       $$5$lcssa = $401;
       break;
      }
     }
    } else {
     $$5$lcssa = $$3477;
    }
    $406 = $$5$lcssa + 18 | 0;
    _pad($0, 48, $406, 18, 0);
    $407 = $11;
    $408 = $$2515;
    $409 = $407 - $408 | 0;
    _out($0, $$2515, $409);
   }
   $410 = $4 ^ 8192;
   _pad($0, 32, $2, $339, $410);
   $$sink757 = $339;
  }
 } while (0);
 $411 = ($$sink757 | 0) < ($2 | 0);
 $$560 = $411 ? $2 : $$sink757;
 STACKTOP = sp;
 return $$560 | 0;
}

function _printf_core($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $$ = 0, $$0 = 0, $$0231 = 0, $$0232336 = 0, $$0234 = 0, $$0237 = 0, $$0239 = 0, $$0242315 = 0, $$0242315373 = 0, $$0242335 = 0, $$0245 = 0, $$0245$ph = 0, $$0245$ph$be = 0, $$0249 = 0, $$0249$ph = 0, $$0251$lcssa = 0, $$0251323 = 0, $$0254 = 0, $$0255 = 0, $$0256 = 0, $$0261 = 0, $$0264$lcssa = 0, $$0264330 = 0, $$0271$ph = 0, $$1 = 0, $$1233342 = 0, $$1235 = 0, $$1238 = 0, $$1240 = 0, $$1243341 = 0, $$1250 = 0, $$1252 = 0, $$1257 = 0, $$1262 = 0, $$1265 = 0, $$1272 = 0, $$2236 = 0, $$2241 = 0, $$2244322 = 0, $$2258 = 0, $$2258$ = 0, $$2263 = 0, $$2273 = 0, $$3259 = 0, $$3267 = 0, $$3274 = 0, $$3319 = 0, $$4260372 = 0, $$4268 = 0, $$5 = 0, $$6270 = 0, $$lcssa310 = 0, $$pre = 0, $$pre$phiZ2D = 0, $$pre362 = 0, $$pre364 = 0, $$pre365 = 0, $$pre365$pre = 0, $$pre366 = 0, $$pre370 = 0, $$sink = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0.0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $arglist_current = 0, $arglist_current2 = 0, $arglist_next = 0, $arglist_next3 = 0, $brmerge = 0, $brmerge328 = 0, $expanded = 0, $expanded10 = 0, $expanded11 = 0, $expanded13 = 0, $expanded14 = 0, $expanded15 = 0, $expanded4 = 0, $expanded6 = 0, $expanded7 = 0, $expanded8 = 0, $or$cond = 0, $or$cond278 = 0, $or$cond280 = 0, $or$cond285 = 0, $spec$select = 0, $spec$select283 = 0, $spec$select286 = 0, $spec$select293 = 0, $spec$select294 = 0, $spec$select295 = 0, $spec$select296 = 0, $spec$select297 = 0, $spec$select298 = 0, $spec$select299 = 0, $spec$select300 = 0, $spec$select301 = 0, $storemerge275$lcssa = 0, $storemerge275329 = 0, $storemerge276 = 0, $trunc = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $7 = sp + 56 | 0;
 $8 = sp + 40 | 0;
 $9 = sp;
 $10 = sp + 48 | 0;
 $11 = sp + 60 | 0;
 HEAP32[$7 >> 2] = $1;
 $12 = ($0 | 0) != (0 | 0);
 $13 = $9 + 40 | 0;
 $14 = $13;
 $15 = $9 + 39 | 0;
 $16 = $10 + 4 | 0;
 $$0245$ph = 0;
 $$0249$ph = 0;
 $$0271$ph = 0;
 L1 : while (1) {
  $$0245 = $$0245$ph;
  $$0249 = $$0249$ph;
  while (1) {
   $17 = ($$0249 | 0) > -1;
   do {
    if ($17) {
     $18 = 2147483647 - $$0249 | 0;
     $19 = ($$0245 | 0) > ($18 | 0);
     if ($19) {
      $20 = ___errno_location() | 0;
      HEAP32[$20 >> 2] = 75;
      $$1250 = -1;
      break;
     } else {
      $21 = $$0245 + $$0249 | 0;
      $$1250 = $21;
      break;
     }
    } else {
     $$1250 = $$0249;
    }
   } while (0);
   $22 = HEAP32[$7 >> 2] | 0;
   $23 = HEAP8[$22 >> 0] | 0;
   $24 = $23 << 24 >> 24 == 0;
   if ($24) {
    label = 92;
    break L1;
   }
   $25 = $23;
   $27 = $22;
   L12 : while (1) {
    switch ($25 << 24 >> 24) {
    case 37:
     {
      label = 10;
      break L12;
      break;
     }
    case 0:
     {
      $$0251$lcssa = $27;
      break L12;
      break;
     }
    default:
     {}
    }
    $26 = $27 + 1 | 0;
    HEAP32[$7 >> 2] = $26;
    $$pre = HEAP8[$26 >> 0] | 0;
    $25 = $$pre;
    $27 = $26;
   }
   L15 : do {
    if ((label | 0) == 10) {
     label = 0;
     $$0251323 = $27;
     $29 = $27;
     while (1) {
      $28 = $29 + 1 | 0;
      $30 = HEAP8[$28 >> 0] | 0;
      $31 = $30 << 24 >> 24 == 37;
      if (!$31) {
       $$0251$lcssa = $$0251323;
       break L15;
      }
      $32 = $$0251323 + 1 | 0;
      $33 = $29 + 2 | 0;
      HEAP32[$7 >> 2] = $33;
      $34 = HEAP8[$33 >> 0] | 0;
      $35 = $34 << 24 >> 24 == 37;
      if ($35) {
       $$0251323 = $32;
       $29 = $33;
      } else {
       $$0251$lcssa = $32;
       break;
      }
     }
    }
   } while (0);
   $36 = $$0251$lcssa;
   $37 = $22;
   $38 = $36 - $37 | 0;
   if ($12) {
    _out($0, $22, $38);
   }
   $39 = ($38 | 0) == 0;
   if ($39) {
    break;
   } else {
    $$0245 = $38;
    $$0249 = $$1250;
   }
  }
  $40 = HEAP32[$7 >> 2] | 0;
  $41 = $40 + 1 | 0;
  $42 = HEAP8[$41 >> 0] | 0;
  $43 = $42 << 24 >> 24;
  $44 = _isdigit($43) | 0;
  $45 = ($44 | 0) == 0;
  $$pre362 = HEAP32[$7 >> 2] | 0;
  if ($45) {
   $$0255 = -1;
   $$1272 = $$0271$ph;
   $$sink = 1;
  } else {
   $46 = $$pre362 + 2 | 0;
   $47 = HEAP8[$46 >> 0] | 0;
   $48 = $47 << 24 >> 24 == 36;
   if ($48) {
    $49 = $$pre362 + 1 | 0;
    $50 = HEAP8[$49 >> 0] | 0;
    $51 = $50 << 24 >> 24;
    $52 = $51 + -48 | 0;
    $$0255 = $52;
    $$1272 = 1;
    $$sink = 3;
   } else {
    $$0255 = -1;
    $$1272 = $$0271$ph;
    $$sink = 1;
   }
  }
  $53 = $$pre362 + $$sink | 0;
  HEAP32[$7 >> 2] = $53;
  $54 = HEAP8[$53 >> 0] | 0;
  $55 = $54 << 24 >> 24;
  $56 = $55 + -32 | 0;
  $57 = $56 >>> 0 > 31;
  $58 = 1 << $56;
  $59 = $58 & 75913;
  $60 = ($59 | 0) == 0;
  $brmerge328 = $57 | $60;
  if ($brmerge328) {
   $$0264$lcssa = 0;
   $$lcssa310 = $54;
   $storemerge275$lcssa = $53;
  } else {
   $$0264330 = 0;
   $62 = $56;
   $storemerge275329 = $53;
   while (1) {
    $61 = 1 << $62;
    $63 = $61 | $$0264330;
    $64 = $storemerge275329 + 1 | 0;
    HEAP32[$7 >> 2] = $64;
    $65 = HEAP8[$64 >> 0] | 0;
    $66 = $65 << 24 >> 24;
    $67 = $66 + -32 | 0;
    $68 = $67 >>> 0 > 31;
    $69 = 1 << $67;
    $70 = $69 & 75913;
    $71 = ($70 | 0) == 0;
    $brmerge = $68 | $71;
    if ($brmerge) {
     $$0264$lcssa = $63;
     $$lcssa310 = $65;
     $storemerge275$lcssa = $64;
     break;
    } else {
     $$0264330 = $63;
     $62 = $67;
     $storemerge275329 = $64;
    }
   }
  }
  $72 = $$lcssa310 << 24 >> 24 == 42;
  if ($72) {
   $73 = $storemerge275$lcssa + 1 | 0;
   $74 = HEAP8[$73 >> 0] | 0;
   $75 = $74 << 24 >> 24;
   $76 = _isdigit($75) | 0;
   $77 = ($76 | 0) == 0;
   if ($77) {
    label = 27;
   } else {
    $78 = HEAP32[$7 >> 2] | 0;
    $79 = $78 + 2 | 0;
    $80 = HEAP8[$79 >> 0] | 0;
    $81 = $80 << 24 >> 24 == 36;
    if ($81) {
     $82 = $78 + 1 | 0;
     $83 = HEAP8[$82 >> 0] | 0;
     $84 = $83 << 24 >> 24;
     $85 = $84 + -48 | 0;
     $86 = $4 + ($85 << 2) | 0;
     HEAP32[$86 >> 2] = 10;
     $87 = HEAP8[$82 >> 0] | 0;
     $88 = $87 << 24 >> 24;
     $89 = $88 + -48 | 0;
     $90 = $3 + ($89 << 3) | 0;
     $91 = $90;
     $92 = $91;
     $93 = HEAP32[$92 >> 2] | 0;
     $94 = $91 + 4 | 0;
     $95 = $94;
     $96 = HEAP32[$95 >> 2] | 0;
     $97 = $78 + 3 | 0;
     $$0261 = $93;
     $$2273 = 1;
     $storemerge276 = $97;
    } else {
     label = 27;
    }
   }
   if ((label | 0) == 27) {
    label = 0;
    $98 = ($$1272 | 0) == 0;
    if (!$98) {
     $$0 = -1;
     break;
    }
    if ($12) {
     $arglist_current = HEAP32[$2 >> 2] | 0;
     $99 = $arglist_current;
     $100 = 0 + 4 | 0;
     $expanded4 = $100;
     $expanded = $expanded4 - 1 | 0;
     $101 = $99 + $expanded | 0;
     $102 = 0 + 4 | 0;
     $expanded8 = $102;
     $expanded7 = $expanded8 - 1 | 0;
     $expanded6 = $expanded7 ^ -1;
     $103 = $101 & $expanded6;
     $104 = $103;
     $105 = HEAP32[$104 >> 2] | 0;
     $arglist_next = $104 + 4 | 0;
     HEAP32[$2 >> 2] = $arglist_next;
     $367 = $105;
    } else {
     $367 = 0;
    }
    $106 = HEAP32[$7 >> 2] | 0;
    $107 = $106 + 1 | 0;
    $$0261 = $367;
    $$2273 = 0;
    $storemerge276 = $107;
   }
   HEAP32[$7 >> 2] = $storemerge276;
   $108 = ($$0261 | 0) < 0;
   $109 = $$0264$lcssa | 8192;
   $110 = 0 - $$0261 | 0;
   $spec$select293 = $108 ? $109 : $$0264$lcssa;
   $spec$select294 = $108 ? $110 : $$0261;
   $$1262 = $spec$select294;
   $$1265 = $spec$select293;
   $$3274 = $$2273;
   $114 = $storemerge276;
  } else {
   $111 = _getint($7) | 0;
   $112 = ($111 | 0) < 0;
   if ($112) {
    $$0 = -1;
    break;
   }
   $$pre364 = HEAP32[$7 >> 2] | 0;
   $$1262 = $111;
   $$1265 = $$0264$lcssa;
   $$3274 = $$1272;
   $114 = $$pre364;
  }
  $113 = HEAP8[$114 >> 0] | 0;
  $115 = $113 << 24 >> 24 == 46;
  do {
   if ($115) {
    $116 = $114 + 1 | 0;
    $117 = HEAP8[$116 >> 0] | 0;
    $118 = $117 << 24 >> 24 == 42;
    if (!$118) {
     HEAP32[$7 >> 2] = $116;
     $154 = _getint($7) | 0;
     $$pre365$pre = HEAP32[$7 >> 2] | 0;
     $$0256 = $154;
     $$pre365 = $$pre365$pre;
     break;
    }
    $119 = $114 + 2 | 0;
    $120 = HEAP8[$119 >> 0] | 0;
    $121 = $120 << 24 >> 24;
    $122 = _isdigit($121) | 0;
    $123 = ($122 | 0) == 0;
    if (!$123) {
     $124 = HEAP32[$7 >> 2] | 0;
     $125 = $124 + 3 | 0;
     $126 = HEAP8[$125 >> 0] | 0;
     $127 = $126 << 24 >> 24 == 36;
     if ($127) {
      $128 = $124 + 2 | 0;
      $129 = HEAP8[$128 >> 0] | 0;
      $130 = $129 << 24 >> 24;
      $131 = $130 + -48 | 0;
      $132 = $4 + ($131 << 2) | 0;
      HEAP32[$132 >> 2] = 10;
      $133 = HEAP8[$128 >> 0] | 0;
      $134 = $133 << 24 >> 24;
      $135 = $134 + -48 | 0;
      $136 = $3 + ($135 << 3) | 0;
      $137 = $136;
      $138 = $137;
      $139 = HEAP32[$138 >> 2] | 0;
      $140 = $137 + 4 | 0;
      $141 = $140;
      $142 = HEAP32[$141 >> 2] | 0;
      $143 = $124 + 4 | 0;
      HEAP32[$7 >> 2] = $143;
      $$0256 = $139;
      $$pre365 = $143;
      break;
     }
    }
    $144 = ($$3274 | 0) == 0;
    if (!$144) {
     $$0 = -1;
     break L1;
    }
    if ($12) {
     $arglist_current2 = HEAP32[$2 >> 2] | 0;
     $145 = $arglist_current2;
     $146 = 0 + 4 | 0;
     $expanded11 = $146;
     $expanded10 = $expanded11 - 1 | 0;
     $147 = $145 + $expanded10 | 0;
     $148 = 0 + 4 | 0;
     $expanded15 = $148;
     $expanded14 = $expanded15 - 1 | 0;
     $expanded13 = $expanded14 ^ -1;
     $149 = $147 & $expanded13;
     $150 = $149;
     $151 = HEAP32[$150 >> 2] | 0;
     $arglist_next3 = $150 + 4 | 0;
     HEAP32[$2 >> 2] = $arglist_next3;
     $368 = $151;
    } else {
     $368 = 0;
    }
    $152 = HEAP32[$7 >> 2] | 0;
    $153 = $152 + 2 | 0;
    HEAP32[$7 >> 2] = $153;
    $$0256 = $368;
    $$pre365 = $153;
   } else {
    $$0256 = -1;
    $$pre365 = $114;
   }
  } while (0);
  $$0254 = 0;
  $156 = $$pre365;
  while (1) {
   $155 = HEAP8[$156 >> 0] | 0;
   $157 = $155 << 24 >> 24;
   $158 = $157 + -65 | 0;
   $159 = $158 >>> 0 > 57;
   if ($159) {
    $$0 = -1;
    break L1;
   }
   $160 = $156 + 1 | 0;
   HEAP32[$7 >> 2] = $160;
   $161 = HEAP8[$156 >> 0] | 0;
   $162 = $161 << 24 >> 24;
   $163 = $162 + -65 | 0;
   $164 = (10352 + ($$0254 * 58 | 0) | 0) + $163 | 0;
   $165 = HEAP8[$164 >> 0] | 0;
   $166 = $165 & 255;
   $167 = $166 + -1 | 0;
   $168 = $167 >>> 0 < 8;
   if ($168) {
    $$0254 = $166;
    $156 = $160;
   } else {
    break;
   }
  }
  $169 = $165 << 24 >> 24 == 0;
  if ($169) {
   $$0 = -1;
   break;
  }
  $170 = $165 << 24 >> 24 == 19;
  $171 = ($$0255 | 0) > -1;
  do {
   if ($170) {
    if ($171) {
     $$0 = -1;
     break L1;
    } else {
     label = 54;
    }
   } else {
    if ($171) {
     $172 = $4 + ($$0255 << 2) | 0;
     HEAP32[$172 >> 2] = $166;
     $173 = $3 + ($$0255 << 3) | 0;
     $174 = $173;
     $175 = $174;
     $176 = HEAP32[$175 >> 2] | 0;
     $177 = $174 + 4 | 0;
     $178 = $177;
     $179 = HEAP32[$178 >> 2] | 0;
     $180 = $8;
     $181 = $180;
     HEAP32[$181 >> 2] = $176;
     $182 = $180 + 4 | 0;
     $183 = $182;
     HEAP32[$183 >> 2] = $179;
     label = 54;
     break;
    }
    if (!$12) {
     $$0 = 0;
     break L1;
    }
    _pop_arg($8, $166, $2, $6);
    $$pre366 = HEAP32[$7 >> 2] | 0;
    $185 = $$pre366;
    label = 55;
   }
  } while (0);
  if ((label | 0) == 54) {
   label = 0;
   if ($12) {
    $185 = $160;
    label = 55;
   } else {
    $$0245$ph$be = 0;
   }
  }
  L77 : do {
   if ((label | 0) == 55) {
    label = 0;
    $184 = $185 + -1 | 0;
    $186 = HEAP8[$184 >> 0] | 0;
    $187 = $186 << 24 >> 24;
    $188 = ($$0254 | 0) != 0;
    $189 = $187 & 15;
    $190 = ($189 | 0) == 3;
    $or$cond278 = $188 & $190;
    $191 = $187 & -33;
    $$0237 = $or$cond278 ? $191 : $187;
    $192 = $$1265 & 8192;
    $193 = ($192 | 0) == 0;
    $194 = $$1265 & -65537;
    $spec$select = $193 ? $$1265 : $194;
    L79 : do {
     switch ($$0237 | 0) {
     case 110:
      {
       $trunc = $$0254 & 255;
       switch ($trunc << 24 >> 24) {
       case 0:
        {
         $201 = HEAP32[$8 >> 2] | 0;
         HEAP32[$201 >> 2] = $$1250;
         $$0245$ph$be = 0;
         break L77;
         break;
        }
       case 1:
        {
         $202 = HEAP32[$8 >> 2] | 0;
         HEAP32[$202 >> 2] = $$1250;
         $$0245$ph$be = 0;
         break L77;
         break;
        }
       case 2:
        {
         $203 = ($$1250 | 0) < 0;
         $204 = $203 << 31 >> 31;
         $205 = HEAP32[$8 >> 2] | 0;
         $206 = $205;
         $207 = $206;
         HEAP32[$207 >> 2] = $$1250;
         $208 = $206 + 4 | 0;
         $209 = $208;
         HEAP32[$209 >> 2] = $204;
         $$0245$ph$be = 0;
         break L77;
         break;
        }
       case 3:
        {
         $210 = $$1250 & 65535;
         $211 = HEAP32[$8 >> 2] | 0;
         HEAP16[$211 >> 1] = $210;
         $$0245$ph$be = 0;
         break L77;
         break;
        }
       case 4:
        {
         $212 = $$1250 & 255;
         $213 = HEAP32[$8 >> 2] | 0;
         HEAP8[$213 >> 0] = $212;
         $$0245$ph$be = 0;
         break L77;
         break;
        }
       case 6:
        {
         $214 = HEAP32[$8 >> 2] | 0;
         HEAP32[$214 >> 2] = $$1250;
         $$0245$ph$be = 0;
         break L77;
         break;
        }
       case 7:
        {
         $215 = ($$1250 | 0) < 0;
         $216 = $215 << 31 >> 31;
         $217 = HEAP32[$8 >> 2] | 0;
         $218 = $217;
         $219 = $218;
         HEAP32[$219 >> 2] = $$1250;
         $220 = $218 + 4 | 0;
         $221 = $220;
         HEAP32[$221 >> 2] = $216;
         $$0245$ph$be = 0;
         break L77;
         break;
        }
       default:
        {
         $$0245$ph$be = 0;
         break L77;
        }
       }
       break;
      }
     case 112:
      {
       $222 = $$0256 >>> 0 > 8;
       $223 = $222 ? $$0256 : 8;
       $224 = $spec$select | 8;
       $$1238 = 120;
       $$1257 = $223;
       $$3267 = $224;
       label = 67;
       break;
      }
     case 88:
     case 120:
      {
       $$1238 = $$0237;
       $$1257 = $$0256;
       $$3267 = $spec$select;
       label = 67;
       break;
      }
     case 111:
      {
       $246 = $8;
       $247 = $246;
       $248 = HEAP32[$247 >> 2] | 0;
       $249 = $246 + 4 | 0;
       $250 = $249;
       $251 = HEAP32[$250 >> 2] | 0;
       $252 = _fmt_o($248, $251, $13) | 0;
       $253 = $spec$select & 8;
       $254 = ($253 | 0) == 0;
       $255 = $252;
       $256 = $14 - $255 | 0;
       $257 = ($$0256 | 0) > ($256 | 0);
       $258 = $256 + 1 | 0;
       $259 = $254 | $257;
       $spec$select297 = $259 ? $$0256 : $258;
       $$0231 = $252;
       $$1235 = 0;
       $$1240 = 35347;
       $$2258 = $spec$select297;
       $$4268 = $spec$select;
       label = 73;
       break;
      }
     case 105:
     case 100:
      {
       $260 = $8;
       $261 = $260;
       $262 = HEAP32[$261 >> 2] | 0;
       $263 = $260 + 4 | 0;
       $264 = $263;
       $265 = HEAP32[$264 >> 2] | 0;
       $266 = ($265 | 0) < 0;
       if ($266) {
        $267 = _i64Subtract(0, 0, $262 | 0, $265 | 0) | 0;
        $268 = getTempRet0() | 0;
        $269 = $8;
        $270 = $269;
        HEAP32[$270 >> 2] = $267;
        $271 = $269 + 4 | 0;
        $272 = $271;
        HEAP32[$272 >> 2] = $268;
        $$0234 = 1;
        $$0239 = 35347;
        $279 = $267;
        $280 = $268;
        label = 72;
        break L79;
       } else {
        $273 = $spec$select & 2048;
        $274 = ($273 | 0) == 0;
        $275 = $spec$select & 1;
        $276 = ($275 | 0) == 0;
        $$ = $276 ? 35347 : 35349;
        $spec$select298 = $274 ? $$ : 35348;
        $277 = $spec$select & 2049;
        $278 = ($277 | 0) != 0;
        $spec$select299 = $278 & 1;
        $$0234 = $spec$select299;
        $$0239 = $spec$select298;
        $279 = $262;
        $280 = $265;
        label = 72;
        break L79;
       }
       break;
      }
     case 117:
      {
       $195 = $8;
       $196 = $195;
       $197 = HEAP32[$196 >> 2] | 0;
       $198 = $195 + 4 | 0;
       $199 = $198;
       $200 = HEAP32[$199 >> 2] | 0;
       $$0234 = 0;
       $$0239 = 35347;
       $279 = $197;
       $280 = $200;
       label = 72;
       break;
      }
     case 99:
      {
       $300 = $8;
       $301 = $300;
       $302 = HEAP32[$301 >> 2] | 0;
       $303 = $300 + 4 | 0;
       $304 = $303;
       $305 = HEAP32[$304 >> 2] | 0;
       $306 = $302 & 255;
       HEAP8[$15 >> 0] = $306;
       $$1 = $15;
       $$2236 = 0;
       $$2241 = 35347;
       $$5 = 1;
       $$6270 = $194;
       $$pre$phiZ2D = $14;
       break;
      }
     case 115:
      {
       $307 = HEAP32[$8 >> 2] | 0;
       $308 = ($307 | 0) == (0 | 0);
       $309 = $308 ? 35357 : $307;
       $310 = _memchr($309, 0, $$0256) | 0;
       $311 = ($310 | 0) == (0 | 0);
       $312 = $310;
       $313 = $309;
       $314 = $312 - $313 | 0;
       $315 = $309 + $$0256 | 0;
       $$3259 = $311 ? $$0256 : $314;
       $$1252 = $311 ? $315 : $310;
       $$pre370 = $$1252;
       $$1 = $309;
       $$2236 = 0;
       $$2241 = 35347;
       $$5 = $$3259;
       $$6270 = $194;
       $$pre$phiZ2D = $$pre370;
       break;
      }
     case 67:
      {
       $316 = $8;
       $317 = $316;
       $318 = HEAP32[$317 >> 2] | 0;
       $319 = $316 + 4 | 0;
       $320 = $319;
       $321 = HEAP32[$320 >> 2] | 0;
       HEAP32[$10 >> 2] = $318;
       HEAP32[$16 >> 2] = 0;
       HEAP32[$8 >> 2] = $10;
       $$4260372 = -1;
       label = 79;
       break;
      }
     case 83:
      {
       $322 = ($$0256 | 0) == 0;
       if ($322) {
        _pad($0, 32, $$1262, 0, $spec$select);
        $$0242315373 = 0;
        label = 89;
       } else {
        $$4260372 = $$0256;
        label = 79;
       }
       break;
      }
     case 65:
     case 71:
     case 70:
     case 69:
     case 97:
     case 103:
     case 102:
     case 101:
      {
       $345 = +HEAPF64[$8 >> 3];
       $346 = FUNCTION_TABLE_iidiiii[$5 & 1023]($0, $345, $$1262, $$0256, $spec$select, $$0237) | 0;
       $$0245$ph$be = $346;
       break L77;
       break;
      }
     default:
      {
       $$1 = $22;
       $$2236 = 0;
       $$2241 = 35347;
       $$5 = $$0256;
       $$6270 = $spec$select;
       $$pre$phiZ2D = $14;
      }
     }
    } while (0);
    L102 : do {
     if ((label | 0) == 67) {
      label = 0;
      $225 = $8;
      $226 = $225;
      $227 = HEAP32[$226 >> 2] | 0;
      $228 = $225 + 4 | 0;
      $229 = $228;
      $230 = HEAP32[$229 >> 2] | 0;
      $231 = $$1238 & 32;
      $232 = _fmt_x($227, $230, $13, $231) | 0;
      $233 = $8;
      $234 = $233;
      $235 = HEAP32[$234 >> 2] | 0;
      $236 = $233 + 4 | 0;
      $237 = $236;
      $238 = HEAP32[$237 >> 2] | 0;
      $239 = ($235 | 0) == 0;
      $240 = ($238 | 0) == 0;
      $241 = $239 & $240;
      $242 = $$3267 & 8;
      $243 = ($242 | 0) == 0;
      $or$cond280 = $243 | $241;
      $244 = $$1238 >>> 4;
      $245 = 35347 + $244 | 0;
      $spec$select295 = $or$cond280 ? 35347 : $245;
      $spec$select296 = $or$cond280 ? 0 : 2;
      $$0231 = $232;
      $$1235 = $spec$select296;
      $$1240 = $spec$select295;
      $$2258 = $$1257;
      $$4268 = $$3267;
      label = 73;
     } else if ((label | 0) == 72) {
      label = 0;
      $281 = _fmt_u($279, $280, $13) | 0;
      $$0231 = $281;
      $$1235 = $$0234;
      $$1240 = $$0239;
      $$2258 = $$0256;
      $$4268 = $spec$select;
      label = 73;
     } else if ((label | 0) == 79) {
      label = 0;
      $323 = HEAP32[$8 >> 2] | 0;
      $$0232336 = $323;
      $$0242335 = 0;
      while (1) {
       $324 = HEAP32[$$0232336 >> 2] | 0;
       $325 = ($324 | 0) == 0;
       if ($325) {
        $$0242315 = $$0242335;
        break;
       }
       $326 = _wctomb($11, $324) | 0;
       $327 = ($326 | 0) < 0;
       $328 = $$4260372 - $$0242335 | 0;
       $329 = $326 >>> 0 > $328 >>> 0;
       $or$cond285 = $327 | $329;
       if ($or$cond285) {
        label = 83;
        break;
       }
       $330 = $$0232336 + 4 | 0;
       $331 = $326 + $$0242335 | 0;
       $332 = $$4260372 >>> 0 > $331 >>> 0;
       if ($332) {
        $$0232336 = $330;
        $$0242335 = $331;
       } else {
        $$0242315 = $331;
        break;
       }
      }
      if ((label | 0) == 83) {
       label = 0;
       if ($327) {
        $$0 = -1;
        break L1;
       } else {
        $$0242315 = $$0242335;
       }
      }
      _pad($0, 32, $$1262, $$0242315, $spec$select);
      $333 = ($$0242315 | 0) == 0;
      if ($333) {
       $$0242315373 = 0;
       label = 89;
      } else {
       $334 = HEAP32[$8 >> 2] | 0;
       $$1233342 = $334;
       $$1243341 = 0;
       while (1) {
        $335 = HEAP32[$$1233342 >> 2] | 0;
        $336 = ($335 | 0) == 0;
        if ($336) {
         $$0242315373 = $$0242315;
         label = 89;
         break L102;
        }
        $337 = _wctomb($11, $335) | 0;
        $338 = $337 + $$1243341 | 0;
        $339 = ($338 | 0) > ($$0242315 | 0);
        if ($339) {
         $$0242315373 = $$0242315;
         label = 89;
         break L102;
        }
        $340 = $$1233342 + 4 | 0;
        _out($0, $11, $337);
        $341 = $338 >>> 0 < $$0242315 >>> 0;
        if ($341) {
         $$1233342 = $340;
         $$1243341 = $338;
        } else {
         $$0242315373 = $$0242315;
         label = 89;
         break;
        }
       }
      }
     }
    } while (0);
    if ((label | 0) == 73) {
     label = 0;
     $282 = ($$2258 | 0) > -1;
     $283 = $$4268 & -65537;
     $spec$select283 = $282 ? $283 : $$4268;
     $284 = $8;
     $285 = $284;
     $286 = HEAP32[$285 >> 2] | 0;
     $287 = $284 + 4 | 0;
     $288 = $287;
     $289 = HEAP32[$288 >> 2] | 0;
     $290 = ($286 | 0) != 0;
     $291 = ($289 | 0) != 0;
     $292 = $290 | $291;
     $293 = ($$2258 | 0) != 0;
     $or$cond = $293 | $292;
     $294 = $$0231;
     $295 = $14 - $294 | 0;
     $296 = $292 ^ 1;
     $297 = $296 & 1;
     $298 = $295 + $297 | 0;
     $299 = ($$2258 | 0) > ($298 | 0);
     $$2258$ = $299 ? $$2258 : $298;
     $spec$select300 = $or$cond ? $$2258$ : 0;
     $spec$select301 = $or$cond ? $$0231 : $13;
     $$1 = $spec$select301;
     $$2236 = $$1235;
     $$2241 = $$1240;
     $$5 = $spec$select300;
     $$6270 = $spec$select283;
     $$pre$phiZ2D = $14;
    } else if ((label | 0) == 89) {
     label = 0;
     $342 = $spec$select ^ 8192;
     _pad($0, 32, $$1262, $$0242315373, $342);
     $343 = ($$1262 | 0) > ($$0242315373 | 0);
     $344 = $343 ? $$1262 : $$0242315373;
     $$0245$ph$be = $344;
     break;
    }
    $347 = $$1;
    $348 = $$pre$phiZ2D - $347 | 0;
    $349 = ($$5 | 0) < ($348 | 0);
    $spec$select286 = $349 ? $348 : $$5;
    $350 = $spec$select286 + $$2236 | 0;
    $351 = ($$1262 | 0) < ($350 | 0);
    $$2263 = $351 ? $350 : $$1262;
    _pad($0, 32, $$2263, $350, $$6270);
    _out($0, $$2241, $$2236);
    $352 = $$6270 ^ 65536;
    _pad($0, 48, $$2263, $350, $352);
    _pad($0, 48, $spec$select286, $348, 0);
    _out($0, $$1, $348);
    $353 = $$6270 ^ 8192;
    _pad($0, 32, $$2263, $350, $353);
    $$0245$ph$be = $$2263;
   }
  } while (0);
  $$0245$ph = $$0245$ph$be;
  $$0249$ph = $$1250;
  $$0271$ph = $$3274;
 }
 L123 : do {
  if ((label | 0) == 92) {
   $354 = ($0 | 0) == (0 | 0);
   if ($354) {
    $355 = ($$0271$ph | 0) == 0;
    if ($355) {
     $$0 = 0;
    } else {
     $$2244322 = 1;
     while (1) {
      $356 = $4 + ($$2244322 << 2) | 0;
      $357 = HEAP32[$356 >> 2] | 0;
      $358 = ($357 | 0) == 0;
      if ($358) {
       break;
      }
      $359 = $3 + ($$2244322 << 3) | 0;
      _pop_arg($359, $357, $2, $6);
      $360 = $$2244322 + 1 | 0;
      $361 = $360 >>> 0 < 10;
      if ($361) {
       $$2244322 = $360;
      } else {
       $$0 = 1;
       break L123;
      }
     }
     $$3319 = $$2244322;
     while (1) {
      $364 = $4 + ($$3319 << 2) | 0;
      $365 = HEAP32[$364 >> 2] | 0;
      $366 = ($365 | 0) == 0;
      $362 = $$3319 + 1 | 0;
      if (!$366) {
       $$0 = -1;
       break L123;
      }
      $363 = $362 >>> 0 < 10;
      if ($363) {
       $$3319 = $362;
      } else {
       $$0 = 1;
       break;
      }
     }
    }
   } else {
    $$0 = $$1250;
   }
  }
 } while (0);
 STACKTOP = sp;
 return $$0 | 0;
}

function __compilecode($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0, $435 = 0, $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0, $472 = 0, $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0, $49 = 0, $490 = 0, $491 = 0, $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $5 = 0, $50 = 0, $500 = 0, $501 = 0, $502 = 0, $503 = 0, $504 = 0, $505 = 0, $506 = 0, $507 = 0, $508 = 0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $514 = 0, $515 = 0, $516 = 0, $517 = 0, $518 = 0, $519 = 0, $52 = 0, $520 = 0, $521 = 0, $522 = 0, $523 = 0, $524 = 0, $525 = 0, $526 = 0, $527 = 0, $528 = 0, $529 = 0, $53 = 0, $530 = 0, $531 = 0, $532 = 0, $533 = 0, $534 = 0, $535 = 0, $536 = 0, $537 = 0, $538 = 0, $539 = 0, $54 = 0, $540 = 0, $541 = 0, $542 = 0, $543 = 0, $544 = 0, $545 = 0, $546 = 0, $547 = 0, $548 = 0, $549 = 0, $55 = 0, $550 = 0, $551 = 0, $552 = 0, $553 = 0, $554 = 0, $555 = 0, $556 = 0, $557 = 0, $558 = 0, $559 = 0, $56 = 0, $560 = 0, $561 = 0, $562 = 0, $563 = 0, $564 = 0, $565 = 0, $566 = 0, $567 = 0, $568 = 0, $569 = 0, $57 = 0, $570 = 0, $571 = 0, $572 = 0, $573 = 0, $574 = 0, $575 = 0, $576 = 0, $577 = 0, $578 = 0, $579 = 0, $58 = 0, $580 = 0, $581 = 0, $582 = 0, $583 = 0, $584 = 0, $585 = 0, $586 = 0, $587 = 0, $588 = 0, $589 = 0, $59 = 0, $590 = 0, $591 = 0, $592 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $14 = $6;
 $15 = ($14 | 0) != 0;
 $16 = $5;
 $17 = $16 + 12 | 0;
 $18 = $15 ? 0 : $17;
 $7 = $18;
 $19 = $5;
 $20 = HEAP32[$19 >> 2] | 0;
 $8 = $20;
 $21 = $5;
 $22 = HEAP32[$21 >> 2] | 0;
 $9 = $22;
 $10 = 0;
 L1 : while (1) {
  $23 = $4;
  $24 = HEAP8[$23 >> 0] | 0;
  $25 = $24 << 24 >> 24;
  $26 = ($25 | 0) != 0;
  if (!$26) {
   label = 152;
   break;
  }
  $27 = $4;
  $28 = HEAP8[$27 >> 0] | 0;
  $29 = $28 << 24 >> 24;
  $30 = ($29 | 0) != 41;
  if (!$30) {
   label = 152;
   break;
  }
  $31 = $4;
  $32 = HEAP8[$31 >> 0] | 0;
  $33 = $32 << 24 >> 24;
  L5 : do {
   switch ($33 | 0) {
   case 92:
    {
     $34 = $4;
     $35 = $34 + 1 | 0;
     $4 = $35;
     $36 = $4;
     $37 = HEAP8[$36 >> 0] | 0;
     $38 = $37 << 24 >> 24 != 0;
     if (!$38) {
      label = 6;
      break L1;
     }
     $39 = $4;
     $40 = HEAP8[$39 >> 0] | 0;
     $41 = $40 << 24 >> 24;
     $42 = $41 | 32;
     $43 = ($42 | 0) == 100;
     if (!$43) {
      $44 = $4;
      $45 = HEAP8[$44 >> 0] | 0;
      $46 = $45 << 24 >> 24;
      $47 = $46 | 32;
      $48 = ($47 | 0) == 115;
      if (!$48) {
       $49 = $4;
       $50 = HEAP8[$49 >> 0] | 0;
       $51 = $50 << 24 >> 24;
       $52 = $51 | 32;
       $53 = ($52 | 0) == 119;
       if (!$53) {
        label = 17;
        break L5;
       }
      }
     }
     $54 = $5;
     $55 = HEAP32[$54 >> 2] | 0;
     $9 = $55;
     $56 = $7;
     $57 = ($56 | 0) != (0 | 0);
     if ($57) {
      $58 = $7;
      $59 = $5;
      $60 = HEAP32[$59 >> 2] | 0;
      $61 = $60 + 1 | 0;
      HEAP32[$59 >> 2] = $61;
      $62 = $58 + $60 | 0;
      HEAP8[$62 >> 0] = 5;
     } else {
      $63 = $5;
      $64 = HEAP32[$63 >> 2] | 0;
      $65 = $64 + 1 | 0;
      HEAP32[$63 >> 2] = $65;
     }
     $66 = $7;
     $67 = ($66 | 0) != (0 | 0);
     if ($67) {
      $68 = $4;
      $69 = HEAP8[$68 >> 0] | 0;
      $70 = $7;
      $71 = $5;
      $72 = HEAP32[$71 >> 2] | 0;
      $73 = $72 + 1 | 0;
      HEAP32[$71 >> 2] = $73;
      $74 = $70 + $72 | 0;
      HEAP8[$74 >> 0] = $69;
     } else {
      $75 = $5;
      $76 = HEAP32[$75 >> 2] | 0;
      $77 = $76 + 1 | 0;
      HEAP32[$75 >> 2] = $77;
     }
     $78 = $5;
     $79 = $78 + 4 | 0;
     $80 = HEAP32[$79 >> 2] | 0;
     $81 = $80 + 1 | 0;
     HEAP32[$79 >> 2] = $81;
     break;
    }
   case 46:
    {
     $110 = $5;
     $111 = HEAP32[$110 >> 2] | 0;
     $9 = $111;
     $112 = $7;
     $113 = ($112 | 0) != (0 | 0);
     if ($113) {
      $114 = $7;
      $115 = $5;
      $116 = HEAP32[$115 >> 2] | 0;
      $117 = $116 + 1 | 0;
      HEAP32[$115 >> 2] = $117;
      $118 = $114 + $116 | 0;
      HEAP8[$118 >> 0] = 2;
     } else {
      $119 = $5;
      $120 = HEAP32[$119 >> 2] | 0;
      $121 = $120 + 1 | 0;
      HEAP32[$119 >> 2] = $121;
     }
     $122 = $5;
     $123 = $122 + 4 | 0;
     $124 = HEAP32[$123 >> 2] | 0;
     $125 = $124 + 1 | 0;
     HEAP32[$123 >> 2] = $125;
     break;
    }
   case 91:
    {
     $126 = $5;
     $127 = HEAP32[$126 >> 2] | 0;
     $9 = $127;
     $128 = $4;
     $129 = $128 + 1 | 0;
     $4 = $129;
     $130 = $4;
     $131 = HEAP8[$130 >> 0] | 0;
     $132 = $131 << 24 >> 24;
     $133 = ($132 | 0) == 94;
     $134 = $7;
     $135 = ($134 | 0) != (0 | 0);
     do {
      if ($133) {
       if ($135) {
        $136 = $7;
        $137 = $5;
        $138 = HEAP32[$137 >> 2] | 0;
        $139 = $138 + 1 | 0;
        HEAP32[$137 >> 2] = $139;
        $140 = $136 + $138 | 0;
        HEAP8[$140 >> 0] = 4;
       } else {
        $141 = $5;
        $142 = HEAP32[$141 >> 2] | 0;
        $143 = $142 + 1 | 0;
        HEAP32[$141 >> 2] = $143;
       }
       $144 = $4;
       $145 = $144 + 1 | 0;
       $4 = $145;
      } else {
       if ($135) {
        $146 = $7;
        $147 = $5;
        $148 = HEAP32[$147 >> 2] | 0;
        $149 = $148 + 1 | 0;
        HEAP32[$147 >> 2] = $149;
        $150 = $146 + $148 | 0;
        HEAP8[$150 >> 0] = 3;
        break;
       } else {
        $151 = $5;
        $152 = HEAP32[$151 >> 2] | 0;
        $153 = $152 + 1 | 0;
        HEAP32[$151 >> 2] = $153;
        break;
       }
      }
     } while (0);
     $154 = $5;
     $155 = HEAP32[$154 >> 2] | 0;
     $156 = $155 + 1 | 0;
     HEAP32[$154 >> 2] = $156;
     $157 = $5;
     $158 = $157 + 4 | 0;
     $159 = HEAP32[$158 >> 2] | 0;
     $160 = $159 + 1 | 0;
     HEAP32[$158 >> 2] = $160;
     $11 = 0;
     while (1) {
      $161 = $4;
      $162 = HEAP8[$161 >> 0] | 0;
      $163 = $162 << 24 >> 24;
      $164 = ($163 | 0) != 93;
      if (!$164) {
       break;
      }
      $165 = $4;
      $166 = HEAP8[$165 >> 0] | 0;
      $167 = $166 << 24 >> 24 != 0;
      if (!$167) {
       label = 39;
       break L1;
      }
      $168 = $7;
      $169 = ($168 | 0) != (0 | 0);
      if ($169) {
       $170 = $4;
       $171 = HEAP8[$170 >> 0] | 0;
       $172 = $7;
       $173 = $5;
       $174 = HEAP32[$173 >> 2] | 0;
       $175 = $174 + 1 | 0;
       HEAP32[$173 >> 2] = $175;
       $176 = $172 + $174 | 0;
       HEAP8[$176 >> 0] = $171;
      } else {
       $177 = $5;
       $178 = HEAP32[$177 >> 2] | 0;
       $179 = $178 + 1 | 0;
       HEAP32[$177 >> 2] = $179;
      }
      $180 = $4;
      $181 = $180 + 1 | 0;
      $182 = HEAP8[$181 >> 0] | 0;
      $183 = $182 << 24 >> 24;
      $184 = ($183 | 0) == 45;
      if ($184) {
       $185 = $4;
       $186 = $185 + 2 | 0;
       $187 = HEAP8[$186 >> 0] | 0;
       $188 = $187 << 24 >> 24;
       $189 = ($188 | 0) != 93;
       if ($189) {
        $190 = $4;
        $191 = $190 + 2 | 0;
        $4 = $191;
       }
      }
      $192 = $7;
      $193 = ($192 | 0) != (0 | 0);
      if ($193) {
       $194 = $4;
       $195 = HEAP8[$194 >> 0] | 0;
       $196 = $7;
       $197 = $5;
       $198 = HEAP32[$197 >> 2] | 0;
       $199 = $198 + 1 | 0;
       HEAP32[$197 >> 2] = $199;
       $200 = $196 + $198 | 0;
       HEAP8[$200 >> 0] = $195;
      } else {
       $201 = $5;
       $202 = HEAP32[$201 >> 2] | 0;
       $203 = $202 + 1 | 0;
       HEAP32[$201 >> 2] = $203;
      }
      $204 = $4;
      $205 = $204 + 1 | 0;
      $4 = $205;
      $206 = $11;
      $207 = $206 + 1 | 0;
      $11 = $207;
     }
     $208 = $7;
     $209 = ($208 | 0) != (0 | 0);
     if ($209) {
      $210 = $11;
      $211 = $210 & 255;
      $212 = $7;
      $213 = $9;
      $214 = $213 + 1 | 0;
      $215 = $212 + $214 | 0;
      HEAP8[$215 >> 0] = $211;
      break L5;
     } else {
      break L5;
     }
     break;
    }
   case 40:
    {
     $216 = $5;
     $217 = HEAP32[$216 >> 2] | 0;
     $9 = $217;
     $12 = 0;
     $218 = $4;
     $219 = $218 + 1 | 0;
     $220 = HEAP8[$219 >> 0] | 0;
     $221 = $220 << 24 >> 24;
     $222 = ($221 | 0) != 63;
     if ($222) {
      $229 = 1;
     } else {
      $223 = $4;
      $224 = $223 + 2 | 0;
      $225 = HEAP8[$224 >> 0] | 0;
      $226 = $225 << 24 >> 24;
      $227 = ($226 | 0) != 58;
      $229 = $227;
     }
     $228 = $229 & 1;
     $13 = $228;
     $230 = $13;
     $231 = ($230 | 0) != 0;
     if ($231) {
      $232 = $5;
      $233 = $232 + 8 | 0;
      $234 = HEAP32[$233 >> 2] | 0;
      $235 = $234 + 1 | 0;
      HEAP32[$233 >> 2] = $235;
      $12 = $235;
      $236 = $7;
      $237 = ($236 | 0) != (0 | 0);
      if ($237) {
       $238 = $7;
       $239 = $5;
       $240 = HEAP32[$239 >> 2] | 0;
       $241 = $240 + 1 | 0;
       HEAP32[$239 >> 2] = $241;
       $242 = $238 + $240 | 0;
       HEAP8[$242 >> 0] = 126;
      } else {
       $243 = $5;
       $244 = HEAP32[$243 >> 2] | 0;
       $245 = $244 + 1 | 0;
       HEAP32[$243 >> 2] = $245;
      }
      $246 = $7;
      $247 = ($246 | 0) != (0 | 0);
      if ($247) {
       $248 = $12;
       $249 = $248 << 1;
       $250 = $249 & 255;
       $251 = $7;
       $252 = $5;
       $253 = HEAP32[$252 >> 2] | 0;
       $254 = $253 + 1 | 0;
       HEAP32[$252 >> 2] = $254;
       $255 = $251 + $253 | 0;
       HEAP8[$255 >> 0] = $250;
      } else {
       $256 = $5;
       $257 = HEAP32[$256 >> 2] | 0;
       $258 = $257 + 1 | 0;
       HEAP32[$256 >> 2] = $258;
      }
      $259 = $5;
      $260 = $259 + 4 | 0;
      $261 = HEAP32[$260 >> 2] | 0;
      $262 = $261 + 1 | 0;
      HEAP32[$260 >> 2] = $262;
     } else {
      $263 = $4;
      $264 = $263 + 2 | 0;
      $4 = $264;
     }
     $265 = $4;
     $266 = $265 + 1 | 0;
     $267 = $5;
     $268 = $6;
     $269 = __compilecode($266, $267, $268) | 0;
     $4 = $269;
     $270 = $4;
     $271 = ($270 | 0) == (0 | 0);
     if ($271) {
      label = 66;
      break L1;
     }
     $272 = $4;
     $273 = HEAP8[$272 >> 0] | 0;
     $274 = $273 << 24 >> 24;
     $275 = ($274 | 0) != 41;
     if ($275) {
      label = 66;
      break L1;
     }
     $276 = $13;
     $277 = ($276 | 0) != 0;
     if ($277) {
      $278 = $7;
      $279 = ($278 | 0) != (0 | 0);
      if ($279) {
       $280 = $7;
       $281 = $5;
       $282 = HEAP32[$281 >> 2] | 0;
       $283 = $282 + 1 | 0;
       HEAP32[$281 >> 2] = $283;
       $284 = $280 + $282 | 0;
       HEAP8[$284 >> 0] = 126;
      } else {
       $285 = $5;
       $286 = HEAP32[$285 >> 2] | 0;
       $287 = $286 + 1 | 0;
       HEAP32[$285 >> 2] = $287;
      }
      $288 = $7;
      $289 = ($288 | 0) != (0 | 0);
      if ($289) {
       $290 = $12;
       $291 = $290 << 1;
       $292 = $291 + 1 | 0;
       $293 = $292 & 255;
       $294 = $7;
       $295 = $5;
       $296 = HEAP32[$295 >> 2] | 0;
       $297 = $296 + 1 | 0;
       HEAP32[$295 >> 2] = $297;
       $298 = $294 + $296 | 0;
       HEAP8[$298 >> 0] = $293;
      } else {
       $299 = $5;
       $300 = HEAP32[$299 >> 2] | 0;
       $301 = $300 + 1 | 0;
       HEAP32[$299 >> 2] = $301;
      }
      $302 = $5;
      $303 = $302 + 4 | 0;
      $304 = HEAP32[$303 >> 2] | 0;
      $305 = $304 + 1 | 0;
      HEAP32[$303 >> 2] = $305;
     }
     break;
    }
   case 63:
    {
     $306 = $5;
     $307 = HEAP32[$306 >> 2] | 0;
     $308 = $9;
     $309 = ($307 | 0) == ($308 | 0);
     if ($309) {
      label = 76;
      break L1;
     }
     $310 = $7;
     $311 = ($310 | 0) != (0 | 0);
     if ($311) {
      $312 = $7;
      $313 = $9;
      $314 = $312 + $313 | 0;
      $315 = $314 + 2 | 0;
      $316 = $7;
      $317 = $9;
      $318 = $316 + $317 | 0;
      $319 = $5;
      $320 = HEAP32[$319 >> 2] | 0;
      $321 = $9;
      $322 = $320 - $321 | 0;
      _memmove($315 | 0, $318 | 0, $322 | 0) | 0;
     }
     $323 = $5;
     $324 = HEAP32[$323 >> 2] | 0;
     $325 = $324 + 2 | 0;
     HEAP32[$323 >> 2] = $325;
     $326 = $4;
     $327 = $326 + 1 | 0;
     $328 = HEAP8[$327 >> 0] | 0;
     $329 = $328 << 24 >> 24;
     $330 = ($329 | 0) == 63;
     $331 = $7;
     $332 = ($331 | 0) != (0 | 0);
     do {
      if ($330) {
       if ($332) {
        $333 = $7;
        $334 = $9;
        $335 = $333 + $334 | 0;
        HEAP8[$335 >> 0] = 98;
       } else {}
       $336 = $4;
       $337 = $336 + 1 | 0;
       $4 = $337;
      } else {
       if ($332) {
        $338 = $7;
        $339 = $9;
        $340 = $338 + $339 | 0;
        HEAP8[$340 >> 0] = 97;
        break;
       } else {
        break;
       }
      }
     } while (0);
     $341 = $7;
     $342 = ($341 | 0) != (0 | 0);
     if ($342) {
      $343 = $5;
      $344 = HEAP32[$343 >> 2] | 0;
      $345 = $9;
      $346 = $344 - $345 | 0;
      $347 = $346 - 2 | 0;
      $348 = $347 & 255;
      $349 = $7;
      $350 = $9;
      $351 = $350 + 1 | 0;
      $352 = $349 + $351 | 0;
      HEAP8[$352 >> 0] = $348;
     } else {}
     $353 = $5;
     $354 = $353 + 4 | 0;
     $355 = HEAP32[$354 >> 2] | 0;
     $356 = $355 + 1 | 0;
     HEAP32[$354 >> 2] = $356;
     $357 = $5;
     $358 = HEAP32[$357 >> 2] | 0;
     $9 = $358;
     break;
    }
   case 42:
    {
     $359 = $5;
     $360 = HEAP32[$359 >> 2] | 0;
     $361 = $9;
     $362 = ($360 | 0) == ($361 | 0);
     if ($362) {
      label = 92;
      break L1;
     }
     $363 = $7;
     $364 = ($363 | 0) != (0 | 0);
     if ($364) {
      $365 = $7;
      $366 = $9;
      $367 = $365 + $366 | 0;
      $368 = $367 + 2 | 0;
      $369 = $7;
      $370 = $9;
      $371 = $369 + $370 | 0;
      $372 = $5;
      $373 = HEAP32[$372 >> 2] | 0;
      $374 = $9;
      $375 = $373 - $374 | 0;
      _memmove($368 | 0, $371 | 0, $375 | 0) | 0;
     }
     $376 = $5;
     $377 = HEAP32[$376 >> 2] | 0;
     $378 = $377 + 2 | 0;
     HEAP32[$376 >> 2] = $378;
     $379 = $7;
     $380 = ($379 | 0) != (0 | 0);
     if ($380) {
      $381 = $7;
      $382 = $5;
      $383 = HEAP32[$382 >> 2] | 0;
      $384 = $381 + $383 | 0;
      HEAP8[$384 >> 0] = 96;
     } else {}
     $385 = $7;
     $386 = ($385 | 0) != (0 | 0);
     if ($386) {
      $387 = $9;
      $388 = $5;
      $389 = HEAP32[$388 >> 2] | 0;
      $390 = $387 - $389 | 0;
      $391 = $390 - 2 | 0;
      $392 = $391 & 255;
      $393 = $7;
      $394 = $5;
      $395 = HEAP32[$394 >> 2] | 0;
      $396 = $395 + 1 | 0;
      $397 = $393 + $396 | 0;
      HEAP8[$397 >> 0] = $392;
     } else {}
     $398 = $5;
     $399 = HEAP32[$398 >> 2] | 0;
     $400 = $399 + 2 | 0;
     HEAP32[$398 >> 2] = $400;
     $401 = $4;
     $402 = $401 + 1 | 0;
     $403 = HEAP8[$402 >> 0] | 0;
     $404 = $403 << 24 >> 24;
     $405 = ($404 | 0) == 63;
     $406 = $7;
     $407 = ($406 | 0) != (0 | 0);
     do {
      if ($405) {
       if ($407) {
        $408 = $7;
        $409 = $9;
        $410 = $408 + $409 | 0;
        HEAP8[$410 >> 0] = 98;
       } else {}
       $411 = $4;
       $412 = $411 + 1 | 0;
       $4 = $412;
      } else {
       if ($407) {
        $413 = $7;
        $414 = $9;
        $415 = $413 + $414 | 0;
        HEAP8[$415 >> 0] = 97;
        break;
       } else {
        break;
       }
      }
     } while (0);
     $416 = $7;
     $417 = ($416 | 0) != (0 | 0);
     if ($417) {
      $418 = $5;
      $419 = HEAP32[$418 >> 2] | 0;
      $420 = $9;
      $421 = $419 - $420 | 0;
      $422 = $421 - 2 | 0;
      $423 = $422 & 255;
      $424 = $7;
      $425 = $9;
      $426 = $425 + 1 | 0;
      $427 = $424 + $426 | 0;
      HEAP8[$427 >> 0] = $423;
     } else {}
     $428 = $5;
     $429 = $428 + 4 | 0;
     $430 = HEAP32[$429 >> 2] | 0;
     $431 = $430 + 2 | 0;
     HEAP32[$429 >> 2] = $431;
     $432 = $5;
     $433 = HEAP32[$432 >> 2] | 0;
     $9 = $433;
     break;
    }
   case 43:
    {
     $434 = $5;
     $435 = HEAP32[$434 >> 2] | 0;
     $436 = $9;
     $437 = ($435 | 0) == ($436 | 0);
     if ($437) {
      label = 114;
      break L1;
     }
     $438 = $4;
     $439 = $438 + 1 | 0;
     $440 = HEAP8[$439 >> 0] | 0;
     $441 = $440 << 24 >> 24;
     $442 = ($441 | 0) == 63;
     $443 = $7;
     $444 = ($443 | 0) != (0 | 0);
     do {
      if ($442) {
       if ($444) {
        $445 = $7;
        $446 = $5;
        $447 = HEAP32[$446 >> 2] | 0;
        $448 = $445 + $447 | 0;
        HEAP8[$448 >> 0] = 97;
       } else {}
       $449 = $4;
       $450 = $449 + 1 | 0;
       $4 = $450;
      } else {
       if ($444) {
        $451 = $7;
        $452 = $5;
        $453 = HEAP32[$452 >> 2] | 0;
        $454 = $451 + $453 | 0;
        HEAP8[$454 >> 0] = 98;
        break;
       } else {
        break;
       }
      }
     } while (0);
     $455 = $7;
     $456 = ($455 | 0) != (0 | 0);
     if ($456) {
      $457 = $9;
      $458 = $5;
      $459 = HEAP32[$458 >> 2] | 0;
      $460 = $457 - $459 | 0;
      $461 = $460 - 2 | 0;
      $462 = $461 & 255;
      $463 = $7;
      $464 = $5;
      $465 = HEAP32[$464 >> 2] | 0;
      $466 = $465 + 1 | 0;
      $467 = $463 + $466 | 0;
      HEAP8[$467 >> 0] = $462;
     } else {}
     $468 = $5;
     $469 = HEAP32[$468 >> 2] | 0;
     $470 = $469 + 2 | 0;
     HEAP32[$468 >> 2] = $470;
     $471 = $5;
     $472 = $471 + 4 | 0;
     $473 = HEAP32[$472 >> 2] | 0;
     $474 = $473 + 1 | 0;
     HEAP32[$472 >> 2] = $474;
     $475 = $5;
     $476 = HEAP32[$475 >> 2] | 0;
     $9 = $476;
     break;
    }
   case 124:
    {
     $477 = $10;
     $478 = ($477 | 0) != 0;
     do {
      if ($478) {
       $479 = $7;
       $480 = ($479 | 0) != (0 | 0);
       if ($480) {
        $481 = $5;
        $482 = HEAP32[$481 >> 2] | 0;
        $483 = $10;
        $484 = $482 - $483 | 0;
        $485 = $484 - 2 | 0;
        $486 = $485 + 1 | 0;
        $487 = $486 & 255;
        $488 = $7;
        $489 = $10;
        $490 = $488 + $489 | 0;
        HEAP8[$490 >> 0] = $487;
        break;
       } else {
        break;
       }
      }
     } while (0);
     $491 = $7;
     $492 = ($491 | 0) != (0 | 0);
     if ($492) {
      $493 = $7;
      $494 = $8;
      $495 = $493 + $494 | 0;
      $496 = $495 + 2 | 0;
      $497 = $7;
      $498 = $8;
      $499 = $497 + $498 | 0;
      $500 = $5;
      $501 = HEAP32[$500 >> 2] | 0;
      $502 = $8;
      $503 = $501 - $502 | 0;
      _memmove($496 | 0, $499 | 0, $503 | 0) | 0;
     }
     $504 = $5;
     $505 = HEAP32[$504 >> 2] | 0;
     $506 = $505 + 2 | 0;
     HEAP32[$504 >> 2] = $506;
     $507 = $7;
     $508 = ($507 | 0) != (0 | 0);
     if ($508) {
      $509 = $7;
      $510 = $5;
      $511 = HEAP32[$510 >> 2] | 0;
      $512 = $511 + 1 | 0;
      HEAP32[$510 >> 2] = $512;
      $513 = $509 + $511 | 0;
      HEAP8[$513 >> 0] = 96;
     } else {
      $514 = $5;
      $515 = HEAP32[$514 >> 2] | 0;
      $516 = $515 + 1 | 0;
      HEAP32[$514 >> 2] = $516;
     }
     $517 = $5;
     $518 = HEAP32[$517 >> 2] | 0;
     $519 = $518 + 1 | 0;
     HEAP32[$517 >> 2] = $519;
     $10 = $518;
     $520 = $7;
     $521 = ($520 | 0) != (0 | 0);
     if ($521) {
      $522 = $7;
      $523 = $8;
      $524 = $522 + $523 | 0;
      HEAP8[$524 >> 0] = 97;
     } else {}
     $525 = $7;
     $526 = ($525 | 0) != (0 | 0);
     if ($526) {
      $527 = $5;
      $528 = HEAP32[$527 >> 2] | 0;
      $529 = $8;
      $530 = $528 - $529 | 0;
      $531 = $530 - 2 | 0;
      $532 = $531 & 255;
      $533 = $7;
      $534 = $8;
      $535 = $534 + 1 | 0;
      $536 = $533 + $535 | 0;
      HEAP8[$536 >> 0] = $532;
     } else {}
     $537 = $5;
     $538 = $537 + 4 | 0;
     $539 = HEAP32[$538 >> 2] | 0;
     $540 = $539 + 2 | 0;
     HEAP32[$538 >> 2] = $540;
     $541 = $5;
     $542 = HEAP32[$541 >> 2] | 0;
     $9 = $542;
     break;
    }
   case 94:
    {
     $543 = $7;
     $544 = ($543 | 0) != (0 | 0);
     if ($544) {
      $545 = $7;
      $546 = $5;
      $547 = HEAP32[$546 >> 2] | 0;
      $548 = $547 + 1 | 0;
      HEAP32[$546 >> 2] = $548;
      $549 = $545 + $547 | 0;
      HEAP8[$549 >> 0] = 80;
     } else {
      $550 = $5;
      $551 = HEAP32[$550 >> 2] | 0;
      $552 = $551 + 1 | 0;
      HEAP32[$550 >> 2] = $552;
     }
     $553 = $5;
     $554 = $553 + 4 | 0;
     $555 = HEAP32[$554 >> 2] | 0;
     $556 = $555 + 1 | 0;
     HEAP32[$554 >> 2] = $556;
     $557 = $5;
     $558 = HEAP32[$557 >> 2] | 0;
     $9 = $558;
     break;
    }
   case 36:
    {
     $559 = $7;
     $560 = ($559 | 0) != (0 | 0);
     if ($560) {
      $561 = $7;
      $562 = $5;
      $563 = HEAP32[$562 >> 2] | 0;
      $564 = $563 + 1 | 0;
      HEAP32[$562 >> 2] = $564;
      $565 = $561 + $563 | 0;
      HEAP8[$565 >> 0] = 81;
     } else {
      $566 = $5;
      $567 = HEAP32[$566 >> 2] | 0;
      $568 = $567 + 1 | 0;
      HEAP32[$566 >> 2] = $568;
     }
     $569 = $5;
     $570 = $569 + 4 | 0;
     $571 = HEAP32[$570 >> 2] | 0;
     $572 = $571 + 1 | 0;
     HEAP32[$570 >> 2] = $572;
     $573 = $5;
     $574 = HEAP32[$573 >> 2] | 0;
     $9 = $574;
     break;
    }
   default:
    {
     label = 17;
    }
   }
  } while (0);
  if ((label | 0) == 17) {
   label = 0;
   $82 = $5;
   $83 = HEAP32[$82 >> 2] | 0;
   $9 = $83;
   $84 = $7;
   $85 = ($84 | 0) != (0 | 0);
   if ($85) {
    $86 = $7;
    $87 = $5;
    $88 = HEAP32[$87 >> 2] | 0;
    $89 = $88 + 1 | 0;
    HEAP32[$87 >> 2] = $89;
    $90 = $86 + $88 | 0;
    HEAP8[$90 >> 0] = 1;
   } else {
    $91 = $5;
    $92 = HEAP32[$91 >> 2] | 0;
    $93 = $92 + 1 | 0;
    HEAP32[$91 >> 2] = $93;
   }
   $94 = $7;
   $95 = ($94 | 0) != (0 | 0);
   if ($95) {
    $96 = $4;
    $97 = HEAP8[$96 >> 0] | 0;
    $98 = $7;
    $99 = $5;
    $100 = HEAP32[$99 >> 2] | 0;
    $101 = $100 + 1 | 0;
    HEAP32[$99 >> 2] = $101;
    $102 = $98 + $100 | 0;
    HEAP8[$102 >> 0] = $97;
   } else {
    $103 = $5;
    $104 = HEAP32[$103 >> 2] | 0;
    $105 = $104 + 1 | 0;
    HEAP32[$103 >> 2] = $105;
   }
   $106 = $5;
   $107 = $106 + 4 | 0;
   $108 = HEAP32[$107 >> 2] | 0;
   $109 = $108 + 1 | 0;
   HEAP32[$107 >> 2] = $109;
  }
  $575 = $4;
  $576 = $575 + 1 | 0;
  $4 = $576;
 }
 if ((label | 0) == 6) {
  $3 = 0;
  $592 = $3;
  STACKTOP = sp;
  return $592 | 0;
 } else if ((label | 0) == 39) {
  $3 = 0;
  $592 = $3;
  STACKTOP = sp;
  return $592 | 0;
 } else if ((label | 0) == 66) {
  $3 = 0;
  $592 = $3;
  STACKTOP = sp;
  return $592 | 0;
 } else if ((label | 0) == 76) {
  $3 = 0;
  $592 = $3;
  STACKTOP = sp;
  return $592 | 0;
 } else if ((label | 0) == 92) {
  $3 = 0;
  $592 = $3;
  STACKTOP = sp;
  return $592 | 0;
 } else if ((label | 0) == 114) {
  $3 = 0;
  $592 = $3;
  STACKTOP = sp;
  return $592 | 0;
 } else if ((label | 0) == 152) {
  $577 = $10;
  $578 = ($577 | 0) != 0;
  do {
   if ($578) {
    $579 = $7;
    $580 = ($579 | 0) != (0 | 0);
    if ($580) {
     $581 = $5;
     $582 = HEAP32[$581 >> 2] | 0;
     $583 = $10;
     $584 = $582 - $583 | 0;
     $585 = $584 - 2 | 0;
     $586 = $585 + 1 | 0;
     $587 = $586 & 255;
     $588 = $7;
     $589 = $10;
     $590 = $588 + $589 | 0;
     HEAP8[$590 >> 0] = $587;
     break;
    } else {
     break;
    }
   }
  } while (0);
  $591 = $4;
  $3 = $591;
  $592 = $3;
  STACKTOP = sp;
  return $592 | 0;
 }
 return 0 | 0;
}

function _mp_obj_str_format_helper($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0.0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0.0, $435 = 0.0, $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $vararg_buffer = 0, $vararg_buffer4 = 0, $vararg_buffer8 = 0, $vararg_ptr11 = 0, $vararg_ptr3 = 0, $vararg_ptr7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 192 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(192 | 0);
 $vararg_buffer8 = sp + 16 | 0;
 $vararg_buffer4 = sp + 8 | 0;
 $vararg_buffer = sp;
 $13 = sp + 144 | 0;
 $14 = sp + 136 | 0;
 $21 = sp + 112 | 0;
 $26 = sp + 80 | 0;
 $27 = sp + 72 | 0;
 $30 = sp + 64 | 0;
 $31 = sp + 60 | 0;
 $34 = sp + 40 | 0;
 $37 = sp + 184 | 0;
 $38 = sp + 28 | 0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 $12 = $6;
 _vstr_init_print($13, 16, $14);
 L1 : while (1) {
  $40 = $7;
  $41 = $8;
  $42 = $40 >>> 0 < $41 >>> 0;
  if (!$42) {
   label = 149;
   break;
  }
  $43 = $7;
  $44 = HEAP8[$43 >> 0] | 0;
  $45 = $44 << 24 >> 24;
  $46 = ($45 | 0) == 125;
  $47 = $7;
  L4 : do {
   if ($46) {
    $48 = $47 + 1 | 0;
    $7 = $48;
    $49 = $7;
    $50 = $8;
    $51 = $49 >>> 0 < $50 >>> 0;
    if (!$51) {
     label = 7;
     break L1;
    }
    $52 = $7;
    $53 = HEAP8[$52 >> 0] | 0;
    $54 = $53 << 24 >> 24;
    $55 = ($54 | 0) == 125;
    if (!$55) {
     label = 7;
     break L1;
    }
    _vstr_add_byte($13, 125);
   } else {
    $56 = HEAP8[$47 >> 0] | 0;
    $57 = $56 << 24 >> 24;
    $58 = ($57 | 0) != 123;
    $59 = $7;
    if ($58) {
     $60 = HEAP8[$59 >> 0] | 0;
     _vstr_add_byte($13, $60);
     break;
    }
    $61 = $59 + 1 | 0;
    $7 = $61;
    $62 = $7;
    $63 = $8;
    $64 = $62 >>> 0 < $63 >>> 0;
    if ($64) {
     $65 = $7;
     $66 = HEAP8[$65 >> 0] | 0;
     $67 = $66 << 24 >> 24;
     $68 = ($67 | 0) == 123;
     if ($68) {
      _vstr_add_byte($13, 123);
      break;
     }
    }
    $15 = 0;
    $16 = 0;
    $17 = 0;
    $18 = 0;
    $69 = $7;
    $70 = $8;
    $71 = $69 >>> 0 < $70 >>> 0;
    if ($71) {
     $72 = $7;
     $73 = HEAP8[$72 >> 0] | 0;
     $74 = $73 << 24 >> 24;
     $75 = ($74 | 0) != 125;
     if ($75) {
      $76 = $7;
      $77 = HEAP8[$76 >> 0] | 0;
      $78 = $77 << 24 >> 24;
      $79 = ($78 | 0) != 33;
      if ($79) {
       $80 = $7;
       $81 = HEAP8[$80 >> 0] | 0;
       $82 = $81 << 24 >> 24;
       $83 = ($82 | 0) != 58;
       if ($83) {
        $84 = $7;
        $15 = $84;
        while (1) {
         $85 = $7;
         $86 = $8;
         $87 = $85 >>> 0 < $86 >>> 0;
         if ($87) {
          $88 = $7;
          $89 = HEAP8[$88 >> 0] | 0;
          $90 = $89 << 24 >> 24;
          $91 = ($90 | 0) != 125;
          if ($91) {
           $92 = $7;
           $93 = HEAP8[$92 >> 0] | 0;
           $94 = $93 << 24 >> 24;
           $95 = ($94 | 0) != 33;
           if ($95) {
            $96 = $7;
            $97 = HEAP8[$96 >> 0] | 0;
            $98 = $97 << 24 >> 24;
            $99 = ($98 | 0) != 58;
            $471 = $99;
           } else {
            $471 = 0;
           }
          } else {
           $471 = 0;
          }
         } else {
          $471 = 0;
         }
         $100 = $7;
         if (!$471) {
          break;
         }
         $101 = $100 + 1 | 0;
         $7 = $101;
        }
        $16 = $100;
       }
      }
     }
    }
    $102 = $7;
    $103 = $8;
    $104 = $102 >>> 0 < $103 >>> 0;
    if ($104) {
     $105 = $7;
     $106 = HEAP8[$105 >> 0] | 0;
     $107 = $106 << 24 >> 24;
     $108 = ($107 | 0) == 33;
     if ($108) {
      $109 = $7;
      $110 = $109 + 1 | 0;
      $7 = $110;
      $111 = $7;
      $112 = $8;
      $113 = $111 >>> 0 < $112 >>> 0;
      if (!$113) {
       label = 31;
       break L1;
      }
      $114 = $7;
      $115 = HEAP8[$114 >> 0] | 0;
      $116 = $115 << 24 >> 24;
      $117 = ($116 | 0) == 114;
      if (!$117) {
       $118 = $7;
       $119 = HEAP8[$118 >> 0] | 0;
       $120 = $119 << 24 >> 24;
       $121 = ($120 | 0) == 115;
       if (!$121) {
        label = 31;
        break L1;
       }
      }
      $122 = $7;
      $123 = $122 + 1 | 0;
      $7 = $123;
      $124 = HEAP8[$122 >> 0] | 0;
      $17 = $124;
     }
    }
    $125 = $7;
    $126 = $8;
    $127 = $125 >>> 0 < $126 >>> 0;
    L39 : do {
     if ($127) {
      $128 = $7;
      $129 = HEAP8[$128 >> 0] | 0;
      $130 = $129 << 24 >> 24;
      $131 = ($130 | 0) == 58;
      if ($131) {
       $132 = $7;
       $133 = $132 + 1 | 0;
       $7 = $133;
       $134 = $7;
       $135 = HEAP8[$134 >> 0] | 0;
       $136 = $135 << 24 >> 24;
       $137 = ($136 | 0) != 125;
       if ($137) {
        $138 = $7;
        $18 = $138;
        $19 = 1;
        while (1) {
         $139 = $7;
         $140 = $8;
         $141 = $139 >>> 0 < $140 >>> 0;
         if (!$141) {
          break L39;
         }
         $142 = $7;
         $143 = HEAP8[$142 >> 0] | 0;
         $144 = $143 << 24 >> 24;
         $145 = ($144 | 0) == 123;
         if ($145) {
          $146 = $19;
          $147 = $146 + 1 | 0;
          $19 = $147;
         } else {
          $148 = $7;
          $149 = HEAP8[$148 >> 0] | 0;
          $150 = $149 << 24 >> 24;
          $151 = ($150 | 0) == 125;
          if ($151) {
           $152 = $19;
           $153 = $152 + -1 | 0;
           $19 = $153;
           $154 = ($153 | 0) == 0;
           if ($154) {
            break L39;
           }
          }
         }
         $155 = $7;
         $156 = $155 + 1 | 0;
         $7 = $156;
        }
       }
      }
     }
    } while (0);
    $157 = $7;
    $158 = $8;
    $159 = $157 >>> 0 >= $158 >>> 0;
    if ($159) {
     label = 43;
     break L1;
    }
    $160 = $7;
    $161 = HEAP8[$160 >> 0] | 0;
    $162 = $161 << 24 >> 24;
    $163 = ($162 | 0) != 125;
    if ($163) {
     label = 45;
     break L1;
    }
    $20 = 17668;
    $164 = $15;
    $165 = ($164 | 0) != (0 | 0);
    if ($165) {
     HEAP32[$21 >> 2] = 0;
     $166 = $15;
     $167 = HEAP8[$166 >> 0] | 0;
     $168 = $167 << 24 >> 24;
     $169 = _unichar_isdigit($168) | 0;
     if ($169) {
      $170 = $9;
      $171 = HEAP32[$170 >> 2] | 0;
      $172 = ($171 | 0) > 0;
      if ($172) {
       label = 49;
       break L1;
      }
      $173 = $15;
      $174 = $16;
      $175 = _str_to_int($173, $174, $21) | 0;
      $15 = $175;
      $176 = HEAP32[$21 >> 2] | 0;
      $177 = $10;
      $178 = $177 - 1 | 0;
      $179 = $176 >>> 0 >= $178 >>> 0;
      if ($179) {
       label = 51;
       break L1;
      }
      $180 = $11;
      $181 = HEAP32[$21 >> 2] | 0;
      $182 = $181 + 1 | 0;
      $183 = $180 + ($182 << 2) | 0;
      $184 = HEAP32[$183 >> 2] | 0;
      $20 = $184;
      $185 = $9;
      HEAP32[$185 >> 2] = -1;
     } else {
      $186 = $15;
      $22 = $186;
      while (1) {
       $187 = $22;
       $188 = $16;
       $189 = $187 >>> 0 < $188 >>> 0;
       if (!$189) {
        break;
       }
       $190 = $22;
       $191 = HEAP8[$190 >> 0] | 0;
       $192 = $191 << 24 >> 24;
       $193 = ($192 | 0) != 46;
       if (!$193) {
        break;
       }
       $194 = $22;
       $195 = HEAP8[$194 >> 0] | 0;
       $196 = $195 << 24 >> 24;
       $197 = ($196 | 0) != 91;
       if (!$197) {
        break;
       }
       $198 = $22;
       $199 = $198 + 1 | 0;
       $22 = $199;
      }
      $200 = $15;
      $201 = $22;
      $202 = $15;
      $203 = $201;
      $204 = $202;
      $205 = $203 - $204 | 0;
      $206 = _mp_obj_new_str_via_qstr($200, $205) | 0;
      $23 = $206;
      $207 = $22;
      $15 = $207;
      $208 = $12;
      $209 = $23;
      $210 = _mp_map_lookup($208, $209, 0) | 0;
      $24 = $210;
      $211 = $24;
      $212 = ($211 | 0) == (0 | 0);
      if ($212) {
       label = 59;
       break L1;
      }
      $215 = $24;
      $216 = $215 + 4 | 0;
      $217 = HEAP32[$216 >> 2] | 0;
      $20 = $217;
     }
     $218 = $15;
     $219 = $16;
     $220 = $218 >>> 0 < $219 >>> 0;
     if ($220) {
      label = 62;
      break L1;
     }
    } else {
     $221 = $9;
     $222 = HEAP32[$221 >> 2] | 0;
     $223 = ($222 | 0) < 0;
     if ($223) {
      label = 64;
      break L1;
     }
     $224 = $9;
     $225 = HEAP32[$224 >> 2] | 0;
     $226 = $10;
     $227 = $226 - 1 | 0;
     $228 = $225 >>> 0 >= $227 >>> 0;
     if ($228) {
      label = 66;
      break L1;
     }
     $229 = $11;
     $230 = $9;
     $231 = HEAP32[$230 >> 2] | 0;
     $232 = $231 + 1 | 0;
     $233 = $229 + ($232 << 2) | 0;
     $234 = HEAP32[$233 >> 2] | 0;
     $20 = $234;
     $235 = $9;
     $236 = HEAP32[$235 >> 2] | 0;
     $237 = $236 + 1 | 0;
     HEAP32[$235 >> 2] = $237;
    }
    $238 = $18;
    $239 = ($238 | 0) != (0 | 0);
    $240 = $17;
    $241 = $240 << 24 >> 24 != 0;
    $or$cond = $239 | $241;
    if (!$or$cond) {
     $17 = 115;
    }
    $242 = $17;
    $243 = $242 << 24 >> 24 != 0;
    if ($243) {
     $244 = $17;
     $245 = $244 << 24 >> 24;
     $246 = ($245 | 0) == 115;
     if ($246) {
      $25 = 0;
     } else {
      $25 = 1;
     }
     _vstr_init_print($26, 16, $27);
     $247 = $20;
     $248 = $25;
     _mp_obj_print_helper($27, $247, $248);
     $249 = _mp_obj_new_str_from_vstr(18680, $26) | 0;
     $20 = $249;
    }
    $28 = 0;
    $29 = 0;
    HEAP32[$30 >> 2] = -1;
    HEAP32[$31 >> 2] = -1;
    $32 = 0;
    $33 = 0;
    $250 = $18;
    $251 = ($250 | 0) != (0 | 0);
    if ($251) {
     $252 = $18;
     $253 = $7;
     $254 = $9;
     $255 = $10;
     $256 = $11;
     $257 = $12;
     _mp_obj_str_format_helper($34, $252, $253, $254, $255, $256, $257);
     $258 = _vstr_null_terminated_str($34) | 0;
     $35 = $258;
     $259 = $35;
     $260 = $34 + 4 | 0;
     $261 = HEAP32[$260 >> 2] | 0;
     $262 = $259 + $261 | 0;
     $36 = $262;
     $263 = $35;
     $264 = HEAP8[$263 >> 0] | 0;
     $265 = _isalignment($264) | 0;
     $266 = $35;
     if ($265) {
      $267 = $266 + 1 | 0;
      $35 = $267;
      $268 = HEAP8[$266 >> 0] | 0;
      $29 = $268;
     } else {
      $269 = HEAP8[$266 >> 0] | 0;
      $270 = $269 << 24 >> 24;
      $271 = ($270 | 0) != 0;
      if ($271) {
       $272 = $35;
       $273 = $272 + 1 | 0;
       $274 = HEAP8[$273 >> 0] | 0;
       $275 = _isalignment($274) | 0;
       if ($275) {
        $276 = $35;
        $277 = $276 + 1 | 0;
        $35 = $277;
        $278 = HEAP8[$276 >> 0] | 0;
        $28 = $278;
        $279 = $35;
        $280 = $279 + 1 | 0;
        $35 = $280;
        $281 = HEAP8[$279 >> 0] | 0;
        $29 = $281;
       }
      }
     }
     $282 = $35;
     $283 = HEAP8[$282 >> 0] | 0;
     $284 = $283 << 24 >> 24;
     $285 = ($284 | 0) == 43;
     if ($285) {
      label = 84;
     } else {
      $286 = $35;
      $287 = HEAP8[$286 >> 0] | 0;
      $288 = $287 << 24 >> 24;
      $289 = ($288 | 0) == 45;
      if ($289) {
       label = 84;
      } else {
       $290 = $35;
       $291 = HEAP8[$290 >> 0] | 0;
       $292 = $291 << 24 >> 24;
       $293 = ($292 | 0) == 32;
       if ($293) {
        label = 84;
       }
      }
     }
     if ((label | 0) == 84) {
      label = 0;
      $294 = $35;
      $295 = HEAP8[$294 >> 0] | 0;
      $296 = $295 << 24 >> 24;
      $297 = ($296 | 0) == 43;
      do {
       if ($297) {
        $298 = $33;
        $299 = $298 | 2;
        $33 = $299;
       } else {
        $300 = $35;
        $301 = HEAP8[$300 >> 0] | 0;
        $302 = $301 << 24 >> 24;
        $303 = ($302 | 0) == 32;
        if (!$303) {
         break;
        }
        $304 = $33;
        $305 = $304 | 4;
        $33 = $305;
       }
      } while (0);
      $306 = $35;
      $307 = $306 + 1 | 0;
      $35 = $307;
     }
     $308 = $35;
     $309 = HEAP8[$308 >> 0] | 0;
     $310 = $309 << 24 >> 24;
     $311 = ($310 | 0) == 35;
     if ($311) {
      $312 = $33;
      $313 = $312 | 16;
      $33 = $313;
      $314 = $35;
      $315 = $314 + 1 | 0;
      $35 = $315;
     }
     $316 = $35;
     $317 = HEAP8[$316 >> 0] | 0;
     $318 = $317 << 24 >> 24;
     $319 = ($318 | 0) == 48;
     do {
      if ($319) {
       $320 = $29;
       $321 = $320 << 24 >> 24 != 0;
       if (!$321) {
        $29 = 61;
       }
       $322 = $28;
       $323 = $322 << 24 >> 24 != 0;
       if ($323) {
        break;
       }
       $28 = 48;
      }
     } while (0);
     $324 = $35;
     $325 = $36;
     $326 = _str_to_int($324, $325, $30) | 0;
     $35 = $326;
     $327 = $35;
     $328 = HEAP8[$327 >> 0] | 0;
     $329 = $328 << 24 >> 24;
     $330 = ($329 | 0) == 44;
     if ($330) {
      $331 = $33;
      $332 = $331 | 32;
      $33 = $332;
      $333 = $35;
      $334 = $333 + 1 | 0;
      $35 = $334;
     }
     $335 = $35;
     $336 = HEAP8[$335 >> 0] | 0;
     $337 = $336 << 24 >> 24;
     $338 = ($337 | 0) == 46;
     if ($338) {
      $339 = $35;
      $340 = $339 + 1 | 0;
      $35 = $340;
      $341 = $35;
      $342 = $36;
      $343 = _str_to_int($341, $342, $31) | 0;
      $35 = $343;
     }
     $344 = $35;
     $345 = HEAP8[$344 >> 0] | 0;
     $346 = _istype($345) | 0;
     if ($346) {
      $347 = $35;
      $348 = $347 + 1 | 0;
      $35 = $348;
      $349 = HEAP8[$347 >> 0] | 0;
      $32 = $349;
     }
     $350 = $35;
     $351 = HEAP8[$350 >> 0] | 0;
     $352 = $351 << 24 >> 24 != 0;
     if ($352) {
      label = 103;
      break L1;
     }
     _vstr_clear($34);
    }
    $353 = $29;
    $354 = $353 << 24 >> 24 != 0;
    do {
     if (!$354) {
      $355 = $20;
      $356 = _arg_looks_numeric($355) | 0;
      if ($356) {
       $29 = 62;
       break;
      } else {
       $29 = 60;
       break;
      }
     }
    } while (0);
    $357 = $28;
    $358 = $357 << 24 >> 24 != 0;
    if (!$358) {
     $28 = 32;
    }
    $359 = $33;
    $360 = $359 & 6;
    $361 = ($360 | 0) != 0;
    if ($361) {
     $362 = $32;
     $363 = $362 << 24 >> 24;
     $364 = ($363 | 0) == 115;
     if ($364) {
      label = 113;
      break L1;
     }
     $365 = $32;
     $366 = $365 << 24 >> 24;
     $367 = ($366 | 0) == 99;
     if ($367) {
      label = 115;
      break L1;
     }
    }
    $368 = $29;
    $369 = $368 << 24 >> 24;
    switch ($369 | 0) {
    case 60:
     {
      $370 = $33;
      $371 = $370 | 1;
      $33 = $371;
      break;
     }
    case 61:
     {
      $372 = $33;
      $373 = $372 | 64;
      $33 = $373;
      break;
     }
    case 94:
     {
      $374 = $33;
      $375 = $374 | 128;
      $33 = $375;
      break;
     }
    default:
     {}
    }
    $376 = $20;
    $377 = _arg_looks_integer($376) | 0;
    L141 : do {
     if ($377) {
      $378 = $32;
      $379 = $378 << 24 >> 24;
      switch ($379 | 0) {
      case 37:
      case 71:
      case 103:
      case 70:
      case 102:
      case 69:
      case 101:
       {
        break L141;
        break;
       }
      case 98:
       {
        $380 = $20;
        $381 = $33;
        $382 = $28;
        $383 = HEAP32[$30 >> 2] | 0;
        _mp_print_mp_int($14, $380, 2, 97, $381, $382, $383, 0) | 0;
        break L4;
        break;
       }
      case 99:
       {
        $384 = $20;
        $385 = _mp_obj_get_int($384) | 0;
        $386 = $385 & 255;
        HEAP8[$37 >> 0] = $386;
        $387 = $33;
        $388 = $28;
        $389 = HEAP32[$30 >> 2] | 0;
        _mp_print_strn($14, $37, 1, $387, $388, $389) | 0;
        break L4;
        break;
       }
      case 100:
      case 110:
      case 0:
       {
        $390 = $20;
        $391 = $33;
        $392 = $28;
        $393 = HEAP32[$30 >> 2] | 0;
        _mp_print_mp_int($14, $390, 10, 97, $391, $392, $393, 0) | 0;
        break L4;
        break;
       }
      case 111:
       {
        $394 = $33;
        $395 = $394 & 16;
        $396 = ($395 | 0) != 0;
        if ($396) {
         $397 = $33;
         $398 = $397 | 512;
         $33 = $398;
        }
        $399 = $20;
        $400 = $33;
        $401 = $28;
        $402 = HEAP32[$30 >> 2] | 0;
        _mp_print_mp_int($14, $399, 8, 97, $400, $401, $402, 0) | 0;
        break L4;
        break;
       }
      case 120:
      case 88:
       {
        $403 = $20;
        $404 = $32;
        $405 = $404 << 24 >> 24;
        $406 = $405 - 23 | 0;
        $407 = $33;
        $408 = $28;
        $409 = HEAP32[$30 >> 2] | 0;
        _mp_print_mp_int($14, $403, 16, $406, $407, $408, $409, 0) | 0;
        break L4;
        break;
       }
      default:
       {
        label = 129;
        break L1;
       }
      }
     }
    } while (0);
    $415 = $20;
    $416 = _arg_looks_numeric($415) | 0;
    if ($416) {
     $417 = $32;
     $418 = $417 << 24 >> 24 != 0;
     if (!$418) {
      $32 = 103;
     }
     $419 = $32;
     $420 = $419 << 24 >> 24;
     $421 = ($420 | 0) == 110;
     if ($421) {
      $32 = 103;
     }
     $422 = $32;
     $423 = $422 << 24 >> 24;
     switch ($423 | 0) {
     case 71:
     case 103:
     case 70:
     case 102:
     case 69:
     case 101:
      {
       $424 = $20;
       $425 = +_mp_obj_get_float($424);
       $426 = $32;
       $427 = $33;
       $428 = $28;
       $429 = HEAP32[$30 >> 2] | 0;
       $430 = HEAP32[$31 >> 2] | 0;
       _mp_print_float($14, $425, $426, $427, $428, $429, $430) | 0;
       break L4;
       break;
      }
     case 37:
      {
       $431 = $33;
       $432 = $431 | 256;
       $33 = $432;
       $433 = $20;
       $434 = +_mp_obj_get_float($433);
       $435 = $434 * 100.0;
       $436 = $33;
       $437 = $28;
       $438 = HEAP32[$30 >> 2] | 0;
       $439 = HEAP32[$31 >> 2] | 0;
       _mp_print_float($14, $435, 102, $436, $437, $438, $439) | 0;
       break L4;
       break;
      }
     default:
      {
       label = 138;
       break L1;
      }
     }
    } else {
     $445 = $29;
     $446 = $445 << 24 >> 24;
     $447 = ($446 | 0) == 61;
     if ($447) {
      label = 140;
      break L1;
     }
     $448 = $32;
     $449 = $448 << 24 >> 24;
     switch ($449 | 0) {
     case 115:
     case 0:
      {
       break;
      }
     default:
      {
       label = 147;
       break L1;
      }
     }
     $450 = $20;
     $451 = _mp_obj_str_get_data($450, $38) | 0;
     $39 = $451;
     $452 = HEAP32[$31 >> 2] | 0;
     $453 = ($452 | 0) < 0;
     if ($453) {
      $454 = HEAP32[$38 >> 2] | 0;
      HEAP32[$31 >> 2] = $454;
     }
     $455 = HEAP32[$38 >> 2] | 0;
     $456 = HEAP32[$31 >> 2] | 0;
     $457 = $455 >>> 0 > $456 >>> 0;
     if ($457) {
      $458 = HEAP32[$31 >> 2] | 0;
      HEAP32[$38 >> 2] = $458;
     }
     $459 = $39;
     $460 = HEAP32[$38 >> 2] | 0;
     $461 = $33;
     $462 = $28;
     $463 = HEAP32[$30 >> 2] | 0;
     _mp_print_strn($14, $459, $460, $461, $462, $463) | 0;
     break;
    }
   }
  } while (0);
  $469 = $7;
  $470 = $469 + 1 | 0;
  $7 = $470;
 }
 switch (label | 0) {
 case 7:
  {
   _mp_raise_ValueError(31775);
   break;
  }
 case 31:
  {
   _mp_raise_ValueError(31815);
   break;
  }
 case 43:
  {
   _mp_raise_ValueError(31840);
   break;
  }
 case 45:
  {
   _mp_raise_ValueError(31864);
   break;
  }
 case 49:
  {
   _mp_raise_ValueError(31900);
   break;
  }
 case 51:
  {
   _mp_raise_msg(15532, 31974);
   break;
  }
 case 59:
  {
   $213 = $23;
   $214 = _mp_obj_new_exception_arg1(15592, $213) | 0;
   _nlr_jump($214);
   break;
  }
 case 62:
  {
   _mp_raise_NotImplementedError(31999);
   break;
  }
 case 64:
  {
   _mp_raise_ValueError(32028);
   break;
  }
 case 66:
  {
   _mp_raise_msg(15532, 31974);
   break;
  }
 case 103:
  {
   _mp_raise_ValueError(32102);
   break;
  }
 case 113:
  {
   _mp_raise_ValueError(32127);
   break;
  }
 case 115:
  {
   _mp_raise_ValueError(32171);
   break;
  }
 case 129:
  {
   $410 = $32;
   $411 = $410 << 24 >> 24;
   $412 = $20;
   $413 = _mp_obj_get_type_str($412) | 0;
   HEAP32[$vararg_buffer >> 2] = $411;
   $vararg_ptr3 = $vararg_buffer + 4 | 0;
   HEAP32[$vararg_ptr3 >> 2] = $413;
   $414 = _mp_obj_new_exception_msg_varg(16072, 32222, $vararg_buffer) | 0;
   _nlr_jump($414);
   break;
  }
 case 138:
  {
   $440 = $32;
   $441 = $440 << 24 >> 24;
   $442 = $20;
   $443 = _mp_obj_get_type_str($442) | 0;
   HEAP32[$vararg_buffer4 >> 2] = $441;
   $vararg_ptr7 = $vararg_buffer4 + 4 | 0;
   HEAP32[$vararg_ptr7 >> 2] = $443;
   $444 = _mp_obj_new_exception_msg_varg(16072, 32222, $vararg_buffer4) | 0;
   _nlr_jump($444);
   break;
  }
 case 140:
  {
   _mp_raise_ValueError(32271);
   break;
  }
 case 147:
  {
   $464 = $32;
   $465 = $464 << 24 >> 24;
   $466 = $20;
   $467 = _mp_obj_get_type_str($466) | 0;
   HEAP32[$vararg_buffer8 >> 2] = $465;
   $vararg_ptr11 = $vararg_buffer8 + 4 | 0;
   HEAP32[$vararg_ptr11 >> 2] = $467;
   $468 = _mp_obj_new_exception_msg_varg(16072, 32222, $vararg_buffer8) | 0;
   _nlr_jump($468);
   break;
  }
 case 149:
  {
   HEAP32[$0 >> 2] = HEAP32[$13 >> 2] | 0;
   HEAP32[$0 + 4 >> 2] = HEAP32[$13 + 4 >> 2] | 0;
   HEAP32[$0 + 8 >> 2] = HEAP32[$13 + 8 >> 2] | 0;
   HEAP32[$0 + 12 >> 2] = HEAP32[$13 + 12 >> 2] | 0;
   STACKTOP = sp;
   return;
   break;
  }
 }
}

function _mp_format_float($0, $1, $2, $3, $4, $5) {
 $0 = +$0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $$old = 0.0, $$old8 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0.0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0.0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0.0, $177 = 0, $178 = 0.0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0.0, $184 = 0.0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0.0, $191 = 0.0, $192 = 0.0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0.0, $20 = 0, $200 = 0, $201 = 0.0, $202 = 0, $203 = 0, $204 = 0, $205 = 0.0, $206 = 0, $207 = 0, $208 = 0, $209 = 0.0, $21 = 0, $210 = 0.0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0.0, $266 = 0.0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0.0, $273 = 0.0, $274 = 0.0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0.0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0.0, $287 = 0.0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0.0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0.0, $379 = 0.0, $38 = 0, $380 = 0.0, $381 = 0.0, $382 = 0.0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0.0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $40 = 0, $400 = 0, $401 = 0, $402 = 0, $403 = 0, $404 = 0, $405 = 0, $406 = 0, $407 = 0, $408 = 0, $409 = 0, $41 = 0, $410 = 0, $411 = 0, $412 = 0, $413 = 0, $414 = 0, $415 = 0, $416 = 0, $417 = 0, $418 = 0, $419 = 0, $42 = 0, $420 = 0, $421 = 0, $422 = 0, $423 = 0, $424 = 0, $425 = 0, $426 = 0, $427 = 0, $428 = 0, $429 = 0, $43 = 0, $430 = 0, $431 = 0, $432 = 0, $433 = 0, $434 = 0, $435 = 0, $436 = 0, $437 = 0, $438 = 0, $439 = 0, $44 = 0.0, $440 = 0, $441 = 0, $442 = 0, $443 = 0, $444 = 0, $445 = 0, $446 = 0, $447 = 0, $448 = 0, $449 = 0, $45 = 0, $450 = 0, $451 = 0, $452 = 0, $453 = 0, $454 = 0, $455 = 0, $456 = 0, $457 = 0, $458 = 0, $459 = 0, $46 = 0, $460 = 0, $461 = 0, $462 = 0, $463 = 0, $464 = 0, $465 = 0, $466 = 0, $467 = 0, $468 = 0, $469 = 0, $47 = 0, $470 = 0, $471 = 0, $472 = 0, $473 = 0, $474 = 0, $475 = 0, $476 = 0, $477 = 0, $478 = 0, $479 = 0, $48 = 0, $480 = 0, $481 = 0, $482 = 0, $483 = 0, $484 = 0, $485 = 0, $486 = 0, $487 = 0, $488 = 0, $489 = 0, $49 = 0, $490 = 0, $491 = 0, $492 = 0, $493 = 0, $494 = 0, $495 = 0, $496 = 0, $497 = 0, $498 = 0, $499 = 0, $50 = 0.0, $500 = 0, $501 = 0, $502 = 0, $503 = 0, $504 = 0, $505 = 0, $506 = 0, $507 = 0, $508 = 0, $509 = 0, $51 = 0, $510 = 0, $511 = 0, $512 = 0, $513 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0.0, $62 = 0.0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0.0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0.0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond12 = 0, $or$cond3 = 0, $or$cond5 = 0, $or$cond7 = 0, $or$cond9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $7 = $0;
 $8 = $1;
 $9 = $2;
 $10 = $3;
 $11 = $4;
 $12 = $5;
 $31 = $8;
 $13 = $31;
 $32 = $9;
 $33 = $32 >>> 0 <= 7;
 if ($33) {
  $34 = $9;
  $35 = $34 >>> 0 >= 2;
  if ($35) {
   $36 = $13;
   $37 = $36 + 1 | 0;
   $13 = $37;
   HEAP8[$36 >> 0] = 63;
  }
  $38 = $9;
  $39 = $38 >>> 0 >= 1;
  if ($39) {
   $40 = $13;
   HEAP8[$40 >> 0] = 0;
  }
  $41 = $9;
  $42 = $41 >>> 0 >= 2;
  $43 = $42 & 1;
  $6 = $43;
  $513 = $6;
  STACKTOP = sp;
  return $513 | 0;
 }
 $44 = $7;
 $45 = ___DOUBLE_BITS($44) | 0;
 $46 = getTempRet0() | 0;
 $47 = _bitshift64Lshr($45 | 0, $46 | 0, 63) | 0;
 $48 = getTempRet0() | 0;
 $49 = ($47 | 0) != 0;
 if ($49) {
  $50 = $7;
  $51 = ___DOUBLE_BITS($50) | 0;
  $52 = getTempRet0() | 0;
  $53 = $52 & 2147483647;
  $54 = $53 >>> 0 > 2146435072;
  $55 = $51 >>> 0 > 0;
  $56 = ($53 | 0) == 2146435072;
  $57 = $56 & $55;
  $58 = $54 | $57;
  if ($58) {
   label = 10;
  } else {
   $59 = $13;
   $60 = $59 + 1 | 0;
   $13 = $60;
   HEAP8[$59 >> 0] = 45;
   $61 = $7;
   $62 = -$61;
   $7 = $62;
  }
 } else {
  label = 10;
 }
 if ((label | 0) == 10) {
  $63 = $12;
  $64 = $63 << 24 >> 24 != 0;
  if ($64) {
   $65 = $12;
   $66 = $13;
   $67 = $66 + 1 | 0;
   $13 = $67;
   HEAP8[$66 >> 0] = $65;
  }
 }
 $68 = $9;
 $69 = $68 - 1 | 0;
 $70 = $13;
 $71 = $8;
 $72 = $70;
 $73 = $71;
 $74 = $72 - $73 | 0;
 $75 = $69 - $74 | 0;
 $14 = $75;
 $76 = $10;
 $77 = $76 << 24 >> 24;
 $78 = $77 & 32;
 $79 = $78 & 255;
 $15 = $79;
 $80 = $7;
 $81 = ___DOUBLE_BITS($80) | 0;
 $82 = getTempRet0() | 0;
 $83 = $82 & 2147483647;
 $84 = ($81 | 0) == 0;
 $85 = ($83 | 0) == 2146435072;
 $86 = $84 & $85;
 do {
  if ($86) {
   $87 = $15;
   $88 = $87 << 24 >> 24;
   $89 = 73 ^ $88;
   $90 = $89 & 255;
   $91 = $13;
   $92 = $91 + 1 | 0;
   $13 = $92;
   HEAP8[$91 >> 0] = $90;
   $93 = $15;
   $94 = $93 << 24 >> 24;
   $95 = 78 ^ $94;
   $96 = $95 & 255;
   $97 = $13;
   $98 = $97 + 1 | 0;
   $13 = $98;
   HEAP8[$97 >> 0] = $96;
   $99 = $15;
   $100 = $99 << 24 >> 24;
   $101 = 70 ^ $100;
   $102 = $101 & 255;
   $103 = $13;
   $104 = $103 + 1 | 0;
   $13 = $104;
   HEAP8[$103 >> 0] = $102;
  } else {
   $105 = $7;
   $106 = ___DOUBLE_BITS($105) | 0;
   $107 = getTempRet0() | 0;
   $108 = $107 & 2147483647;
   $109 = $108 >>> 0 > 2146435072;
   $110 = $106 >>> 0 > 0;
   $111 = ($108 | 0) == 2146435072;
   $112 = $111 & $110;
   $113 = $109 | $112;
   if ($113) {
    $114 = $15;
    $115 = $114 << 24 >> 24;
    $116 = 78 ^ $115;
    $117 = $116 & 255;
    $118 = $13;
    $119 = $118 + 1 | 0;
    $13 = $119;
    HEAP8[$118 >> 0] = $117;
    $120 = $15;
    $121 = $120 << 24 >> 24;
    $122 = 65 ^ $121;
    $123 = $122 & 255;
    $124 = $13;
    $125 = $124 + 1 | 0;
    $13 = $125;
    HEAP8[$124 >> 0] = $123;
    $126 = $15;
    $127 = $126 << 24 >> 24;
    $128 = 78 ^ $127;
    $129 = $128 & 255;
    $130 = $13;
    $131 = $130 + 1 | 0;
    $13 = $131;
    HEAP8[$130 >> 0] = $129;
    break;
   }
   $138 = $11;
   $139 = ($138 | 0) < 0;
   if ($139) {
    $11 = 6;
   }
   $140 = $10;
   $141 = $140 << 24 >> 24;
   $142 = $141 & 32;
   $143 = 69 | $142;
   $144 = $143 & 255;
   $16 = $144;
   $145 = $10;
   $146 = $145 << 24 >> 24;
   $147 = $146 | 32;
   $148 = $147 & 255;
   $10 = $148;
   $149 = $10;
   $17 = $149;
   $150 = $10;
   $151 = $150 << 24 >> 24;
   $152 = ($151 | 0) == 103;
   $153 = $11;
   $154 = ($153 | 0) == 0;
   $or$cond = $152 & $154;
   if ($or$cond) {
    $11 = 1;
   }
   $20 = 0;
   $21 = 0;
   $22 = 0;
   $23 = 2896;
   $24 = 2976;
   $155 = $7;
   $156 = $155 == 0.0;
   L30 : do {
    if ($156) {
     $18 = 0;
     $157 = $10;
     $158 = $157 << 24 >> 24;
     $159 = ($158 | 0) == 102;
     $160 = $11;
     if ($159) {
      $161 = $160 + 2 | 0;
      $162 = $14;
      $163 = ($161 | 0) > ($162 | 0);
      if ($163) {
       $164 = $14;
       $165 = $164 - 2 | 0;
       $11 = $165;
      }
      $166 = $11;
      $167 = $166 + 1 | 0;
      $22 = $167;
      break;
     }
     $168 = $160 + 6 | 0;
     $169 = $14;
     $170 = ($168 | 0) > ($169 | 0);
     if ($170) {
      $171 = $14;
      $172 = $171 - 6 | 0;
      $11 = $172;
     }
     $173 = $10;
     $174 = $173 << 24 >> 24;
     $175 = ($174 | 0) == 101;
     if ($175) {
      $21 = 43;
     }
    } else {
     $176 = $7;
     $177 = $176 < 1.0;
     if ($177) {
      $25 = 48;
      $178 = $7;
      $179 = $178 >= .999999999995;
      if ($179) {
       $25 = 49;
      }
      $18 = 0;
      $19 = 256;
      while (1) {
       $180 = $19;
       $181 = ($180 | 0) != 0;
       if (!$181) {
        break;
       }
       $182 = $24;
       $183 = +HEAPF64[$182 >> 3];
       $184 = $7;
       $185 = $183 > $184;
       if ($185) {
        $186 = $19;
        $187 = $18;
        $188 = $187 + $186 | 0;
        $18 = $188;
        $189 = $23;
        $190 = +HEAPF64[$189 >> 3];
        $191 = $7;
        $192 = $191 * $190;
        $7 = $192;
       }
       $193 = $19;
       $194 = $193 >> 1;
       $19 = $194;
       $195 = $23;
       $196 = $195 + 8 | 0;
       $23 = $196;
       $197 = $24;
       $198 = $197 + 8 | 0;
       $24 = $198;
      }
      $26 = 45;
      $199 = $7;
      $200 = $199 < 1.0;
      $201 = $7;
      $202 = $201 >= .999999999995;
      $or$cond3 = $200 & $202;
      if ($or$cond3) {
       $7 = 1.0;
       $203 = $18;
       $204 = ($203 | 0) == 0;
       if ($204) {
        $26 = 43;
       }
      } else {
       $205 = $7;
       $206 = $205 < 1.0;
       if ($206) {
        $207 = $18;
        $208 = $207 + 1 | 0;
        $18 = $208;
        $209 = $7;
        $210 = $209 * 10.0;
        $7 = $210;
       }
      }
      $211 = $10;
      $212 = $211 << 24 >> 24;
      $213 = ($212 | 0) == 102;
      if (!$213) {
       $214 = $10;
       $215 = $214 << 24 >> 24;
       $216 = ($215 | 0) == 103;
       $217 = $18;
       $218 = ($217 | 0) <= 4;
       $or$cond5 = $216 & $218;
       if (!$or$cond5) {
        $250 = $26;
        $21 = $250;
        $20 = 0;
        $251 = $11;
        $252 = $14;
        $253 = $252 - 7 | 0;
        $254 = ($251 | 0) > ($253 | 0);
        if (!$254) {
         break;
        }
        $255 = $14;
        $256 = $255 - 7 | 0;
        $11 = $256;
        $257 = $10;
        $258 = $257 << 24 >> 24;
        $259 = ($258 | 0) == 103;
        if (!$259) {
         break;
        }
        $260 = $11;
        $261 = $260 + 1 | 0;
        $11 = $261;
        break;
       }
      }
      $10 = 102;
      $20 = -1;
      $219 = $25;
      $220 = $13;
      $221 = $220 + 1 | 0;
      $13 = $221;
      HEAP8[$220 >> 0] = $219;
      $222 = $17;
      $223 = $222 << 24 >> 24;
      $224 = ($223 | 0) == 103;
      if ($224) {
       $225 = $18;
       $226 = $225 - 1 | 0;
       $227 = $11;
       $228 = $227 + $226 | 0;
       $11 = $228;
      }
      $229 = $11;
      $230 = $229 + 2 | 0;
      $231 = $14;
      $232 = ($230 | 0) > ($231 | 0);
      if ($232) {
       $233 = $14;
       $234 = $233 - 2 | 0;
       $11 = $234;
      }
      $235 = $11;
      $22 = $235;
      $236 = $22;
      $237 = ($236 | 0) != 0;
      if (!$237) {
       break;
      }
      $238 = $13;
      $239 = $238 + 1 | 0;
      $13 = $239;
      HEAP8[$238 >> 0] = 46;
      while (1) {
       $240 = $18;
       $241 = $240 + -1 | 0;
       $18 = $241;
       $242 = ($241 | 0) != 0;
       $243 = $22;
       $244 = ($243 | 0) != 0;
       $245 = $242 ? $244 : 0;
       if (!$245) {
        break L30;
       }
       $246 = $13;
       $247 = $246 + 1 | 0;
       $13 = $247;
       HEAP8[$246 >> 0] = 48;
       $248 = $22;
       $249 = $248 + -1 | 0;
       $22 = $249;
      }
     } else {
      $18 = 0;
      $19 = 256;
      while (1) {
       $262 = $19;
       $263 = ($262 | 0) != 0;
       if (!$263) {
        break;
       }
       $264 = $23;
       $265 = +HEAPF64[$264 >> 3];
       $266 = $7;
       $267 = $265 <= $266;
       if ($267) {
        $268 = $19;
        $269 = $18;
        $270 = $269 + $268 | 0;
        $18 = $270;
        $271 = $24;
        $272 = +HEAPF64[$271 >> 3];
        $273 = $7;
        $274 = $273 * $272;
        $7 = $274;
       }
       $275 = $19;
       $276 = $275 >> 1;
       $19 = $276;
       $277 = $23;
       $278 = $277 + 8 | 0;
       $23 = $278;
       $279 = $24;
       $280 = $279 + 8 | 0;
       $24 = $280;
      }
      $281 = $7;
      $282 = ~~$281;
      $283 = ($282 | 0) >= 10;
      if ($283) {
       $284 = $18;
       $285 = $284 + 1 | 0;
       $18 = $285;
       $286 = $7;
       $287 = $286 * .1;
       $7 = $287;
      }
      $288 = $10;
      $289 = $288 << 24 >> 24;
      $290 = ($289 | 0) == 102;
      do {
       if ($290) {
        $291 = $18;
        $292 = $14;
        $293 = ($291 | 0) >= ($292 | 0);
        if ($293) {
         $10 = 101;
         break;
        }
        $294 = $18;
        $295 = $11;
        $296 = $294 + $295 | 0;
        $297 = $296 + 2 | 0;
        $298 = $14;
        $299 = ($297 | 0) > ($298 | 0);
        if ($299) {
         $300 = $14;
         $301 = $18;
         $302 = $300 - $301 | 0;
         $303 = $302 - 2 | 0;
         $11 = $303;
         $304 = $11;
         $305 = ($304 | 0) < 0;
         if ($305) {
          $306 = $11;
          $307 = $306 + 1 | 0;
          $11 = $307;
         }
        }
       }
      } while (0);
      $308 = $10;
      $309 = $308 << 24 >> 24;
      $310 = ($309 | 0) == 101;
      if ($310) {
       $311 = $11;
       $312 = $14;
       $313 = $312 - 7 | 0;
       $314 = ($311 | 0) > ($313 | 0);
       if ($314) {
        $315 = $14;
        $316 = $315 - 7 | 0;
        $11 = $316;
       }
      }
      $317 = $10;
      $318 = $317 << 24 >> 24;
      $319 = ($318 | 0) == 103;
      if ($319) {
       $320 = $11;
       $321 = $320 + 6 | 0;
       $322 = $14;
       $323 = ($321 | 0) > ($322 | 0);
       if ($323) {
        $324 = $14;
        $325 = $324 - 6 | 0;
        $11 = $325;
       }
      }
      $326 = $10;
      $327 = $326 << 24 >> 24;
      $328 = ($327 | 0) == 103;
      if ($328) {
       $329 = $18;
       $330 = $11;
       $331 = ($329 | 0) < ($330 | 0);
       if ($331) {
        $10 = 102;
        $332 = $18;
        $333 = $332 + 1 | 0;
        $334 = $11;
        $335 = $334 - $333 | 0;
        $11 = $335;
       }
      }
      $336 = $10;
      $337 = $336 << 24 >> 24;
      $338 = ($337 | 0) == 102;
      if ($338) {
       $339 = $18;
       $20 = $339;
       $340 = $11;
       $341 = $18;
       $342 = $340 + $341 | 0;
       $343 = $342 + 1 | 0;
       $22 = $343;
       break;
      } else {
       $21 = 43;
       break;
      }
     }
    }
   } while (0);
   $344 = $11;
   $345 = ($344 | 0) < 0;
   if ($345) {
    $11 = 0;
   }
   $346 = $10;
   $347 = $346 << 24 >> 24;
   $348 = ($347 | 0) == 101;
   if ($348) {
    $349 = $11;
    $350 = $349 + 1 | 0;
    $22 = $350;
   } else {
    $351 = $10;
    $352 = $351 << 24 >> 24;
    $353 = ($352 | 0) == 103;
    if ($353) {
     $354 = $11;
     $355 = ($354 | 0) == 0;
     if ($355) {
      $11 = 1;
     }
     $356 = $11;
     $22 = $356;
    }
   }
   $27 = 0;
   while (1) {
    $357 = $27;
    $358 = $22;
    $359 = ($357 | 0) < ($358 | 0);
    if (!$359) {
     break;
    }
    $360 = $7;
    $361 = ~~$360;
    $28 = $361;
    $362 = $28;
    $363 = ($362 | 0) < 0;
    if ($363) {
     $364 = $13;
     $365 = $364 + 1 | 0;
     $13 = $365;
     HEAP8[$364 >> 0] = 48;
    } else {
     $366 = $28;
     $367 = 48 + $366 | 0;
     $368 = $367 & 255;
     $369 = $13;
     $370 = $369 + 1 | 0;
     $13 = $370;
     HEAP8[$369 >> 0] = $368;
    }
    $371 = $20;
    $372 = ($371 | 0) == 0;
    $373 = $11;
    $374 = ($373 | 0) > 0;
    $or$cond7 = $372 & $374;
    if ($or$cond7) {
     $375 = $13;
     $376 = $375 + 1 | 0;
     $13 = $376;
     HEAP8[$375 >> 0] = 46;
    }
    $377 = $28;
    $378 = +($377 | 0);
    $379 = $7;
    $380 = $379 - $378;
    $7 = $380;
    $381 = $7;
    $382 = $381 * 10.0;
    $7 = $382;
    $383 = $27;
    $384 = $383 + 1 | 0;
    $27 = $384;
    $385 = $20;
    $386 = $385 + -1 | 0;
    $20 = $386;
   }
   $387 = $17;
   $388 = $387 << 24 >> 24;
   $389 = ($388 | 0) != 102;
   if ($389) {
    $$old = $7;
    $$old8 = $$old >= 5.0;
    if ($$old8) {
     label = 100;
    }
   } else {
    $390 = $18;
    $391 = $22;
    $392 = ($390 | 0) <= ($391 | 0);
    $393 = $7;
    $394 = $393 >= 5.0;
    $or$cond9 = $392 & $394;
    if ($or$cond9) {
     label = 100;
    }
   }
   if ((label | 0) == 100) {
    $395 = $13;
    $29 = $395;
    $396 = $29;
    $397 = $396 + -1 | 0;
    $29 = $397;
    while (1) {
     $398 = $29;
     $399 = HEAP8[$398 >> 0] | 0;
     $400 = $399 << 24 >> 24;
     $401 = ($400 | 0) == 46;
     $402 = $29;
     if ($401) {
      $403 = $402 + -1 | 0;
      $29 = $403;
      continue;
     }
     $404 = HEAP8[$402 >> 0] | 0;
     $405 = $404 << 24 >> 24;
     $406 = ($405 | 0) < 48;
     if ($406) {
      label = 105;
      break;
     }
     $407 = $29;
     $408 = HEAP8[$407 >> 0] | 0;
     $409 = $408 << 24 >> 24;
     $410 = ($409 | 0) > 57;
     if ($410) {
      label = 105;
      break;
     }
     $413 = $29;
     $414 = HEAP8[$413 >> 0] | 0;
     $415 = $414 << 24 >> 24;
     $416 = ($415 | 0) < 57;
     $417 = $29;
     if ($416) {
      label = 107;
      break;
     }
     HEAP8[$417 >> 0] = 48;
     $420 = $29;
     $421 = $8;
     $422 = ($420 | 0) == ($421 | 0);
     if ($422) {
      break;
     }
     $423 = $29;
     $424 = $423 + -1 | 0;
     $29 = $424;
    }
    if ((label | 0) == 105) {
     $411 = $29;
     $412 = $411 + 1 | 0;
     $29 = $412;
    } else if ((label | 0) == 107) {
     $418 = HEAP8[$417 >> 0] | 0;
     $419 = $418 + 1 << 24 >> 24;
     HEAP8[$417 >> 0] = $419;
    }
    $425 = $29;
    $426 = HEAP8[$425 >> 0] | 0;
    $427 = $426 << 24 >> 24;
    $428 = ($427 | 0) == 48;
    if ($428) {
     $429 = $29;
     $430 = $429 + 1 | 0;
     $431 = HEAP8[$430 >> 0] | 0;
     $432 = $431 << 24 >> 24;
     $433 = ($432 | 0) == 46;
     do {
      if ($433) {
       $434 = $10;
       $435 = $434 << 24 >> 24;
       $436 = ($435 | 0) != 102;
       if ($436) {
        $437 = $29;
        HEAP8[$437 >> 0] = 46;
        $438 = $29;
        $439 = $438 + 1 | 0;
        HEAP8[$439 >> 0] = 48;
        $440 = $21;
        $441 = $440 << 24 >> 24;
        $442 = ($441 | 0) == 45;
        $443 = $18;
        if (!$442) {
         $447 = $443 + 1 | 0;
         $18 = $447;
         break;
        }
        $444 = $443 + -1 | 0;
        $18 = $444;
        $445 = $18;
        $446 = ($445 | 0) == 0;
        if ($446) {
         $21 = 43;
        }
       } else {
        label = 117;
       }
      } else {
       label = 117;
      }
     } while (0);
     if ((label | 0) == 117) {
      $448 = $13;
      $449 = $448 + 1 | 0;
      $13 = $449;
     }
     $450 = $13;
     $30 = $450;
     while (1) {
      $451 = $30;
      $452 = $29;
      $453 = $451 >>> 0 > $452 >>> 0;
      if (!$453) {
       break;
      }
      $454 = $30;
      $455 = $454 + -1 | 0;
      $456 = HEAP8[$455 >> 0] | 0;
      $457 = $30;
      HEAP8[$457 >> 0] = $456;
      $458 = $30;
      $459 = $458 + -1 | 0;
      $30 = $459;
     }
     $460 = $29;
     HEAP8[$460 >> 0] = 49;
    }
   }
   $461 = $17;
   $462 = $461 << 24 >> 24;
   $463 = ($462 | 0) == 103;
   $464 = $11;
   $465 = ($464 | 0) > 0;
   $or$cond12 = $463 & $465;
   if ($or$cond12) {
    while (1) {
     $466 = $13;
     $467 = $466 + -1 | 0;
     $468 = HEAP8[$467 >> 0] | 0;
     $469 = $468 << 24 >> 24;
     $470 = ($469 | 0) == 48;
     $471 = $13;
     $472 = $471 + -1 | 0;
     if (!$470) {
      break;
     }
     $13 = $472;
    }
    $473 = HEAP8[$472 >> 0] | 0;
    $474 = $473 << 24 >> 24;
    $475 = ($474 | 0) == 46;
    if ($475) {
     $476 = $13;
     $477 = $476 + -1 | 0;
     $13 = $477;
    }
   }
   $478 = $21;
   $479 = $478 << 24 >> 24 != 0;
   if ($479) {
    $480 = $16;
    $481 = $13;
    $482 = $481 + 1 | 0;
    $13 = $482;
    HEAP8[$481 >> 0] = $480;
    $483 = $21;
    $484 = $13;
    $485 = $484 + 1 | 0;
    $13 = $485;
    HEAP8[$484 >> 0] = $483;
    $486 = $18;
    $487 = ($486 | 0) >= 100;
    if ($487) {
     $488 = $18;
     $489 = ($488 | 0) / 100 & -1;
     $490 = 48 + $489 | 0;
     $491 = $490 & 255;
     $492 = $13;
     $493 = $492 + 1 | 0;
     $13 = $493;
     HEAP8[$492 >> 0] = $491;
    }
    $494 = $18;
    $495 = ($494 | 0) / 10 & -1;
    $496 = ($495 | 0) % 10 & -1;
    $497 = 48 + $496 | 0;
    $498 = $497 & 255;
    $499 = $13;
    $500 = $499 + 1 | 0;
    $13 = $500;
    HEAP8[$499 >> 0] = $498;
    $501 = $18;
    $502 = ($501 | 0) % 10 & -1;
    $503 = 48 + $502 | 0;
    $504 = $503 & 255;
    $505 = $13;
    $506 = $505 + 1 | 0;
    $13 = $506;
    HEAP8[$505 >> 0] = $504;
   }
   $507 = $13;
   HEAP8[$507 >> 0] = 0;
   $508 = $13;
   $509 = $8;
   $510 = $508;
   $511 = $509;
   $512 = $510 - $511 | 0;
   $6 = $512;
   $513 = $6;
   STACKTOP = sp;
   return $513 | 0;
  }
 } while (0);
 $132 = $13;
 HEAP8[$132 >> 0] = 0;
 $133 = $13;
 $134 = $8;
 $135 = $133;
 $136 = $134;
 $137 = $135 - $136 | 0;
 $6 = $137;
 $513 = $6;
 STACKTOP = sp;
 return $513 | 0;
}

function ___rem_pio2_large($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $$0$lcssa = 0.0, $$0248$lcssa = 0.0, $$0248336 = 0.0, $$0250 = 0, $$0250278 = 0, $$0250279 = 0, $$0251 = 0, $$0251$in = 0, $$0253 = 0, $$0256 = 0, $$0258373 = 0, $$0263372 = 0, $$0271 = 0, $$0271277 = 0, $$0273$lcssa = 0, $$0273341 = 0, $$0363 = 0.0, $$1$lcssa = 0.0, $$10291 = 0, $$11313 = 0, $$12309 = 0, $$1249 = 0.0, $$1252 = 0, $$1252$ph = 0, $$1254 = 0, $$1254$in = 0, $$1257318 = 0, $$1259362 = 0, $$1264368 = 0, $$1272 = 0, $$1274 = 0, $$1274$ph = 0, $$13303 = 0, $$1354 = 0.0, $$2255 = 0, $$2260335 = 0, $$2265334 = 0, $$2330 = 0.0, $$3261347 = 0, $$3266342 = 0, $$3319 = 0.0, $$4$lcssa = 0.0, $$4262353 = 0, $$4267348 = 0, $$4267348$in = 0, $$4290 = 0.0, $$5$lcssa = 0.0, $$5268361 = 0, $$5268361$in = 0, $$5298 = 0.0, $$6$lcssa = 0.0, $$6269329 = 0, $$6292 = 0.0, $$7$lcssa = 0.0, $$7270324 = 0, $$7304 = 0.0, $$8289 = 0, $$9297 = 0, $$neg = 0, $$neg281 = 0, $$phi$trans$insert = 0, $$phi$trans$insert395 = 0, $$pre = 0.0, $$pre396 = 0.0, $$sink = 0, $$sink425 = 0, $$sink427 = 0, $10 = 0, $100 = 0.0, $101 = 0, $102 = 0.0, $103 = 0.0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0.0, $121 = 0, $122 = 0, $123 = 0, $124 = 0.0, $125 = 0, $126 = 0, $127 = 0.0, $128 = 0.0, $129 = 0.0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0.0, $138 = 0, $139 = 0.0, $14 = 0, $140 = 0, $141 = 0.0, $142 = 0.0, $143 = 0.0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0.0, $151 = 0, $152 = 0, $153 = 0, $154 = 0.0, $155 = 0.0, $156 = 0, $157 = 0.0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0.0, $163 = 0, $164 = 0, $165 = 0.0, $166 = 0.0, $167 = 0.0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0.0, $176 = 0.0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0.0, $181 = 0.0, $182 = 0, $183 = 0.0, $184 = 0.0, $185 = 0, $186 = 0, $187 = 0, $188 = 0.0, $189 = 0.0, $19 = 0, $190 = 0.0, $191 = 0.0, $192 = 0, $193 = 0, $194 = 0.0, $195 = 0.0, $196 = 0, $197 = 0.0, $198 = 0.0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0.0, $204 = 0, $205 = 0.0, $206 = 0.0, $207 = 0.0, $208 = 0.0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0.0, $214 = 0, $215 = 0.0, $216 = 0.0, $217 = 0.0, $218 = 0.0, $219 = 0, $22 = 0, $220 = 0, $221 = 0.0, $222 = 0.0, $223 = 0, $224 = 0, $225 = 0, $226 = 0.0, $227 = 0, $228 = 0.0, $229 = 0, $23 = 0.0, $230 = 0, $231 = 0.0, $232 = 0, $233 = 0.0, $234 = 0.0, $235 = 0, $236 = 0.0, $237 = 0, $238 = 0, $24 = 0, $25 = 0.0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0.0, $32 = 0, $33 = 0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0.0, $48 = 0, $49 = 0.0, $5 = 0, $50 = 0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0.0, $59 = 0.0, $6 = 0, $60 = 0, $61 = 0, $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $exitcond = 0, $exitcond391 = 0, $exitcond392 = 0, $exitcond393 = 0, $exitcond394 = 0, $or$cond = 0, $spec$store$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 560 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(560 | 0);
 $5 = sp + 480 | 0;
 $6 = sp + 320 | 0;
 $7 = sp + 160 | 0;
 $8 = sp;
 $9 = 1e4 + ($4 << 2) | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $3 + -1 | 0;
 $12 = $2 + -3 | 0;
 $13 = ($12 | 0) / 24 & -1;
 $14 = ($13 | 0) > 0;
 $spec$store$select = $14 ? $13 : 0;
 $$neg = Math_imul($spec$store$select, -24) | 0;
 $$neg281 = $2 + -24 | 0;
 $15 = $$neg281 + $$neg | 0;
 $16 = $10 + $11 | 0;
 $17 = ($16 | 0) < 0;
 if (!$17) {
  $18 = $spec$store$select - $11 | 0;
  $19 = $10 + $3 | 0;
  $$0258373 = $18;
  $$0263372 = 0;
  while (1) {
   $20 = ($$0258373 | 0) < 0;
   if ($20) {
    $25 = 0.0;
   } else {
    $21 = 10016 + ($$0258373 << 2) | 0;
    $22 = HEAP32[$21 >> 2] | 0;
    $23 = +($22 | 0);
    $25 = $23;
   }
   $24 = $6 + ($$0263372 << 3) | 0;
   HEAPF64[$24 >> 3] = $25;
   $26 = $$0263372 + 1 | 0;
   $27 = $$0258373 + 1 | 0;
   $exitcond394 = ($26 | 0) == ($19 | 0);
   if ($exitcond394) {
    break;
   } else {
    $$0258373 = $27;
    $$0263372 = $26;
   }
  }
 }
 $28 = ($3 | 0) > 0;
 $$1264368 = 0;
 while (1) {
  if ($28) {
   $29 = $$1264368 + $11 | 0;
   $$0363 = 0.0;
   $$1259362 = 0;
   while (1) {
    $30 = $0 + ($$1259362 << 3) | 0;
    $31 = +HEAPF64[$30 >> 3];
    $32 = $29 - $$1259362 | 0;
    $33 = $6 + ($32 << 3) | 0;
    $34 = +HEAPF64[$33 >> 3];
    $35 = $31 * $34;
    $36 = $$0363 + $35;
    $37 = $$1259362 + 1 | 0;
    $exitcond393 = ($37 | 0) == ($3 | 0);
    if ($exitcond393) {
     $$0$lcssa = $36;
     break;
    } else {
     $$0363 = $36;
     $$1259362 = $37;
    }
   }
  } else {
   $$0$lcssa = 0.0;
  }
  $38 = $8 + ($$1264368 << 3) | 0;
  HEAPF64[$38 >> 3] = $$0$lcssa;
  $39 = $$1264368 + 1 | 0;
  $40 = ($$1264368 | 0) < ($10 | 0);
  if ($40) {
   $$1264368 = $39;
  } else {
   break;
  }
 }
 $41 = ($15 | 0) > 0;
 $42 = 24 - $15 | 0;
 $43 = 23 - $15 | 0;
 $44 = ($15 | 0) == 0;
 $45 = ($3 | 0) > 0;
 $$0253 = $10;
 while (1) {
  $46 = $8 + ($$0253 << 3) | 0;
  $47 = +HEAPF64[$46 >> 3];
  $48 = ($$0253 | 0) > 0;
  if ($48) {
   $$0248336 = $47;
   $$2260335 = $$0253;
   $$2265334 = 0;
   while (1) {
    $49 = $$0248336 * 5.9604644775390625e-08;
    $50 = ~~$49;
    $51 = +($50 | 0);
    $52 = $51 * 16777216.0;
    $53 = $$0248336 - $52;
    $54 = ~~$53;
    $55 = $5 + ($$2265334 << 2) | 0;
    HEAP32[$55 >> 2] = $54;
    $56 = $$2260335 + -1 | 0;
    $57 = $8 + ($56 << 3) | 0;
    $58 = +HEAPF64[$57 >> 3];
    $59 = $58 + $51;
    $60 = $$2265334 + 1 | 0;
    $61 = ($$2260335 | 0) > 1;
    if ($61) {
     $$0248336 = $59;
     $$2260335 = $56;
     $$2265334 = $60;
    } else {
     $$0248$lcssa = $59;
     break;
    }
   }
  } else {
   $$0248$lcssa = $47;
  }
  $62 = +_scalbn($$0248$lcssa, $15);
  $63 = $62 * .125;
  $64 = +Math_floor(+$63);
  $65 = $64 * 8.0;
  $66 = $62 - $65;
  $67 = ~~$66;
  $68 = +($67 | 0);
  $69 = $66 - $68;
  do {
   if ($41) {
    $70 = $$0253 + -1 | 0;
    $71 = $5 + ($70 << 2) | 0;
    $72 = HEAP32[$71 >> 2] | 0;
    $73 = $72 >> $42;
    $74 = $73 + $67 | 0;
    $75 = $73 << $42;
    $76 = $72 - $75 | 0;
    HEAP32[$71 >> 2] = $76;
    $77 = $76 >> $43;
    $$0250 = $77;
    $$0271 = $74;
    label = 21;
   } else {
    if ($44) {
     $78 = $$0253 + -1 | 0;
     $79 = $5 + ($78 << 2) | 0;
     $80 = HEAP32[$79 >> 2] | 0;
     $81 = $80 >> 23;
     $$0250 = $81;
     $$0271 = $67;
     label = 21;
     break;
    } else {
     $82 = !($69 >= .5);
     if ($82) {
      $$0250279 = 0;
      $$1249 = $69;
      $$1272 = $67;
      break;
     } else {
      $$0250278 = 2;
      $$0271277 = $67;
      label = 22;
      break;
     }
    }
   }
  } while (0);
  if ((label | 0) == 21) {
   label = 0;
   $83 = ($$0250 | 0) > 0;
   if ($83) {
    $$0250278 = $$0250;
    $$0271277 = $$0271;
    label = 22;
   } else {
    $$0250279 = $$0250;
    $$1249 = $69;
    $$1272 = $$0271;
   }
  }
  if ((label | 0) == 22) {
   label = 0;
   $84 = $$0271277 + 1 | 0;
   if ($48) {
    $$0273341 = 0;
    $$3266342 = 0;
    while (1) {
     $85 = $5 + ($$3266342 << 2) | 0;
     $86 = HEAP32[$85 >> 2] | 0;
     $87 = ($$0273341 | 0) == 0;
     if ($87) {
      $88 = ($86 | 0) == 0;
      if ($88) {
       $$1274 = 0;
      } else {
       $$1274$ph = 1;
       $$sink425 = 16777216;
       label = 26;
      }
     } else {
      $$1274$ph = $$0273341;
      $$sink425 = 16777215;
      label = 26;
     }
     if ((label | 0) == 26) {
      label = 0;
      $89 = $$sink425 - $86 | 0;
      HEAP32[$85 >> 2] = $89;
      $$1274 = $$1274$ph;
     }
     $90 = $$3266342 + 1 | 0;
     $exitcond391 = ($90 | 0) == ($$0253 | 0);
     if ($exitcond391) {
      $$0273$lcssa = $$1274;
      break;
     } else {
      $$0273341 = $$1274;
      $$3266342 = $90;
     }
    }
   } else {
    $$0273$lcssa = 0;
   }
   L44 : do {
    if ($41) {
     switch ($15 | 0) {
     case 1:
      {
       $91 = $$0253 + -1 | 0;
       $92 = $5 + ($91 << 2) | 0;
       $93 = HEAP32[$92 >> 2] | 0;
       $94 = $93 & 8388607;
       HEAP32[$92 >> 2] = $94;
       break L44;
       break;
      }
     case 2:
      {
       $95 = $$0253 + -1 | 0;
       $96 = $5 + ($95 << 2) | 0;
       $97 = HEAP32[$96 >> 2] | 0;
       $98 = $97 & 4194303;
       HEAP32[$96 >> 2] = $98;
       break L44;
       break;
      }
     default:
      {
       break L44;
      }
     }
    }
   } while (0);
   $99 = ($$0250278 | 0) == 2;
   if ($99) {
    $100 = 1.0 - $69;
    $101 = ($$0273$lcssa | 0) == 0;
    if ($101) {
     $$0250279 = 2;
     $$1249 = $100;
     $$1272 = $84;
    } else {
     $102 = +_scalbn(1.0, $15);
     $103 = $100 - $102;
     $$0250279 = 2;
     $$1249 = $103;
     $$1272 = $84;
    }
   } else {
    $$0250279 = $$0250278;
    $$1249 = $69;
    $$1272 = $84;
   }
  }
  $104 = $$1249 == 0.0;
  if (!$104) {
   label = 49;
   break;
  }
  $105 = ($$0253 | 0) > ($10 | 0);
  if ($105) {
   $$3261347 = 0;
   $$4267348$in = $$0253;
   while (1) {
    $$4267348 = $$4267348$in + -1 | 0;
    $106 = $5 + ($$4267348 << 2) | 0;
    $107 = HEAP32[$106 >> 2] | 0;
    $108 = $107 | $$3261347;
    $109 = ($$4267348 | 0) > ($10 | 0);
    if ($109) {
     $$3261347 = $108;
     $$4267348$in = $$4267348;
    } else {
     break;
    }
   }
   $110 = ($108 | 0) == 0;
   if (!$110) {
    label = 41;
    break;
   }
  }
  $$0256 = 1;
  while (1) {
   $111 = $10 - $$0256 | 0;
   $112 = $5 + ($111 << 2) | 0;
   $113 = HEAP32[$112 >> 2] | 0;
   $114 = ($113 | 0) == 0;
   $115 = $$0256 + 1 | 0;
   if ($114) {
    $$0256 = $115;
   } else {
    break;
   }
  }
  $116 = $$0256 + $$0253 | 0;
  $$5268361$in = $$0253;
  while (1) {
   $$5268361 = $$5268361$in + 1 | 0;
   $117 = $$5268361 + $spec$store$select | 0;
   $118 = 10016 + ($117 << 2) | 0;
   $119 = HEAP32[$118 >> 2] | 0;
   $120 = +($119 | 0);
   $121 = $$5268361$in + $3 | 0;
   $122 = $6 + ($121 << 3) | 0;
   HEAPF64[$122 >> 3] = $120;
   if ($45) {
    $$1354 = 0.0;
    $$4262353 = 0;
    while (1) {
     $123 = $0 + ($$4262353 << 3) | 0;
     $124 = +HEAPF64[$123 >> 3];
     $125 = $121 - $$4262353 | 0;
     $126 = $6 + ($125 << 3) | 0;
     $127 = +HEAPF64[$126 >> 3];
     $128 = $124 * $127;
     $129 = $$1354 + $128;
     $130 = $$4262353 + 1 | 0;
     $exitcond392 = ($130 | 0) == ($3 | 0);
     if ($exitcond392) {
      $$1$lcssa = $129;
      break;
     } else {
      $$1354 = $129;
      $$4262353 = $130;
     }
    }
   } else {
    $$1$lcssa = 0.0;
   }
   $131 = $8 + ($$5268361 << 3) | 0;
   HEAPF64[$131 >> 3] = $$1$lcssa;
   $132 = ($$5268361 | 0) < ($116 | 0);
   if ($132) {
    $$5268361$in = $$5268361;
   } else {
    break;
   }
  }
  $$0253 = $116;
 }
 if ((label | 0) == 41) {
  $$0251$in = $15;
  $$1254$in = $$0253;
  while (1) {
   $$0251 = $$0251$in + -24 | 0;
   $$1254 = $$1254$in + -1 | 0;
   $133 = $5 + ($$1254 << 2) | 0;
   $134 = HEAP32[$133 >> 2] | 0;
   $135 = ($134 | 0) == 0;
   if ($135) {
    $$0251$in = $$0251;
    $$1254$in = $$1254;
   } else {
    $$1252 = $$0251;
    $$2255 = $$1254;
    break;
   }
  }
 } else if ((label | 0) == 49) {
  $136 = 0 - $15 | 0;
  $137 = +_scalbn($$1249, $136);
  $138 = !($137 >= 16777216.0);
  if ($138) {
   $148 = ~~$137;
   $$1252$ph = $15;
   $$sink = $148;
   $$sink427 = $$0253;
  } else {
   $139 = $137 * 5.9604644775390625e-08;
   $140 = ~~$139;
   $141 = +($140 | 0);
   $142 = $141 * 16777216.0;
   $143 = $137 - $142;
   $144 = ~~$143;
   $145 = $5 + ($$0253 << 2) | 0;
   HEAP32[$145 >> 2] = $144;
   $146 = $$0253 + 1 | 0;
   $147 = $$neg + $2 | 0;
   $$1252$ph = $147;
   $$sink = $140;
   $$sink427 = $146;
  }
  $149 = $5 + ($$sink427 << 2) | 0;
  HEAP32[$149 >> 2] = $$sink;
  $$1252 = $$1252$ph;
  $$2255 = $$sink427;
 }
 $150 = +_scalbn(1.0, $$1252);
 $151 = ($$2255 | 0) > -1;
 if ($151) {
  $$2330 = $150;
  $$6269329 = $$2255;
  while (1) {
   $152 = $5 + ($$6269329 << 2) | 0;
   $153 = HEAP32[$152 >> 2] | 0;
   $154 = +($153 | 0);
   $155 = $$2330 * $154;
   $156 = $8 + ($$6269329 << 3) | 0;
   HEAPF64[$156 >> 3] = $155;
   $157 = $$2330 * 5.9604644775390625e-08;
   $158 = $$6269329 + -1 | 0;
   $159 = ($$6269329 | 0) > 0;
   if ($159) {
    $$2330 = $157;
    $$6269329 = $158;
   } else {
    break;
   }
  }
  if ($151) {
   $$7270324 = $$2255;
   while (1) {
    $160 = $$2255 - $$7270324 | 0;
    $$1257318 = 0;
    $$3319 = 0.0;
    while (1) {
     $161 = 10288 + ($$1257318 << 3) | 0;
     $162 = +HEAPF64[$161 >> 3];
     $163 = $$1257318 + $$7270324 | 0;
     $164 = $8 + ($163 << 3) | 0;
     $165 = +HEAPF64[$164 >> 3];
     $166 = $162 * $165;
     $167 = $$3319 + $166;
     $168 = $$1257318 + 1 | 0;
     $169 = ($$1257318 | 0) >= ($10 | 0);
     $170 = $$1257318 >>> 0 >= $160 >>> 0;
     $or$cond = $169 | $170;
     if ($or$cond) {
      break;
     } else {
      $$1257318 = $168;
      $$3319 = $167;
     }
    }
    $171 = $7 + ($160 << 3) | 0;
    HEAPF64[$171 >> 3] = $167;
    $172 = $$7270324 + -1 | 0;
    $173 = ($$7270324 | 0) > 0;
    if ($173) {
     $$7270324 = $172;
    } else {
     break;
    }
   }
  }
 }
 L93 : do {
  switch ($4 | 0) {
  case 0:
   {
    if ($151) {
     $$4290 = 0.0;
     $$8289 = $$2255;
     while (1) {
      $174 = $7 + ($$8289 << 3) | 0;
      $175 = +HEAPF64[$174 >> 3];
      $176 = $$4290 + $175;
      $177 = $$8289 + -1 | 0;
      $178 = ($$8289 | 0) > 0;
      if ($178) {
       $$4290 = $176;
       $$8289 = $177;
      } else {
       $$4$lcssa = $176;
       break;
      }
     }
    } else {
     $$4$lcssa = 0.0;
    }
    $179 = ($$0250279 | 0) == 0;
    $180 = -$$4$lcssa;
    $181 = $179 ? $$4$lcssa : $180;
    HEAPF64[$1 >> 3] = $181;
    break;
   }
  case 2:
  case 1:
   {
    if ($151) {
     $$5298 = 0.0;
     $$9297 = $$2255;
     while (1) {
      $182 = $7 + ($$9297 << 3) | 0;
      $183 = +HEAPF64[$182 >> 3];
      $184 = $$5298 + $183;
      $185 = $$9297 + -1 | 0;
      $186 = ($$9297 | 0) > 0;
      if ($186) {
       $$5298 = $184;
       $$9297 = $185;
      } else {
       $$5$lcssa = $184;
       break;
      }
     }
    } else {
     $$5$lcssa = 0.0;
    }
    $187 = ($$0250279 | 0) == 0;
    $188 = -$$5$lcssa;
    $189 = $187 ? $$5$lcssa : $188;
    HEAPF64[$1 >> 3] = $189;
    $190 = +HEAPF64[$7 >> 3];
    $191 = $190 - $$5$lcssa;
    $192 = ($$2255 | 0) < 1;
    if ($192) {
     $$6$lcssa = $191;
    } else {
     $$10291 = 1;
     $$6292 = $191;
     while (1) {
      $193 = $7 + ($$10291 << 3) | 0;
      $194 = +HEAPF64[$193 >> 3];
      $195 = $$6292 + $194;
      $196 = $$10291 + 1 | 0;
      $exitcond = ($$10291 | 0) == ($$2255 | 0);
      if ($exitcond) {
       $$6$lcssa = $195;
       break;
      } else {
       $$10291 = $196;
       $$6292 = $195;
      }
     }
    }
    $197 = -$$6$lcssa;
    $198 = $187 ? $$6$lcssa : $197;
    $199 = $1 + 8 | 0;
    HEAPF64[$199 >> 3] = $198;
    break;
   }
  case 3:
   {
    $200 = ($$2255 | 0) > 0;
    if ($200) {
     $$phi$trans$insert = $7 + ($$2255 << 3) | 0;
     $$pre = +HEAPF64[$$phi$trans$insert >> 3];
     $$11313 = $$2255;
     $206 = $$pre;
     while (1) {
      $201 = $$11313 + -1 | 0;
      $202 = $7 + ($201 << 3) | 0;
      $203 = +HEAPF64[$202 >> 3];
      $204 = $7 + ($$11313 << 3) | 0;
      $205 = $203 + $206;
      $207 = $203 - $205;
      $208 = $206 + $207;
      HEAPF64[$204 >> 3] = $208;
      HEAPF64[$202 >> 3] = $205;
      $209 = ($$11313 | 0) > 1;
      if ($209) {
       $$11313 = $201;
       $206 = $205;
      } else {
       break;
      }
     }
     $210 = ($$2255 | 0) > 1;
     if ($210) {
      $$phi$trans$insert395 = $7 + ($$2255 << 3) | 0;
      $$pre396 = +HEAPF64[$$phi$trans$insert395 >> 3];
      $$12309 = $$2255;
      $216 = $$pre396;
      while (1) {
       $211 = $$12309 + -1 | 0;
       $212 = $7 + ($211 << 3) | 0;
       $213 = +HEAPF64[$212 >> 3];
       $214 = $7 + ($$12309 << 3) | 0;
       $215 = $213 + $216;
       $217 = $213 - $215;
       $218 = $216 + $217;
       HEAPF64[$214 >> 3] = $218;
       HEAPF64[$212 >> 3] = $215;
       $219 = ($$12309 | 0) > 2;
       if ($219) {
        $$12309 = $211;
        $216 = $215;
       } else {
        break;
       }
      }
      if ($210) {
       $$13303 = $$2255;
       $$7304 = 0.0;
       while (1) {
        $220 = $7 + ($$13303 << 3) | 0;
        $221 = +HEAPF64[$220 >> 3];
        $222 = $$7304 + $221;
        $223 = $$13303 + -1 | 0;
        $224 = ($$13303 | 0) > 2;
        if ($224) {
         $$13303 = $223;
         $$7304 = $222;
        } else {
         $$7$lcssa = $222;
         break;
        }
       }
      } else {
       $$7$lcssa = 0.0;
      }
     } else {
      $$7$lcssa = 0.0;
     }
    } else {
     $$7$lcssa = 0.0;
    }
    $225 = ($$0250279 | 0) == 0;
    $226 = +HEAPF64[$7 >> 3];
    if ($225) {
     HEAPF64[$1 >> 3] = $226;
     $227 = $7 + 8 | 0;
     $228 = +HEAPF64[$227 >> 3];
     $229 = $1 + 8 | 0;
     HEAPF64[$229 >> 3] = $228;
     $230 = $1 + 16 | 0;
     HEAPF64[$230 >> 3] = $$7$lcssa;
     break L93;
    } else {
     $231 = -$226;
     HEAPF64[$1 >> 3] = $231;
     $232 = $7 + 8 | 0;
     $233 = +HEAPF64[$232 >> 3];
     $234 = -$233;
     $235 = $1 + 8 | 0;
     HEAPF64[$235 >> 3] = $234;
     $236 = -$$7$lcssa;
     $237 = $1 + 16 | 0;
     HEAPF64[$237 >> 3] = $236;
     break L93;
    }
    break;
   }
  default:
   {}
  }
 } while (0);
 $238 = $$1272 & 7;
 STACKTOP = sp;
 return $238 | 0;
}
function _mp_vprintf($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0.0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0.0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0.0, $332 = 0.0, $333 = 0, $334 = 0.0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $arglist_current = 0, $arglist_current12 = 0, $arglist_current15 = 0, $arglist_current18 = 0, $arglist_current21 = 0, $arglist_current24 = 0, $arglist_current3 = 0, $arglist_current6 = 0, $arglist_current9 = 0, $arglist_next = 0, $arglist_next10 = 0, $arglist_next13 = 0, $arglist_next16 = 0, $arglist_next19 = 0, $arglist_next22 = 0, $arglist_next25 = 0, $arglist_next4 = 0, $arglist_next7 = 0, $expanded = 0, $expanded26 = 0, $expanded28 = 0, $expanded29 = 0, $expanded30 = 0, $expanded32 = 0, $expanded33 = 0, $expanded35 = 0, $expanded36 = 0, $expanded37 = 0, $expanded39 = 0, $expanded40 = 0, $expanded42 = 0, $expanded43 = 0, $expanded44 = 0, $expanded46 = 0, $expanded47 = 0, $expanded49 = 0, $expanded50 = 0, $expanded51 = 0, $expanded53 = 0, $expanded54 = 0, $expanded56 = 0, $expanded57 = 0, $expanded58 = 0, $expanded60 = 0, $expanded61 = 0, $expanded63 = 0, $expanded64 = 0, $expanded65 = 0, $expanded67 = 0, $expanded68 = 0, $expanded70 = 0, $expanded71 = 0, $expanded72 = 0, $expanded74 = 0, $expanded75 = 0, $expanded77 = 0, $expanded78 = 0, $expanded79 = 0, $expanded81 = 0, $expanded82 = 0, $expanded84 = 0, $expanded85 = 0, $expanded86 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112 | 0);
 $15 = sp + 109 | 0;
 $19 = sp + 52 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = 0;
 while (1) {
  $32 = $4;
  $7 = $32;
  while (1) {
   $33 = $7;
   $34 = HEAP8[$33 >> 0] | 0;
   $35 = $34 << 24 >> 24;
   $36 = ($35 | 0) != 0;
   if ($36) {
    $37 = $7;
    $38 = HEAP8[$37 >> 0] | 0;
    $39 = $38 << 24 >> 24;
    $40 = ($39 | 0) != 37;
    $355 = $40;
   } else {
    $355 = 0;
   }
   $41 = $7;
   if (!$355) {
    break;
   }
   $42 = $41 + 1 | 0;
   $7 = $42;
  }
  $43 = $4;
  $44 = $41 >>> 0 > $43 >>> 0;
  if ($44) {
   $45 = $3;
   $46 = $45 + 4 | 0;
   $47 = HEAP32[$46 >> 2] | 0;
   $48 = $3;
   $49 = HEAP32[$48 >> 2] | 0;
   $50 = $4;
   $51 = $7;
   $52 = $4;
   $53 = $51;
   $54 = $52;
   $55 = $53 - $54 | 0;
   FUNCTION_TABLE_viii[$47 & 1023]($49, $50, $55);
   $56 = $7;
   $57 = $4;
   $58 = $56;
   $59 = $57;
   $60 = $58 - $59 | 0;
   $61 = $6;
   $62 = $61 + $60 | 0;
   $6 = $62;
   $63 = $7;
   $4 = $63;
  }
  $64 = $4;
  $65 = HEAP8[$64 >> 0] | 0;
  $66 = $65 << 24 >> 24;
  $67 = ($66 | 0) == 0;
  if ($67) {
   label = 56;
   break;
  }
  $68 = $4;
  $69 = $68 + 1 | 0;
  $4 = $69;
  $8 = 0;
  $9 = 32;
  L14 : while (1) {
   $70 = $4;
   $71 = HEAP8[$70 >> 0] | 0;
   $72 = $71 << 24 >> 24;
   $73 = ($72 | 0) != 0;
   if (!$73) {
    break;
   }
   $74 = $4;
   $75 = HEAP8[$74 >> 0] | 0;
   $76 = $75 << 24 >> 24;
   $77 = ($76 | 0) == 45;
   do {
    if ($77) {
     $78 = $8;
     $79 = $78 | 1;
     $8 = $79;
    } else {
     $80 = $4;
     $81 = HEAP8[$80 >> 0] | 0;
     $82 = $81 << 24 >> 24;
     $83 = ($82 | 0) == 43;
     if ($83) {
      $84 = $8;
      $85 = $84 | 2;
      $8 = $85;
      break;
     }
     $86 = $4;
     $87 = HEAP8[$86 >> 0] | 0;
     $88 = $87 << 24 >> 24;
     $89 = ($88 | 0) == 32;
     if ($89) {
      $90 = $8;
      $91 = $90 | 4;
      $8 = $91;
      break;
     }
     $92 = $4;
     $93 = HEAP8[$92 >> 0] | 0;
     $94 = $93 << 24 >> 24;
     $95 = ($94 | 0) == 33;
     if ($95) {
      $96 = $8;
      $97 = $96 | 8;
      $8 = $97;
      break;
     }
     $98 = $4;
     $99 = HEAP8[$98 >> 0] | 0;
     $100 = $99 << 24 >> 24;
     $101 = ($100 | 0) == 48;
     if (!$101) {
      break L14;
     }
     $102 = $8;
     $103 = $102 | 64;
     $8 = $103;
     $9 = 48;
    }
   } while (0);
   $104 = $4;
   $105 = $104 + 1 | 0;
   $4 = $105;
  }
  $10 = 0;
  while (1) {
   $106 = $4;
   $107 = HEAP8[$106 >> 0] | 0;
   $108 = $107 << 24 >> 24;
   $109 = 48 <= ($108 | 0);
   if (!$109) {
    break;
   }
   $110 = $4;
   $111 = HEAP8[$110 >> 0] | 0;
   $112 = $111 << 24 >> 24;
   $113 = ($112 | 0) <= 57;
   if (!$113) {
    break;
   }
   $114 = $10;
   $115 = $114 * 10 | 0;
   $116 = $4;
   $117 = HEAP8[$116 >> 0] | 0;
   $118 = $117 << 24 >> 24;
   $119 = $115 + $118 | 0;
   $120 = $119 - 48 | 0;
   $10 = $120;
   $121 = $4;
   $122 = $121 + 1 | 0;
   $4 = $122;
  }
  $11 = -1;
  $123 = $4;
  $124 = HEAP8[$123 >> 0] | 0;
  $125 = $124 << 24 >> 24;
  $126 = ($125 | 0) == 46;
  if ($126) {
   $127 = $4;
   $128 = $127 + 1 | 0;
   $4 = $128;
   $129 = $4;
   $130 = HEAP8[$129 >> 0] | 0;
   $131 = $130 << 24 >> 24;
   $132 = ($131 | 0) == 42;
   L39 : do {
    if ($132) {
     $133 = $4;
     $134 = $133 + 1 | 0;
     $4 = $134;
     $135 = $5;
     $arglist_current = HEAP32[$135 >> 2] | 0;
     $136 = $arglist_current;
     $137 = 0 + 4 | 0;
     $expanded26 = $137;
     $expanded = $expanded26 - 1 | 0;
     $138 = $136 + $expanded | 0;
     $139 = 0 + 4 | 0;
     $expanded30 = $139;
     $expanded29 = $expanded30 - 1 | 0;
     $expanded28 = $expanded29 ^ -1;
     $140 = $138 & $expanded28;
     $141 = $140;
     $142 = HEAP32[$141 >> 2] | 0;
     $arglist_next = $141 + 4 | 0;
     HEAP32[$135 >> 2] = $arglist_next;
     $12 = $142;
     $143 = $12;
     $11 = $143;
    } else {
     $11 = 0;
     while (1) {
      $144 = $4;
      $145 = HEAP8[$144 >> 0] | 0;
      $146 = $145 << 24 >> 24;
      $147 = 48 <= ($146 | 0);
      if (!$147) {
       break L39;
      }
      $148 = $4;
      $149 = HEAP8[$148 >> 0] | 0;
      $150 = $149 << 24 >> 24;
      $151 = ($150 | 0) <= 57;
      if (!$151) {
       break L39;
      }
      $152 = $11;
      $153 = $152 * 10 | 0;
      $154 = $4;
      $155 = HEAP8[$154 >> 0] | 0;
      $156 = $155 << 24 >> 24;
      $157 = $153 + $156 | 0;
      $158 = $157 - 48 | 0;
      $11 = $158;
      $159 = $4;
      $160 = $159 + 1 | 0;
      $4 = $160;
     }
    }
   } while (0);
   $161 = $11;
   $162 = ($161 | 0) < 0;
   if ($162) {
    $11 = 0;
   }
  }
  $13 = 0;
  $163 = $4;
  $164 = HEAP8[$163 >> 0] | 0;
  $165 = $164 << 24 >> 24;
  $166 = ($165 | 0) == 108;
  if ($166) {
   $167 = $4;
   $168 = $167 + 1 | 0;
   $4 = $168;
  }
  $169 = $4;
  $170 = HEAP8[$169 >> 0] | 0;
  $171 = $170 << 24 >> 24;
  $172 = ($171 | 0) == 0;
  if ($172) {
   label = 56;
   break;
  }
  $173 = $4;
  $174 = HEAP8[$173 >> 0] | 0;
  $175 = $174 << 24 >> 24;
  L53 : do {
   switch ($175 | 0) {
   case 98:
    {
     $176 = $5;
     $arglist_current3 = HEAP32[$176 >> 2] | 0;
     $177 = $arglist_current3;
     $178 = 0 + 4 | 0;
     $expanded33 = $178;
     $expanded32 = $expanded33 - 1 | 0;
     $179 = $177 + $expanded32 | 0;
     $180 = 0 + 4 | 0;
     $expanded37 = $180;
     $expanded36 = $expanded37 - 1 | 0;
     $expanded35 = $expanded36 ^ -1;
     $181 = $179 & $expanded35;
     $182 = $181;
     $183 = HEAP32[$182 >> 2] | 0;
     $arglist_next4 = $182 + 4 | 0;
     HEAP32[$176 >> 2] = $arglist_next4;
     $14 = $183;
     $184 = $14;
     $185 = ($184 | 0) != 0;
     $186 = $3;
     $187 = $8;
     $188 = $9;
     $189 = $10;
     if ($185) {
      $190 = _mp_print_strn($186, 30856, 4, $187, $188, $189) | 0;
      $191 = $6;
      $192 = $191 + $190 | 0;
      $6 = $192;
      break L53;
     } else {
      $193 = _mp_print_strn($186, 30861, 5, $187, $188, $189) | 0;
      $194 = $6;
      $195 = $194 + $193 | 0;
      $6 = $195;
      break L53;
     }
     break;
    }
   case 99:
    {
     $196 = $5;
     $arglist_current6 = HEAP32[$196 >> 2] | 0;
     $197 = $arglist_current6;
     $198 = 0 + 4 | 0;
     $expanded40 = $198;
     $expanded39 = $expanded40 - 1 | 0;
     $199 = $197 + $expanded39 | 0;
     $200 = 0 + 4 | 0;
     $expanded44 = $200;
     $expanded43 = $expanded44 - 1 | 0;
     $expanded42 = $expanded43 ^ -1;
     $201 = $199 & $expanded42;
     $202 = $201;
     $203 = HEAP32[$202 >> 2] | 0;
     $arglist_next7 = $202 + 4 | 0;
     HEAP32[$196 >> 2] = $arglist_next7;
     $16 = $203;
     $204 = $16;
     $205 = $204 & 255;
     HEAP8[$15 >> 0] = $205;
     $206 = $3;
     $207 = $8;
     $208 = $9;
     $209 = $10;
     $210 = _mp_print_strn($206, $15, 1, $207, $208, $209) | 0;
     $211 = $6;
     $212 = $211 + $210 | 0;
     $6 = $212;
     break;
    }
   case 113:
    {
     $213 = $5;
     $arglist_current9 = HEAP32[$213 >> 2] | 0;
     $214 = $arglist_current9;
     $215 = 0 + 4 | 0;
     $expanded47 = $215;
     $expanded46 = $expanded47 - 1 | 0;
     $216 = $214 + $expanded46 | 0;
     $217 = 0 + 4 | 0;
     $expanded51 = $217;
     $expanded50 = $expanded51 - 1 | 0;
     $expanded49 = $expanded50 ^ -1;
     $218 = $216 & $expanded49;
     $219 = $218;
     $220 = HEAP32[$219 >> 2] | 0;
     $arglist_next10 = $219 + 4 | 0;
     HEAP32[$213 >> 2] = $arglist_next10;
     $18 = $220;
     $221 = $18;
     $17 = $221;
     $222 = $17;
     $223 = _qstr_data($222, $19) | 0;
     $20 = $223;
     $224 = $11;
     $225 = ($224 | 0) < 0;
     if ($225) {
      $226 = HEAP32[$19 >> 2] | 0;
      $11 = $226;
     }
     $227 = $3;
     $228 = $20;
     $229 = $11;
     $230 = $8;
     $231 = $9;
     $232 = $10;
     $233 = _mp_print_strn($227, $228, $229, $230, $231, $232) | 0;
     $234 = $6;
     $235 = $234 + $233 | 0;
     $6 = $235;
     break;
    }
   case 115:
    {
     $236 = $5;
     $arglist_current12 = HEAP32[$236 >> 2] | 0;
     $237 = $arglist_current12;
     $238 = 0 + 4 | 0;
     $expanded54 = $238;
     $expanded53 = $expanded54 - 1 | 0;
     $239 = $237 + $expanded53 | 0;
     $240 = 0 + 4 | 0;
     $expanded58 = $240;
     $expanded57 = $expanded58 - 1 | 0;
     $expanded56 = $expanded57 ^ -1;
     $241 = $239 & $expanded56;
     $242 = $241;
     $243 = HEAP32[$242 >> 2] | 0;
     $arglist_next13 = $242 + 4 | 0;
     HEAP32[$236 >> 2] = $arglist_next13;
     $22 = $243;
     $244 = $22;
     $21 = $244;
     $245 = $11;
     $246 = ($245 | 0) < 0;
     if ($246) {
      $247 = $21;
      $248 = _strlen($247) | 0;
      $11 = $248;
     }
     $249 = $3;
     $250 = $21;
     $251 = $11;
     $252 = $8;
     $253 = $9;
     $254 = $10;
     $255 = _mp_print_strn($249, $250, $251, $252, $253, $254) | 0;
     $256 = $6;
     $257 = $256 + $255 | 0;
     $6 = $257;
     break;
    }
   case 100:
    {
     $258 = $5;
     $arglist_current15 = HEAP32[$258 >> 2] | 0;
     $259 = $arglist_current15;
     $260 = 0 + 4 | 0;
     $expanded61 = $260;
     $expanded60 = $expanded61 - 1 | 0;
     $261 = $259 + $expanded60 | 0;
     $262 = 0 + 4 | 0;
     $expanded65 = $262;
     $expanded64 = $expanded65 - 1 | 0;
     $expanded63 = $expanded64 ^ -1;
     $263 = $261 & $expanded63;
     $264 = $263;
     $265 = HEAP32[$264 >> 2] | 0;
     $arglist_next16 = $264 + 4 | 0;
     HEAP32[$258 >> 2] = $arglist_next16;
     $24 = $265;
     $266 = $24;
     $23 = $266;
     $267 = $3;
     $268 = $23;
     $269 = $8;
     $270 = $9;
     $271 = $10;
     $272 = _mp_print_int($267, $268, 1, 10, 97, $269, $270, $271) | 0;
     $273 = $6;
     $274 = $273 + $272 | 0;
     $6 = $274;
     break;
    }
   case 88:
   case 120:
   case 117:
    {
     $275 = $4;
     $276 = HEAP8[$275 >> 0] | 0;
     $277 = $276 << 24 >> 24;
     $278 = $277 + 1 | 0;
     $279 = $278 & 6;
     $280 = 16 - $279 | 0;
     $25 = $280;
     $281 = $4;
     $282 = HEAP8[$281 >> 0] | 0;
     $283 = $282 << 24 >> 24;
     $284 = $283 & 240;
     $285 = $284 - 80 | 0;
     $286 = $285 + 65 | 0;
     $287 = $286 & 255;
     $26 = $287;
     $288 = $5;
     $arglist_current18 = HEAP32[$288 >> 2] | 0;
     $289 = $arglist_current18;
     $290 = 0 + 4 | 0;
     $expanded68 = $290;
     $expanded67 = $expanded68 - 1 | 0;
     $291 = $289 + $expanded67 | 0;
     $292 = 0 + 4 | 0;
     $expanded72 = $292;
     $expanded71 = $expanded72 - 1 | 0;
     $expanded70 = $expanded71 ^ -1;
     $293 = $291 & $expanded70;
     $294 = $293;
     $295 = HEAP32[$294 >> 2] | 0;
     $arglist_next19 = $294 + 4 | 0;
     HEAP32[$288 >> 2] = $arglist_next19;
     $28 = $295;
     $296 = $28;
     $27 = $296;
     $297 = $3;
     $298 = $27;
     $299 = $25;
     $300 = $26;
     $301 = $300 << 24 >> 24;
     $302 = $8;
     $303 = $9;
     $304 = $10;
     $305 = _mp_print_int($297, $298, 0, $299, $301, $302, $303, $304) | 0;
     $306 = $6;
     $307 = $306 + $305 | 0;
     $6 = $307;
     break;
    }
   case 80:
   case 112:
    {
     $308 = $3;
     $309 = $5;
     $arglist_current21 = HEAP32[$309 >> 2] | 0;
     $310 = $arglist_current21;
     $311 = 0 + 4 | 0;
     $expanded75 = $311;
     $expanded74 = $expanded75 - 1 | 0;
     $312 = $310 + $expanded74 | 0;
     $313 = 0 + 4 | 0;
     $expanded79 = $313;
     $expanded78 = $expanded79 - 1 | 0;
     $expanded77 = $expanded78 ^ -1;
     $314 = $312 & $expanded77;
     $315 = $314;
     $316 = HEAP32[$315 >> 2] | 0;
     $arglist_next22 = $315 + 4 | 0;
     HEAP32[$309 >> 2] = $arglist_next22;
     $29 = $316;
     $317 = $29;
     $318 = $8;
     $319 = $9;
     $320 = $10;
     $321 = _mp_print_int($308, $317, 0, 16, 97, $318, $319, $320) | 0;
     $322 = $6;
     $323 = $322 + $321 | 0;
     $6 = $323;
     break;
    }
   case 71:
   case 103:
   case 70:
   case 102:
   case 69:
   case 101:
    {
     $324 = $5;
     $arglist_current24 = HEAP32[$324 >> 2] | 0;
     $325 = $arglist_current24;
     $326 = 0 + 8 | 0;
     $expanded82 = $326;
     $expanded81 = $expanded82 - 1 | 0;
     $327 = $325 + $expanded81 | 0;
     $328 = 0 + 8 | 0;
     $expanded86 = $328;
     $expanded85 = $expanded86 - 1 | 0;
     $expanded84 = $expanded85 ^ -1;
     $329 = $327 & $expanded84;
     $330 = $329;
     $331 = +HEAPF64[$330 >> 3];
     $arglist_next25 = $330 + 8 | 0;
     HEAP32[$324 >> 2] = $arglist_next25;
     $31 = $331;
     $332 = $31;
     $30 = $332;
     $333 = $3;
     $334 = $30;
     $335 = $4;
     $336 = HEAP8[$335 >> 0] | 0;
     $337 = $8;
     $338 = $9;
     $339 = $10;
     $340 = $11;
     $341 = _mp_print_float($333, $334, $336, $337, $338, $339, $340) | 0;
     $342 = $6;
     $343 = $342 + $341 | 0;
     $6 = $343;
     break;
    }
   default:
    {
     $344 = $3;
     $345 = $344 + 4 | 0;
     $346 = HEAP32[$345 >> 2] | 0;
     $347 = $3;
     $348 = HEAP32[$347 >> 2] | 0;
     $349 = $4;
     FUNCTION_TABLE_viii[$346 & 1023]($348, $349, 1);
     $350 = $6;
     $351 = $350 + 1 | 0;
     $6 = $351;
    }
   }
  } while (0);
  $352 = $4;
  $353 = $352 + 1 | 0;
  $4 = $353;
 }
 if ((label | 0) == 56) {
  $354 = $6;
  STACKTOP = sp;
  return $354 | 0;
 }
 return 0 | 0;
}

function _pow($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $$ = 0.0, $$0 = 0.0, $$0385 = 0.0, $$0386 = 0.0, $$0387 = 0.0, $$0388 = 0.0, $$0390 = 0.0, $$0391 = 0, $$0392 = 0, $$0392399 = 0, $$0392400 = 0, $$0396 = 0, $$12 = 0.0, $$1394 = 0, $$1397 = 0, $$2 = 0.0, $$3 = 0, $$pre = 0.0, $$sink = 0.0, $$sink410 = 0.0, $10 = 0, $100 = 0.0, $101 = 0, $102 = 0, $103 = 0.0, $104 = 0.0, $105 = 0, $106 = 0.0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0.0, $121 = 0, $122 = 0.0, $123 = 0.0, $124 = 0.0, $125 = 0.0, $126 = 0.0, $127 = 0, $128 = 0, $129 = 0.0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0.0, $136 = 0.0, $137 = 0.0, $138 = 0.0, $139 = 0.0, $14 = 0, $140 = 0.0, $141 = 0.0, $142 = 0.0, $143 = 0.0, $144 = 0.0, $145 = 0.0, $146 = 0.0, $147 = 0.0, $148 = 0.0, $149 = 0.0, $15 = 0, $150 = 0.0, $151 = 0.0, $152 = 0.0, $153 = 0.0, $154 = 0.0, $155 = 0.0, $156 = 0.0, $157 = 0.0, $158 = 0.0, $159 = 0.0, $16 = 0, $160 = 0.0, $161 = 0.0, $162 = 0, $163 = 0, $164 = 0.0, $165 = 0.0, $166 = 0.0, $167 = 0.0, $168 = 0.0, $169 = 0.0, $17 = 0, $170 = 0.0, $171 = 0.0, $172 = 0.0, $173 = 0, $174 = 0, $175 = 0.0, $176 = 0.0, $177 = 0.0, $178 = 0.0, $179 = 0.0, $18 = 0.0, $180 = 0.0, $181 = 0.0, $182 = 0, $183 = 0.0, $184 = 0.0, $185 = 0.0, $186 = 0.0, $187 = 0, $188 = 0.0, $189 = 0.0, $19 = 0, $190 = 0.0, $191 = 0, $192 = 0, $193 = 0.0, $194 = 0.0, $195 = 0.0, $196 = 0.0, $197 = 0.0, $198 = 0.0, $199 = 0.0, $2 = 0, $20 = 0, $200 = 0.0, $201 = 0.0, $202 = 0.0, $203 = 0.0, $204 = 0.0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0.0, $212 = 0.0, $213 = 0.0, $214 = 0.0, $215 = 0, $216 = 0.0, $217 = 0.0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0.0, $224 = 0.0, $225 = 0.0, $226 = 0, $227 = 0.0, $228 = 0.0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0.0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0.0, $248 = 0, $249 = 0, $25 = 0, $250 = 0.0, $251 = 0, $252 = 0.0, $253 = 0.0, $254 = 0.0, $255 = 0.0, $256 = 0.0, $257 = 0.0, $258 = 0.0, $259 = 0.0, $26 = 0, $260 = 0.0, $261 = 0.0, $262 = 0.0, $263 = 0.0, $264 = 0.0, $265 = 0.0, $266 = 0.0, $267 = 0.0, $268 = 0.0, $269 = 0.0, $27 = 0, $270 = 0.0, $271 = 0.0, $272 = 0.0, $273 = 0.0, $274 = 0.0, $275 = 0.0, $276 = 0.0, $277 = 0.0, $278 = 0.0, $279 = 0.0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0.0, $286 = 0.0, $287 = 0.0, $288 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0, $47 = 0, $48 = 0.0, $49 = 0, $5 = 0, $50 = 0.0, $51 = 0, $52 = 0, $53 = 0.0, $54 = 0.0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0.0, $61 = 0, $62 = 0, $63 = 0, $64 = 0.0, $65 = 0.0, $66 = 0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0.0, $78 = 0.0, $79 = 0.0, $8 = 0, $80 = 0.0, $81 = 0.0, $82 = 0, $83 = 0, $84 = 0.0, $85 = 0.0, $86 = 0.0, $87 = 0.0, $88 = 0.0, $89 = 0.0, $9 = 0, $90 = 0.0, $91 = 0.0, $92 = 0.0, $93 = 0.0, $94 = 0.0, $95 = 0.0, $96 = 0.0, $97 = 0.0, $98 = 0.0, $99 = 0.0, $not$ = 0, $or$cond = 0, $or$cond14 = 0, $or$cond3 = 0, $or$cond5 = 0, $or$cond7 = 0, $spec$select = 0.0, $spec$select398 = 0, $spec$select402 = 0, $spec$select403 = 0, $spec$select404 = 0.0, $spec$select405 = 0, $spec$select406 = 0, $spec$select407 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $2 = HEAP32[tempDoublePtr >> 2] | 0;
 $3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 HEAPF64[tempDoublePtr >> 3] = $1;
 $4 = HEAP32[tempDoublePtr >> 2] | 0;
 $5 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $6 = $3 & 2147483647;
 $7 = $5 & 2147483647;
 $8 = $7 | $4;
 $9 = ($8 | 0) == 0;
 if ($9) {
  $$0 = 1.0;
  return +$$0;
 }
 $10 = ($3 | 0) == 1072693248;
 $11 = ($2 | 0) == 0;
 $or$cond = $11 & $10;
 if ($or$cond) {
  $$0 = 1.0;
  return +$$0;
 }
 $12 = $6 >>> 0 > 2146435072;
 if (!$12) {
  $13 = ($6 | 0) == 2146435072;
  $14 = ($2 | 0) != 0;
  $or$cond3 = $14 & $13;
  $15 = $7 >>> 0 > 2146435072;
  $or$cond5 = $or$cond3 | $15;
  if (!$or$cond5) {
   $16 = ($7 | 0) == 2146435072;
   $17 = ($4 | 0) != 0;
   $or$cond7 = $17 & $16;
   if (!$or$cond7) {
    $19 = ($3 | 0) < 0;
    do {
     if ($19) {
      $20 = $7 >>> 0 > 1128267775;
      if ($20) {
       $$0392 = 2;
       label = 14;
      } else {
       $21 = $7 >>> 0 > 1072693247;
       if ($21) {
        $22 = $7 >>> 20;
        $23 = $7 >>> 0 > 1094713343;
        if ($23) {
         $24 = 1075 - $22 | 0;
         $25 = $4 >>> $24;
         $26 = $25 << $24;
         $27 = ($26 | 0) == ($4 | 0);
         $28 = $25 & 1;
         $29 = 2 - $28 | 0;
         $spec$select402 = $27 ? $29 : 0;
         $$0392 = $spec$select402;
         label = 14;
         break;
        }
        $30 = ($4 | 0) == 0;
        if ($30) {
         $31 = 1043 - $22 | 0;
         $32 = $7 >>> $31;
         $33 = $32 << $31;
         $34 = ($33 | 0) == ($7 | 0);
         $35 = $32 & 1;
         $36 = 2 - $35 | 0;
         $spec$select403 = $34 ? $36 : 0;
         $$0392400 = $spec$select403;
         label = 15;
        } else {
         $$0392399 = 0;
        }
       } else {
        $$0392 = 0;
        label = 14;
       }
      }
     } else {
      $$0392 = 0;
      label = 14;
     }
    } while (0);
    if ((label | 0) == 14) {
     $37 = ($4 | 0) == 0;
     if ($37) {
      $$0392400 = $$0392;
      label = 15;
     } else {
      $$0392399 = $$0392;
     }
    }
    if ((label | 0) == 15) {
     if ($16) {
      $38 = $6 + -1072693248 | 0;
      $39 = $38 | $2;
      $40 = ($39 | 0) == 0;
      if ($40) {
       $$0 = 1.0;
       return +$$0;
      }
      $41 = $6 >>> 0 > 1072693247;
      $42 = ($5 | 0) > -1;
      if ($41) {
       $43 = $42 ? $1 : 0.0;
       $$0 = $43;
       return +$$0;
      } else {
       $44 = -$1;
       $45 = $42 ? 0.0 : $44;
       $$0 = $45;
       return +$$0;
      }
     }
     $46 = ($7 | 0) == 1072693248;
     if ($46) {
      $47 = ($5 | 0) > -1;
      $48 = 1.0 / $0;
      $spec$select404 = $47 ? $0 : $48;
      return +$spec$select404;
     }
     $49 = ($5 | 0) == 1073741824;
     if ($49) {
      $50 = $0 * $0;
      $$0 = $50;
      return +$$0;
     }
     $51 = ($5 | 0) == 1071644672;
     $52 = ($3 | 0) > -1;
     $or$cond14 = $52 & $51;
     if ($or$cond14) {
      $53 = +Math_sqrt(+$0);
      $$0 = $53;
      return +$$0;
     } else {
      $$0392399 = $$0392400;
     }
    }
    $54 = +Math_abs(+$0);
    if ($11) {
     $55 = ($6 | 0) == 0;
     $56 = $6 | 1073741824;
     $57 = ($56 | 0) == 2146435072;
     $58 = $55 | $57;
     if ($58) {
      $59 = ($5 | 0) < 0;
      $60 = 1.0 / $54;
      $$0385 = $59 ? $60 : $54;
      if (!$19) {
       $$0 = $$0385;
       return +$$0;
      }
      $61 = $6 + -1072693248 | 0;
      $62 = $$0392399 | $61;
      $63 = ($62 | 0) == 0;
      if (!$63) {
       $66 = ($$0392399 | 0) == 1;
       $67 = -$$0385;
       $spec$select = $66 ? $67 : $$0385;
       return +$spec$select;
      }
      $64 = $$0385 - $$0385;
      $65 = $64 / $64;
      $$0 = $65;
      return +$$0;
     }
    }
    L55 : do {
     if ($19) {
      switch ($$0392399 | 0) {
      case 0:
       {
        break;
       }
      case 1:
       {
        $$0390 = -1.0;
        break L55;
        break;
       }
      default:
       {
        $$0390 = 1.0;
        break L55;
       }
      }
      $68 = $0 - $0;
      $69 = $68 / $68;
      $$0 = $69;
      return +$$0;
     } else {
      $$0390 = 1.0;
     }
    } while (0);
    $70 = $7 >>> 0 > 1105199104;
    do {
     if ($70) {
      $71 = $7 >>> 0 > 1139802112;
      if ($71) {
       $72 = $6 >>> 0 < 1072693248;
       if ($72) {
        $73 = ($5 | 0) < 0;
        $$ = $73 ? inf : 0.0;
        $$0 = $$;
        return +$$0;
       } else {
        $74 = ($5 | 0) > 0;
        $$12 = $74 ? inf : 0.0;
        $$0 = $$12;
        return +$$0;
       }
      }
      $75 = $6 >>> 0 < 1072693247;
      if ($75) {
       $76 = ($5 | 0) < 0;
       $77 = $$0390 * 1.e+300;
       $78 = $77 * 1.e+300;
       $79 = $$0390 * 1.0e-300;
       $80 = $79 * 1.0e-300;
       $81 = $76 ? $78 : $80;
       $$0 = $81;
       return +$$0;
      }
      $82 = $6 >>> 0 > 1072693248;
      if (!$82) {
       $89 = $54 + -1.0;
       $90 = $89 * $89;
       $91 = $89 * .25;
       $92 = .3333333333333333 - $91;
       $93 = $89 * $92;
       $94 = .5 - $93;
       $95 = $90 * $94;
       $96 = $89 * 1.4426950216293335;
       $97 = $89 * 1.9259629911266175e-08;
       $98 = $95 * 1.4426950408889634;
       $99 = $97 - $98;
       $100 = $96 + $99;
       HEAPF64[tempDoublePtr >> 3] = $100;
       $101 = HEAP32[tempDoublePtr >> 2] | 0;
       $102 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
       HEAP32[tempDoublePtr >> 2] = 0;
       HEAP32[tempDoublePtr + 4 >> 2] = $102;
       $103 = +HEAPF64[tempDoublePtr >> 3];
       $104 = $103 - $96;
       $$0388 = $103;
       $$sink = $99;
       $$sink410 = $104;
       break;
      }
      $83 = ($5 | 0) > 0;
      $84 = $$0390 * 1.e+300;
      $85 = $84 * 1.e+300;
      $86 = $$0390 * 1.0e-300;
      $87 = $86 * 1.0e-300;
      $88 = $83 ? $85 : $87;
      $$0 = $88;
      return +$$0;
     } else {
      $105 = $6 >>> 0 < 1048576;
      $106 = $54 * 9007199254740992.0;
      HEAPF64[tempDoublePtr >> 3] = $106;
      $107 = HEAP32[tempDoublePtr >> 2] | 0;
      $108 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
      $$0396 = $105 ? $108 : $6;
      $$0386 = $105 ? $106 : $54;
      $109 = $$0396 >> 20;
      $110 = $105 ? -1076 : -1023;
      $111 = $110 + $109 | 0;
      $112 = $$0396 & 1048575;
      $113 = $112 | 1072693248;
      $114 = $112 >>> 0 < 235663;
      if ($114) {
       $$0391 = 0;
       $$1394 = $111;
       $$1397 = $113;
      } else {
       $115 = $112 >>> 0 < 767610;
       $116 = $113 + -1048576 | 0;
       $spec$select405 = $115 ? $113 : $116;
       $not$ = $115 ^ 1;
       $117 = $not$ & 1;
       $spec$select406 = $111 + $117 | 0;
       $spec$select407 = $115 & 1;
       $$0391 = $spec$select407;
       $$1394 = $spec$select406;
       $$1397 = $spec$select405;
      }
      HEAPF64[tempDoublePtr >> 3] = $$0386;
      $118 = HEAP32[tempDoublePtr >> 2] | 0;
      $119 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
      HEAP32[tempDoublePtr >> 2] = $118;
      HEAP32[tempDoublePtr + 4 >> 2] = $$1397;
      $120 = +HEAPF64[tempDoublePtr >> 3];
      $121 = 10912 + ($$0391 << 3) | 0;
      $122 = +HEAPF64[$121 >> 3];
      $123 = $120 - $122;
      $124 = $122 + $120;
      $125 = 1.0 / $124;
      $126 = $123 * $125;
      HEAPF64[tempDoublePtr >> 3] = $126;
      $127 = HEAP32[tempDoublePtr >> 2] | 0;
      $128 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
      HEAP32[tempDoublePtr >> 2] = 0;
      HEAP32[tempDoublePtr + 4 >> 2] = $128;
      $129 = +HEAPF64[tempDoublePtr >> 3];
      $130 = $$1397 >> 1;
      $131 = $130 | 536870912;
      $132 = $131 + 524288 | 0;
      $133 = $$0391 << 18;
      $134 = $132 + $133 | 0;
      HEAP32[tempDoublePtr >> 2] = 0;
      HEAP32[tempDoublePtr + 4 >> 2] = $134;
      $135 = +HEAPF64[tempDoublePtr >> 3];
      $136 = $135 - $122;
      $137 = $120 - $136;
      $138 = $135 * $129;
      $139 = $123 - $138;
      $140 = $137 * $129;
      $141 = $139 - $140;
      $142 = $125 * $141;
      $143 = $126 * $126;
      $144 = $143 * $143;
      $145 = $143 * .20697501780033842;
      $146 = $145 + .23066074577556175;
      $147 = $143 * $146;
      $148 = $147 + .272728123808534;
      $149 = $143 * $148;
      $150 = $149 + .33333332981837743;
      $151 = $143 * $150;
      $152 = $151 + .4285714285785502;
      $153 = $143 * $152;
      $154 = $153 + .5999999999999946;
      $155 = $144 * $154;
      $156 = $126 + $129;
      $157 = $156 * $142;
      $158 = $157 + $155;
      $159 = $129 * $129;
      $160 = $159 + 3.0;
      $161 = $160 + $158;
      HEAPF64[tempDoublePtr >> 3] = $161;
      $162 = HEAP32[tempDoublePtr >> 2] | 0;
      $163 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
      HEAP32[tempDoublePtr >> 2] = 0;
      HEAP32[tempDoublePtr + 4 >> 2] = $163;
      $164 = +HEAPF64[tempDoublePtr >> 3];
      $165 = $164 + -3.0;
      $166 = $165 - $159;
      $167 = $158 - $166;
      $168 = $129 * $164;
      $169 = $142 * $164;
      $170 = $126 * $167;
      $171 = $169 + $170;
      $172 = $168 + $171;
      HEAPF64[tempDoublePtr >> 3] = $172;
      $173 = HEAP32[tempDoublePtr >> 2] | 0;
      $174 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
      HEAP32[tempDoublePtr >> 2] = 0;
      HEAP32[tempDoublePtr + 4 >> 2] = $174;
      $175 = +HEAPF64[tempDoublePtr >> 3];
      $176 = $175 - $168;
      $177 = $171 - $176;
      $178 = $175 * .9617967009544373;
      $179 = $175 * 7.028461650952758e-09;
      $180 = $177 * .9617966939259756;
      $181 = $180 - $179;
      $182 = 10928 + ($$0391 << 3) | 0;
      $183 = +HEAPF64[$182 >> 3];
      $184 = $183 + $181;
      $185 = +($$1394 | 0);
      $186 = $178 + $184;
      $187 = 10944 + ($$0391 << 3) | 0;
      $188 = +HEAPF64[$187 >> 3];
      $189 = $188 + $186;
      $190 = $189 + $185;
      HEAPF64[tempDoublePtr >> 3] = $190;
      $191 = HEAP32[tempDoublePtr >> 2] | 0;
      $192 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
      HEAP32[tempDoublePtr >> 2] = 0;
      HEAP32[tempDoublePtr + 4 >> 2] = $192;
      $193 = +HEAPF64[tempDoublePtr >> 3];
      $194 = $193 - $185;
      $195 = $194 - $188;
      $196 = $195 - $178;
      $$0388 = $193;
      $$sink = $184;
      $$sink410 = $196;
     }
    } while (0);
    $197 = $$sink - $$sink410;
    HEAP32[tempDoublePtr >> 2] = 0;
    HEAP32[tempDoublePtr + 4 >> 2] = $5;
    $198 = +HEAPF64[tempDoublePtr >> 3];
    $199 = $1 - $198;
    $200 = $199 * $$0388;
    $201 = $197 * $1;
    $202 = $201 + $200;
    $203 = $$0388 * $198;
    $204 = $203 + $202;
    HEAPF64[tempDoublePtr >> 3] = $204;
    $205 = HEAP32[tempDoublePtr >> 2] | 0;
    $206 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
    $207 = ($206 | 0) > 1083179007;
    if ($207) {
     $208 = $206 + -1083179008 | 0;
     $209 = $208 | $205;
     $210 = ($209 | 0) == 0;
     if (!$210) {
      $211 = $$0390 * 1.e+300;
      $212 = $211 * 1.e+300;
      $$0 = $212;
      return +$$0;
     }
     $213 = $202 + 8.008566259537294e-17;
     $214 = $204 - $203;
     $215 = $213 > $214;
     if ($215) {
      $216 = $$0390 * 1.e+300;
      $217 = $216 * 1.e+300;
      $$0 = $217;
      return +$$0;
     }
    } else {
     $218 = $206 & 2147482624;
     $219 = $218 >>> 0 > 1083231231;
     if ($219) {
      $220 = $206 + 1064252416 | 0;
      $221 = $220 | $205;
      $222 = ($221 | 0) == 0;
      if (!$222) {
       $223 = $$0390 * 1.0e-300;
       $224 = $223 * 1.0e-300;
       $$0 = $224;
       return +$$0;
      }
      $225 = $204 - $203;
      $226 = !($202 <= $225);
      if (!$226) {
       $227 = $$0390 * 1.0e-300;
       $228 = $227 * 1.0e-300;
       $$0 = $228;
       return +$$0;
      }
     }
    }
    $229 = $206 & 2147483647;
    $230 = $229 >>> 0 > 1071644672;
    if ($230) {
     $231 = $229 >>> 20;
     $232 = $231 + -1022 | 0;
     $233 = 1048576 >>> $232;
     $234 = $233 + $206 | 0;
     $235 = $234 >>> 20;
     $236 = $235 & 2047;
     $237 = $236 + -1023 | 0;
     $238 = -1048576 >> $237;
     $239 = $238 & $234;
     HEAP32[tempDoublePtr >> 2] = 0;
     HEAP32[tempDoublePtr + 4 >> 2] = $239;
     $240 = +HEAPF64[tempDoublePtr >> 3];
     $241 = $234 & 1048575;
     $242 = $241 | 1048576;
     $243 = 1043 - $236 | 0;
     $244 = $242 >>> $243;
     $245 = ($206 | 0) < 0;
     $246 = 0 - $244 | 0;
     $spec$select398 = $245 ? $246 : $244;
     $247 = $203 - $240;
     $$pre = $202 + $247;
     HEAPF64[tempDoublePtr >> 3] = $$pre;
     $248 = HEAP32[tempDoublePtr >> 2] | 0;
     $249 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
     $$0387 = $247;
     $$3 = $spec$select398;
     $251 = $249;
     $288 = $248;
    } else {
     $$0387 = $203;
     $$3 = 0;
     $251 = $206;
     $288 = $205;
    }
    HEAP32[tempDoublePtr >> 2] = 0;
    HEAP32[tempDoublePtr + 4 >> 2] = $251;
    $250 = +HEAPF64[tempDoublePtr >> 3];
    $252 = $250 * .6931471824645996;
    $253 = $250 - $$0387;
    $254 = $202 - $253;
    $255 = $254 * .6931471805599453;
    $256 = $250 * 1.904654299957768e-09;
    $257 = $255 - $256;
    $258 = $252 + $257;
    $259 = $258 - $252;
    $260 = $257 - $259;
    $261 = $258 * $258;
    $262 = $261 * 4.1381367970572385e-08;
    $263 = $262 + -1.6533902205465252e-06;
    $264 = $261 * $263;
    $265 = $264 + 6.613756321437934e-05;
    $266 = $261 * $265;
    $267 = $266 + -2.7777777777015593e-03;
    $268 = $261 * $267;
    $269 = $268 + .16666666666666602;
    $270 = $261 * $269;
    $271 = $258 - $270;
    $272 = $258 * $271;
    $273 = $271 + -2.0;
    $274 = $272 / $273;
    $275 = $258 * $260;
    $276 = $260 + $275;
    $277 = $274 - $276;
    $278 = $277 - $258;
    $279 = 1.0 - $278;
    HEAPF64[tempDoublePtr >> 3] = $279;
    $280 = HEAP32[tempDoublePtr >> 2] | 0;
    $281 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
    $282 = $$3 << 20;
    $283 = $282 + $281 | 0;
    $284 = ($283 | 0) < 1048576;
    if ($284) {
     $285 = +_scalbn($279, $$3);
     $$2 = $285;
    } else {
     HEAP32[tempDoublePtr >> 2] = $280;
     HEAP32[tempDoublePtr + 4 >> 2] = $283;
     $286 = +HEAPF64[tempDoublePtr >> 3];
     $$2 = $286;
    }
    $287 = $$0390 * $$2;
    $$0 = $287;
    return +$$0;
   }
  }
 }
 $18 = $0 + $1;
 $$0 = $18;
 return +$$0;
}

function _mp_parse($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(128 | 0);
 $5 = sp + 56 | 0;
 $8 = sp + 48 | 0;
 $9 = sp + 44 | 0;
 $3 = $1;
 $4 = $2;
 HEAP32[$5 >> 2] = 64;
 $25 = $5 + 4 | 0;
 HEAP32[$25 >> 2] = 0;
 $26 = HEAP32[$5 >> 2] | 0;
 $27 = $26 << 3;
 $28 = _m_malloc($27) | 0;
 $29 = $5 + 8 | 0;
 HEAP32[$29 >> 2] = $28;
 $30 = $5 + 12 | 0;
 HEAP32[$30 >> 2] = 32;
 $31 = $5 + 16 | 0;
 HEAP32[$31 >> 2] = 0;
 $32 = $5 + 12 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = $33 << 2;
 $35 = _m_malloc($34) | 0;
 $36 = $5 + 20 | 0;
 HEAP32[$36 >> 2] = $35;
 $37 = $3;
 $38 = $5 + 24 | 0;
 HEAP32[$38 >> 2] = $37;
 $39 = $5 + 28 | 0;
 $40 = $39 + 4 | 0;
 HEAP32[$40 >> 2] = 0;
 $41 = $5 + 36 | 0;
 HEAP32[$41 >> 2] = 0;
 $42 = $5 + 40 | 0;
 _mp_map_init($42, 0);
 $43 = $4;
 switch ($43 | 0) {
 case 0:
  {
   $6 = 58;
   break;
  }
 case 2:
  {
   $6 = 60;
   break;
  }
 default:
  {
   $6 = 0;
  }
 }
 $44 = $3;
 $45 = $44 + 56 | 0;
 $46 = HEAP32[$45 >> 2] | 0;
 $47 = $6;
 $48 = $47 & 255;
 _push_rule($5, $46, $48, 0);
 $7 = 0;
 L6 : while (1) {
  L8 : while (1) {
   $49 = $5 + 4 | 0;
   $50 = HEAP32[$49 >> 2] | 0;
   $51 = ($50 | 0) == 0;
   if ($51) {
    label = 84;
    break L6;
   }
   $52 = _pop_rule($5, $8, $9) | 0;
   $10 = $52;
   $53 = $10;
   $54 = $53 & 255;
   $55 = 1408 + $54 | 0;
   $56 = HEAP8[$55 >> 0] | 0;
   $11 = $56;
   $57 = $10;
   $58 = _get_rule_arg($57) | 0;
   $12 = $58;
   $59 = $11;
   $60 = $59 & 255;
   $61 = $60 & 15;
   $13 = $61;
   $62 = $11;
   $63 = $62 & 255;
   $64 = $63 & 48;
   switch ($64 | 0) {
   case 16:
    {
     $65 = HEAP32[$8 >> 2] | 0;
     $66 = $65 >>> 0 > 0;
     if ($66) {
      $67 = $7;
      $68 = $67 & 1;
      if (!$68) {
       continue L8;
      }
     }
     $7 = 0;
     while (1) {
      $69 = HEAP32[$8 >> 2] | 0;
      $70 = $13;
      $71 = $69 >>> 0 < $70 >>> 0;
      if (!$71) {
       label = 21;
       break L8;
      }
      $72 = $12;
      $73 = HEAP32[$8 >> 2] | 0;
      $74 = $72 + ($73 << 1) | 0;
      $75 = HEAP16[$74 >> 1] | 0;
      $76 = $75 & 65535;
      $77 = $76 & 61440;
      $78 = $77 & 65535;
      $14 = $78;
      $79 = $14;
      $80 = $79 & 65535;
      $81 = ($80 | 0) == 4096;
      if (!$81) {
       break;
      }
      $82 = $3;
      $83 = $82 + 64 | 0;
      $84 = HEAP32[$83 >> 2] | 0;
      $85 = $12;
      $86 = HEAP32[$8 >> 2] | 0;
      $87 = $85 + ($86 << 1) | 0;
      $88 = HEAP16[$87 >> 1] | 0;
      $89 = $88 & 65535;
      $90 = $89 & 4095;
      $91 = ($84 | 0) == ($90 | 0);
      if ($91) {
       label = 16;
       break;
      }
      $107 = HEAP32[$8 >> 2] | 0;
      $108 = $107 + 1 | 0;
      HEAP32[$8 >> 2] = $108;
     }
     if ((label | 0) == 16) {
      label = 0;
      $92 = $10;
      _push_result_token($5, $92);
      $93 = $3;
      _mp_lexer_to_next($93);
      continue L8;
     }
     $94 = HEAP32[$8 >> 2] | 0;
     $95 = $94 + 1 | 0;
     $96 = $13;
     $97 = $95 >>> 0 < $96 >>> 0;
     if ($97) {
      $98 = HEAP32[$9 >> 2] | 0;
      $99 = $10;
      $100 = HEAP32[$8 >> 2] | 0;
      $101 = $100 + 1 | 0;
      _push_rule($5, $98, $99, $101);
     }
     $102 = $12;
     $103 = HEAP32[$8 >> 2] | 0;
     $104 = $102 + ($103 << 1) | 0;
     $105 = HEAP16[$104 >> 1] | 0;
     $106 = $105 & 65535;
     _push_rule_from_arg($5, $106);
     continue L8;
     break;
    }
   case 32:
    {
     $109 = $7;
     $110 = $109 & 1;
     do {
      if ($110) {
       $111 = $12;
       $112 = HEAP32[$8 >> 2] | 0;
       $113 = $112 - 1 | 0;
       $114 = $111 + ($113 << 1) | 0;
       $115 = HEAP16[$114 >> 1] | 0;
       $116 = $115 & 65535;
       $117 = $116 & 61440;
       $118 = ($117 | 0) == 12288;
       if ($118) {
        _push_result_node($5, 0);
        $7 = 0;
        break;
       }
       $119 = HEAP32[$8 >> 2] | 0;
       $120 = $119 >>> 0 > 1;
       if ($120) {
        break L6;
       }
       continue L8;
      }
     } while (0);
     while (1) {
      $121 = HEAP32[$8 >> 2] | 0;
      $122 = $13;
      $123 = $121 >>> 0 < $122 >>> 0;
      if (!$123) {
       label = 37;
       break L8;
      }
      $124 = $12;
      $125 = HEAP32[$8 >> 2] | 0;
      $126 = $124 + ($125 << 1) | 0;
      $127 = HEAP16[$126 >> 1] | 0;
      $128 = $127 & 65535;
      $129 = $128 & 61440;
      $130 = ($129 | 0) == 4096;
      if (!$130) {
       label = 36;
       break;
      }
      $131 = $12;
      $132 = HEAP32[$8 >> 2] | 0;
      $133 = $131 + ($132 << 1) | 0;
      $134 = HEAP16[$133 >> 1] | 0;
      $135 = $134 & 65535;
      $136 = $135 & 4095;
      $15 = $136;
      $137 = $3;
      $138 = $137 + 64 | 0;
      $139 = HEAP32[$138 >> 2] | 0;
      $140 = $15;
      $141 = ($139 | 0) == ($140 | 0);
      if (!$141) {
       break;
      }
      $142 = $15;
      $143 = ($142 | 0) == 7;
      if ($143) {
       $144 = $10;
       _push_result_token($5, $144);
      }
      $145 = $3;
      _mp_lexer_to_next($145);
      $146 = HEAP32[$8 >> 2] | 0;
      $147 = $146 + 1 | 0;
      HEAP32[$8 >> 2] = $147;
     }
     if ((label | 0) == 36) {
      label = 0;
      $150 = HEAP32[$9 >> 2] | 0;
      $151 = $10;
      $152 = HEAP32[$8 >> 2] | 0;
      $153 = $152 + 1 | 0;
      _push_rule($5, $150, $151, $153);
      $154 = $12;
      $155 = HEAP32[$8 >> 2] | 0;
      $156 = $154 + ($155 << 1) | 0;
      $157 = HEAP16[$156 >> 1] | 0;
      $158 = $157 & 65535;
      _push_rule_from_arg($5, $158);
      continue L8;
     }
     $148 = HEAP32[$8 >> 2] | 0;
     $149 = $148 >>> 0 > 0;
     if ($149) {
      break L6;
     }
     $7 = 1;
     continue L8;
     break;
    }
   default:
    {
     $215 = $7;
     $216 = $215 & 1;
     do {
      if (!$216) {
       while (1) {
        $226 = $12;
        $227 = HEAP32[$8 >> 2] | 0;
        $228 = $227 & 1;
        $229 = $13;
        $230 = $228 & $229;
        $231 = $226 + ($230 << 1) | 0;
        $232 = HEAP16[$231 >> 1] | 0;
        $233 = $232 & 65535;
        $23 = $233;
        $234 = $23;
        $235 = $234 & 61440;
        $236 = ($235 | 0) == 4096;
        if (!$236) {
         label = 75;
         break;
        }
        $237 = $3;
        $238 = $237 + 64 | 0;
        $239 = HEAP32[$238 >> 2] | 0;
        $240 = $23;
        $241 = $240 & 4095;
        $242 = ($239 | 0) == ($241 | 0);
        $243 = HEAP32[$8 >> 2] | 0;
        if (!$242) {
         label = 74;
         break;
        }
        $244 = $243 & 1;
        $245 = $13;
        $246 = $244 & $245;
        $247 = ($246 | 0) != 0;
        if (!$247) {
         $248 = $10;
         _push_result_token($5, $248);
        }
        $249 = $3;
        _mp_lexer_to_next($249);
        $250 = HEAP32[$8 >> 2] | 0;
        $251 = $250 + 1 | 0;
        HEAP32[$8 >> 2] = $251;
       }
       if ((label | 0) == 74) {
        label = 0;
        $252 = $243 + 1 | 0;
        HEAP32[$8 >> 2] = $252;
        $7 = 1;
        break;
       } else if ((label | 0) == 75) {
        label = 0;
        $253 = HEAP32[$9 >> 2] | 0;
        $254 = $10;
        $255 = HEAP32[$8 >> 2] | 0;
        $256 = $255 + 1 | 0;
        _push_rule($5, $253, $254, $256);
        $257 = $23;
        _push_rule_from_arg($5, $257);
        continue L8;
       }
      }
     } while (0);
     $22 = 0;
     $217 = $13;
     $218 = ($217 | 0) == 2;
     $219 = HEAP32[$8 >> 2] | 0;
     $220 = ($219 | 0) == 1;
     if ($218) {
      if (!$220) {
       label = 61;
       break L8;
      }
      continue L8;
     } else {
      if (!$220) {
       label = 64;
       break L8;
      }
      continue L8;
     }
    }
   }
  }
  do {
   if ((label | 0) == 21) {
    label = 0;
    $7 = 1;
   } else if ((label | 0) == 37) {
    label = 0;
    HEAP32[$8 >> 2] = 0;
    $16 = 0;
    $159 = $13;
    $17 = $159;
    while (1) {
     $160 = $17;
     $161 = $160 >>> 0 > 0;
     if (!$161) {
      break;
     }
     $162 = $17;
     $163 = $162 + -1 | 0;
     $17 = $163;
     $164 = $12;
     $165 = $17;
     $166 = $164 + ($165 << 1) | 0;
     $167 = HEAP16[$166 >> 1] | 0;
     $168 = $167 & 65535;
     $169 = $168 & 61440;
     $170 = ($169 | 0) == 4096;
     if ($170) {
      $171 = $12;
      $172 = $17;
      $173 = $171 + ($172 << 1) | 0;
      $174 = HEAP16[$173 >> 1] | 0;
      $175 = $174 & 65535;
      $176 = $175 & 4095;
      $18 = $176;
      $177 = $18;
      $178 = ($177 | 0) == 7;
      if ($178) {
       $179 = HEAP32[$8 >> 2] | 0;
       $180 = $179 + 1 | 0;
       HEAP32[$8 >> 2] = $180;
       $181 = $16;
       $182 = $181 + 1 | 0;
       $16 = $182;
      }
     } else {
      $183 = HEAP32[$8 >> 2] | 0;
      $184 = _peek_result($5, $183) | 0;
      $185 = ($184 | 0) != 0;
      if ($185) {
       $186 = $16;
       $187 = $186 + 1 | 0;
       $16 = $187;
      }
      $188 = HEAP32[$8 >> 2] | 0;
      $189 = $188 + 1 | 0;
      HEAP32[$8 >> 2] = $189;
     }
    }
    $190 = $16;
    $191 = ($190 | 0) == 1;
    if ($191) {
     $192 = $11;
     $193 = $192 & 255;
     $194 = $193 & 64;
     $195 = ($194 | 0) != 0;
     if ($195) {
      $19 = 0;
      $20 = 0;
      while (1) {
       $196 = $20;
       $197 = HEAP32[$8 >> 2] | 0;
       $198 = $196 >>> 0 < $197 >>> 0;
       if (!$198) {
        break;
       }
       $199 = _pop_result($5) | 0;
       $21 = $199;
       $200 = $21;
       $201 = ($200 | 0) != 0;
       if ($201) {
        $202 = $21;
        $19 = $202;
       }
       $203 = $20;
       $204 = $203 + 1 | 0;
       $20 = $204;
      }
      $205 = $19;
      _push_result_node($5, $205);
      break;
     }
    }
    $206 = $11;
    $207 = $206 & 255;
    $208 = $207 & 128;
    $209 = ($208 | 0) != 0;
    if ($209) {
     _push_result_node($5, 0);
     $210 = HEAP32[$8 >> 2] | 0;
     $211 = $210 + 1 | 0;
     HEAP32[$8 >> 2] = $211;
    }
    $212 = HEAP32[$9 >> 2] | 0;
    $213 = $10;
    $214 = HEAP32[$8 >> 2] | 0;
    _push_result_rule($5, $212, $213, $214);
   } else if ((label | 0) == 61) {
    label = 0;
    $7 = 0;
    label = 76;
   } else if ((label | 0) == 64) {
    label = 0;
    $221 = HEAP32[$8 >> 2] | 0;
    $222 = $221 & 1;
    $223 = ($222 | 0) == 1;
    if (!$223) {
     $7 = 0;
     label = 76;
     break;
    }
    $224 = $13;
    $225 = ($224 | 0) == 3;
    if (!$225) {
     break L6;
    }
    $22 = 1;
    $7 = 0;
    label = 76;
   }
  } while (0);
  do {
   if ((label | 0) == 76) {
    label = 0;
    $258 = HEAP32[$8 >> 2] | 0;
    $259 = $258 - 1 | 0;
    HEAP32[$8 >> 2] = $259;
    $260 = $13;
    $261 = $260 & 1;
    $262 = ($261 | 0) != 0;
    if ($262) {
     $263 = $12;
     $264 = $263 + 2 | 0;
     $265 = HEAP16[$264 >> 1] | 0;
     $266 = $265 & 65535;
     $267 = $266 & 61440;
     $268 = ($267 | 0) == 4096;
     if ($268) {
      $269 = HEAP32[$8 >> 2] | 0;
      $270 = $269 + 1 | 0;
      $271 = ($270 >>> 0) / 2 & -1;
      HEAP32[$8 >> 2] = $271;
     }
    }
    $272 = HEAP32[$8 >> 2] | 0;
    $273 = ($272 | 0) == 1;
    if (!$273) {
     $279 = HEAP32[$9 >> 2] | 0;
     $280 = $10;
     $281 = HEAP32[$8 >> 2] | 0;
     _push_result_rule($5, $279, $280, $281);
     break;
    }
    $274 = $22;
    $275 = $274 & 1;
    if ($275) {
     $276 = HEAP32[$9 >> 2] | 0;
     $277 = $10;
     $278 = HEAP32[$8 >> 2] | 0;
     _push_result_rule($5, $276, $277, $278);
    }
   }
  } while (0);
 }
 if ((label | 0) == 84) {
  $282 = $5 + 40 | 0;
  _mp_map_deinit($282);
  $283 = $5 + 36 | 0;
  $284 = HEAP32[$283 >> 2] | 0;
  $285 = ($284 | 0) != (0 | 0);
  if ($285) {
   $286 = $5 + 36 | 0;
   $287 = HEAP32[$286 >> 2] | 0;
   $288 = $5 + 36 | 0;
   $289 = HEAP32[$288 >> 2] | 0;
   $290 = $289 + 4 | 0;
   $291 = HEAP32[$290 >> 2] | 0;
   $292 = 8 + $291 | 0;
   $293 = $292;
   _m_realloc_maybe($287, $293, 0) | 0;
   $294 = $5 + 36 | 0;
   $295 = HEAP32[$294 >> 2] | 0;
   $296 = $295 + 4 | 0;
   $297 = HEAP32[$296 >> 2] | 0;
   $298 = $5 + 36 | 0;
   $299 = HEAP32[$298 >> 2] | 0;
   HEAP32[$299 >> 2] = $297;
   $300 = $5 + 28 | 0;
   $301 = $300 + 4 | 0;
   $302 = HEAP32[$301 >> 2] | 0;
   $303 = $5 + 36 | 0;
   $304 = HEAP32[$303 >> 2] | 0;
   $305 = $304 + 4 | 0;
   HEAP32[$305 >> 2] = $302;
   $306 = $5 + 36 | 0;
   $307 = HEAP32[$306 >> 2] | 0;
   $308 = $5 + 28 | 0;
   $309 = $308 + 4 | 0;
   HEAP32[$309 >> 2] = $307;
  }
  $310 = $3;
  $311 = $310 + 64 | 0;
  $312 = HEAP32[$311 >> 2] | 0;
  $313 = ($312 | 0) != 0;
  if (!$313) {
   $314 = $5 + 16 | 0;
   $315 = HEAP32[$314 >> 2] | 0;
   $316 = ($315 | 0) == 0;
   if (!$316) {
    $335 = $5 + 20 | 0;
    $336 = HEAP32[$335 >> 2] | 0;
    $337 = HEAP32[$336 >> 2] | 0;
    $338 = $5 + 28 | 0;
    HEAP32[$338 >> 2] = $337;
    $339 = $5 + 8 | 0;
    $340 = HEAP32[$339 >> 2] | 0;
    _m_free($340);
    $341 = $5 + 20 | 0;
    $342 = HEAP32[$341 >> 2] | 0;
    _m_free($342);
    $343 = $3;
    _mp_lexer_free($343);
    $344 = $5 + 28 | 0;
    HEAP32[$0 >> 2] = HEAP32[$344 >> 2] | 0;
    HEAP32[$0 + 4 >> 2] = HEAP32[$344 + 4 >> 2] | 0;
    STACKTOP = sp;
    return;
   }
  }
 }
 $317 = $3;
 $318 = $317 + 64 | 0;
 $319 = HEAP32[$318 >> 2] | 0;
 $320 = ($319 | 0) == 5;
 if ($320) {
  $321 = _mp_obj_new_exception_msg(15952, 28624) | 0;
  $24 = $321;
  $328 = $24;
  $329 = $3;
  $330 = HEAP32[$329 >> 2] | 0;
  $331 = $3;
  $332 = $331 + 56 | 0;
  $333 = HEAP32[$332 >> 2] | 0;
  _mp_obj_exception_add_traceback($328, $330, $333, 0);
  $334 = $24;
  _nlr_jump($334);
 }
 $322 = $3;
 $323 = $322 + 64 | 0;
 $324 = HEAP32[$323 >> 2] | 0;
 $325 = ($324 | 0) == 2;
 if ($325) {
  $326 = _mp_obj_new_exception_msg(15952, 28642) | 0;
  $24 = $326;
  $328 = $24;
  $329 = $3;
  $330 = HEAP32[$329 >> 2] | 0;
  $331 = $3;
  $332 = $331 + 56 | 0;
  $333 = HEAP32[$332 >> 2] | 0;
  _mp_obj_exception_add_traceback($328, $330, $333, 0);
  $334 = $24;
  _nlr_jump($334);
 } else {
  $327 = _mp_obj_new_exception_msg(15892, 28787) | 0;
  $24 = $327;
  $328 = $24;
  $329 = $3;
  $330 = HEAP32[$329 >> 2] | 0;
  $331 = $3;
  $332 = $331 + 56 | 0;
  $333 = HEAP32[$332 >> 2] | 0;
  _mp_obj_exception_add_traceback($328, $330, $333, 0);
  $334 = $24;
  _nlr_jump($334);
 }
}

function _mp_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0.0, $14 = 0, $140 = 0, $141 = 0.0, $142 = 0.0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0.0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0.0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0.0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $vararg_buffer = 0, $vararg_ptr2 = 0, $vararg_ptr3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112 | 0);
 $vararg_buffer = sp;
 $18 = sp + 24 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $21 = $4;
 $22 = ($21 | 0) == 7;
 if ($22) {
  $23 = $5;
  $24 = $6;
  $25 = ($23 | 0) == ($24 | 0);
  $26 = $25 & 1;
  $27 = _mp_obj_new_bool($26) | 0;
  $3 = $27;
  $303 = $3;
  STACKTOP = sp;
  return $303 | 0;
 }
 $28 = $4;
 $29 = ($28 | 0) == 2;
 $30 = $4;
 $31 = ($30 | 0) == 5;
 $or$cond = $29 | $31;
 if ($or$cond) {
  $32 = $5;
  $33 = $6;
  $34 = _mp_obj_equal($32, $33) | 0;
  $35 = $4;
  $36 = ($35 | 0) == 2;
  if ($34) {
   if ($36) {
    $3 = 13864;
    $303 = $3;
    STACKTOP = sp;
    return $303 | 0;
   } else {
    $3 = 13856;
    $303 = $3;
    STACKTOP = sp;
    return $303 | 0;
   }
  } else {
   if ($36) {
    $3 = 13856;
    $303 = $3;
    STACKTOP = sp;
    return $303 | 0;
   } else {
    $3 = 13864;
    $303 = $3;
    STACKTOP = sp;
    return $303 | 0;
   }
  }
 }
 $37 = $4;
 $38 = ($37 | 0) == 8;
 L21 : do {
  if ($38) {
   $39 = $6;
   $40 = _mp_obj_is_exception_type($39) | 0;
   if ($40) {
    $41 = $5;
    $42 = $6;
    $43 = _mp_obj_exception_match($41, $42) | 0;
    if ($43) {
     $3 = 13864;
     $303 = $3;
     STACKTOP = sp;
     return $303 | 0;
    } else {
     $3 = 13856;
     $303 = $3;
     STACKTOP = sp;
     return $303 | 0;
    }
   }
   $44 = $6;
   $45 = _mp_obj_is_obj_729($44) | 0;
   if ($45) {
    $46 = $6;
    $47 = HEAP32[$46 >> 2] | 0;
    $48 = ($47 | 0) == (18952 | 0);
    if ($48) {
     $49 = $6;
     $7 = $49;
     $8 = 0;
     while (1) {
      $50 = $8;
      $51 = $7;
      $52 = $51 + 4 | 0;
      $53 = HEAP32[$52 >> 2] | 0;
      $54 = $50 >>> 0 < $53 >>> 0;
      if (!$54) {
       label = 24;
       break;
      }
      $55 = $7;
      $56 = $55 + 8 | 0;
      $57 = $8;
      $58 = $56 + ($57 << 2) | 0;
      $59 = HEAP32[$58 >> 2] | 0;
      $6 = $59;
      $60 = $6;
      $61 = _mp_obj_is_exception_type($60) | 0;
      if (!$61) {
       break L21;
      }
      $62 = $5;
      $63 = $6;
      $64 = _mp_obj_exception_match($62, $63) | 0;
      if ($64) {
       label = 22;
       break;
      }
      $65 = $8;
      $66 = $65 + 1 | 0;
      $8 = $66;
     }
     if ((label | 0) == 22) {
      $3 = 13864;
      $303 = $3;
      STACKTOP = sp;
      return $303 | 0;
     } else if ((label | 0) == 24) {
      $3 = 13856;
      $303 = $3;
      STACKTOP = sp;
      return $303 | 0;
     }
    }
   }
  } else {
   $67 = $5;
   $68 = _mp_obj_is_small_int_727($67) | 0;
   L44 : do {
    if ($68) {
     $69 = $5;
     $70 = $69;
     $71 = $70 >> 1;
     $9 = $71;
     $72 = $6;
     $73 = _mp_obj_is_small_int_727($72) | 0;
     $74 = $6;
     if (!$73) {
      $238 = _mp_obj_is_obj_729($74) | 0;
      if ($238) {
       $239 = $6;
       $240 = HEAP32[$239 >> 2] | 0;
       $241 = ($240 | 0) == (16252 | 0);
       if ($241) {
        $242 = $4;
        $243 = $9;
        $244 = +($243 | 0);
        $245 = $6;
        $246 = _mp_obj_float_binary_op($242, $244, $245) | 0;
        $13 = $246;
        $247 = $13;
        $248 = ($247 | 0) == (0 | 0);
        if ($248) {
         break L21;
        }
        $249 = $13;
        $3 = $249;
        $303 = $3;
        STACKTOP = sp;
        return $303 | 0;
       }
      }
      $250 = $6;
      $251 = _mp_obj_is_obj_729($250) | 0;
      if (!$251) {
       label = 83;
       break;
      }
      $252 = $6;
      $253 = HEAP32[$252 >> 2] | 0;
      $254 = ($253 | 0) == (14052 | 0);
      if (!$254) {
       label = 83;
       break;
      }
      $255 = $4;
      $256 = $9;
      $257 = +($256 | 0);
      $258 = $6;
      $259 = _mp_obj_complex_binary_op($255, $257, 0.0, $258) | 0;
      $14 = $259;
      $260 = $14;
      $261 = ($260 | 0) == (0 | 0);
      if ($261) {
       break L21;
      }
      $262 = $14;
      $3 = $262;
      $303 = $3;
      STACKTOP = sp;
      return $303 | 0;
     }
     $75 = $74;
     $76 = $75 >> 1;
     $10 = $76;
     $77 = $4;
     L59 : do {
      switch ($77 | 0) {
      case 9:
      case 21:
       {
        $78 = $10;
        $79 = $9;
        $80 = $79 | $78;
        $9 = $80;
        break;
       }
      case 10:
      case 22:
       {
        $81 = $10;
        $82 = $9;
        $83 = $82 ^ $81;
        $9 = $83;
        break;
       }
      case 11:
      case 23:
       {
        $84 = $10;
        $85 = $9;
        $86 = $85 & $84;
        $9 = $86;
        break;
       }
      case 12:
      case 24:
       {
        $87 = $10;
        $88 = ($87 | 0) < 0;
        if ($88) {
         _mp_raise_ValueError(31400);
        }
        $89 = $10;
        $90 = ($89 | 0) >= 32;
        if (!$90) {
         $91 = $9;
         $92 = $10;
         $93 = 1073741823 >> $92;
         $94 = ($91 | 0) > ($93 | 0);
         if (!$94) {
          $95 = $9;
          $96 = $10;
          $97 = -1073741824 >> $96;
          $98 = ($95 | 0) < ($97 | 0);
          if (!$98) {
           $103 = $10;
           $104 = $9;
           $105 = $104 << $103;
           $9 = $105;
           break L59;
          }
         }
        }
        $99 = $9;
        $100 = ($99 | 0) < 0;
        $101 = $100 << 31 >> 31;
        $102 = _mp_obj_new_int_from_ll($99, $101) | 0;
        $5 = $102;
        break L44;
        break;
       }
      case 13:
      case 25:
       {
        $106 = $10;
        $107 = ($106 | 0) < 0;
        if ($107) {
         _mp_raise_ValueError(31400);
        }
        $108 = $10;
        $109 = ($108 | 0) >= 32;
        if ($109) {
         $10 = 31;
        }
        $110 = $10;
        $111 = $9;
        $112 = $111 >> $110;
        $9 = $112;
        break;
       }
      case 14:
      case 26:
       {
        $113 = $10;
        $114 = $9;
        $115 = $114 + $113 | 0;
        $9 = $115;
        break;
       }
      case 15:
      case 27:
       {
        $116 = $10;
        $117 = $9;
        $118 = $117 - $116 | 0;
        $9 = $118;
        break;
       }
      case 16:
      case 28:
       {
        $119 = $9;
        $120 = $10;
        $121 = _mp_small_int_mul_overflow($119, $120) | 0;
        $122 = $9;
        if ($121) {
         $123 = ($122 | 0) < 0;
         $124 = $123 << 31 >> 31;
         $125 = _mp_obj_new_int_from_ll($122, $124) | 0;
         $5 = $125;
         break L44;
        }
        $126 = $10;
        $127 = Math_imul($122, $126) | 0;
        $128 = $127 << 1;
        $129 = $128 | 1;
        $130 = $129;
        $3 = $130;
        $303 = $3;
        STACKTOP = sp;
        return $303 | 0;
        break;
       }
      case 17:
      case 29:
       {
        $131 = $10;
        $132 = ($131 | 0) == 0;
        if ($132) {
         _mp_raise_msg(15172, 33845);
        } else {
         $133 = $9;
         $134 = $10;
         $135 = _mp_small_int_floor_divide($133, $134) | 0;
         $9 = $135;
         break L59;
        }
        break;
       }
      case 18:
      case 30:
       {
        $136 = $10;
        $137 = ($136 | 0) == 0;
        if ($137) {
         _mp_raise_msg(15172, 33845);
        }
        $138 = $9;
        $139 = +($138 | 0);
        $140 = $10;
        $141 = +($140 | 0);
        $142 = $139 / $141;
        $143 = _mp_obj_new_float($142) | 0;
        $3 = $143;
        $303 = $3;
        STACKTOP = sp;
        return $303 | 0;
        break;
       }
      case 19:
      case 31:
       {
        $144 = $10;
        $145 = ($144 | 0) == 0;
        if ($145) {
         _mp_raise_msg(15172, 33845);
        } else {
         $146 = $9;
         $147 = $10;
         $148 = _mp_small_int_modulo($146, $147) | 0;
         $9 = $148;
         break L59;
        }
        break;
       }
      case 20:
      case 32:
       {
        $149 = $10;
        $150 = ($149 | 0) < 0;
        if ($150) {
         $151 = $4;
         $152 = $9;
         $153 = +($152 | 0);
         $154 = $6;
         $155 = _mp_obj_float_binary_op($151, $153, $154) | 0;
         $3 = $155;
         $303 = $3;
         STACKTOP = sp;
         return $303 | 0;
        }
        $11 = 1;
        while (1) {
         $156 = $10;
         $157 = ($156 | 0) > 0;
         if (!$157) {
          label = 64;
          break;
         }
         $158 = $10;
         $159 = $158 & 1;
         $160 = ($159 | 0) != 0;
         if ($160) {
          $161 = $11;
          $162 = $9;
          $163 = _mp_small_int_mul_overflow($161, $162) | 0;
          if ($163) {
           label = 65;
           break;
          }
          $164 = $9;
          $165 = $11;
          $166 = Math_imul($165, $164) | 0;
          $11 = $166;
         }
         $167 = $10;
         $168 = ($167 | 0) == 1;
         if ($168) {
          label = 64;
          break;
         }
         $169 = $10;
         $170 = ($169 | 0) / 2 & -1;
         $10 = $170;
         $171 = $9;
         $172 = $9;
         $173 = _mp_small_int_mul_overflow($171, $172) | 0;
         if ($173) {
          label = 65;
          break;
         }
         $174 = $9;
         $175 = $9;
         $176 = Math_imul($175, $174) | 0;
         $9 = $176;
        }
        if ((label | 0) == 64) {
         $177 = $11;
         $9 = $177;
         break L59;
        } else if ((label | 0) == 65) {
         $178 = $5;
         $179 = $178;
         $180 = $179 >> 1;
         $181 = ($180 | 0) < 0;
         $182 = $181 << 31 >> 31;
         $183 = _mp_obj_new_int_from_ll($180, $182) | 0;
         $5 = $183;
         break L44;
        }
        break;
       }
      case 33:
       {
        $184 = $10;
        $185 = ($184 | 0) == 0;
        if ($185) {
         _mp_raise_msg(15172, 33845);
        }
        $186 = _mp_obj_new_tuple(2, 0) | 0;
        $12 = $186;
        $187 = $9;
        $188 = $10;
        $189 = _mp_small_int_floor_divide($187, $188) | 0;
        $190 = $189 << 1;
        $191 = $190 | 1;
        $192 = $191;
        $193 = $12;
        $194 = $193 + 8 | 0;
        HEAP32[$194 >> 2] = $192;
        $195 = $9;
        $196 = $10;
        $197 = _mp_small_int_modulo($195, $196) | 0;
        $198 = $197 << 1;
        $199 = $198 | 1;
        $200 = $199;
        $201 = $12;
        $202 = $201 + 8 | 0;
        $203 = $202 + 4 | 0;
        HEAP32[$203 >> 2] = $200;
        $204 = $12;
        $3 = $204;
        $303 = $3;
        STACKTOP = sp;
        return $303 | 0;
        break;
       }
      case 0:
       {
        $205 = $9;
        $206 = $10;
        $207 = ($205 | 0) < ($206 | 0);
        $208 = $207 & 1;
        $209 = _mp_obj_new_bool($208) | 0;
        $3 = $209;
        $303 = $3;
        STACKTOP = sp;
        return $303 | 0;
        break;
       }
      case 1:
       {
        $210 = $9;
        $211 = $10;
        $212 = ($210 | 0) > ($211 | 0);
        $213 = $212 & 1;
        $214 = _mp_obj_new_bool($213) | 0;
        $3 = $214;
        $303 = $3;
        STACKTOP = sp;
        return $303 | 0;
        break;
       }
      case 3:
       {
        $215 = $9;
        $216 = $10;
        $217 = ($215 | 0) <= ($216 | 0);
        $218 = $217 & 1;
        $219 = _mp_obj_new_bool($218) | 0;
        $3 = $219;
        $303 = $3;
        STACKTOP = sp;
        return $303 | 0;
        break;
       }
      case 4:
       {
        $220 = $9;
        $221 = $10;
        $222 = ($220 | 0) >= ($221 | 0);
        $223 = $222 & 1;
        $224 = _mp_obj_new_bool($223) | 0;
        $3 = $224;
        $303 = $3;
        STACKTOP = sp;
        return $303 | 0;
        break;
       }
      default:
       {
        break L21;
       }
      }
     } while (0);
     $225 = $9;
     $226 = $9;
     $227 = $226 << 1;
     $228 = $225 ^ $227;
     $229 = $228 & -2147483648;
     $230 = ($229 | 0) == 0;
     $231 = $9;
     if ($230) {
      $232 = $231 << 1;
      $233 = $232 | 1;
      $234 = $233;
      $3 = $234;
      $303 = $3;
      STACKTOP = sp;
      return $303 | 0;
     } else {
      $235 = ($231 | 0) < 0;
      $236 = $235 << 31 >> 31;
      $237 = _mp_obj_new_int_from_ll($231, $236) | 0;
      $3 = $237;
      $303 = $3;
      STACKTOP = sp;
      return $303 | 0;
     }
    } else {
     label = 83;
    }
   } while (0);
   if ((label | 0) == 83) {
    $263 = $4;
    $264 = ($263 | 0) == 6;
    if ($264) {
     $4 = 34;
     $265 = $5;
     $15 = $265;
     $266 = $6;
     $5 = $266;
     $267 = $15;
     $6 = $267;
    }
   }
   $268 = $5;
   $269 = _mp_obj_get_type($268) | 0;
   $16 = $269;
   $270 = $16;
   $271 = $270 + 24 | 0;
   $272 = HEAP32[$271 >> 2] | 0;
   $273 = ($272 | 0) != (0 | 0);
   if ($273) {
    $274 = $16;
    $275 = $274 + 24 | 0;
    $276 = HEAP32[$275 >> 2] | 0;
    $277 = $4;
    $278 = $5;
    $279 = $6;
    $280 = FUNCTION_TABLE_iiii[$276 & 1023]($277, $278, $279) | 0;
    $17 = $280;
    $281 = $17;
    $282 = ($281 | 0) != (0 | 0);
    if ($282) {
     $283 = $17;
     $3 = $283;
     $303 = $3;
     STACKTOP = sp;
     return $303 | 0;
    }
   }
   $284 = $4;
   $285 = ($284 | 0) == 34;
   if ($285) {
    $286 = $5;
    $287 = _mp_getiter($286, $18) | 0;
    $19 = $287;
    while (1) {
     $288 = $19;
     $289 = _mp_iternext($288) | 0;
     $20 = $289;
     $290 = ($289 | 0) != (0 | 0);
     if (!$290) {
      label = 94;
      break;
     }
     $291 = $20;
     $292 = $6;
     $293 = _mp_obj_equal($291, $292) | 0;
     if ($293) {
      label = 92;
      break;
     }
    }
    if ((label | 0) == 92) {
     $3 = 13864;
     $303 = $3;
     STACKTOP = sp;
     return $303 | 0;
    } else if ((label | 0) == 94) {
     $3 = 13856;
     $303 = $3;
     STACKTOP = sp;
     return $303 | 0;
    }
   }
  }
 } while (0);
 $294 = $4;
 $295 = 4608 + $294 | 0;
 $296 = HEAP8[$295 >> 0] | 0;
 $297 = $296 & 255;
 $298 = $5;
 $299 = _mp_obj_get_type_str($298) | 0;
 $300 = $6;
 $301 = _mp_obj_get_type_str($300) | 0;
 HEAP32[$vararg_buffer >> 2] = $297;
 $vararg_ptr2 = $vararg_buffer + 4 | 0;
 HEAP32[$vararg_ptr2 >> 2] = $299;
 $vararg_ptr3 = $vararg_buffer + 8 | 0;
 HEAP32[$vararg_ptr3 >> 2] = $301;
 $302 = _mp_obj_new_exception_msg_varg(16012, 29638, $vararg_buffer) | 0;
 _nlr_jump($302);
 return 0 | 0;
}

function _mp_lexer_to_next($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $1 = $0;
 $14 = $1;
 $15 = $14 + 68 | 0;
 _vstr_reset($15);
 $16 = $1;
 $17 = _skip_whitespace($16, 0) | 0;
 $18 = $17 & 1;
 $2 = $18;
 $19 = $1;
 $20 = $19 + 28 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $1;
 $23 = $22 + 56 | 0;
 HEAP32[$23 >> 2] = $21;
 $24 = $1;
 $25 = $24 + 32 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = $1;
 $28 = $27 + 60 | 0;
 HEAP32[$28 >> 2] = $26;
 $29 = $1;
 $30 = $29 + 36 | 0;
 $31 = HEAP32[$30 >> 2] | 0;
 $32 = ($31 | 0) < 0;
 $33 = $1;
 if ($32) {
  $34 = $33 + 64 | 0;
  HEAP32[$34 >> 2] = 6;
  $35 = $1;
  $36 = $35 + 36 | 0;
  $37 = HEAP32[$36 >> 2] | 0;
  $38 = $37 + 1 | 0;
  HEAP32[$36 >> 2] = $38;
  STACKTOP = sp;
  return;
 }
 $39 = $33 + 36 | 0;
 $40 = HEAP32[$39 >> 2] | 0;
 $41 = ($40 | 0) > 0;
 if ($41) {
  $42 = $1;
  $43 = $42 + 64 | 0;
  HEAP32[$43 >> 2] = 5;
  $44 = $1;
  $45 = $44 + 36 | 0;
  $46 = HEAP32[$45 >> 2] | 0;
  $47 = $46 - 1 | 0;
  HEAP32[$45 >> 2] = $47;
  STACKTOP = sp;
  return;
 }
 $48 = $2;
 $49 = $48 & 1;
 if ($49) {
  $50 = $1;
  $51 = $50 + 40 | 0;
  $52 = HEAP32[$51 >> 2] | 0;
  $53 = ($52 | 0) == 0;
  if ($53) {
   $54 = $1;
   $55 = $54 + 64 | 0;
   HEAP32[$55 >> 2] = 4;
   $56 = $1;
   $57 = $56 + 32 | 0;
   $58 = HEAP32[$57 >> 2] | 0;
   $59 = $58 - 1 | 0;
   $3 = $59;
   $60 = $3;
   $61 = $1;
   $62 = _indent_top($61) | 0;
   $63 = ($60 | 0) == ($62 | 0);
   if ($63) {
    STACKTOP = sp;
    return;
   }
   $64 = $3;
   $65 = $1;
   $66 = _indent_top($65) | 0;
   $67 = $64 >>> 0 > $66 >>> 0;
   if ($67) {
    $68 = $1;
    $69 = $3;
    _indent_push($68, $69);
    $70 = $1;
    $71 = $70 + 36 | 0;
    $72 = HEAP32[$71 >> 2] | 0;
    $73 = $72 + 1 | 0;
    HEAP32[$71 >> 2] = $73;
    STACKTOP = sp;
    return;
   }
   while (1) {
    $74 = $3;
    $75 = $1;
    $76 = _indent_top($75) | 0;
    $77 = $74 >>> 0 < $76 >>> 0;
    if (!$77) {
     break;
    }
    $78 = $1;
    _indent_pop($78);
    $79 = $1;
    $80 = $79 + 36 | 0;
    $81 = HEAP32[$80 >> 2] | 0;
    $82 = $81 - 1 | 0;
    HEAP32[$80 >> 2] = $82;
   }
   $83 = $3;
   $84 = $1;
   $85 = _indent_top($84) | 0;
   $86 = ($83 | 0) != ($85 | 0);
   if (!$86) {
    STACKTOP = sp;
    return;
   }
   $87 = $1;
   $88 = $87 + 64 | 0;
   HEAP32[$88 >> 2] = 2;
   STACKTOP = sp;
   return;
  }
 }
 $89 = $1;
 $90 = _is_end($89) | 0;
 $91 = $1;
 if ($90) {
  $92 = $91 + 64 | 0;
  HEAP32[$92 >> 2] = 0;
  STACKTOP = sp;
  return;
 }
 $93 = _is_string_or_bytes($91) | 0;
 $94 = $1;
 if ($93) {
  $95 = $94 + 64 | 0;
  HEAP32[$95 >> 2] = 0;
  while (1) {
   $4 = 0;
   $5 = 10;
   $6 = 0;
   $96 = $1;
   $97 = _is_char($96, 117) | 0;
   do {
    if ($97) {
     $6 = 1;
    } else {
     $98 = $1;
     $99 = _is_char($98, 98) | 0;
     if ($99) {
      $5 = 11;
      $6 = 1;
      $100 = $1;
      $101 = _is_char_following($100, 114) | 0;
      if (!$101) {
       break;
      }
      $4 = 1;
      $6 = 2;
      break;
     }
     $102 = $1;
     $103 = _is_char($102, 114) | 0;
     if ($103) {
      $4 = 1;
      $6 = 1;
      $104 = $1;
      $105 = _is_char_following($104, 98) | 0;
      if ($105) {
       $5 = 11;
       $6 = 2;
      }
     }
    }
   } while (0);
   $106 = $1;
   $107 = $106 + 64 | 0;
   $108 = HEAP32[$107 >> 2] | 0;
   $109 = ($108 | 0) == 0;
   if ($109) {
    $110 = $5;
    $111 = $1;
    $112 = $111 + 64 | 0;
    HEAP32[$112 >> 2] = $110;
   } else {
    $113 = $1;
    $114 = $113 + 64 | 0;
    $115 = HEAP32[$114 >> 2] | 0;
    $116 = $5;
    $117 = ($115 | 0) != ($116 | 0);
    if ($117) {
     label = 103;
     break;
    }
   }
   $118 = $6;
   $119 = ($118 | 0) != 0;
   if ($119) {
    $120 = $1;
    _next_char($120);
    $121 = $6;
    $122 = ($121 | 0) == 2;
    if ($122) {
     $123 = $1;
     _next_char($123);
    }
   }
   $124 = $1;
   $125 = $4;
   $126 = $125 & 1;
   _parse_string_literal($124, $126);
   $127 = $1;
   _skip_whitespace($127, 1) | 0;
   $128 = $1;
   $129 = _is_string_or_bytes($128) | 0;
   if (!$129) {
    label = 103;
    break;
   }
  }
  if ((label | 0) == 103) {
   STACKTOP = sp;
   return;
  }
 }
 $130 = _is_head_of_identifier($94) | 0;
 $131 = $1;
 if ($130) {
  $132 = $131 + 64 | 0;
  HEAP32[$132 >> 2] = 7;
  $133 = $1;
  $134 = $133 + 68 | 0;
  $135 = $1;
  $136 = $135 + 16 | 0;
  $137 = HEAP32[$136 >> 2] | 0;
  $138 = $137 & 255;
  _vstr_add_byte($134, $138);
  $139 = $1;
  _next_char($139);
  while (1) {
   $140 = $1;
   $141 = _is_end($140) | 0;
   if ($141) {
    $357 = 0;
   } else {
    $142 = $1;
    $143 = _is_tail_of_identifier($142) | 0;
    $357 = $143;
   }
   $144 = $1;
   $145 = $144 + 68 | 0;
   if (!$357) {
    break;
   }
   $146 = $1;
   $147 = $146 + 16 | 0;
   $148 = HEAP32[$147 >> 2] | 0;
   $149 = $148 & 255;
   _vstr_add_byte($145, $149);
   $150 = $1;
   _next_char($150);
  }
  $151 = _vstr_null_terminated_str($145) | 0;
  $7 = $151;
  $8 = 0;
  while (1) {
   $152 = $8;
   $153 = $152 >>> 0 < 36;
   if (!$153) {
    label = 103;
    break;
   }
   $154 = $7;
   $155 = $8;
   $156 = 1216 + ($155 << 2) | 0;
   $157 = HEAP32[$156 >> 2] | 0;
   $158 = _strcmp($154, $157) | 0;
   $9 = $158;
   $159 = $9;
   $160 = ($159 | 0) == 0;
   if ($160) {
    label = 43;
    break;
   }
   $174 = $9;
   $175 = ($174 | 0) < 0;
   if ($175) {
    label = 103;
    break;
   }
   $176 = $8;
   $177 = $176 + 1 | 0;
   $8 = $177;
  }
  if ((label | 0) == 43) {
   $161 = $8;
   $162 = 13 + $161 | 0;
   $163 = $1;
   $164 = $163 + 64 | 0;
   HEAP32[$164 >> 2] = $162;
   $165 = $1;
   $166 = $165 + 64 | 0;
   $167 = HEAP32[$166 >> 2] | 0;
   $168 = ($167 | 0) == 16;
   if (!$168) {
    STACKTOP = sp;
    return;
   }
   $169 = HEAP32[40736 >> 2] | 0;
   $170 = ($169 | 0) == 0;
   $171 = $170 ? 15 : 13;
   $172 = $1;
   $173 = $172 + 64 | 0;
   HEAP32[$173 >> 2] = $171;
   STACKTOP = sp;
   return;
  } else if ((label | 0) == 103) {
   STACKTOP = sp;
   return;
  }
 }
 $178 = _is_digit($131) | 0;
 do {
  if (!$178) {
   $179 = $1;
   $180 = _is_char($179, 46) | 0;
   if ($180) {
    $181 = $1;
    $182 = _is_following_digit($181) | 0;
    if ($182) {
     break;
    }
   }
   $11 = 28396;
   $12 = 0;
   while (1) {
    $238 = $11;
    $239 = HEAP8[$238 >> 0] | 0;
    $240 = $239 << 24 >> 24;
    $241 = ($240 | 0) != 0;
    if (!$241) {
     break;
    }
    $242 = $1;
    $243 = $11;
    $244 = HEAP8[$243 >> 0] | 0;
    $245 = _is_char($242, $244) | 0;
    $246 = $245 ^ 1;
    if (!$246) {
     break;
    }
    $247 = $11;
    $248 = HEAP8[$247 >> 0] | 0;
    $249 = $248 << 24 >> 24;
    $250 = ($249 | 0) == 101;
    if ($250) {
     label = 76;
    } else {
     $251 = $11;
     $252 = HEAP8[$251 >> 0] | 0;
     $253 = $252 << 24 >> 24;
     $254 = ($253 | 0) == 99;
     if ($254) {
      label = 76;
     }
    }
    if ((label | 0) == 76) {
     label = 0;
     $255 = $11;
     $256 = $255 + 1 | 0;
     $11 = $256;
    }
    $257 = $12;
    $258 = $257 + 1 | 0;
    $12 = $258;
    $259 = $11;
    $260 = $259 + 1 | 0;
    $11 = $260;
   }
   $261 = $1;
   _next_char($261);
   $262 = $11;
   $263 = HEAP8[$262 >> 0] | 0;
   $264 = $263 << 24 >> 24;
   $265 = ($264 | 0) == 0;
   if ($265) {
    $266 = $1;
    $267 = $266 + 64 | 0;
    HEAP32[$267 >> 2] = 1;
    STACKTOP = sp;
    return;
   }
   $268 = $11;
   $269 = HEAP8[$268 >> 0] | 0;
   $270 = $269 << 24 >> 24;
   $271 = ($270 | 0) == 33;
   if ($271) {
    $272 = $1;
    $273 = _is_char($272, 61) | 0;
    $274 = $1;
    if ($273) {
     _next_char($274);
     $275 = $1;
     $276 = $275 + 64 | 0;
     HEAP32[$276 >> 2] = 67;
     STACKTOP = sp;
     return;
    } else {
     $277 = $274 + 64 | 0;
     HEAP32[$277 >> 2] = 1;
     STACKTOP = sp;
     return;
    }
   }
   $278 = $11;
   $279 = HEAP8[$278 >> 0] | 0;
   $280 = $279 << 24 >> 24;
   $281 = ($280 | 0) == 46;
   if ($281) {
    $282 = $1;
    $283 = _is_char_and($282, 46, 46) | 0;
    $284 = $1;
    if ($283) {
     _next_char($284);
     $285 = $1;
     _next_char($285);
     $286 = $1;
     $287 = $286 + 64 | 0;
     HEAP32[$287 >> 2] = 12;
     STACKTOP = sp;
     return;
    } else {
     $288 = $284 + 64 | 0;
     HEAP32[$288 >> 2] = 76;
     STACKTOP = sp;
     return;
    }
   }
   $289 = $11;
   $290 = $289 + 1 | 0;
   $11 = $290;
   $291 = $12;
   $13 = $291;
   while (1) {
    $292 = $11;
    $293 = HEAP8[$292 >> 0] | 0;
    $294 = $293 << 24 >> 24;
    $295 = ($294 | 0) == 99;
    if (!$295) {
     $296 = $11;
     $297 = HEAP8[$296 >> 0] | 0;
     $298 = $297 << 24 >> 24;
     $299 = ($298 | 0) == 101;
     if (!$299) {
      break;
     }
    }
    $300 = $13;
    $301 = $300 + 1 | 0;
    $13 = $301;
    $302 = $1;
    $303 = $11;
    $304 = $303 + 1 | 0;
    $305 = HEAP8[$304 >> 0] | 0;
    $306 = _is_char($302, $305) | 0;
    if ($306) {
     $307 = $1;
     _next_char($307);
     $308 = $13;
     $12 = $308;
     $309 = $11;
     $310 = HEAP8[$309 >> 0] | 0;
     $311 = $310 << 24 >> 24;
     $312 = ($311 | 0) == 101;
     if ($312) {
      break;
     }
    } else {
     $313 = $11;
     $314 = HEAP8[$313 >> 0] | 0;
     $315 = $314 << 24 >> 24;
     $316 = ($315 | 0) == 99;
     if ($316) {
      break;
     }
    }
    $317 = $11;
    $318 = $317 + 2 | 0;
    $11 = $318;
   }
   $319 = $12;
   $320 = 1360 + $319 | 0;
   $321 = HEAP8[$320 >> 0] | 0;
   $322 = $321 & 255;
   $323 = $1;
   $324 = $323 + 64 | 0;
   HEAP32[$324 >> 2] = $322;
   $325 = $1;
   $326 = $325 + 64 | 0;
   $327 = HEAP32[$326 >> 2] | 0;
   $328 = ($327 | 0) == 68;
   if (!$328) {
    $329 = $1;
    $330 = $329 + 64 | 0;
    $331 = HEAP32[$330 >> 2] | 0;
    $332 = ($331 | 0) == 70;
    if (!$332) {
     $333 = $1;
     $334 = $333 + 64 | 0;
     $335 = HEAP32[$334 >> 2] | 0;
     $336 = ($335 | 0) == 72;
     if (!$336) {
      $341 = $1;
      $342 = $341 + 64 | 0;
      $343 = HEAP32[$342 >> 2] | 0;
      $344 = ($343 | 0) == 69;
      if (!$344) {
       $345 = $1;
       $346 = $345 + 64 | 0;
       $347 = HEAP32[$346 >> 2] | 0;
       $348 = ($347 | 0) == 71;
       if (!$348) {
        $349 = $1;
        $350 = $349 + 64 | 0;
        $351 = HEAP32[$350 >> 2] | 0;
        $352 = ($351 | 0) == 73;
        if (!$352) {
         STACKTOP = sp;
         return;
        }
       }
      }
      $353 = $1;
      $354 = $353 + 40 | 0;
      $355 = HEAP32[$354 >> 2] | 0;
      $356 = $355 - 1 | 0;
      HEAP32[$354 >> 2] = $356;
      STACKTOP = sp;
      return;
     }
    }
   }
   $337 = $1;
   $338 = $337 + 40 | 0;
   $339 = HEAP32[$338 >> 2] | 0;
   $340 = $339 + 1 | 0;
   HEAP32[$338 >> 2] = $340;
   STACKTOP = sp;
   return;
  }
 } while (0);
 $10 = 0;
 $183 = $1;
 $184 = _is_char($183, 46) | 0;
 $185 = $1;
 $186 = $185 + 64 | 0;
 if ($184) {
  HEAP32[$186 >> 2] = 9;
 } else {
  HEAP32[$186 >> 2] = 8;
  $187 = $1;
  $188 = _is_char($187, 48) | 0;
  if ($188) {
   $189 = $1;
   $190 = _is_following_base_char($189) | 0;
   if ($190) {
    $10 = 1;
   }
  }
 }
 $191 = $1;
 $192 = $191 + 68 | 0;
 $193 = $1;
 $194 = $193 + 16 | 0;
 $195 = HEAP32[$194 >> 2] | 0;
 _vstr_add_char($192, $195);
 $196 = $1;
 _next_char($196);
 L145 : while (1) {
  $197 = $1;
  $198 = _is_end($197) | 0;
  $199 = $198 ^ 1;
  if (!$199) {
   label = 103;
   break;
  }
  $200 = $10;
  $201 = $200 & 1;
  do {
   if ($201) {
    label = 62;
   } else {
    $202 = $1;
    $203 = _is_char_or($202, 101, 69) | 0;
    if ($203) {
     $204 = $1;
     $205 = $204 + 64 | 0;
     HEAP32[$205 >> 2] = 9;
     $206 = $1;
     $207 = $206 + 68 | 0;
     _vstr_add_char($207, 101);
     $208 = $1;
     _next_char($208);
     $209 = $1;
     $210 = _is_char($209, 43) | 0;
     if (!$210) {
      $211 = $1;
      $212 = _is_char($211, 45) | 0;
      if (!$212) {
       break;
      }
     }
     $213 = $1;
     $214 = $213 + 68 | 0;
     $215 = $1;
     $216 = $215 + 16 | 0;
     $217 = HEAP32[$216 >> 2] | 0;
     _vstr_add_char($214, $217);
     $218 = $1;
     _next_char($218);
    } else {
     label = 62;
    }
   }
  } while (0);
  do {
   if ((label | 0) == 62) {
    label = 0;
    $219 = $1;
    $220 = _is_letter($219) | 0;
    if (!$220) {
     $221 = $1;
     $222 = _is_digit($221) | 0;
     if (!$222) {
      $223 = $1;
      $224 = _is_char($223, 46) | 0;
      if (!$224) {
       $235 = $1;
       $236 = _is_char($235, 95) | 0;
       if (!$236) {
        label = 103;
        break L145;
       }
       $237 = $1;
       _next_char($237);
       break;
      }
     }
    }
    $225 = $1;
    $226 = _is_char_or3($225, 46, 106, 74) | 0;
    if ($226) {
     $227 = $1;
     $228 = $227 + 64 | 0;
     HEAP32[$228 >> 2] = 9;
    }
    $229 = $1;
    $230 = $229 + 68 | 0;
    $231 = $1;
    $232 = $231 + 16 | 0;
    $233 = HEAP32[$232 >> 2] | 0;
    _vstr_add_char($230, $233);
    $234 = $1;
    _next_char($234);
   }
  } while (0);
 }
 if ((label | 0) == 103) {
  STACKTOP = sp;
  return;
 }
}

function _parse_compile_execute($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$0 = 0, $$073 = 0, $$073$phi = 0, $$074 = 0, $$1 = 0, $$reg2mem71$0 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $cond = 0, $cond100 = 0, $cond101 = 0, $cond102 = 0, $cond103 = 0, $cond104 = 0, $cond105 = 0, $cond106 = 0, $cond107 = 0, $cond86 = 0, $cond87 = 0, $cond88 = 0, $cond89 = 0, $cond90 = 0, $cond91 = 0, $cond92 = 0, $cond93 = 0, $cond94 = 0, $cond95 = 0, $cond96 = 0, $cond97 = 0, $cond98 = 0, $cond99 = 0, $vararg_buffer = 0, $vararg_buffer75 = 0, $vararg_ptr78 = 0, $vararg_ptr79 = 0, $vararg_ptr80 = 0, _setjmpTable = 0, _setjmpTableSize = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 224 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(224 | 0);
 $vararg_buffer75 = sp + 8 | 0;
 $vararg_buffer = sp;
 _setjmpTableSize = 4;
 _setjmpTable = _malloc(40) | 0;
 HEAP32[_setjmpTable >> 2] = 0;
 $3 = sp + 48 | 0;
 $4 = sp + 40 | 0;
 $5 = sp + 36 | 0;
 $6 = sp + 32 | 0;
 $7 = sp + 28 | 0;
 $8 = sp + 24 | 0;
 __THREW__ = 0;
 invoke_ii(496, $3 | 0) | 0;
 $9 = __THREW__;
 __THREW__ = 0;
 if (($9 | 0) != 0 & (threwValue | 0) != 0) {
  $10 = _testSetjmp(HEAP32[$9 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  if (($10 | 0) == 0) {
   _longjmp($9 | 0, threwValue | 0);
  }
  setTempRet0(threwValue | 0);
 } else {
  $10 = -1;
 }
 $11 = getTempRet0() | 0;
 $cond = ($10 | 0) == 1;
 if ($cond) {
  $$073 = 0;
  $$reg2mem71$0 = $11;
 } else {
  $12 = $3 + 8 | 0;
  _setjmpTable = _saveSetjmp($12, 1, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  _setjmpTableSize = getTempRet0() | 0;
  __THREW__ = 0;
  $13 = __THREW__;
  __THREW__ = 0;
  if (($13 | 0) != 0 & (threwValue | 0) != 0) {
   $14 = _testSetjmp(HEAP32[$13 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($14 | 0) == 0) {
    _longjmp($13 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $14 = -1;
  }
  $15 = getTempRet0() | 0;
  $cond86 = ($14 | 0) == 1;
  if ($cond86) {
   $$073 = 0;
   $$reg2mem71$0 = $15;
  } else {
   $$073 = 0;
   $$reg2mem71$0 = 0;
  }
 }
 L4 : while (1) {
  $16 = ($$reg2mem71$0 | 0) == 0;
  do {
   if ($16) {
    $17 = $2 & 16;
    $18 = ($17 | 0) != 0;
    do {
     if ($18) {
      $19 = $0 + 8 | 0;
      $20 = HEAP32[$19 >> 2] | 0;
      $21 = $0 + 4 | 0;
      $22 = HEAP32[$21 >> 2] | 0;
      __THREW__ = 0;
      $23 = invoke_iiiii(616, 215, $20 | 0, $22 | 0, 0) | 0;
      $24 = __THREW__;
      __THREW__ = 0;
      if (($24 | 0) != 0 & (threwValue | 0) != 0) {
       $25 = _testSetjmp(HEAP32[$24 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
       if (($25 | 0) == 0) {
        _longjmp($24 | 0, threwValue | 0);
       }
       setTempRet0(threwValue | 0);
      } else {
       $25 = -1;
      }
      $26 = getTempRet0() | 0;
      $cond107 = ($25 | 0) == 1;
      if ($cond107) {
       $$073$phi = $$073;
       $$reg2mem71$0 = $26;
       $$073 = $$073$phi;
       continue L4;
      }
      $$0 = $23;
     } else {
      $27 = $2 & 32;
      $28 = ($27 | 0) != 0;
      if (!$28) {
       $$0 = $0;
       break;
      }
      __THREW__ = 0;
      $29 = invoke_ii(617, $0 | 0) | 0;
      $30 = __THREW__;
      __THREW__ = 0;
      if (($30 | 0) != 0 & (threwValue | 0) != 0) {
       $31 = _testSetjmp(HEAP32[$30 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
       if (($31 | 0) == 0) {
        _longjmp($30 | 0, threwValue | 0);
       }
       setTempRet0(threwValue | 0);
      } else {
       $31 = -1;
      }
      $32 = getTempRet0() | 0;
      $cond106 = ($31 | 0) == 1;
      if ($cond106) {
       $$073$phi = $$073;
       $$reg2mem71$0 = $32;
       $$073 = $$073$phi;
       continue L4;
      }
      $$0 = $29;
     }
    } while (0);
    $33 = HEAP32[$$0 >> 2] | 0;
    __THREW__ = 0;
    invoke_viii(507, $4 | 0, $$0 | 0, $1 | 0);
    $34 = __THREW__;
    __THREW__ = 0;
    if (($34 | 0) != 0 & (threwValue | 0) != 0) {
     $35 = _testSetjmp(HEAP32[$34 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($35 | 0) == 0) {
      _longjmp($34 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $35 = -1;
    }
    $36 = getTempRet0() | 0;
    $cond98 = ($35 | 0) == 1;
    if ($cond98) {
     $$073$phi = $$073;
     $$reg2mem71$0 = $36;
     $$073 = $$073$phi;
     continue L4;
    }
    $37 = $2 & 4;
    $38 = ($37 | 0) != 0;
    __THREW__ = 0;
    $39 = invoke_iiiii(508, $4 | 0, $33 | 0, 0, $38 | 0) | 0;
    $40 = __THREW__;
    __THREW__ = 0;
    if (($40 | 0) != 0 & (threwValue | 0) != 0) {
     $41 = _testSetjmp(HEAP32[$40 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($41 | 0) == 0) {
      _longjmp($40 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $41 = -1;
    }
    $42 = getTempRet0() | 0;
    $cond99 = ($41 | 0) == 1;
    if ($cond99) {
     $$073$phi = $$073;
     $$reg2mem71$0 = $42;
     $$073 = $$073$phi;
     continue L4;
    }
    __THREW__ = 0;
    invoke_vi(618, 3);
    $43 = __THREW__;
    __THREW__ = 0;
    if (($43 | 0) != 0 & (threwValue | 0) != 0) {
     $44 = _testSetjmp(HEAP32[$43 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($44 | 0) == 0) {
      _longjmp($43 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $44 = -1;
    }
    $45 = getTempRet0() | 0;
    $cond100 = ($44 | 0) == 1;
    if ($cond100) {
     $$073$phi = $$073;
     $$reg2mem71$0 = $45;
     $$073 = $$073$phi;
     continue L4;
    }
    __THREW__ = 0;
    $46 = invoke_i(619) | 0;
    $47 = __THREW__;
    __THREW__ = 0;
    if (($47 | 0) != 0 & (threwValue | 0) != 0) {
     $48 = _testSetjmp(HEAP32[$47 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($48 | 0) == 0) {
      _longjmp($47 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $48 = -1;
    }
    $49 = getTempRet0() | 0;
    $cond101 = ($48 | 0) == 1;
    if ($cond101) {
     $$073$phi = $$073;
     $$reg2mem71$0 = $49;
     $$073 = $$073$phi;
     continue L4;
    }
    __THREW__ = 0;
    invoke_ii(509, $39 | 0) | 0;
    $50 = __THREW__;
    __THREW__ = 0;
    if (($50 | 0) != 0 & (threwValue | 0) != 0) {
     $51 = _testSetjmp(HEAP32[$50 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($51 | 0) == 0) {
      _longjmp($50 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $51 = -1;
    }
    $52 = getTempRet0() | 0;
    $cond102 = ($51 | 0) == 1;
    if ($cond102) {
     $$073 = $46;
     $$reg2mem71$0 = $52;
     continue L4;
    }
    __THREW__ = 0;
    invoke_vi(618, -1);
    $53 = __THREW__;
    __THREW__ = 0;
    if (($53 | 0) != 0 & (threwValue | 0) != 0) {
     $54 = _testSetjmp(HEAP32[$53 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($54 | 0) == 0) {
      _longjmp($53 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $54 = -1;
    }
    $55 = getTempRet0() | 0;
    $cond103 = ($54 | 0) == 1;
    if ($cond103) {
     $$073 = $46;
     $$reg2mem71$0 = $55;
     continue L4;
    }
    __THREW__ = 0;
    invoke_v(498);
    $56 = __THREW__;
    __THREW__ = 0;
    if (($56 | 0) != 0 & (threwValue | 0) != 0) {
     $57 = _testSetjmp(HEAP32[$56 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($57 | 0) == 0) {
      _longjmp($56 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $57 = -1;
    }
    $58 = getTempRet0() | 0;
    $cond104 = ($57 | 0) == 1;
    if ($cond104) {
     $$073 = $46;
     $$reg2mem71$0 = $58;
     continue L4;
    }
    $59 = $2 & 1;
    $60 = ($59 | 0) != 0;
    if ($60) {
     __THREW__ = 0;
     invoke_vii(620, 35207 | 0, 1);
     $61 = __THREW__;
     __THREW__ = 0;
     if (($61 | 0) != 0 & (threwValue | 0) != 0) {
      $62 = _testSetjmp(HEAP32[$61 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($62 | 0) == 0) {
       _longjmp($61 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $62 = -1;
     }
     $63 = getTempRet0() | 0;
     $cond105 = ($62 | 0) == 1;
     if ($cond105) {
      $$073 = $46;
      $$reg2mem71$0 = $63;
      continue L4;
     }
     $$074 = 1;
     $$1 = $46;
    } else {
     $$074 = 1;
     $$1 = $46;
    }
   } else {
    __THREW__ = 0;
    invoke_vi(618, -1);
    $64 = __THREW__;
    __THREW__ = 0;
    if (($64 | 0) != 0 & (threwValue | 0) != 0) {
     $65 = _testSetjmp(HEAP32[$64 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($65 | 0) == 0) {
      _longjmp($64 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $65 = -1;
    }
    $66 = getTempRet0() | 0;
    $cond87 = ($65 | 0) == 1;
    if ($cond87) {
     $$073$phi = $$073;
     $$reg2mem71$0 = $66;
     $$073 = $$073$phi;
     continue L4;
    }
    $67 = $2 & 1;
    $68 = ($67 | 0) != 0;
    if ($68) {
     __THREW__ = 0;
     invoke_vii(620, 35207 | 0, 1);
     $69 = __THREW__;
     __THREW__ = 0;
     if (($69 | 0) != 0 & (threwValue | 0) != 0) {
      $70 = _testSetjmp(HEAP32[$69 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($70 | 0) == 0) {
       _longjmp($69 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $70 = -1;
     }
     $71 = getTempRet0() | 0;
     $cond97 = ($70 | 0) == 1;
     if ($cond97) {
      $$073$phi = $$073;
      $$reg2mem71$0 = $71;
      $$073 = $$073$phi;
      continue L4;
     }
    }
    $72 = $3 + 4 | 0;
    $73 = HEAP32[$72 >> 2] | 0;
    $74 = HEAP32[$73 >> 2] | 0;
    __THREW__ = 0;
    $75 = invoke_iii(499, $74 | 0, 14872 | 0) | 0;
    $76 = __THREW__;
    __THREW__ = 0;
    if (($76 | 0) != 0 & (threwValue | 0) != 0) {
     $77 = _testSetjmp(HEAP32[$76 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($77 | 0) == 0) {
      _longjmp($76 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $77 = -1;
    }
    $78 = getTempRet0() | 0;
    $cond88 = ($77 | 0) == 1;
    if ($cond88) {
     $$073$phi = $$073;
     $$reg2mem71$0 = $78;
     $$073 = $$073$phi;
     continue L4;
    }
    if ($75) {
     $$074 = 0;
     $$1 = $$073;
     break;
    }
    $79 = $3 + 4 | 0;
    $80 = HEAP32[$79 >> 2] | 0;
    __THREW__ = 0;
    invoke_vii(511, 13344 | 0, $80 | 0);
    $81 = __THREW__;
    __THREW__ = 0;
    if (($81 | 0) != 0 & (threwValue | 0) != 0) {
     $82 = _testSetjmp(HEAP32[$81 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($82 | 0) == 0) {
      _longjmp($81 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $82 = -1;
    }
    $83 = getTempRet0() | 0;
    $cond89 = ($82 | 0) == 1;
    if ($cond89) {
     $$073$phi = $$073;
     $$reg2mem71$0 = $83;
     $$073 = $$073$phi;
     continue L4;
    }
    $$074 = 0;
    $$1 = $$073;
   }
  } while (0);
  $84 = $2 & 2;
  $85 = ($84 | 0) != 0;
  if ($85) {
   $86 = 0 & 1;
   if ($86) {
    __THREW__ = 0;
    $87 = invoke_i(619) | 0;
    $88 = __THREW__;
    __THREW__ = 0;
    if (($88 | 0) != 0 & (threwValue | 0) != 0) {
     $89 = _testSetjmp(HEAP32[$88 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($89 | 0) == 0) {
      _longjmp($88 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $89 = -1;
    }
    $90 = getTempRet0() | 0;
    $cond91 = ($89 | 0) == 1;
    if ($cond91) {
     $$073 = $$1;
     $$reg2mem71$0 = $90;
     continue;
    }
    $91 = $87 - $$1 | 0;
    __THREW__ = 0;
    HEAP32[$vararg_buffer >> 2] = $91;
    invoke_iii(621, 35209 | 0, $vararg_buffer | 0) | 0;
    $92 = __THREW__;
    __THREW__ = 0;
    if (($92 | 0) != 0 & (threwValue | 0) != 0) {
     $93 = _testSetjmp(HEAP32[$92 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($93 | 0) == 0) {
      _longjmp($92 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $93 = -1;
    }
    $94 = getTempRet0() | 0;
    $cond92 = ($93 | 0) == 1;
    if ($cond92) {
     $$073 = $$1;
     $$reg2mem71$0 = $94;
     continue;
    }
    __THREW__ = 0;
    invoke_viiii(622, $5 | 0, $6 | 0, $7 | 0, $8 | 0);
    $95 = __THREW__;
    __THREW__ = 0;
    if (($95 | 0) != 0 & (threwValue | 0) != 0) {
     $96 = _testSetjmp(HEAP32[$95 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($96 | 0) == 0) {
      _longjmp($95 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $96 = -1;
    }
    $97 = getTempRet0() | 0;
    $cond93 = ($96 | 0) == 1;
    if ($cond93) {
     $$073 = $$1;
     $$reg2mem71$0 = $97;
     continue;
    }
    $98 = HEAP32[$5 >> 2] | 0;
    $99 = HEAP32[$6 >> 2] | 0;
    $100 = HEAP32[$7 >> 2] | 0;
    $101 = HEAP32[$8 >> 2] | 0;
    __THREW__ = 0;
    HEAP32[$vararg_buffer75 >> 2] = $98;
    $vararg_ptr78 = $vararg_buffer75 + 4 | 0;
    HEAP32[$vararg_ptr78 >> 2] = $99;
    $vararg_ptr79 = $vararg_buffer75 + 8 | 0;
    HEAP32[$vararg_ptr79 >> 2] = $100;
    $vararg_ptr80 = $vararg_buffer75 + 12 | 0;
    HEAP32[$vararg_ptr80 >> 2] = $101;
    invoke_iii(621, 35221 | 0, $vararg_buffer75 | 0) | 0;
    $102 = __THREW__;
    __THREW__ = 0;
    if (($102 | 0) != 0 & (threwValue | 0) != 0) {
     $103 = _testSetjmp(HEAP32[$102 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($103 | 0) == 0) {
      _longjmp($102 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $103 = -1;
    }
    $104 = getTempRet0() | 0;
    $cond94 = ($103 | 0) == 1;
    if ($cond94) {
     $$073 = $$1;
     $$reg2mem71$0 = $104;
     continue;
    }
    __THREW__ = 0;
    invoke_v(623);
    $105 = __THREW__;
    __THREW__ = 0;
    if (($105 | 0) != 0 & (threwValue | 0) != 0) {
     $106 = _testSetjmp(HEAP32[$105 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($106 | 0) == 0) {
      _longjmp($105 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $106 = -1;
    }
    $107 = getTempRet0() | 0;
    $cond95 = ($106 | 0) == 1;
    if ($cond95) {
     $$073 = $$1;
     $$reg2mem71$0 = $107;
     continue;
    }
    __THREW__ = 0;
    invoke_v(624);
    $108 = __THREW__;
    __THREW__ = 0;
    if (($108 | 0) != 0 & (threwValue | 0) != 0) {
     $109 = _testSetjmp(HEAP32[$108 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($109 | 0) == 0) {
      _longjmp($108 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $109 = -1;
    }
    $110 = getTempRet0() | 0;
    $cond96 = ($109 | 0) == 1;
    if ($cond96) {
     $$073 = $$1;
     $$reg2mem71$0 = $110;
     continue;
    }
   }
  }
  $111 = $2 & 1;
  $112 = ($111 | 0) != 0;
  if (!$112) {
   label = 43;
   break;
  }
  __THREW__ = 0;
  invoke_vii(620, 35207 | 0, 1);
  $113 = __THREW__;
  __THREW__ = 0;
  if (($113 | 0) != 0 & (threwValue | 0) != 0) {
   $114 = _testSetjmp(HEAP32[$113 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($114 | 0) == 0) {
    _longjmp($113 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $114 = -1;
  }
  $115 = getTempRet0() | 0;
  $cond90 = ($114 | 0) == 1;
  if ($cond90) {
   $$073 = $$1;
   $$reg2mem71$0 = $115;
  } else {
   break;
  }
 }
 if ((label | 0) == 43) {
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$074 | 0;
 }
 _free(_setjmpTable | 0);
 STACKTOP = sp;
 return $$074 | 0;
}

function _fold_constants($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val11 = 0, $$expand_i1_val13 = 0, $$expand_i1_val15 = 0, $$expand_i1_val17 = 0, $$expand_i1_val19 = 0, $$expand_i1_val21 = 0, $$expand_i1_val23 = 0, $$expand_i1_val25 = 0, $$expand_i1_val27 = 0, $$expand_i1_val5 = 0, $$expand_i1_val7 = 0, $$expand_i1_val9 = 0, $$pre_trunc = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112 | 0);
 $3 = sp + 97 | 0;
 $7 = sp + 84 | 0;
 $11 = sp + 68 | 0;
 $14 = sp + 56 | 0;
 $25 = sp + 12 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $29 = $5;
 $30 = $29 & 255;
 $31 = ($30 | 0) == 34;
 L1 : do {
  if ($31) {
   label = 4;
  } else {
   $32 = $5;
   $33 = $32 & 255;
   $34 = ($33 | 0) == 35;
   if ($34) {
    label = 4;
   } else {
    $35 = $5;
    $36 = $35 & 255;
    $37 = ($36 | 0) == 36;
    if ($37) {
     label = 4;
    } else {
     $65 = $5;
     $66 = $65 & 255;
     $67 = ($66 | 0) == 37;
     if (!$67) {
      $68 = $5;
      $69 = $68 & 255;
      $70 = ($69 | 0) == 38;
      if (!$70) {
       $71 = $5;
       $72 = $71 & 255;
       $73 = ($72 | 0) == 39;
       if (!$73) {
        $117 = $5;
        $118 = $117 & 255;
        $119 = ($118 | 0) == 40;
        if ($119) {
         $120 = $4;
         $121 = _peek_result($120, 0) | 0;
         $18 = $121;
         $122 = $18;
         $123 = _mp_parse_node_get_int_maybe($122, $7) | 0;
         if (!$123) {
          $$expand_i1_val17 = 0;
          HEAP8[$3 >> 0] = $$expand_i1_val17;
          $$pre_trunc = HEAP8[$3 >> 0] | 0;
          $268 = $$pre_trunc & 1;
          STACKTOP = sp;
          return $268 | 0;
         }
         $124 = $4;
         $125 = _peek_result($124, 1) | 0;
         $126 = $125 >>> 4;
         $19 = $126;
         $127 = $19;
         $128 = ($127 | 0) == 49;
         do {
          if ($128) {
           $20 = 0;
          } else {
           $129 = $19;
           $130 = ($129 | 0) == 50;
           if ($130) {
            $20 = 1;
            break;
           } else {
            $20 = 2;
            break;
           }
          }
         } while (0);
         $131 = $20;
         $132 = HEAP32[$7 >> 2] | 0;
         $133 = _mp_unary_op($131, $132) | 0;
         HEAP32[$7 >> 2] = $133;
         break;
        }
        $134 = $5;
        $135 = $134 & 255;
        $136 = ($135 | 0) == 5;
        if (!$136) {
         $$expand_i1_val25 = 0;
         HEAP8[$3 >> 0] = $$expand_i1_val25;
         $$pre_trunc = HEAP8[$3 >> 0] | 0;
         $268 = $$pre_trunc & 1;
         STACKTOP = sp;
         return $268 | 0;
        }
        $137 = $4;
        $138 = _peek_result($137, 0) | 0;
        $21 = $138;
        $139 = $21;
        $140 = ($139 | 0) == 0;
        do {
         if (!$140) {
          $141 = $21;
          $142 = ($141 | 0) != 0;
          if ($142) {
           $143 = $21;
           $144 = $143 & 3;
           $145 = ($144 | 0) == 0;
           if ($145) {
            $146 = $21;
            $147 = $146;
            $148 = $147 + 4 | 0;
            $149 = HEAP32[$148 >> 2] | 0;
            $150 = $149 & 255;
            $151 = ($150 | 0) == 86;
            if ($151) {
             break;
            }
           }
          }
          $152 = $21;
          $153 = ($152 | 0) != 0;
          if ($153) {
           $154 = $21;
           $155 = $154 & 3;
           $156 = ($155 | 0) == 0;
           if ($156) {
            $157 = $21;
            $158 = $157;
            $159 = $158 + 4 | 0;
            $160 = HEAP32[$159 >> 2] | 0;
            $161 = $160 & 255;
            $162 = ($161 | 0) == 87;
            if ($162) {
             break;
            }
           }
          }
          $163 = $4;
          $164 = _peek_result($163, 1) | 0;
          $22 = $164;
          $165 = $22;
          $166 = $165 & 15;
          $167 = ($166 | 0) == 2;
          $168 = $21;
          $169 = ($168 | 0) != 0;
          $or$cond = $167 & $169;
          if ($or$cond) {
           $170 = $21;
           $171 = $170 & 3;
           $172 = ($171 | 0) == 0;
           if ($172) {
            $173 = $21;
            $174 = $173;
            $175 = $174 + 4 | 0;
            $176 = HEAP32[$175 >> 2] | 0;
            $177 = $176 & 255;
            $178 = ($177 | 0) == 43;
            if ($178) {
             $179 = $21;
             $180 = $179;
             $181 = $180 + 8 | 0;
             $182 = HEAP32[$181 >> 2] | 0;
             $183 = $182 & 15;
             $184 = ($183 | 0) == 2;
             if ($184) {
              $185 = $21;
              $186 = $185;
              $187 = $186 + 8 | 0;
              $188 = HEAP32[$187 >> 2] | 0;
              $189 = $188 >>> 4;
              $190 = ($189 | 0) == 72;
              if ($190) {
               $191 = $21;
               $192 = $191;
               $193 = $192 + 8 | 0;
               $194 = $193 + 4 | 0;
               $195 = HEAP32[$194 >> 2] | 0;
               $196 = ($195 | 0) != 0;
               if ($196) {
                $197 = $21;
                $198 = $197;
                $199 = $198 + 8 | 0;
                $200 = $199 + 4 | 0;
                $201 = HEAP32[$200 >> 2] | 0;
                $202 = $201 & 3;
                $203 = ($202 | 0) == 0;
                if (!$203) {
                 break;
                }
                $204 = $21;
                $205 = $204;
                $206 = $205 + 8 | 0;
                $207 = $206 + 4 | 0;
                $208 = HEAP32[$207 >> 2] | 0;
                $209 = $208;
                $210 = $209 + 4 | 0;
                $211 = HEAP32[$210 >> 2] | 0;
                $212 = $211 & 255;
                $213 = ($212 | 0) == 47;
                if (!$213) {
                 break;
                }
                $214 = $22;
                $215 = $214 >>> 4;
                $23 = $215;
                $216 = $21;
                $217 = $216;
                $218 = $217 + 8 | 0;
                $219 = $218 + 4 | 0;
                $220 = HEAP32[$219 >> 2] | 0;
                $221 = $220;
                $222 = $221 + 8 | 0;
                $223 = HEAP32[$222 >> 2] | 0;
                $24 = $223;
                $224 = $24;
                $225 = _mp_parse_node_get_int_maybe($224, $25) | 0;
                if (!$225) {
                 $226 = _mp_obj_new_exception_msg(15892, 28699) | 0;
                 $26 = $226;
                 $227 = $26;
                 $228 = $4;
                 $229 = $228 + 24 | 0;
                 $230 = HEAP32[$229 >> 2] | 0;
                 $231 = HEAP32[$230 >> 2] | 0;
                 $232 = $21;
                 $233 = $232;
                 $234 = HEAP32[$233 >> 2] | 0;
                 _mp_obj_exception_add_traceback($227, $231, $234, 0);
                 $235 = $26;
                 _nlr_jump($235);
                }
                $236 = $4;
                $237 = $236 + 40 | 0;
                $238 = $23;
                $239 = $238 << 2;
                $240 = $239 | 2;
                $241 = $240;
                $242 = _mp_map_lookup($237, $241, 1) | 0;
                $27 = $242;
                $243 = HEAP32[$25 >> 2] | 0;
                $244 = $27;
                $245 = $244 + 4 | 0;
                HEAP32[$245 >> 2] = $243;
                $246 = $23;
                $247 = _qstr_str($246) | 0;
                $248 = HEAP8[$247 >> 0] | 0;
                $249 = $248 << 24 >> 24;
                $250 = ($249 | 0) == 95;
                $251 = $4;
                _pop_result($251) | 0;
                $252 = $4;
                if ($250) {
                 _pop_result($252) | 0;
                 $253 = $4;
                 _push_result_rule($253, 0, 8, 0);
                 $$expand_i1_val19 = 1;
                 HEAP8[$3 >> 0] = $$expand_i1_val19;
                 $$pre_trunc = HEAP8[$3 >> 0] | 0;
                 $268 = $$pre_trunc & 1;
                 STACKTOP = sp;
                 return $268 | 0;
                } else {
                 $254 = $24;
                 _push_result_node($252, $254);
                 $$expand_i1_val21 = 0;
                 HEAP8[$3 >> 0] = $$expand_i1_val21;
                 $$pre_trunc = HEAP8[$3 >> 0] | 0;
                 $268 = $$pre_trunc & 1;
                 STACKTOP = sp;
                 return $268 | 0;
                }
               }
              }
             }
            }
           }
          }
         }
        } while (0);
        $$expand_i1_val23 = 0;
        HEAP8[$3 >> 0] = $$expand_i1_val23;
        $$pre_trunc = HEAP8[$3 >> 0] | 0;
        $268 = $$pre_trunc & 1;
        STACKTOP = sp;
        return $268 | 0;
       }
      }
     }
     $74 = $4;
     $75 = $6;
     $76 = $75 - 1 | 0;
     $77 = _peek_result($74, $76) | 0;
     $12 = $77;
     $78 = $12;
     $79 = _mp_parse_node_get_int_maybe($78, $7) | 0;
     if (!$79) {
      $$expand_i1_val7 = 0;
      HEAP8[$3 >> 0] = $$expand_i1_val7;
      $$pre_trunc = HEAP8[$3 >> 0] | 0;
      $268 = $$pre_trunc & 1;
      STACKTOP = sp;
      return $268 | 0;
     }
     $80 = $6;
     $81 = $80 - 2 | 0;
     $13 = $81;
     while (1) {
      $82 = $13;
      $83 = ($82 | 0) >= 1;
      if (!$83) {
       break L1;
      }
      $84 = $4;
      $85 = $13;
      $86 = $85 - 1 | 0;
      $87 = _peek_result($84, $86) | 0;
      $12 = $87;
      $88 = $12;
      $89 = _mp_parse_node_get_int_maybe($88, $14) | 0;
      if (!$89) {
       label = 24;
       break;
      }
      $90 = $4;
      $91 = $13;
      $92 = _peek_result($90, $91) | 0;
      $93 = $92 >>> 4;
      $15 = $93;
      $94 = $15;
      $95 = $94 - 49 | 0;
      $96 = 28688 + $95 | 0;
      $97 = HEAP8[$96 >> 0] | 0;
      $98 = $97 & 255;
      $16 = $98;
      $99 = $16;
      $100 = ($99 | 0) == 255;
      if ($100) {
       label = 26;
       break;
      }
      $101 = HEAP32[$14 >> 2] | 0;
      $102 = _mp_obj_int_sign($101) | 0;
      $17 = $102;
      $103 = $16;
      $104 = $103 >>> 0 <= 25;
      if ($104) {
       $105 = $17;
       $106 = ($105 | 0) < 0;
       if ($106) {
        label = 29;
        break;
       }
      } else {
       $107 = $16;
       $108 = $107 >>> 0 >= 29;
       $109 = $17;
       $110 = ($109 | 0) == 0;
       $or$cond3 = $108 & $110;
       if ($or$cond3) {
        label = 31;
        break;
       }
      }
      $111 = $16;
      $112 = HEAP32[$7 >> 2] | 0;
      $113 = HEAP32[$14 >> 2] | 0;
      $114 = _mp_binary_op($111, $112, $113) | 0;
      HEAP32[$7 >> 2] = $114;
      $115 = $13;
      $116 = $115 - 2 | 0;
      $13 = $116;
     }
     if ((label | 0) == 24) {
      $$expand_i1_val9 = 0;
      HEAP8[$3 >> 0] = $$expand_i1_val9;
      $$pre_trunc = HEAP8[$3 >> 0] | 0;
      $268 = $$pre_trunc & 1;
      STACKTOP = sp;
      return $268 | 0;
     } else if ((label | 0) == 26) {
      $$expand_i1_val11 = 0;
      HEAP8[$3 >> 0] = $$expand_i1_val11;
      $$pre_trunc = HEAP8[$3 >> 0] | 0;
      $268 = $$pre_trunc & 1;
      STACKTOP = sp;
      return $268 | 0;
     } else if ((label | 0) == 29) {
      $$expand_i1_val13 = 0;
      HEAP8[$3 >> 0] = $$expand_i1_val13;
      $$pre_trunc = HEAP8[$3 >> 0] | 0;
      $268 = $$pre_trunc & 1;
      STACKTOP = sp;
      return $268 | 0;
     } else if ((label | 0) == 31) {
      $$expand_i1_val15 = 0;
      HEAP8[$3 >> 0] = $$expand_i1_val15;
      $$pre_trunc = HEAP8[$3 >> 0] | 0;
      $268 = $$pre_trunc & 1;
      STACKTOP = sp;
      return $268 | 0;
     }
    }
   }
  }
 } while (0);
 L78 : do {
  if ((label | 0) == 4) {
   $38 = $4;
   $39 = $6;
   $40 = $39 - 1 | 0;
   $41 = _peek_result($38, $40) | 0;
   $8 = $41;
   $42 = $8;
   $43 = _mp_parse_node_get_int_maybe($42, $7) | 0;
   if (!$43) {
    $$expand_i1_val = 0;
    HEAP8[$3 >> 0] = $$expand_i1_val;
    $$pre_trunc = HEAP8[$3 >> 0] | 0;
    $268 = $$pre_trunc & 1;
    STACKTOP = sp;
    return $268 | 0;
   }
   $44 = $5;
   $45 = $44 & 255;
   $46 = ($45 | 0) == 34;
   do {
    if ($46) {
     $9 = 21;
    } else {
     $47 = $5;
     $48 = $47 & 255;
     $49 = ($48 | 0) == 35;
     if ($49) {
      $9 = 22;
      break;
     } else {
      $9 = 23;
      break;
     }
    }
   } while (0);
   $50 = $6;
   $51 = $50 - 2 | 0;
   $10 = $51;
   while (1) {
    $52 = $10;
    $53 = ($52 | 0) >= 0;
    if (!$53) {
     break L78;
    }
    $54 = $4;
    $55 = $10;
    $56 = _peek_result($54, $55) | 0;
    $8 = $56;
    $57 = $8;
    $58 = _mp_parse_node_get_int_maybe($57, $11) | 0;
    if (!$58) {
     break;
    }
    $59 = $9;
    $60 = HEAP32[$7 >> 2] | 0;
    $61 = HEAP32[$11 >> 2] | 0;
    $62 = _mp_binary_op($59, $60, $61) | 0;
    HEAP32[$7 >> 2] = $62;
    $63 = $10;
    $64 = $63 + -1 | 0;
    $10 = $64;
   }
   $$expand_i1_val5 = 0;
   HEAP8[$3 >> 0] = $$expand_i1_val5;
   $$pre_trunc = HEAP8[$3 >> 0] | 0;
   $268 = $$pre_trunc & 1;
   STACKTOP = sp;
   return $268 | 0;
  }
 } while (0);
 $255 = $6;
 $28 = $255;
 while (1) {
  $256 = $28;
  $257 = $256 >>> 0 > 0;
  if (!$257) {
   break;
  }
  $258 = $4;
  _pop_result($258) | 0;
  $259 = $28;
  $260 = $259 + -1 | 0;
  $28 = $260;
 }
 $261 = HEAP32[$7 >> 2] | 0;
 $262 = _mp_obj_is_small_int_558($261) | 0;
 $263 = $4;
 $264 = $4;
 $265 = HEAP32[$7 >> 2] | 0;
 if ($262) {
  $266 = _mp_parse_node_new_small_int_checked($264, $265) | 0;
  _push_result_node($263, $266);
 } else {
  $267 = _make_node_const_object($264, 0, $265) | 0;
  _push_result_node($263, $267);
 }
 $$expand_i1_val27 = 1;
 HEAP8[$3 >> 0] = $$expand_i1_val27;
 $$pre_trunc = HEAP8[$3 >> 0] | 0;
 $268 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $268 | 0;
}

function _free($0) {
 $0 = $0 | 0;
 var $$0194$i = 0, $$0194$in$i = 0, $$0346381 = 0, $$0347$lcssa = 0, $$0347380 = 0, $$0359 = 0, $$0366 = 0, $$1 = 0, $$1345 = 0, $$1350 = 0, $$1350$be = 0, $$1350$ph = 0, $$1353 = 0, $$1353$be = 0, $$1353$ph = 0, $$1361 = 0, $$1361$be = 0, $$1361$ph = 0, $$1365 = 0, $$1365$be = 0, $$1365$ph = 0, $$2 = 0, $$3 = 0, $$3363 = 0, $$pre = 0, $$pre$phiZ2D = 0, $$sink = 0, $$sink395 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $cond371 = 0, $cond372 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = ($0 | 0) == (0 | 0);
 if ($1) {
  return;
 }
 $2 = $0 + -8 | 0;
 $3 = HEAP32[41056 >> 2] | 0;
 $4 = $0 + -4 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 $6 = $5 & -8;
 $7 = $2 + $6 | 0;
 $8 = $5 & 1;
 $9 = ($8 | 0) == 0;
 do {
  if ($9) {
   $10 = HEAP32[$2 >> 2] | 0;
   $11 = $5 & 3;
   $12 = ($11 | 0) == 0;
   if ($12) {
    return;
   }
   $13 = 0 - $10 | 0;
   $14 = $2 + $13 | 0;
   $15 = $10 + $6 | 0;
   $16 = $14 >>> 0 < $3 >>> 0;
   if ($16) {
    return;
   }
   $17 = HEAP32[41060 >> 2] | 0;
   $18 = ($17 | 0) == ($14 | 0);
   if ($18) {
    $79 = $7 + 4 | 0;
    $80 = HEAP32[$79 >> 2] | 0;
    $81 = $80 & 3;
    $82 = ($81 | 0) == 3;
    if (!$82) {
     $$1 = $14;
     $$1345 = $15;
     $87 = $14;
     break;
    }
    $83 = $14 + $15 | 0;
    $84 = $14 + 4 | 0;
    $85 = $15 | 1;
    $86 = $80 & -2;
    HEAP32[41048 >> 2] = $15;
    HEAP32[$79 >> 2] = $86;
    HEAP32[$84 >> 2] = $85;
    HEAP32[$83 >> 2] = $15;
    return;
   }
   $19 = $10 >>> 3;
   $20 = $10 >>> 0 < 256;
   if ($20) {
    $21 = $14 + 8 | 0;
    $22 = HEAP32[$21 >> 2] | 0;
    $23 = $14 + 12 | 0;
    $24 = HEAP32[$23 >> 2] | 0;
    $25 = ($24 | 0) == ($22 | 0);
    if ($25) {
     $26 = 1 << $19;
     $27 = $26 ^ -1;
     $28 = HEAP32[10260] | 0;
     $29 = $28 & $27;
     HEAP32[10260] = $29;
     $$1 = $14;
     $$1345 = $15;
     $87 = $14;
     break;
    } else {
     $30 = $22 + 12 | 0;
     HEAP32[$30 >> 2] = $24;
     $31 = $24 + 8 | 0;
     HEAP32[$31 >> 2] = $22;
     $$1 = $14;
     $$1345 = $15;
     $87 = $14;
     break;
    }
   }
   $32 = $14 + 24 | 0;
   $33 = HEAP32[$32 >> 2] | 0;
   $34 = $14 + 12 | 0;
   $35 = HEAP32[$34 >> 2] | 0;
   $36 = ($35 | 0) == ($14 | 0);
   do {
    if ($36) {
     $41 = $14 + 16 | 0;
     $42 = $41 + 4 | 0;
     $43 = HEAP32[$42 >> 2] | 0;
     $44 = ($43 | 0) == (0 | 0);
     if ($44) {
      $45 = HEAP32[$41 >> 2] | 0;
      $46 = ($45 | 0) == (0 | 0);
      if ($46) {
       $$3 = 0;
       break;
      } else {
       $$1350$ph = $45;
       $$1353$ph = $41;
      }
     } else {
      $$1350$ph = $43;
      $$1353$ph = $42;
     }
     $$1350 = $$1350$ph;
     $$1353 = $$1353$ph;
     while (1) {
      $47 = $$1350 + 20 | 0;
      $48 = HEAP32[$47 >> 2] | 0;
      $49 = ($48 | 0) == (0 | 0);
      if ($49) {
       $50 = $$1350 + 16 | 0;
       $51 = HEAP32[$50 >> 2] | 0;
       $52 = ($51 | 0) == (0 | 0);
       if ($52) {
        break;
       } else {
        $$1350$be = $51;
        $$1353$be = $50;
       }
      } else {
       $$1350$be = $48;
       $$1353$be = $47;
      }
      $$1350 = $$1350$be;
      $$1353 = $$1353$be;
     }
     HEAP32[$$1353 >> 2] = 0;
     $$3 = $$1350;
    } else {
     $37 = $14 + 8 | 0;
     $38 = HEAP32[$37 >> 2] | 0;
     $39 = $38 + 12 | 0;
     HEAP32[$39 >> 2] = $35;
     $40 = $35 + 8 | 0;
     HEAP32[$40 >> 2] = $38;
     $$3 = $35;
    }
   } while (0);
   $53 = ($33 | 0) == (0 | 0);
   if ($53) {
    $$1 = $14;
    $$1345 = $15;
    $87 = $14;
   } else {
    $54 = $14 + 28 | 0;
    $55 = HEAP32[$54 >> 2] | 0;
    $56 = 41344 + ($55 << 2) | 0;
    $57 = HEAP32[$56 >> 2] | 0;
    $58 = ($57 | 0) == ($14 | 0);
    if ($58) {
     HEAP32[$56 >> 2] = $$3;
     $cond371 = ($$3 | 0) == (0 | 0);
     if ($cond371) {
      $59 = 1 << $55;
      $60 = $59 ^ -1;
      $61 = HEAP32[41044 >> 2] | 0;
      $62 = $61 & $60;
      HEAP32[41044 >> 2] = $62;
      $$1 = $14;
      $$1345 = $15;
      $87 = $14;
      break;
     }
    } else {
     $63 = $33 + 16 | 0;
     $64 = HEAP32[$63 >> 2] | 0;
     $65 = ($64 | 0) == ($14 | 0);
     $66 = $33 + 20 | 0;
     $$sink = $65 ? $63 : $66;
     HEAP32[$$sink >> 2] = $$3;
     $67 = ($$3 | 0) == (0 | 0);
     if ($67) {
      $$1 = $14;
      $$1345 = $15;
      $87 = $14;
      break;
     }
    }
    $68 = $$3 + 24 | 0;
    HEAP32[$68 >> 2] = $33;
    $69 = $14 + 16 | 0;
    $70 = HEAP32[$69 >> 2] | 0;
    $71 = ($70 | 0) == (0 | 0);
    if (!$71) {
     $72 = $$3 + 16 | 0;
     HEAP32[$72 >> 2] = $70;
     $73 = $70 + 24 | 0;
     HEAP32[$73 >> 2] = $$3;
    }
    $74 = $69 + 4 | 0;
    $75 = HEAP32[$74 >> 2] | 0;
    $76 = ($75 | 0) == (0 | 0);
    if ($76) {
     $$1 = $14;
     $$1345 = $15;
     $87 = $14;
    } else {
     $77 = $$3 + 20 | 0;
     HEAP32[$77 >> 2] = $75;
     $78 = $75 + 24 | 0;
     HEAP32[$78 >> 2] = $$3;
     $$1 = $14;
     $$1345 = $15;
     $87 = $14;
    }
   }
  } else {
   $$1 = $2;
   $$1345 = $6;
   $87 = $2;
  }
 } while (0);
 $88 = $87 >>> 0 < $7 >>> 0;
 if (!$88) {
  return;
 }
 $89 = $7 + 4 | 0;
 $90 = HEAP32[$89 >> 2] | 0;
 $91 = $90 & 1;
 $92 = ($91 | 0) == 0;
 if ($92) {
  return;
 }
 $93 = $90 & 2;
 $94 = ($93 | 0) == 0;
 if ($94) {
  $95 = HEAP32[41064 >> 2] | 0;
  $96 = ($95 | 0) == ($7 | 0);
  if ($96) {
   $97 = HEAP32[41052 >> 2] | 0;
   $98 = $97 + $$1345 | 0;
   HEAP32[41052 >> 2] = $98;
   HEAP32[41064 >> 2] = $$1;
   $99 = $98 | 1;
   $100 = $$1 + 4 | 0;
   HEAP32[$100 >> 2] = $99;
   $101 = HEAP32[41060 >> 2] | 0;
   $102 = ($$1 | 0) == ($101 | 0);
   if (!$102) {
    return;
   }
   HEAP32[41060 >> 2] = 0;
   HEAP32[41048 >> 2] = 0;
   return;
  }
  $103 = HEAP32[41060 >> 2] | 0;
  $104 = ($103 | 0) == ($7 | 0);
  if ($104) {
   $105 = HEAP32[41048 >> 2] | 0;
   $106 = $105 + $$1345 | 0;
   HEAP32[41048 >> 2] = $106;
   HEAP32[41060 >> 2] = $87;
   $107 = $106 | 1;
   $108 = $$1 + 4 | 0;
   HEAP32[$108 >> 2] = $107;
   $109 = $87 + $106 | 0;
   HEAP32[$109 >> 2] = $106;
   return;
  }
  $110 = $90 & -8;
  $111 = $110 + $$1345 | 0;
  $112 = $90 >>> 3;
  $113 = $90 >>> 0 < 256;
  do {
   if ($113) {
    $114 = $7 + 8 | 0;
    $115 = HEAP32[$114 >> 2] | 0;
    $116 = $7 + 12 | 0;
    $117 = HEAP32[$116 >> 2] | 0;
    $118 = ($117 | 0) == ($115 | 0);
    if ($118) {
     $119 = 1 << $112;
     $120 = $119 ^ -1;
     $121 = HEAP32[10260] | 0;
     $122 = $121 & $120;
     HEAP32[10260] = $122;
     break;
    } else {
     $123 = $115 + 12 | 0;
     HEAP32[$123 >> 2] = $117;
     $124 = $117 + 8 | 0;
     HEAP32[$124 >> 2] = $115;
     break;
    }
   } else {
    $125 = $7 + 24 | 0;
    $126 = HEAP32[$125 >> 2] | 0;
    $127 = $7 + 12 | 0;
    $128 = HEAP32[$127 >> 2] | 0;
    $129 = ($128 | 0) == ($7 | 0);
    do {
     if ($129) {
      $134 = $7 + 16 | 0;
      $135 = $134 + 4 | 0;
      $136 = HEAP32[$135 >> 2] | 0;
      $137 = ($136 | 0) == (0 | 0);
      if ($137) {
       $138 = HEAP32[$134 >> 2] | 0;
       $139 = ($138 | 0) == (0 | 0);
       if ($139) {
        $$3363 = 0;
        break;
       } else {
        $$1361$ph = $138;
        $$1365$ph = $134;
       }
      } else {
       $$1361$ph = $136;
       $$1365$ph = $135;
      }
      $$1361 = $$1361$ph;
      $$1365 = $$1365$ph;
      while (1) {
       $140 = $$1361 + 20 | 0;
       $141 = HEAP32[$140 >> 2] | 0;
       $142 = ($141 | 0) == (0 | 0);
       if ($142) {
        $143 = $$1361 + 16 | 0;
        $144 = HEAP32[$143 >> 2] | 0;
        $145 = ($144 | 0) == (0 | 0);
        if ($145) {
         break;
        } else {
         $$1361$be = $144;
         $$1365$be = $143;
        }
       } else {
        $$1361$be = $141;
        $$1365$be = $140;
       }
       $$1361 = $$1361$be;
       $$1365 = $$1365$be;
      }
      HEAP32[$$1365 >> 2] = 0;
      $$3363 = $$1361;
     } else {
      $130 = $7 + 8 | 0;
      $131 = HEAP32[$130 >> 2] | 0;
      $132 = $131 + 12 | 0;
      HEAP32[$132 >> 2] = $128;
      $133 = $128 + 8 | 0;
      HEAP32[$133 >> 2] = $131;
      $$3363 = $128;
     }
    } while (0);
    $146 = ($126 | 0) == (0 | 0);
    if (!$146) {
     $147 = $7 + 28 | 0;
     $148 = HEAP32[$147 >> 2] | 0;
     $149 = 41344 + ($148 << 2) | 0;
     $150 = HEAP32[$149 >> 2] | 0;
     $151 = ($150 | 0) == ($7 | 0);
     if ($151) {
      HEAP32[$149 >> 2] = $$3363;
      $cond372 = ($$3363 | 0) == (0 | 0);
      if ($cond372) {
       $152 = 1 << $148;
       $153 = $152 ^ -1;
       $154 = HEAP32[41044 >> 2] | 0;
       $155 = $154 & $153;
       HEAP32[41044 >> 2] = $155;
       break;
      }
     } else {
      $156 = $126 + 16 | 0;
      $157 = HEAP32[$156 >> 2] | 0;
      $158 = ($157 | 0) == ($7 | 0);
      $159 = $126 + 20 | 0;
      $$sink395 = $158 ? $156 : $159;
      HEAP32[$$sink395 >> 2] = $$3363;
      $160 = ($$3363 | 0) == (0 | 0);
      if ($160) {
       break;
      }
     }
     $161 = $$3363 + 24 | 0;
     HEAP32[$161 >> 2] = $126;
     $162 = $7 + 16 | 0;
     $163 = HEAP32[$162 >> 2] | 0;
     $164 = ($163 | 0) == (0 | 0);
     if (!$164) {
      $165 = $$3363 + 16 | 0;
      HEAP32[$165 >> 2] = $163;
      $166 = $163 + 24 | 0;
      HEAP32[$166 >> 2] = $$3363;
     }
     $167 = $162 + 4 | 0;
     $168 = HEAP32[$167 >> 2] | 0;
     $169 = ($168 | 0) == (0 | 0);
     if (!$169) {
      $170 = $$3363 + 20 | 0;
      HEAP32[$170 >> 2] = $168;
      $171 = $168 + 24 | 0;
      HEAP32[$171 >> 2] = $$3363;
     }
    }
   }
  } while (0);
  $172 = $111 | 1;
  $173 = $$1 + 4 | 0;
  HEAP32[$173 >> 2] = $172;
  $174 = $87 + $111 | 0;
  HEAP32[$174 >> 2] = $111;
  $175 = HEAP32[41060 >> 2] | 0;
  $176 = ($$1 | 0) == ($175 | 0);
  if ($176) {
   HEAP32[41048 >> 2] = $111;
   return;
  } else {
   $$2 = $111;
  }
 } else {
  $177 = $90 & -2;
  HEAP32[$89 >> 2] = $177;
  $178 = $$1345 | 1;
  $179 = $$1 + 4 | 0;
  HEAP32[$179 >> 2] = $178;
  $180 = $87 + $$1345 | 0;
  HEAP32[$180 >> 2] = $$1345;
  $$2 = $$1345;
 }
 $181 = $$2 >>> 3;
 $182 = $$2 >>> 0 < 256;
 if ($182) {
  $183 = $181 << 1;
  $184 = 41080 + ($183 << 2) | 0;
  $185 = HEAP32[10260] | 0;
  $186 = 1 << $181;
  $187 = $185 & $186;
  $188 = ($187 | 0) == 0;
  if ($188) {
   $189 = $185 | $186;
   HEAP32[10260] = $189;
   $$pre = $184 + 8 | 0;
   $$0366 = $184;
   $$pre$phiZ2D = $$pre;
  } else {
   $190 = $184 + 8 | 0;
   $191 = HEAP32[$190 >> 2] | 0;
   $$0366 = $191;
   $$pre$phiZ2D = $190;
  }
  HEAP32[$$pre$phiZ2D >> 2] = $$1;
  $192 = $$0366 + 12 | 0;
  HEAP32[$192 >> 2] = $$1;
  $193 = $$1 + 8 | 0;
  HEAP32[$193 >> 2] = $$0366;
  $194 = $$1 + 12 | 0;
  HEAP32[$194 >> 2] = $184;
  return;
 }
 $195 = $$2 >>> 8;
 $196 = ($195 | 0) == 0;
 if ($196) {
  $$0359 = 0;
 } else {
  $197 = $$2 >>> 0 > 16777215;
  if ($197) {
   $$0359 = 31;
  } else {
   $198 = $195 + 1048320 | 0;
   $199 = $198 >>> 16;
   $200 = $199 & 8;
   $201 = $195 << $200;
   $202 = $201 + 520192 | 0;
   $203 = $202 >>> 16;
   $204 = $203 & 4;
   $205 = $204 | $200;
   $206 = $201 << $204;
   $207 = $206 + 245760 | 0;
   $208 = $207 >>> 16;
   $209 = $208 & 2;
   $210 = $205 | $209;
   $211 = 14 - $210 | 0;
   $212 = $206 << $209;
   $213 = $212 >>> 15;
   $214 = $211 + $213 | 0;
   $215 = $214 << 1;
   $216 = $214 + 7 | 0;
   $217 = $$2 >>> $216;
   $218 = $217 & 1;
   $219 = $218 | $215;
   $$0359 = $219;
  }
 }
 $220 = 41344 + ($$0359 << 2) | 0;
 $221 = $$1 + 28 | 0;
 HEAP32[$221 >> 2] = $$0359;
 $222 = $$1 + 16 | 0;
 $223 = $$1 + 20 | 0;
 HEAP32[$223 >> 2] = 0;
 HEAP32[$222 >> 2] = 0;
 $224 = HEAP32[41044 >> 2] | 0;
 $225 = 1 << $$0359;
 $226 = $224 & $225;
 $227 = ($226 | 0) == 0;
 L112 : do {
  if ($227) {
   $228 = $224 | $225;
   HEAP32[41044 >> 2] = $228;
   HEAP32[$220 >> 2] = $$1;
   $229 = $$1 + 24 | 0;
   HEAP32[$229 >> 2] = $220;
   $230 = $$1 + 12 | 0;
   HEAP32[$230 >> 2] = $$1;
   $231 = $$1 + 8 | 0;
   HEAP32[$231 >> 2] = $$1;
  } else {
   $232 = HEAP32[$220 >> 2] | 0;
   $233 = $232 + 4 | 0;
   $234 = HEAP32[$233 >> 2] | 0;
   $235 = $234 & -8;
   $236 = ($235 | 0) == ($$2 | 0);
   L115 : do {
    if ($236) {
     $$0347$lcssa = $232;
    } else {
     $237 = ($$0359 | 0) == 31;
     $238 = $$0359 >>> 1;
     $239 = 25 - $238 | 0;
     $240 = $237 ? 0 : $239;
     $241 = $$2 << $240;
     $$0346381 = $241;
     $$0347380 = $232;
     while (1) {
      $248 = $$0346381 >>> 31;
      $249 = ($$0347380 + 16 | 0) + ($248 << 2) | 0;
      $244 = HEAP32[$249 >> 2] | 0;
      $250 = ($244 | 0) == (0 | 0);
      if ($250) {
       break;
      }
      $242 = $$0346381 << 1;
      $243 = $244 + 4 | 0;
      $245 = HEAP32[$243 >> 2] | 0;
      $246 = $245 & -8;
      $247 = ($246 | 0) == ($$2 | 0);
      if ($247) {
       $$0347$lcssa = $244;
       break L115;
      } else {
       $$0346381 = $242;
       $$0347380 = $244;
      }
     }
     HEAP32[$249 >> 2] = $$1;
     $251 = $$1 + 24 | 0;
     HEAP32[$251 >> 2] = $$0347380;
     $252 = $$1 + 12 | 0;
     HEAP32[$252 >> 2] = $$1;
     $253 = $$1 + 8 | 0;
     HEAP32[$253 >> 2] = $$1;
     break L112;
    }
   } while (0);
   $254 = $$0347$lcssa + 8 | 0;
   $255 = HEAP32[$254 >> 2] | 0;
   $256 = $255 + 12 | 0;
   HEAP32[$256 >> 2] = $$1;
   HEAP32[$254 >> 2] = $$1;
   $257 = $$1 + 8 | 0;
   HEAP32[$257 >> 2] = $255;
   $258 = $$1 + 12 | 0;
   HEAP32[$258 >> 2] = $$0347$lcssa;
   $259 = $$1 + 24 | 0;
   HEAP32[$259 >> 2] = 0;
  }
 } while (0);
 $260 = HEAP32[41072 >> 2] | 0;
 $261 = $260 + -1 | 0;
 HEAP32[41072 >> 2] = $261;
 $262 = ($261 | 0) == 0;
 if (!$262) {
  return;
 }
 $$0194$in$i = 41496;
 while (1) {
  $$0194$i = HEAP32[$$0194$in$i >> 2] | 0;
  $263 = ($$0194$i | 0) == (0 | 0);
  $264 = $$0194$i + 8 | 0;
  if ($263) {
   break;
  } else {
   $$0194$in$i = $264;
  }
 }
 HEAP32[41072 >> 2] = -1;
 return;
}

function _mp_setup_code_state($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $335 = 0, $336 = 0, $337 = 0, $338 = 0, $339 = 0, $34 = 0, $340 = 0, $341 = 0, $342 = 0, $343 = 0, $344 = 0, $345 = 0, $346 = 0, $347 = 0, $348 = 0, $349 = 0, $35 = 0, $350 = 0, $351 = 0, $352 = 0, $353 = 0, $354 = 0, $355 = 0, $356 = 0, $357 = 0, $358 = 0, $359 = 0, $36 = 0, $360 = 0, $361 = 0, $362 = 0, $363 = 0, $364 = 0, $365 = 0, $366 = 0, $367 = 0, $368 = 0, $369 = 0, $37 = 0, $370 = 0, $371 = 0, $372 = 0, $373 = 0, $374 = 0, $375 = 0, $376 = 0, $377 = 0, $378 = 0, $379 = 0, $38 = 0, $380 = 0, $381 = 0, $382 = 0, $383 = 0, $384 = 0, $385 = 0, $386 = 0, $387 = 0, $388 = 0, $389 = 0, $39 = 0, $390 = 0, $391 = 0, $392 = 0, $393 = 0, $394 = 0, $395 = 0, $396 = 0, $397 = 0, $398 = 0, $399 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(144 | 0);
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $30 = $4;
 $31 = HEAP32[$30 >> 2] | 0;
 $8 = $31;
 $32 = $8;
 $33 = $32 + 8 | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = $4;
 $36 = $35 + 4 | 0;
 $37 = HEAP32[$36 >> 2] | 0;
 $38 = $37;
 $39 = $34 + $38 | 0;
 $40 = $4;
 $41 = $40 + 4 | 0;
 HEAP32[$41 >> 2] = $39;
 $42 = $4;
 $43 = $42 + 4 | 0;
 $44 = _mp_decode_uint($43) | 0;
 $9 = $44;
 $45 = $4;
 $46 = $45 + 4 | 0;
 $47 = HEAP32[$46 >> 2] | 0;
 $48 = _mp_decode_uint_skip($47) | 0;
 $49 = $4;
 $50 = $49 + 4 | 0;
 HEAP32[$50 >> 2] = $48;
 $51 = $4;
 $52 = $51 + 4 | 0;
 $53 = HEAP32[$52 >> 2] | 0;
 $54 = $53 + 1 | 0;
 HEAP32[$52 >> 2] = $54;
 $55 = HEAP8[$53 >> 0] | 0;
 $56 = $55 & 255;
 $10 = $56;
 $57 = $4;
 $58 = $57 + 4 | 0;
 $59 = HEAP32[$58 >> 2] | 0;
 $60 = $59 + 1 | 0;
 HEAP32[$58 >> 2] = $60;
 $61 = HEAP8[$59 >> 0] | 0;
 $62 = $61 & 255;
 $11 = $62;
 $63 = $4;
 $64 = $63 + 4 | 0;
 $65 = HEAP32[$64 >> 2] | 0;
 $66 = $65 + 1 | 0;
 HEAP32[$64 >> 2] = $66;
 $67 = HEAP8[$65 >> 0] | 0;
 $68 = $67 & 255;
 $12 = $68;
 $69 = $4;
 $70 = $69 + 4 | 0;
 $71 = HEAP32[$70 >> 2] | 0;
 $72 = $71 + 1 | 0;
 HEAP32[$70 >> 2] = $72;
 $73 = HEAP8[$71 >> 0] | 0;
 $74 = $73 & 255;
 $13 = $74;
 $75 = $4;
 $76 = $75 + 20 | 0;
 $77 = $76 + -4 | 0;
 $78 = $4;
 $79 = $78 + 8 | 0;
 HEAP32[$79 >> 2] = $77;
 $80 = $4;
 $81 = $80 + 20 | 0;
 $82 = $9;
 $83 = $81 + ($82 << 2) | 0;
 $84 = $83 + -12 | 0;
 $85 = $4;
 $86 = $85 + 12 | 0;
 HEAP32[$86 >> 2] = $84;
 $87 = $4;
 $88 = $87 + 20 | 0;
 $89 = $9;
 $90 = $89 << 2;
 _memset($88 | 0, 0, $90 | 0) | 0;
 $91 = $7;
 $92 = $5;
 $93 = $91 + ($92 << 2) | 0;
 $14 = $93;
 $94 = $4;
 $95 = $94 + 20 | 0;
 $96 = $9;
 $97 = $96 - 1 | 0;
 $98 = $11;
 $99 = $97 - $98 | 0;
 $100 = $12;
 $101 = $99 - $100 | 0;
 $102 = $95 + ($101 << 2) | 0;
 $15 = $102;
 $103 = $5;
 $104 = $11;
 $105 = $103 >>> 0 > $104 >>> 0;
 $106 = $10;
 $107 = $106 & 1;
 L1 : do {
  if ($105) {
   $108 = ($107 | 0) == 0;
   if ($108) {
    $109 = $8;
    $110 = $11;
    $111 = $5;
    _fun_pos_args_mismatch($109, $110, $111);
   } else {
    $112 = $5;
    $113 = $11;
    $114 = $112 - $113 | 0;
    $115 = $7;
    $116 = $11;
    $117 = $115 + ($116 << 2) | 0;
    $118 = _mp_obj_new_tuple($114, $117) | 0;
    $119 = $15;
    $120 = $119 + -4 | 0;
    $15 = $120;
    HEAP32[$119 >> 2] = $118;
    $121 = $11;
    $5 = $121;
    break;
   }
  } else {
   $122 = ($107 | 0) != 0;
   if ($122) {
    $123 = $15;
    $124 = $123 + -4 | 0;
    $15 = $124;
    HEAP32[$123 >> 2] = 18944;
   }
   $125 = $6;
   $126 = ($125 | 0) == 0;
   if ($126) {
    $127 = $10;
    $128 = $127 & 8;
    $129 = ($128 | 0) == 0;
    if ($129) {
     $130 = $5;
     $131 = $11;
     $132 = $13;
     $133 = $131 - $132 | 0;
     $134 = $130 >>> 0 >= $133 >>> 0;
     if (!$134) {
      $157 = $8;
      $158 = $11;
      $159 = $13;
      $160 = $158 - $159 | 0;
      $161 = $5;
      _fun_pos_args_mismatch($157, $160, $161);
     }
     $135 = $5;
     $16 = $135;
     while (1) {
      $136 = $16;
      $137 = $11;
      $138 = $136 >>> 0 < $137 >>> 0;
      if (!$138) {
       break L1;
      }
      $139 = $8;
      $140 = $139 + 16 | 0;
      $141 = $16;
      $142 = $11;
      $143 = $13;
      $144 = $142 - $143 | 0;
      $145 = $141 - $144 | 0;
      $146 = $140 + ($145 << 2) | 0;
      $147 = HEAP32[$146 >> 2] | 0;
      $148 = $4;
      $149 = $148 + 20 | 0;
      $150 = $9;
      $151 = $150 - 1 | 0;
      $152 = $16;
      $153 = $151 - $152 | 0;
      $154 = $149 + ($153 << 2) | 0;
      HEAP32[$154 >> 2] = $147;
      $155 = $16;
      $156 = $155 + 1 | 0;
      $16 = $156;
     }
    }
   }
  }
 } while (0);
 $17 = 0;
 while (1) {
  $162 = $17;
  $163 = $5;
  $164 = $162 >>> 0 < $163 >>> 0;
  if (!$164) {
   break;
  }
  $165 = $7;
  $166 = $17;
  $167 = $165 + ($166 << 2) | 0;
  $168 = HEAP32[$167 >> 2] | 0;
  $169 = $4;
  $170 = $169 + 20 | 0;
  $171 = $9;
  $172 = $171 - 1 | 0;
  $173 = $17;
  $174 = $172 - $173 | 0;
  $175 = $170 + ($174 << 2) | 0;
  HEAP32[$175 >> 2] = $168;
  $176 = $17;
  $177 = $176 + 1 | 0;
  $17 = $177;
 }
 $178 = $6;
 $179 = ($178 | 0) != 0;
 if ($179) {
  label = 19;
 } else {
  $180 = $10;
  $181 = $180 & 8;
  $182 = ($181 | 0) != 0;
  if ($182) {
   label = 19;
  } else {
   $362 = $12;
   $363 = ($362 | 0) != 0;
   if ($363) {
    _mp_raise_TypeError(34309);
   }
   $364 = $10;
   $365 = $364 & 2;
   $366 = ($365 | 0) != 0;
   if ($366) {
    $367 = _mp_obj_new_dict(0) | 0;
    $368 = $15;
    HEAP32[$368 >> 2] = $367;
   }
  }
 }
 L30 : do {
  if ((label | 0) == 19) {
   $18 = 0;
   $183 = $10;
   $184 = $183 & 2;
   $185 = ($184 | 0) != 0;
   if ($185) {
    $186 = $6;
    $187 = _mp_obj_new_dict($186) | 0;
    $18 = $187;
    $188 = $18;
    $189 = $15;
    HEAP32[$189 >> 2] = $188;
   }
   $190 = $8;
   $191 = $190 + 12 | 0;
   $192 = HEAP32[$191 >> 2] | 0;
   $19 = $192;
   $20 = 0;
   while (1) {
    $193 = $20;
    $194 = $6;
    $195 = $193 >>> 0 < $194 >>> 0;
    if (!$195) {
     label = 34;
     break;
    }
    $196 = $14;
    $197 = $20;
    $198 = $197 << 1;
    $199 = $196 + ($198 << 2) | 0;
    $200 = HEAP32[$199 >> 2] | 0;
    $21 = $200;
    $22 = 0;
    while (1) {
     $201 = $22;
     $202 = $11;
     $203 = $12;
     $204 = $202 + $203 | 0;
     $205 = $201 >>> 0 < $204 >>> 0;
     if (!$205) {
      label = 30;
      break;
     }
     $206 = $21;
     $207 = $19;
     $208 = $22;
     $209 = $207 + ($208 << 2) | 0;
     $210 = HEAP32[$209 >> 2] | 0;
     $211 = ($206 | 0) == ($210 | 0);
     if ($211) {
      label = 26;
      break;
     }
     $238 = $22;
     $239 = $238 + 1 | 0;
     $22 = $239;
    }
    if ((label | 0) == 26) {
     label = 0;
     $212 = $4;
     $213 = $212 + 20 | 0;
     $214 = $9;
     $215 = $214 - 1 | 0;
     $216 = $22;
     $217 = $215 - $216 | 0;
     $218 = $213 + ($217 << 2) | 0;
     $219 = HEAP32[$218 >> 2] | 0;
     $220 = ($219 | 0) != (0 | 0);
     if ($220) {
      label = 27;
      break;
     }
     $225 = $14;
     $226 = $20;
     $227 = $226 << 1;
     $228 = $227 + 1 | 0;
     $229 = $225 + ($228 << 2) | 0;
     $230 = HEAP32[$229 >> 2] | 0;
     $231 = $4;
     $232 = $231 + 20 | 0;
     $233 = $9;
     $234 = $233 - 1 | 0;
     $235 = $22;
     $236 = $234 - $235 | 0;
     $237 = $232 + ($236 << 2) | 0;
     HEAP32[$237 >> 2] = $230;
    } else if ((label | 0) == 30) {
     label = 0;
     $240 = $10;
     $241 = $240 & 2;
     $242 = ($241 | 0) == 0;
     if ($242) {
      label = 31;
      break;
     }
     $247 = $18;
     $248 = $14;
     $249 = $20;
     $250 = $249 << 1;
     $251 = $248 + ($250 << 2) | 0;
     $252 = HEAP32[$251 >> 2] | 0;
     $253 = $14;
     $254 = $20;
     $255 = $254 << 1;
     $256 = $255 + 1 | 0;
     $257 = $253 + ($256 << 2) | 0;
     $258 = HEAP32[$257 >> 2] | 0;
     _mp_obj_dict_store($247, $252, $258) | 0;
    }
    $259 = $20;
    $260 = $259 + 1 | 0;
    $20 = $260;
   }
   if ((label | 0) == 27) {
    $221 = $21;
    $222 = $221;
    $223 = $222 >>> 2;
    HEAP32[$vararg_buffer >> 2] = $223;
    $224 = _mp_obj_new_exception_msg_varg(16012, 34131, $vararg_buffer) | 0;
    _nlr_jump($224);
   } else if ((label | 0) == 31) {
    $243 = $21;
    $244 = $243;
    $245 = $244 >>> 2;
    HEAP32[$vararg_buffer1 >> 2] = $245;
    $246 = _mp_obj_new_exception_msg_varg(16012, 34178, $vararg_buffer1) | 0;
    _nlr_jump($246);
   } else if ((label | 0) == 34) {
    $261 = $4;
    $262 = $261 + 20 | 0;
    $263 = $9;
    $264 = $11;
    $265 = $263 - $264 | 0;
    $266 = $262 + ($265 << 2) | 0;
    $23 = $266;
    $267 = $8;
    $268 = $267 + 16 | 0;
    $269 = $13;
    $270 = $269 - 1 | 0;
    $271 = $268 + ($270 << 2) | 0;
    $24 = $271;
    $272 = $13;
    $25 = $272;
    while (1) {
     $273 = $25;
     $274 = $273 >>> 0 > 0;
     if (!$274) {
      break;
     }
     $275 = $23;
     $276 = HEAP32[$275 >> 2] | 0;
     $277 = ($276 | 0) == (0 | 0);
     if ($277) {
      $278 = $24;
      $279 = HEAP32[$278 >> 2] | 0;
      $280 = $23;
      HEAP32[$280 >> 2] = $279;
     }
     $281 = $25;
     $282 = $281 + -1 | 0;
     $25 = $282;
     $283 = $23;
     $284 = $283 + 4 | 0;
     $23 = $284;
     $285 = $24;
     $286 = $285 + -4 | 0;
     $24 = $286;
    }
    while (1) {
     $287 = $23;
     $288 = $4;
     $289 = $288 + 20 | 0;
     $290 = $9;
     $291 = $289 + ($290 << 2) | 0;
     $292 = $287 >>> 0 < $291 >>> 0;
     if (!$292) {
      break;
     }
     $293 = $23;
     $294 = $293 + 4 | 0;
     $23 = $294;
     $295 = HEAP32[$293 >> 2] | 0;
     $296 = ($295 | 0) == (0 | 0);
     if ($296) {
      label = 42;
      break;
     }
    }
    if ((label | 0) == 42) {
     $297 = $4;
     $298 = $297 + 20 | 0;
     $299 = $9;
     $300 = $298 + ($299 << 2) | 0;
     $301 = $23;
     $302 = $300;
     $303 = $301;
     $304 = $302 - $303 | 0;
     $305 = ($304 | 0) / 4 & -1;
     HEAP32[$vararg_buffer4 >> 2] = $305;
     $306 = _mp_obj_new_exception_msg_varg(16012, 34211, $vararg_buffer4) | 0;
     _nlr_jump($306);
    }
    $26 = 0;
    while (1) {
     $307 = $26;
     $308 = $12;
     $309 = $307 >>> 0 < $308 >>> 0;
     if (!$309) {
      break L30;
     }
     $310 = $4;
     $311 = $310 + 20 | 0;
     $312 = $9;
     $313 = $312 - 1 | 0;
     $314 = $11;
     $315 = $313 - $314 | 0;
     $316 = $26;
     $317 = $315 - $316 | 0;
     $318 = $311 + ($317 << 2) | 0;
     $319 = HEAP32[$318 >> 2] | 0;
     $320 = ($319 | 0) == (0 | 0);
     if ($320) {
      $27 = 0;
      $321 = $10;
      $322 = $321 & 8;
      $323 = ($322 | 0) != 0;
      if ($323) {
       $324 = $8;
       $325 = $324 + 16 | 0;
       $326 = $13;
       $327 = $325 + ($326 << 2) | 0;
       $328 = HEAP32[$327 >> 2] | 0;
       $329 = $328 + 4 | 0;
       $330 = $19;
       $331 = $11;
       $332 = $26;
       $333 = $331 + $332 | 0;
       $334 = $330 + ($333 << 2) | 0;
       $335 = HEAP32[$334 >> 2] | 0;
       $336 = _mp_map_lookup($329, $335, 0) | 0;
       $27 = $336;
      }
      $337 = $27;
      $338 = ($337 | 0) != (0 | 0);
      if (!$338) {
       break;
      }
      $339 = $27;
      $340 = $339 + 4 | 0;
      $341 = HEAP32[$340 >> 2] | 0;
      $342 = $4;
      $343 = $342 + 20 | 0;
      $344 = $9;
      $345 = $344 - 1 | 0;
      $346 = $11;
      $347 = $345 - $346 | 0;
      $348 = $26;
      $349 = $347 - $348 | 0;
      $350 = $343 + ($349 << 2) | 0;
      HEAP32[$350 >> 2] = $341;
     }
     $360 = $26;
     $361 = $360 + 1 | 0;
     $26 = $361;
    }
    $351 = $19;
    $352 = $11;
    $353 = $26;
    $354 = $352 + $353 | 0;
    $355 = $351 + ($354 << 2) | 0;
    $356 = HEAP32[$355 >> 2] | 0;
    $357 = $356;
    $358 = $357 >>> 2;
    HEAP32[$vararg_buffer7 >> 2] = $358;
    $359 = _mp_obj_new_exception_msg_varg(16012, 34261, $vararg_buffer7) | 0;
    _nlr_jump($359);
   }
  }
 } while (0);
 $369 = $4;
 $370 = $369 + 4 | 0;
 $371 = HEAP32[$370 >> 2] | 0;
 $28 = $371;
 $372 = $28;
 $373 = _mp_decode_uint_value($372) | 0;
 $374 = $28;
 $375 = $374 + $373 | 0;
 $28 = $375;
 while (1) {
  $376 = $28;
  $377 = $376 + 1 | 0;
  $28 = $377;
  $378 = HEAP8[$376 >> 0] | 0;
  $379 = $378 & 255;
  $29 = $379;
  $380 = ($379 | 0) != 255;
  if (!$380) {
   break;
  }
  $381 = $4;
  $382 = $381 + 20 | 0;
  $383 = $9;
  $384 = $383 - 1 | 0;
  $385 = $29;
  $386 = $384 - $385 | 0;
  $387 = $382 + ($386 << 2) | 0;
  $388 = HEAP32[$387 >> 2] | 0;
  $389 = _mp_obj_new_cell($388) | 0;
  $390 = $4;
  $391 = $390 + 20 | 0;
  $392 = $9;
  $393 = $392 - 1 | 0;
  $394 = $29;
  $395 = $393 - $394 | 0;
  $396 = $391 + ($395 << 2) | 0;
  HEAP32[$396 >> 2] = $389;
 }
 $397 = $28;
 $398 = $4;
 $399 = $398 + 4 | 0;
 HEAP32[$399 >> 2] = $397;
 STACKTOP = sp;
 return;
}

function _str_modulo_format($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0.0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $vararg_buffer = 0, $vararg_ptr1 = 0, $vararg_ptr2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(160 | 0);
 $vararg_buffer = sp;
 $9 = sp + 120 | 0;
 $13 = sp + 96 | 0;
 $14 = sp + 88 | 0;
 $22 = sp + 60 | 0;
 $23 = sp + 56 | 0;
 $24 = sp + 52 | 0;
 $26 = sp + 144 | 0;
 $27 = sp + 32 | 0;
 $28 = sp + 24 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $31 = $4;
 $32 = _mp_obj_is_qstr_1128($31) | 0;
 $33 = $4;
 if ($32) {
  $34 = $33;
  $35 = $34 >>> 2;
  $36 = _qstr_data($35, $9) | 0;
  $8 = $36;
 } else {
  $37 = $33 + 8 | 0;
  $38 = HEAP32[$37 >> 2] | 0;
  HEAP32[$9 >> 2] = $38;
  $39 = $4;
  $40 = $39 + 12 | 0;
  $41 = HEAP32[$40 >> 2] | 0;
  $8 = $41;
 }
 $42 = $8;
 $10 = $42;
 $43 = $4;
 $44 = _mp_obj_is_obj_1154($43) | 0;
 if ($44) {
  $45 = $4;
  $46 = HEAP32[$45 >> 2] | 0;
  $47 = ($46 | 0) == (18304 | 0);
  $49 = $47;
 } else {
  $49 = 0;
 }
 $48 = $49 & 1;
 $11 = $48;
 $12 = 0;
 _vstr_init_print($13, 16, $14);
 $50 = $8;
 $51 = HEAP32[$9 >> 2] | 0;
 $52 = $50 + $51 | 0;
 $15 = $52;
 L8 : while (1) {
  $53 = $8;
  $54 = $15;
  $55 = $53 >>> 0 < $54 >>> 0;
  if (!$55) {
   label = 81;
   break;
  }
  $16 = 0;
  $56 = $8;
  $57 = HEAP8[$56 >> 0] | 0;
  $58 = $57 & 255;
  $59 = ($58 | 0) != 37;
  $60 = $8;
  L11 : do {
   if ($59) {
    $61 = HEAP8[$60 >> 0] | 0;
    _vstr_add_byte($13, $61);
   } else {
    $62 = $60 + 1 | 0;
    $8 = $62;
    $63 = $15;
    $64 = $62 >>> 0 >= $63 >>> 0;
    if ($64) {
     label = 48;
     break L8;
    }
    $65 = $8;
    $66 = HEAP8[$65 >> 0] | 0;
    $67 = $66 & 255;
    $68 = ($67 | 0) == 37;
    if ($68) {
     _vstr_add_byte($13, 37);
     break;
    }
    $69 = $8;
    $70 = HEAP8[$69 >> 0] | 0;
    $71 = $70 & 255;
    $72 = ($71 | 0) == 40;
    if ($72) {
     $73 = $7;
     $74 = ($73 | 0) == (0 | 0);
     if ($74) {
      label = 15;
      break L8;
     }
     $12 = 1;
     $75 = $8;
     $76 = $75 + 1 | 0;
     $8 = $76;
     $17 = $76;
     while (1) {
      $77 = $8;
      $78 = HEAP8[$77 >> 0] | 0;
      $79 = $78 & 255;
      $80 = ($79 | 0) != 41;
      if (!$80) {
       break;
      }
      $81 = $8;
      $82 = $15;
      $83 = $81 >>> 0 >= $82 >>> 0;
      if ($83) {
       label = 19;
       break L8;
      }
      $84 = $8;
      $85 = $84 + 1 | 0;
      $8 = $85;
     }
     $86 = $17;
     $87 = $8;
     $88 = $17;
     $89 = $87;
     $90 = $88;
     $91 = $89 - $90 | 0;
     $92 = _mp_obj_new_str_via_qstr($86, $91) | 0;
     $18 = $92;
     $93 = $7;
     $94 = $18;
     $95 = _mp_obj_dict_get($93, $94) | 0;
     $16 = $95;
     $96 = $8;
     $97 = $96 + 1 | 0;
     $8 = $97;
    }
    $19 = 0;
    $20 = 32;
    $21 = 0;
    L27 : while (1) {
     $98 = $8;
     $99 = $15;
     $100 = $98 >>> 0 < $99 >>> 0;
     if (!$100) {
      break;
     }
     $101 = $8;
     $102 = HEAP8[$101 >> 0] | 0;
     $103 = $102 & 255;
     $104 = ($103 | 0) == 45;
     do {
      if ($104) {
       $105 = $19;
       $106 = $105 | 1;
       $19 = $106;
      } else {
       $107 = $8;
       $108 = HEAP8[$107 >> 0] | 0;
       $109 = $108 & 255;
       $110 = ($109 | 0) == 43;
       if ($110) {
        $111 = $19;
        $112 = $111 | 2;
        $19 = $112;
        break;
       }
       $113 = $8;
       $114 = HEAP8[$113 >> 0] | 0;
       $115 = $114 & 255;
       $116 = ($115 | 0) == 32;
       if ($116) {
        $117 = $19;
        $118 = $117 | 4;
        $19 = $118;
        break;
       }
       $119 = $8;
       $120 = HEAP8[$119 >> 0] | 0;
       $121 = $120 & 255;
       $122 = ($121 | 0) == 35;
       if ($122) {
        $21 = 16;
        break;
       }
       $123 = $8;
       $124 = HEAP8[$123 >> 0] | 0;
       $125 = $124 & 255;
       $126 = ($125 | 0) == 48;
       if (!$126) {
        break L27;
       }
       $127 = $19;
       $128 = $127 | 64;
       $19 = $128;
       $20 = 48;
      }
     } while (0);
     $129 = $8;
     $130 = $129 + 1 | 0;
     $8 = $130;
    }
    HEAP32[$22 >> 2] = 0;
    $131 = $8;
    $132 = $15;
    $133 = $131 >>> 0 < $132 >>> 0;
    do {
     if ($133) {
      $134 = $8;
      $135 = HEAP8[$134 >> 0] | 0;
      $136 = $135 & 255;
      $137 = ($136 | 0) == 42;
      if (!$137) {
       $149 = $8;
       $150 = $15;
       $151 = _str_to_int($149, $150, $22) | 0;
       $8 = $151;
       break;
      }
      $138 = $12;
      $139 = $5;
      $140 = $138 >>> 0 >= $139 >>> 0;
      if ($140) {
       label = 51;
       break L8;
      }
      $141 = $6;
      $142 = $12;
      $143 = $142 + 1 | 0;
      $12 = $143;
      $144 = $141 + ($142 << 2) | 0;
      $145 = HEAP32[$144 >> 2] | 0;
      $146 = _mp_obj_get_int($145) | 0;
      HEAP32[$22 >> 2] = $146;
      $147 = $8;
      $148 = $147 + 1 | 0;
      $8 = $148;
     }
    } while (0);
    HEAP32[$23 >> 2] = -1;
    $152 = $8;
    $153 = $15;
    $154 = $152 >>> 0 < $153 >>> 0;
    do {
     if ($154) {
      $155 = $8;
      $156 = HEAP8[$155 >> 0] | 0;
      $157 = $156 & 255;
      $158 = ($157 | 0) == 46;
      if ($158) {
       $159 = $8;
       $160 = $159 + 1 | 0;
       $8 = $160;
       $161 = $15;
       $162 = $160 >>> 0 < $161 >>> 0;
       if ($162) {
        $163 = $8;
        $164 = HEAP8[$163 >> 0] | 0;
        $165 = $164 & 255;
        $166 = ($165 | 0) == 42;
        if (!$166) {
         HEAP32[$23 >> 2] = 0;
         $178 = $8;
         $179 = $15;
         $180 = _str_to_int($178, $179, $23) | 0;
         $8 = $180;
         break;
        }
        $167 = $12;
        $168 = $5;
        $169 = $167 >>> 0 >= $168 >>> 0;
        if ($169) {
         label = 51;
         break L8;
        }
        $170 = $6;
        $171 = $12;
        $172 = $171 + 1 | 0;
        $12 = $172;
        $173 = $170 + ($171 << 2) | 0;
        $174 = HEAP32[$173 >> 2] | 0;
        $175 = _mp_obj_get_int($174) | 0;
        HEAP32[$23 >> 2] = $175;
        $176 = $8;
        $177 = $176 + 1 | 0;
        $8 = $177;
       }
      }
     }
    } while (0);
    $181 = $8;
    $182 = $15;
    $183 = $181 >>> 0 >= $182 >>> 0;
    if ($183) {
     label = 48;
     break L8;
    }
    $184 = $16;
    $185 = ($184 | 0) == (0 | 0);
    if ($185) {
     $186 = $12;
     $187 = $5;
     $188 = $186 >>> 0 >= $187 >>> 0;
     if ($188) {
      label = 51;
      break L8;
     }
     $189 = $6;
     $190 = $12;
     $191 = $190 + 1 | 0;
     $12 = $191;
     $192 = $189 + ($190 << 2) | 0;
     $193 = HEAP32[$192 >> 2] | 0;
     $16 = $193;
    }
    $194 = $8;
    $195 = HEAP8[$194 >> 0] | 0;
    $196 = $195 & 255;
    switch ($196 | 0) {
    case 99:
     {
      $197 = $16;
      $198 = _mp_obj_is_qstr_1128($197) | 0;
      do {
       if (!$198) {
        $199 = $16;
        $200 = _mp_obj_is_obj_1154($199) | 0;
        if ($200) {
         $201 = $16;
         $202 = HEAP32[$201 >> 2] | 0;
         $203 = ($202 | 0) == (18680 | 0);
         if ($203) {
          break;
         }
        }
        $211 = $16;
        $212 = _arg_looks_integer($211) | 0;
        if (!$212) {
         label = 62;
         break L8;
        }
        $213 = $16;
        $214 = _mp_obj_get_int($213) | 0;
        $215 = $214 & 255;
        HEAP8[$26 >> 0] = $215;
        $216 = $19;
        $217 = HEAP32[$22 >> 2] | 0;
        _mp_print_strn($14, $26, 1, $216, 32, $217) | 0;
        break L11;
       }
      } while (0);
      $204 = $16;
      $205 = _mp_obj_str_get_data($204, $24) | 0;
      $25 = $205;
      $206 = HEAP32[$24 >> 2] | 0;
      $207 = ($206 | 0) != 1;
      if ($207) {
       label = 58;
       break L8;
      }
      $208 = $25;
      $209 = $19;
      $210 = HEAP32[$22 >> 2] | 0;
      _mp_print_strn($14, $208, 1, $209, 32, $210) | 0;
      break L11;
      break;
     }
    case 117:
    case 105:
    case 100:
     {
      $218 = $16;
      $219 = _arg_as_int($218) | 0;
      $220 = $19;
      $221 = $20;
      $222 = HEAP32[$22 >> 2] | 0;
      $223 = HEAP32[$23 >> 2] | 0;
      _mp_print_mp_int($14, $219, 10, 97, $220, $221, $222, $223) | 0;
      break L11;
      break;
     }
    case 71:
    case 103:
    case 70:
    case 102:
    case 69:
    case 101:
     {
      $224 = $16;
      $225 = +_mp_obj_get_float($224);
      $226 = $8;
      $227 = HEAP8[$226 >> 0] | 0;
      $228 = $19;
      $229 = $20;
      $230 = HEAP32[$22 >> 2] | 0;
      $231 = HEAP32[$23 >> 2] | 0;
      _mp_print_float($14, $225, $227, $228, $229, $230, $231) | 0;
      break L11;
      break;
     }
    case 111:
     {
      $232 = $21;
      $233 = ($232 | 0) != 0;
      if ($233) {
       $234 = $19;
       $235 = $234 | 528;
       $19 = $235;
      }
      $236 = $16;
      $237 = $19;
      $238 = $20;
      $239 = HEAP32[$22 >> 2] | 0;
      $240 = HEAP32[$23 >> 2] | 0;
      _mp_print_mp_int($14, $236, 8, 97, $237, $238, $239, $240) | 0;
      break L11;
      break;
     }
    case 115:
    case 114:
     {
      _vstr_init_print($27, 16, $28);
      $241 = $8;
      $242 = HEAP8[$241 >> 0] | 0;
      $243 = $242 & 255;
      $244 = ($243 | 0) == 114;
      $245 = $244 ? 1 : 0;
      $29 = $245;
      $246 = $29;
      $247 = ($246 | 0) == 0;
      if ($247) {
       $248 = $11;
       $249 = $248 & 1;
       if ($249) {
        $250 = $16;
        $251 = _mp_obj_is_obj_1154($250) | 0;
        if ($251) {
         $252 = $16;
         $253 = HEAP32[$252 >> 2] | 0;
         $254 = ($253 | 0) == (18304 | 0);
         if ($254) {
          $29 = 4;
         }
        }
       }
      }
      $255 = $16;
      $256 = $29;
      _mp_obj_print_helper($28, $255, $256);
      $257 = $27 + 4 | 0;
      $258 = HEAP32[$257 >> 2] | 0;
      $30 = $258;
      $259 = HEAP32[$23 >> 2] | 0;
      $260 = ($259 | 0) < 0;
      if ($260) {
       $261 = $30;
       HEAP32[$23 >> 2] = $261;
      }
      $262 = $30;
      $263 = HEAP32[$23 >> 2] | 0;
      $264 = $262 >>> 0 > $263 >>> 0;
      if ($264) {
       $265 = HEAP32[$23 >> 2] | 0;
       $30 = $265;
      }
      $266 = $27 + 8 | 0;
      $267 = HEAP32[$266 >> 2] | 0;
      $268 = $30;
      $269 = $19;
      $270 = HEAP32[$22 >> 2] | 0;
      _mp_print_strn($14, $267, $268, $269, 32, $270) | 0;
      _vstr_clear($27);
      break L11;
      break;
     }
    case 120:
    case 88:
     {
      $271 = $16;
      $272 = $8;
      $273 = HEAP8[$272 >> 0] | 0;
      $274 = $273 & 255;
      $275 = $274 - 23 | 0;
      $276 = $19;
      $277 = $21;
      $278 = $276 | $277;
      $279 = $20;
      $280 = HEAP32[$22 >> 2] | 0;
      $281 = HEAP32[$23 >> 2] | 0;
      _mp_print_mp_int($14, $271, 16, $275, $278, $279, $280, $281) | 0;
      break L11;
      break;
     }
    default:
     {
      label = 79;
      break L8;
     }
    }
   }
  } while (0);
  $294 = $8;
  $295 = $294 + 1 | 0;
  $8 = $295;
 }
 if ((label | 0) == 15) {
  _mp_raise_TypeError(32474);
 } else if ((label | 0) == 19) {
  _mp_raise_ValueError(32494);
 } else if ((label | 0) == 48) {
  _mp_raise_ValueError(32516);
 } else if ((label | 0) == 51) {
  _mp_raise_TypeError(32534);
 } else if ((label | 0) == 58) {
  _mp_raise_TypeError(32569);
 } else if ((label | 0) == 62) {
  _mp_raise_TypeError(32591);
 } else if ((label | 0) == 79) {
  $282 = $8;
  $283 = HEAP8[$282 >> 0] | 0;
  $284 = $283 & 255;
  $285 = $8;
  $286 = HEAP8[$285 >> 0] | 0;
  $287 = $286 & 255;
  $288 = $8;
  $289 = $10;
  $290 = $288;
  $291 = $289;
  $292 = $290 - $291 | 0;
  HEAP32[$vararg_buffer >> 2] = $284;
  $vararg_ptr1 = $vararg_buffer + 4 | 0;
  HEAP32[$vararg_ptr1 >> 2] = $287;
  $vararg_ptr2 = $vararg_buffer + 8 | 0;
  HEAP32[$vararg_ptr2 >> 2] = $292;
  $293 = _mp_obj_new_exception_msg_varg(16072, 32606, $vararg_buffer) | 0;
  _nlr_jump($293);
 } else if ((label | 0) == 81) {
  $296 = $12;
  $297 = $5;
  $298 = ($296 | 0) != ($297 | 0);
  if ($298) {
   _mp_raise_TypeError(32659);
  } else {
   $299 = $11;
   $300 = $299 & 1;
   $301 = $300 ? 18304 : 18680;
   $302 = _mp_obj_new_str_from_vstr($301, $13) | 0;
   STACKTOP = sp;
   return $302 | 0;
  }
 }
 return 0 | 0;
}

function _dispose_chunk($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$03649 = 0, $$0365$lcssa = 0, $$03658 = 0, $$0376 = 0, $$0383 = 0, $$1 = 0, $$1363 = 0, $$1371 = 0, $$1371$be = 0, $$1371$ph = 0, $$1374 = 0, $$1374$be = 0, $$1374$ph = 0, $$1378 = 0, $$1378$be = 0, $$1378$ph = 0, $$1382 = 0, $$1382$be = 0, $$1382$ph = 0, $$2 = 0, $$3 = 0, $$3380 = 0, $$pre = 0, $$pre$phiZ2D = 0, $$sink = 0, $$sink24 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $cond = 0, $cond4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = $0 + $1 | 0;
 $3 = $0 + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $4 & 1;
 $6 = ($5 | 0) == 0;
 do {
  if ($6) {
   $7 = HEAP32[$0 >> 2] | 0;
   $8 = $4 & 3;
   $9 = ($8 | 0) == 0;
   if ($9) {
    return;
   }
   $10 = 0 - $7 | 0;
   $11 = $0 + $10 | 0;
   $12 = $7 + $1 | 0;
   $13 = HEAP32[41060 >> 2] | 0;
   $14 = ($13 | 0) == ($11 | 0);
   if ($14) {
    $75 = $2 + 4 | 0;
    $76 = HEAP32[$75 >> 2] | 0;
    $77 = $76 & 3;
    $78 = ($77 | 0) == 3;
    if (!$78) {
     $$1 = $11;
     $$1363 = $12;
     break;
    }
    $79 = $11 + 4 | 0;
    $80 = $12 | 1;
    $81 = $76 & -2;
    HEAP32[41048 >> 2] = $12;
    HEAP32[$75 >> 2] = $81;
    HEAP32[$79 >> 2] = $80;
    HEAP32[$2 >> 2] = $12;
    return;
   }
   $15 = $7 >>> 3;
   $16 = $7 >>> 0 < 256;
   if ($16) {
    $17 = $11 + 8 | 0;
    $18 = HEAP32[$17 >> 2] | 0;
    $19 = $11 + 12 | 0;
    $20 = HEAP32[$19 >> 2] | 0;
    $21 = ($20 | 0) == ($18 | 0);
    if ($21) {
     $22 = 1 << $15;
     $23 = $22 ^ -1;
     $24 = HEAP32[10260] | 0;
     $25 = $24 & $23;
     HEAP32[10260] = $25;
     $$1 = $11;
     $$1363 = $12;
     break;
    } else {
     $26 = $18 + 12 | 0;
     HEAP32[$26 >> 2] = $20;
     $27 = $20 + 8 | 0;
     HEAP32[$27 >> 2] = $18;
     $$1 = $11;
     $$1363 = $12;
     break;
    }
   }
   $28 = $11 + 24 | 0;
   $29 = HEAP32[$28 >> 2] | 0;
   $30 = $11 + 12 | 0;
   $31 = HEAP32[$30 >> 2] | 0;
   $32 = ($31 | 0) == ($11 | 0);
   do {
    if ($32) {
     $37 = $11 + 16 | 0;
     $38 = $37 + 4 | 0;
     $39 = HEAP32[$38 >> 2] | 0;
     $40 = ($39 | 0) == (0 | 0);
     if ($40) {
      $41 = HEAP32[$37 >> 2] | 0;
      $42 = ($41 | 0) == (0 | 0);
      if ($42) {
       $$3 = 0;
       break;
      } else {
       $$1371$ph = $41;
       $$1374$ph = $37;
      }
     } else {
      $$1371$ph = $39;
      $$1374$ph = $38;
     }
     $$1371 = $$1371$ph;
     $$1374 = $$1374$ph;
     while (1) {
      $43 = $$1371 + 20 | 0;
      $44 = HEAP32[$43 >> 2] | 0;
      $45 = ($44 | 0) == (0 | 0);
      if ($45) {
       $46 = $$1371 + 16 | 0;
       $47 = HEAP32[$46 >> 2] | 0;
       $48 = ($47 | 0) == (0 | 0);
       if ($48) {
        break;
       } else {
        $$1371$be = $47;
        $$1374$be = $46;
       }
      } else {
       $$1371$be = $44;
       $$1374$be = $43;
      }
      $$1371 = $$1371$be;
      $$1374 = $$1374$be;
     }
     HEAP32[$$1374 >> 2] = 0;
     $$3 = $$1371;
    } else {
     $33 = $11 + 8 | 0;
     $34 = HEAP32[$33 >> 2] | 0;
     $35 = $34 + 12 | 0;
     HEAP32[$35 >> 2] = $31;
     $36 = $31 + 8 | 0;
     HEAP32[$36 >> 2] = $34;
     $$3 = $31;
    }
   } while (0);
   $49 = ($29 | 0) == (0 | 0);
   if ($49) {
    $$1 = $11;
    $$1363 = $12;
   } else {
    $50 = $11 + 28 | 0;
    $51 = HEAP32[$50 >> 2] | 0;
    $52 = 41344 + ($51 << 2) | 0;
    $53 = HEAP32[$52 >> 2] | 0;
    $54 = ($53 | 0) == ($11 | 0);
    if ($54) {
     HEAP32[$52 >> 2] = $$3;
     $cond = ($$3 | 0) == (0 | 0);
     if ($cond) {
      $55 = 1 << $51;
      $56 = $55 ^ -1;
      $57 = HEAP32[41044 >> 2] | 0;
      $58 = $57 & $56;
      HEAP32[41044 >> 2] = $58;
      $$1 = $11;
      $$1363 = $12;
      break;
     }
    } else {
     $59 = $29 + 16 | 0;
     $60 = HEAP32[$59 >> 2] | 0;
     $61 = ($60 | 0) == ($11 | 0);
     $62 = $29 + 20 | 0;
     $$sink = $61 ? $59 : $62;
     HEAP32[$$sink >> 2] = $$3;
     $63 = ($$3 | 0) == (0 | 0);
     if ($63) {
      $$1 = $11;
      $$1363 = $12;
      break;
     }
    }
    $64 = $$3 + 24 | 0;
    HEAP32[$64 >> 2] = $29;
    $65 = $11 + 16 | 0;
    $66 = HEAP32[$65 >> 2] | 0;
    $67 = ($66 | 0) == (0 | 0);
    if (!$67) {
     $68 = $$3 + 16 | 0;
     HEAP32[$68 >> 2] = $66;
     $69 = $66 + 24 | 0;
     HEAP32[$69 >> 2] = $$3;
    }
    $70 = $65 + 4 | 0;
    $71 = HEAP32[$70 >> 2] | 0;
    $72 = ($71 | 0) == (0 | 0);
    if ($72) {
     $$1 = $11;
     $$1363 = $12;
    } else {
     $73 = $$3 + 20 | 0;
     HEAP32[$73 >> 2] = $71;
     $74 = $71 + 24 | 0;
     HEAP32[$74 >> 2] = $$3;
     $$1 = $11;
     $$1363 = $12;
    }
   }
  } else {
   $$1 = $0;
   $$1363 = $1;
  }
 } while (0);
 $82 = $2 + 4 | 0;
 $83 = HEAP32[$82 >> 2] | 0;
 $84 = $83 & 2;
 $85 = ($84 | 0) == 0;
 if ($85) {
  $86 = HEAP32[41064 >> 2] | 0;
  $87 = ($86 | 0) == ($2 | 0);
  if ($87) {
   $88 = HEAP32[41052 >> 2] | 0;
   $89 = $88 + $$1363 | 0;
   HEAP32[41052 >> 2] = $89;
   HEAP32[41064 >> 2] = $$1;
   $90 = $89 | 1;
   $91 = $$1 + 4 | 0;
   HEAP32[$91 >> 2] = $90;
   $92 = HEAP32[41060 >> 2] | 0;
   $93 = ($$1 | 0) == ($92 | 0);
   if (!$93) {
    return;
   }
   HEAP32[41060 >> 2] = 0;
   HEAP32[41048 >> 2] = 0;
   return;
  }
  $94 = HEAP32[41060 >> 2] | 0;
  $95 = ($94 | 0) == ($2 | 0);
  if ($95) {
   $96 = HEAP32[41048 >> 2] | 0;
   $97 = $96 + $$1363 | 0;
   HEAP32[41048 >> 2] = $97;
   HEAP32[41060 >> 2] = $$1;
   $98 = $97 | 1;
   $99 = $$1 + 4 | 0;
   HEAP32[$99 >> 2] = $98;
   $100 = $$1 + $97 | 0;
   HEAP32[$100 >> 2] = $97;
   return;
  }
  $101 = $83 & -8;
  $102 = $101 + $$1363 | 0;
  $103 = $83 >>> 3;
  $104 = $83 >>> 0 < 256;
  do {
   if ($104) {
    $105 = $2 + 8 | 0;
    $106 = HEAP32[$105 >> 2] | 0;
    $107 = $2 + 12 | 0;
    $108 = HEAP32[$107 >> 2] | 0;
    $109 = ($108 | 0) == ($106 | 0);
    if ($109) {
     $110 = 1 << $103;
     $111 = $110 ^ -1;
     $112 = HEAP32[10260] | 0;
     $113 = $112 & $111;
     HEAP32[10260] = $113;
     break;
    } else {
     $114 = $106 + 12 | 0;
     HEAP32[$114 >> 2] = $108;
     $115 = $108 + 8 | 0;
     HEAP32[$115 >> 2] = $106;
     break;
    }
   } else {
    $116 = $2 + 24 | 0;
    $117 = HEAP32[$116 >> 2] | 0;
    $118 = $2 + 12 | 0;
    $119 = HEAP32[$118 >> 2] | 0;
    $120 = ($119 | 0) == ($2 | 0);
    do {
     if ($120) {
      $125 = $2 + 16 | 0;
      $126 = $125 + 4 | 0;
      $127 = HEAP32[$126 >> 2] | 0;
      $128 = ($127 | 0) == (0 | 0);
      if ($128) {
       $129 = HEAP32[$125 >> 2] | 0;
       $130 = ($129 | 0) == (0 | 0);
       if ($130) {
        $$3380 = 0;
        break;
       } else {
        $$1378$ph = $129;
        $$1382$ph = $125;
       }
      } else {
       $$1378$ph = $127;
       $$1382$ph = $126;
      }
      $$1378 = $$1378$ph;
      $$1382 = $$1382$ph;
      while (1) {
       $131 = $$1378 + 20 | 0;
       $132 = HEAP32[$131 >> 2] | 0;
       $133 = ($132 | 0) == (0 | 0);
       if ($133) {
        $134 = $$1378 + 16 | 0;
        $135 = HEAP32[$134 >> 2] | 0;
        $136 = ($135 | 0) == (0 | 0);
        if ($136) {
         break;
        } else {
         $$1378$be = $135;
         $$1382$be = $134;
        }
       } else {
        $$1378$be = $132;
        $$1382$be = $131;
       }
       $$1378 = $$1378$be;
       $$1382 = $$1382$be;
      }
      HEAP32[$$1382 >> 2] = 0;
      $$3380 = $$1378;
     } else {
      $121 = $2 + 8 | 0;
      $122 = HEAP32[$121 >> 2] | 0;
      $123 = $122 + 12 | 0;
      HEAP32[$123 >> 2] = $119;
      $124 = $119 + 8 | 0;
      HEAP32[$124 >> 2] = $122;
      $$3380 = $119;
     }
    } while (0);
    $137 = ($117 | 0) == (0 | 0);
    if (!$137) {
     $138 = $2 + 28 | 0;
     $139 = HEAP32[$138 >> 2] | 0;
     $140 = 41344 + ($139 << 2) | 0;
     $141 = HEAP32[$140 >> 2] | 0;
     $142 = ($141 | 0) == ($2 | 0);
     if ($142) {
      HEAP32[$140 >> 2] = $$3380;
      $cond4 = ($$3380 | 0) == (0 | 0);
      if ($cond4) {
       $143 = 1 << $139;
       $144 = $143 ^ -1;
       $145 = HEAP32[41044 >> 2] | 0;
       $146 = $145 & $144;
       HEAP32[41044 >> 2] = $146;
       break;
      }
     } else {
      $147 = $117 + 16 | 0;
      $148 = HEAP32[$147 >> 2] | 0;
      $149 = ($148 | 0) == ($2 | 0);
      $150 = $117 + 20 | 0;
      $$sink24 = $149 ? $147 : $150;
      HEAP32[$$sink24 >> 2] = $$3380;
      $151 = ($$3380 | 0) == (0 | 0);
      if ($151) {
       break;
      }
     }
     $152 = $$3380 + 24 | 0;
     HEAP32[$152 >> 2] = $117;
     $153 = $2 + 16 | 0;
     $154 = HEAP32[$153 >> 2] | 0;
     $155 = ($154 | 0) == (0 | 0);
     if (!$155) {
      $156 = $$3380 + 16 | 0;
      HEAP32[$156 >> 2] = $154;
      $157 = $154 + 24 | 0;
      HEAP32[$157 >> 2] = $$3380;
     }
     $158 = $153 + 4 | 0;
     $159 = HEAP32[$158 >> 2] | 0;
     $160 = ($159 | 0) == (0 | 0);
     if (!$160) {
      $161 = $$3380 + 20 | 0;
      HEAP32[$161 >> 2] = $159;
      $162 = $159 + 24 | 0;
      HEAP32[$162 >> 2] = $$3380;
     }
    }
   }
  } while (0);
  $163 = $102 | 1;
  $164 = $$1 + 4 | 0;
  HEAP32[$164 >> 2] = $163;
  $165 = $$1 + $102 | 0;
  HEAP32[$165 >> 2] = $102;
  $166 = HEAP32[41060 >> 2] | 0;
  $167 = ($$1 | 0) == ($166 | 0);
  if ($167) {
   HEAP32[41048 >> 2] = $102;
   return;
  } else {
   $$2 = $102;
  }
 } else {
  $168 = $83 & -2;
  HEAP32[$82 >> 2] = $168;
  $169 = $$1363 | 1;
  $170 = $$1 + 4 | 0;
  HEAP32[$170 >> 2] = $169;
  $171 = $$1 + $$1363 | 0;
  HEAP32[$171 >> 2] = $$1363;
  $$2 = $$1363;
 }
 $172 = $$2 >>> 3;
 $173 = $$2 >>> 0 < 256;
 if ($173) {
  $174 = $172 << 1;
  $175 = 41080 + ($174 << 2) | 0;
  $176 = HEAP32[10260] | 0;
  $177 = 1 << $172;
  $178 = $176 & $177;
  $179 = ($178 | 0) == 0;
  if ($179) {
   $180 = $176 | $177;
   HEAP32[10260] = $180;
   $$pre = $175 + 8 | 0;
   $$0383 = $175;
   $$pre$phiZ2D = $$pre;
  } else {
   $181 = $175 + 8 | 0;
   $182 = HEAP32[$181 >> 2] | 0;
   $$0383 = $182;
   $$pre$phiZ2D = $181;
  }
  HEAP32[$$pre$phiZ2D >> 2] = $$1;
  $183 = $$0383 + 12 | 0;
  HEAP32[$183 >> 2] = $$1;
  $184 = $$1 + 8 | 0;
  HEAP32[$184 >> 2] = $$0383;
  $185 = $$1 + 12 | 0;
  HEAP32[$185 >> 2] = $175;
  return;
 }
 $186 = $$2 >>> 8;
 $187 = ($186 | 0) == 0;
 if ($187) {
  $$0376 = 0;
 } else {
  $188 = $$2 >>> 0 > 16777215;
  if ($188) {
   $$0376 = 31;
  } else {
   $189 = $186 + 1048320 | 0;
   $190 = $189 >>> 16;
   $191 = $190 & 8;
   $192 = $186 << $191;
   $193 = $192 + 520192 | 0;
   $194 = $193 >>> 16;
   $195 = $194 & 4;
   $196 = $195 | $191;
   $197 = $192 << $195;
   $198 = $197 + 245760 | 0;
   $199 = $198 >>> 16;
   $200 = $199 & 2;
   $201 = $196 | $200;
   $202 = 14 - $201 | 0;
   $203 = $197 << $200;
   $204 = $203 >>> 15;
   $205 = $202 + $204 | 0;
   $206 = $205 << 1;
   $207 = $205 + 7 | 0;
   $208 = $$2 >>> $207;
   $209 = $208 & 1;
   $210 = $209 | $206;
   $$0376 = $210;
  }
 }
 $211 = 41344 + ($$0376 << 2) | 0;
 $212 = $$1 + 28 | 0;
 HEAP32[$212 >> 2] = $$0376;
 $213 = $$1 + 16 | 0;
 $214 = $$1 + 20 | 0;
 HEAP32[$214 >> 2] = 0;
 HEAP32[$213 >> 2] = 0;
 $215 = HEAP32[41044 >> 2] | 0;
 $216 = 1 << $$0376;
 $217 = $215 & $216;
 $218 = ($217 | 0) == 0;
 if ($218) {
  $219 = $215 | $216;
  HEAP32[41044 >> 2] = $219;
  HEAP32[$211 >> 2] = $$1;
  $220 = $$1 + 24 | 0;
  HEAP32[$220 >> 2] = $211;
  $221 = $$1 + 12 | 0;
  HEAP32[$221 >> 2] = $$1;
  $222 = $$1 + 8 | 0;
  HEAP32[$222 >> 2] = $$1;
  return;
 }
 $223 = HEAP32[$211 >> 2] | 0;
 $224 = $223 + 4 | 0;
 $225 = HEAP32[$224 >> 2] | 0;
 $226 = $225 & -8;
 $227 = ($226 | 0) == ($$2 | 0);
 L104 : do {
  if ($227) {
   $$0365$lcssa = $223;
  } else {
   $228 = ($$0376 | 0) == 31;
   $229 = $$0376 >>> 1;
   $230 = 25 - $229 | 0;
   $231 = $228 ? 0 : $230;
   $232 = $$2 << $231;
   $$03649 = $232;
   $$03658 = $223;
   while (1) {
    $239 = $$03649 >>> 31;
    $240 = ($$03658 + 16 | 0) + ($239 << 2) | 0;
    $235 = HEAP32[$240 >> 2] | 0;
    $241 = ($235 | 0) == (0 | 0);
    if ($241) {
     break;
    }
    $233 = $$03649 << 1;
    $234 = $235 + 4 | 0;
    $236 = HEAP32[$234 >> 2] | 0;
    $237 = $236 & -8;
    $238 = ($237 | 0) == ($$2 | 0);
    if ($238) {
     $$0365$lcssa = $235;
     break L104;
    } else {
     $$03649 = $233;
     $$03658 = $235;
    }
   }
   HEAP32[$240 >> 2] = $$1;
   $242 = $$1 + 24 | 0;
   HEAP32[$242 >> 2] = $$03658;
   $243 = $$1 + 12 | 0;
   HEAP32[$243 >> 2] = $$1;
   $244 = $$1 + 8 | 0;
   HEAP32[$244 >> 2] = $$1;
   return;
  }
 } while (0);
 $245 = $$0365$lcssa + 8 | 0;
 $246 = HEAP32[$245 >> 2] | 0;
 $247 = $246 + 12 | 0;
 HEAP32[$247 >> 2] = $$1;
 HEAP32[$245 >> 2] = $$1;
 $248 = $$1 + 8 | 0;
 HEAP32[$248 >> 2] = $246;
 $249 = $$1 + 12 | 0;
 HEAP32[$249 >> 2] = $$0365$lcssa;
 $250 = $$1 + 24 | 0;
 HEAP32[$250 >> 2] = 0;
 return;
}

function _readline_process_char($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, $or$cond5 = 0, $or$cond7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $9 = sp + 8 | 0;
 $2 = $0;
 $12 = HEAP32[10405] | 0;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $3 = $14;
 $4 = 0;
 $5 = 0;
 $6 = 0;
 $15 = HEAP32[10407] | 0;
 $16 = ($15 | 0) == 0;
 L1 : do {
  if ($16) {
   $17 = $2;
   $18 = 1 <= ($17 | 0);
   $19 = $2;
   $20 = ($19 | 0) <= 5;
   $or$cond = $18 & $20;
   if ($or$cond) {
    $21 = HEAP32[10405] | 0;
    $22 = _vstr_len_1566($21) | 0;
    $23 = HEAP32[10406] | 0;
    $24 = ($22 | 0) == ($23 | 0);
    if ($24) {
     $25 = $2;
     $1 = $25;
     $279 = $1;
     STACKTOP = sp;
     return $279 | 0;
    }
   }
   $26 = $2;
   $27 = ($26 | 0) == 1;
   if ($27) {
    label = 63;
   } else {
    $28 = $2;
    $29 = ($28 | 0) == 3;
    $30 = $2;
    if ($29) {
     $1 = $30;
     $279 = $1;
     STACKTOP = sp;
     return $279 | 0;
    }
    $31 = ($30 | 0) == 5;
    if ($31) {
     label = 66;
    } else {
     $32 = $2;
     $33 = ($32 | 0) == 13;
     if ($33) {
      _mp_hal_stdout_tx_str(35325);
      $34 = HEAP32[10405] | 0;
      $35 = _vstr_null_terminated_str($34) | 0;
      $36 = HEAP32[10406] | 0;
      $37 = $35 + $36 | 0;
      _readline_push_history($37);
      $1 = 0;
      $279 = $1;
      STACKTOP = sp;
      return $279 | 0;
     }
     $38 = $2;
     $39 = ($38 | 0) == 27;
     if ($39) {
      HEAP32[10407] = 1;
      break;
     }
     $40 = $2;
     $41 = ($40 | 0) == 8;
     $42 = $2;
     $43 = ($42 | 0) == 127;
     $or$cond3 = $41 | $43;
     if ($or$cond3) {
      $44 = HEAP32[10409] | 0;
      $45 = HEAP32[10406] | 0;
      $46 = $44 >>> 0 > $45 >>> 0;
      if (!$46) {
       break;
      }
      $7 = 0;
      $47 = HEAP32[10406] | 0;
      $8 = $47;
      while (1) {
       $48 = $8;
       $49 = HEAP32[10409] | 0;
       $50 = $48 >>> 0 < $49 >>> 0;
       if (!$50) {
        break;
       }
       $51 = HEAP32[10405] | 0;
       $52 = $51 + 8 | 0;
       $53 = HEAP32[$52 >> 2] | 0;
       $54 = $8;
       $55 = $53 + $54 | 0;
       $56 = HEAP8[$55 >> 0] | 0;
       $57 = $56 << 24 >> 24;
       $58 = ($57 | 0) != 32;
       if ($58) {
        label = 18;
        break;
       }
       $59 = $7;
       $60 = $59 + 1 | 0;
       $7 = $60;
       $61 = $8;
       $62 = $61 + 1 | 0;
       $8 = $62;
      }
      if ((label | 0) == 18) {
       $7 = 0;
      }
      $63 = $7;
      $64 = ($63 | 0) < 4;
      if ($64) {
       $7 = 1;
      } else {
       $7 = 4;
      }
      $65 = HEAP32[10405] | 0;
      $66 = HEAP32[10409] | 0;
      $67 = $7;
      $68 = $66 - $67 | 0;
      $69 = $7;
      _vstr_cut_out_bytes($65, $68, $69);
      $70 = $7;
      $4 = $70;
      $5 = 1;
      break;
     } else {
      $71 = $2;
      $72 = ($71 | 0) == 9;
      if (!$72) {
       $108 = $2;
       $109 = 32 <= ($108 | 0);
       $110 = $2;
       $111 = ($110 | 0) <= 126;
       $or$cond5 = $109 & $111;
       if (!$or$cond5) {
        break;
       }
       $112 = HEAP32[10405] | 0;
       $113 = HEAP32[10409] | 0;
       $114 = $2;
       _vstr_ins_char($112, $113, $114);
       $5 = 1;
       $6 = 1;
       break;
      }
      $73 = HEAP32[10405] | 0;
      $74 = $73 + 8 | 0;
      $75 = HEAP32[$74 >> 2] | 0;
      $76 = HEAP32[10406] | 0;
      $77 = $75 + $76 | 0;
      $78 = HEAP32[10409] | 0;
      $79 = HEAP32[10406] | 0;
      $80 = $78 - $79 | 0;
      $81 = _mp_repl_autocomplete($77, $80, 13344, $9) | 0;
      $10 = $81;
      $82 = $10;
      $83 = ($82 | 0) == 0;
      if ($83) {
       break;
      }
      $84 = $10;
      $85 = ($84 | 0) == -1;
      if ($85) {
       $86 = HEAP32[10410] | 0;
       _mp_hal_stdout_tx_str($86);
       $87 = HEAP32[10405] | 0;
       $88 = $87 + 8 | 0;
       $89 = HEAP32[$88 >> 2] | 0;
       $90 = HEAP32[10406] | 0;
       $91 = $89 + $90 | 0;
       $92 = HEAP32[10409] | 0;
       $93 = HEAP32[10406] | 0;
       $94 = $92 - $93 | 0;
       _mp_hal_stdout_tx_strn($91, $94);
       $5 = 1;
       break;
      }
      $11 = 0;
      while (1) {
       $95 = $11;
       $96 = $10;
       $97 = $95 >>> 0 < $96 >>> 0;
       if (!$97) {
        break;
       }
       $98 = HEAP32[10405] | 0;
       $99 = HEAP32[10409] | 0;
       $100 = $11;
       $101 = $99 + $100 | 0;
       $102 = HEAP32[$9 >> 2] | 0;
       $103 = $102 + 1 | 0;
       HEAP32[$9 >> 2] = $103;
       $104 = HEAP8[$102 >> 0] | 0;
       _vstr_ins_byte($98, $101, $104);
       $105 = $11;
       $106 = $105 + 1 | 0;
       $11 = $106;
      }
      $5 = 1;
      $107 = $10;
      $6 = $107;
      break;
     }
    }
   }
  } else {
   $115 = HEAP32[10407] | 0;
   $116 = ($115 | 0) == 1;
   if ($116) {
    $117 = $2;
    switch ($117 | 0) {
    case 91:
     {
      HEAP32[10407] = 2;
      break L1;
      break;
     }
    case 79:
     {
      HEAP32[10407] = 4;
      break L1;
      break;
     }
    default:
     {
      HEAP32[10407] = 0;
      break L1;
     }
    }
   }
   $118 = HEAP32[10407] | 0;
   $119 = ($118 | 0) == 2;
   if (!$119) {
    $195 = HEAP32[10407] | 0;
    $196 = ($195 | 0) == 3;
    if (!$196) {
     $229 = HEAP32[10407] | 0;
     $230 = ($229 | 0) == 4;
     if (!$230) {
      HEAP32[10407] = 0;
      break;
     }
     $231 = $2;
     switch ($231 | 0) {
     case 72:
      {
       label = 63;
       break L1;
       break;
      }
     case 70:
      {
       label = 66;
       break L1;
       break;
      }
     default:
      {}
     }
     HEAP32[10407] = 0;
     break;
    }
    $197 = $2;
    $198 = ($197 | 0) == 126;
    if (!$198) {
     label = 70;
     break;
    }
    $199 = HEAP8[41644] | 0;
    $200 = $199 << 24 >> 24;
    $201 = ($200 | 0) == 49;
    if ($201) {
     label = 63;
     break;
    }
    $202 = HEAP8[41644] | 0;
    $203 = $202 << 24 >> 24;
    $204 = ($203 | 0) == 55;
    if ($204) {
     label = 63;
     break;
    }
    $208 = HEAP8[41644] | 0;
    $209 = $208 << 24 >> 24;
    $210 = ($209 | 0) == 52;
    if ($210) {
     label = 66;
     break;
    }
    $211 = HEAP8[41644] | 0;
    $212 = $211 << 24 >> 24;
    $213 = ($212 | 0) == 56;
    if ($213) {
     label = 66;
     break;
    }
    $219 = HEAP8[41644] | 0;
    $220 = $219 << 24 >> 24;
    $221 = ($220 | 0) == 51;
    if (!$221) {
     label = 70;
     break;
    }
    $222 = HEAP32[10409] | 0;
    $223 = HEAP32[10405] | 0;
    $224 = $223 + 4 | 0;
    $225 = HEAP32[$224 >> 2] | 0;
    $226 = $222 >>> 0 < $225 >>> 0;
    if (!$226) {
     label = 70;
     break;
    }
    $227 = HEAP32[10405] | 0;
    $228 = HEAP32[10409] | 0;
    _vstr_cut_out_bytes($227, $228, 1);
    $5 = 1;
    label = 70;
    break;
   }
   $120 = $2;
   $121 = 48 <= ($120 | 0);
   $122 = $2;
   $123 = ($122 | 0) <= 57;
   $or$cond7 = $121 & $123;
   if ($or$cond7) {
    HEAP32[10407] = 3;
    $124 = $2;
    $125 = $124 & 255;
    HEAP8[41644] = $125;
    break;
   }
   HEAP32[10407] = 0;
   $126 = $2;
   $127 = ($126 | 0) == 65;
   if ($127) {
    $128 = HEAP32[10408] | 0;
    $129 = $128 + 1 | 0;
    $130 = ($129 | 0) < 8;
    if (!$130) {
     break;
    }
    $131 = HEAP32[10408] | 0;
    $132 = $131 + 1 | 0;
    $133 = 40688 + ($132 << 2) | 0;
    $134 = HEAP32[$133 >> 2] | 0;
    $135 = ($134 | 0) != (0 | 0);
    if (!$135) {
     break;
    }
    $136 = HEAP32[10408] | 0;
    $137 = $136 + 1 | 0;
    HEAP32[10408] = $137;
    $138 = HEAP32[10406] | 0;
    $139 = HEAP32[10405] | 0;
    $140 = $139 + 4 | 0;
    HEAP32[$140 >> 2] = $138;
    $141 = HEAP32[10405] | 0;
    $142 = HEAP32[10408] | 0;
    $143 = 40688 + ($142 << 2) | 0;
    $144 = HEAP32[$143 >> 2] | 0;
    _vstr_add_str($141, $144);
    $145 = HEAP32[10409] | 0;
    $146 = HEAP32[10406] | 0;
    $147 = $145 - $146 | 0;
    $4 = $147;
    $5 = 1;
    $148 = HEAP32[10405] | 0;
    $149 = $148 + 4 | 0;
    $150 = HEAP32[$149 >> 2] | 0;
    $151 = HEAP32[10406] | 0;
    $152 = $150 - $151 | 0;
    $6 = $152;
    break;
   }
   $153 = $2;
   $154 = ($153 | 0) == 66;
   if ($154) {
    $155 = HEAP32[10408] | 0;
    $156 = ($155 | 0) >= 0;
    if (!$156) {
     break;
    }
    $157 = HEAP32[10408] | 0;
    $158 = $157 - 1 | 0;
    HEAP32[10408] = $158;
    $159 = HEAP32[10405] | 0;
    $160 = HEAP32[10405] | 0;
    $161 = $160 + 4 | 0;
    $162 = HEAP32[$161 >> 2] | 0;
    $163 = HEAP32[10406] | 0;
    $164 = $162 - $163 | 0;
    _vstr_cut_tail_bytes($159, $164);
    $165 = HEAP32[10408] | 0;
    $166 = ($165 | 0) >= 0;
    if ($166) {
     $167 = HEAP32[10405] | 0;
     $168 = HEAP32[10408] | 0;
     $169 = 40688 + ($168 << 2) | 0;
     $170 = HEAP32[$169 >> 2] | 0;
     _vstr_add_str($167, $170);
    }
    $171 = HEAP32[10409] | 0;
    $172 = HEAP32[10406] | 0;
    $173 = $171 - $172 | 0;
    $4 = $173;
    $5 = 1;
    $174 = HEAP32[10405] | 0;
    $175 = $174 + 4 | 0;
    $176 = HEAP32[$175 >> 2] | 0;
    $177 = HEAP32[10406] | 0;
    $178 = $176 - $177 | 0;
    $6 = $178;
    break;
   }
   $179 = $2;
   $180 = ($179 | 0) == 67;
   if ($180) {
    $181 = HEAP32[10409] | 0;
    $182 = HEAP32[10405] | 0;
    $183 = $182 + 4 | 0;
    $184 = HEAP32[$183 >> 2] | 0;
    $185 = $181 >>> 0 < $184 >>> 0;
    if (!$185) {
     break;
    }
    $6 = 1;
    break;
   }
   $186 = $2;
   $187 = ($186 | 0) == 68;
   if ($187) {
    $188 = HEAP32[10409] | 0;
    $189 = HEAP32[10406] | 0;
    $190 = $188 >>> 0 > $189 >>> 0;
    if (!$190) {
     break;
    }
    $4 = 1;
    break;
   } else {
    $191 = $2;
    $192 = ($191 | 0) == 72;
    if ($192) {
     label = 63;
     break;
    }
    $193 = $2;
    $194 = ($193 | 0) == 70;
    if ($194) {
     label = 66;
     break;
    } else {
     break;
    }
   }
  }
 } while (0);
 if ((label | 0) == 63) {
  $205 = HEAP32[10409] | 0;
  $206 = HEAP32[10406] | 0;
  $207 = $205 - $206 | 0;
  $4 = $207;
  label = 70;
 } else if ((label | 0) == 66) {
  $214 = HEAP32[10405] | 0;
  $215 = $214 + 4 | 0;
  $216 = HEAP32[$215 >> 2] | 0;
  $217 = HEAP32[10409] | 0;
  $218 = $216 - $217 | 0;
  $6 = $218;
  label = 70;
 }
 if ((label | 0) == 70) {
  HEAP32[10407] = 0;
 }
 $232 = $4;
 $233 = ($232 | 0) > 0;
 if ($233) {
  $234 = $4;
  _mp_hal_move_cursor_back($234);
  $235 = $4;
  $236 = HEAP32[10409] | 0;
  $237 = $236 - $235 | 0;
  HEAP32[10409] = $237;
 }
 $238 = $5;
 $239 = $238 & 1;
 if ($239) {
  $240 = HEAP32[10405] | 0;
  $241 = $240 + 4 | 0;
  $242 = HEAP32[$241 >> 2] | 0;
  $243 = $3;
  $244 = $242 >>> 0 < $243 >>> 0;
  if ($244) {
   $245 = $3;
   $246 = HEAP32[10409] | 0;
   $247 = $245 - $246 | 0;
   _mp_hal_erase_line_from_cursor($247);
  }
  $248 = HEAP32[10405] | 0;
  $249 = $248 + 8 | 0;
  $250 = HEAP32[$249 >> 2] | 0;
  $251 = HEAP32[10409] | 0;
  $252 = $250 + $251 | 0;
  $253 = HEAP32[10405] | 0;
  $254 = $253 + 4 | 0;
  $255 = HEAP32[$254 >> 2] | 0;
  $256 = HEAP32[10409] | 0;
  $257 = $255 - $256 | 0;
  _mp_hal_stdout_tx_strn($252, $257);
  $258 = HEAP32[10405] | 0;
  $259 = $258 + 4 | 0;
  $260 = HEAP32[$259 >> 2] | 0;
  $261 = HEAP32[10409] | 0;
  $262 = $6;
  $263 = $261 + $262 | 0;
  $264 = $260 - $263 | 0;
  _mp_hal_move_cursor_back($264);
  $265 = $6;
  $266 = HEAP32[10409] | 0;
  $267 = $266 + $265 | 0;
  HEAP32[10409] = $267;
 } else {
  $268 = $6;
  $269 = ($268 | 0) > 0;
  if ($269) {
   $270 = HEAP32[10405] | 0;
   $271 = $270 + 8 | 0;
   $272 = HEAP32[$271 >> 2] | 0;
   $273 = HEAP32[10409] | 0;
   $274 = $272 + $273 | 0;
   $275 = $6;
   _mp_hal_stdout_tx_strn($274, $275);
   $276 = $6;
   $277 = HEAP32[10409] | 0;
   $278 = $277 + $276 | 0;
   HEAP32[10409] = $278;
  }
 }
 $1 = -1;
 $279 = $1;
 STACKTOP = sp;
 return $279 | 0;
}

function _array_subscr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $3 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $8 = sp + 48 | 0;
 $13 = sp + 20 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $19 = $6;
 $20 = ($19 | 0) == (0 | 0);
 if ($20) {
  $3 = 0;
  $321 = $3;
  STACKTOP = sp;
  return $321 | 0;
 }
 $21 = $4;
 $7 = $21;
 $22 = $5;
 $23 = _mp_obj_is_obj_817($22) | 0;
 if ($23) {
  $24 = $5;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = ($25 | 0) == (18228 | 0);
  if ($26) {
   $27 = $7;
   $28 = $27 + 8 | 0;
   $29 = HEAP32[$28 >> 2] | 0;
   $30 = $5;
   $31 = _mp_seq_get_fast_slice_indexes($29, $30, $8) | 0;
   if (!$31) {
    _mp_raise_NotImplementedError(32934);
   }
   $32 = $6;
   $33 = ($32 | 0) != (4 | 0);
   $34 = $7;
   $35 = $34 + 4 | 0;
   $36 = HEAP32[$35 >> 2] | 0;
   $37 = $36 & 255;
   $38 = $37 & 127;
   $39 = $38 & 255;
   $40 = _mp_binary_get_size(64, $39, 0) | 0;
   if (!$33) {
    $17 = $40;
    $233 = $7;
    $234 = HEAP32[$233 >> 2] | 0;
    $235 = ($234 | 0) == (13464 | 0);
    if ($235) {
     $236 = _m_malloc(16) | 0;
     $16 = $236;
     $237 = $16;
     $238 = $7;
     HEAP32[$237 >> 2] = HEAP32[$238 >> 2] | 0;
     HEAP32[$237 + 4 >> 2] = HEAP32[$238 + 4 >> 2] | 0;
     HEAP32[$237 + 8 >> 2] = HEAP32[$238 + 8 >> 2] | 0;
     HEAP32[$237 + 12 >> 2] = HEAP32[$238 + 12 >> 2] | 0;
     $239 = HEAP32[$8 >> 2] | 0;
     $240 = $16;
     $241 = $240 + 4 | 0;
     $242 = HEAP32[$241 >> 2] | 0;
     $243 = $242 >>> 8;
     $244 = $243 + $239 | 0;
     $245 = HEAP32[$241 >> 2] | 0;
     $246 = $244 & 16777215;
     $247 = $246 << 8;
     $248 = $245 & 255;
     $249 = $248 | $247;
     HEAP32[$241 >> 2] = $249;
     $250 = $8 + 4 | 0;
     $251 = HEAP32[$250 >> 2] | 0;
     $252 = HEAP32[$8 >> 2] | 0;
     $253 = $251 - $252 | 0;
     $254 = $16;
     $255 = $254 + 8 | 0;
     HEAP32[$255 >> 2] = $253;
    } else {
     $256 = $7;
     $257 = $256 + 4 | 0;
     $258 = HEAP32[$257 >> 2] | 0;
     $259 = $258 & 255;
     $260 = $259 & 255;
     $261 = $8 + 4 | 0;
     $262 = HEAP32[$261 >> 2] | 0;
     $263 = HEAP32[$8 >> 2] | 0;
     $264 = $262 - $263 | 0;
     $265 = _array_new($260, $264) | 0;
     $16 = $265;
     $266 = $16;
     $267 = $266 + 12 | 0;
     $268 = HEAP32[$267 >> 2] | 0;
     $269 = $7;
     $270 = $269 + 12 | 0;
     $271 = HEAP32[$270 >> 2] | 0;
     $272 = HEAP32[$8 >> 2] | 0;
     $273 = $17;
     $274 = Math_imul($272, $273) | 0;
     $275 = $271 + $274 | 0;
     $276 = $8 + 4 | 0;
     $277 = HEAP32[$276 >> 2] | 0;
     $278 = HEAP32[$8 >> 2] | 0;
     $279 = $277 - $278 | 0;
     $280 = $17;
     $281 = Math_imul($279, $280) | 0;
     _memcpy($268 | 0, $275 | 0, $281 | 0) | 0;
    }
    $282 = $16;
    $3 = $282;
    $321 = $3;
    STACKTOP = sp;
    return $321 | 0;
   }
   $11 = $40;
   $41 = $6;
   $42 = _mp_obj_is_obj_817($41) | 0;
   if ($42) {
    $43 = $6;
    $44 = HEAP32[$43 >> 2] | 0;
    $45 = $44 + 32 | 0;
    $46 = HEAP32[$45 >> 2] | 0;
    $47 = ($46 | 0) == (56 | 0);
    if ($47) {
     $48 = $6;
     $12 = $48;
     $49 = $11;
     $50 = $12;
     $51 = $50 + 4 | 0;
     $52 = HEAP32[$51 >> 2] | 0;
     $53 = $52 & 255;
     $54 = $53 & 127;
     $55 = $54 & 255;
     $56 = _mp_binary_get_size(64, $55, 0) | 0;
     $57 = ($49 | 0) != ($56 | 0);
     if ($57) {
      _mp_raise_ValueError(30757);
     }
     $58 = $12;
     $59 = $58 + 8 | 0;
     $60 = HEAP32[$59 >> 2] | 0;
     $9 = $60;
     $61 = $12;
     $62 = $61 + 12 | 0;
     $63 = HEAP32[$62 >> 2] | 0;
     $10 = $63;
     $64 = $6;
     $65 = _mp_obj_is_obj_817($64) | 0;
     if ($65) {
      $66 = $6;
      $67 = HEAP32[$66 >> 2] | 0;
      $68 = ($67 | 0) == (13464 | 0);
      if ($68) {
       $69 = $10;
       $70 = $12;
       $71 = $70 + 4 | 0;
       $72 = HEAP32[$71 >> 2] | 0;
       $73 = $72 >>> 8;
       $74 = $11;
       $75 = Math_imul($73, $74) | 0;
       $76 = $69 + $75 | 0;
       $10 = $76;
      }
     }
    } else {
     label = 15;
    }
   } else {
    label = 15;
   }
   do {
    if ((label | 0) == 15) {
     $77 = $6;
     $78 = _mp_obj_is_obj_817($77) | 0;
     if (!$78) {
      _mp_raise_NotImplementedError(30790);
     }
     $79 = $6;
     $80 = HEAP32[$79 >> 2] | 0;
     $81 = ($80 | 0) == (18304 | 0);
     if (!$81) {
      _mp_raise_NotImplementedError(30790);
     }
     $82 = $11;
     $83 = ($82 | 0) != 1;
     if ($83) {
      _mp_raise_ValueError(30757);
     } else {
      $84 = $6;
      _mp_get_buffer_raise($84, $13, 1);
      $85 = $13 + 4 | 0;
      $86 = HEAP32[$85 >> 2] | 0;
      $9 = $86;
      $87 = HEAP32[$13 >> 2] | 0;
      $10 = $87;
      break;
     }
    }
   } while (0);
   $88 = $9;
   $89 = $8 + 4 | 0;
   $90 = HEAP32[$89 >> 2] | 0;
   $91 = HEAP32[$8 >> 2] | 0;
   $92 = $90 - $91 | 0;
   $93 = $88 - $92 | 0;
   $14 = $93;
   $94 = $7;
   $95 = $94 + 12 | 0;
   $96 = HEAP32[$95 >> 2] | 0;
   $15 = $96;
   $97 = $7;
   $98 = HEAP32[$97 >> 2] | 0;
   $99 = ($98 | 0) == (13464 | 0);
   do {
    if ($99) {
     $100 = $7;
     $101 = $100 + 4 | 0;
     $102 = HEAP32[$101 >> 2] | 0;
     $103 = $102 & 255;
     $104 = $103 & 128;
     $105 = ($104 | 0) != 0;
     if (!$105) {
      $3 = 0;
      $321 = $3;
      STACKTOP = sp;
      return $321 | 0;
     }
     $106 = $14;
     $107 = ($106 | 0) != 0;
     if ($107) {
      _mp_raise_ValueError(30757);
     } else {
      $108 = $7;
      $109 = $108 + 4 | 0;
      $110 = HEAP32[$109 >> 2] | 0;
      $111 = $110 >>> 8;
      $112 = $11;
      $113 = Math_imul($111, $112) | 0;
      $114 = $15;
      $115 = $114 + $113 | 0;
      $15 = $115;
      break;
     }
    }
   } while (0);
   $116 = $14;
   $117 = ($116 | 0) > 0;
   if ($117) {
    $118 = $14;
    $119 = $7;
    $120 = $119 + 4 | 0;
    $121 = HEAP32[$120 >> 2] | 0;
    $122 = $121 >>> 8;
    $123 = ($118 | 0) > ($122 | 0);
    if ($123) {
     $124 = $7;
     $125 = $124 + 12 | 0;
     $126 = HEAP32[$125 >> 2] | 0;
     $127 = $7;
     $128 = $127 + 8 | 0;
     $129 = HEAP32[$128 >> 2] | 0;
     $130 = $14;
     $131 = $129 + $130 | 0;
     $132 = $11;
     $133 = Math_imul($131, $132) | 0;
     $134 = $133;
     $135 = _m_realloc($126, $134) | 0;
     $136 = $7;
     $137 = $136 + 12 | 0;
     HEAP32[$137 >> 2] = $135;
     $138 = $7;
     $139 = $138 + 4 | 0;
     $140 = HEAP32[$139 >> 2] | 0;
     $141 = $140 & 255;
     HEAP32[$139 >> 2] = $141;
     $142 = $7;
     $143 = $142 + 12 | 0;
     $144 = HEAP32[$143 >> 2] | 0;
     $15 = $144;
    }
    $145 = $15;
    $146 = HEAP32[$8 >> 2] | 0;
    $147 = $9;
    $148 = $146 + $147 | 0;
    $149 = $11;
    $150 = Math_imul($148, $149) | 0;
    $151 = $145 + $150 | 0;
    $152 = $15;
    $153 = $8 + 4 | 0;
    $154 = HEAP32[$153 >> 2] | 0;
    $155 = $11;
    $156 = Math_imul($154, $155) | 0;
    $157 = $152 + $156 | 0;
    $158 = $7;
    $159 = $158 + 8 | 0;
    $160 = HEAP32[$159 >> 2] | 0;
    $161 = $14;
    $162 = $160 + $161 | 0;
    $163 = HEAP32[$8 >> 2] | 0;
    $164 = $9;
    $165 = $163 + $164 | 0;
    $166 = $162 - $165 | 0;
    $167 = $11;
    $168 = Math_imul($166, $167) | 0;
    _memmove($151 | 0, $157 | 0, $168 | 0) | 0;
    $169 = $15;
    $170 = HEAP32[$8 >> 2] | 0;
    $171 = $11;
    $172 = Math_imul($170, $171) | 0;
    $173 = $169 + $172 | 0;
    $174 = $10;
    $175 = $9;
    $176 = $11;
    $177 = Math_imul($175, $176) | 0;
    _memmove($173 | 0, $174 | 0, $177 | 0) | 0;
   } else {
    $178 = $15;
    $179 = HEAP32[$8 >> 2] | 0;
    $180 = $11;
    $181 = Math_imul($179, $180) | 0;
    $182 = $178 + $181 | 0;
    $183 = $10;
    $184 = $9;
    $185 = $11;
    $186 = Math_imul($184, $185) | 0;
    _memcpy($182 | 0, $183 | 0, $186 | 0) | 0;
    $187 = $15;
    $188 = HEAP32[$8 >> 2] | 0;
    $189 = $9;
    $190 = $188 + $189 | 0;
    $191 = $11;
    $192 = Math_imul($190, $191) | 0;
    $193 = $187 + $192 | 0;
    $194 = $15;
    $195 = $8 + 4 | 0;
    $196 = HEAP32[$195 >> 2] | 0;
    $197 = $11;
    $198 = Math_imul($196, $197) | 0;
    $199 = $194 + $198 | 0;
    $200 = $7;
    $201 = $200 + 8 | 0;
    $202 = HEAP32[$201 >> 2] | 0;
    $203 = $8 + 4 | 0;
    $204 = HEAP32[$203 >> 2] | 0;
    $205 = $202 - $204 | 0;
    $206 = $11;
    $207 = Math_imul($205, $206) | 0;
    _memmove($193 | 0, $199 | 0, $207 | 0) | 0;
    $208 = $15;
    $209 = $7;
    $210 = $209 + 8 | 0;
    $211 = HEAP32[$210 >> 2] | 0;
    $212 = $14;
    $213 = $211 + $212 | 0;
    $214 = $11;
    $215 = Math_imul($213, $214) | 0;
    $216 = $208 + $215 | 0;
    $217 = $7;
    $218 = $217 + 8 | 0;
    $219 = HEAP32[$218 >> 2] | 0;
    $220 = $7;
    $221 = $220 + 8 | 0;
    $222 = HEAP32[$221 >> 2] | 0;
    $223 = $14;
    $224 = $222 + $223 | 0;
    $225 = $219 - $224 | 0;
    $226 = $11;
    $227 = Math_imul($225, $226) | 0;
    _memset($216 | 0, 0, $227 | 0) | 0;
   }
   $228 = $14;
   $229 = $7;
   $230 = $229 + 8 | 0;
   $231 = HEAP32[$230 >> 2] | 0;
   $232 = $231 + $228 | 0;
   HEAP32[$230 >> 2] = $232;
   $3 = 17668;
   $321 = $3;
   STACKTOP = sp;
   return $321 | 0;
  }
 }
 $283 = $7;
 $284 = HEAP32[$283 >> 2] | 0;
 $285 = $7;
 $286 = $285 + 8 | 0;
 $287 = HEAP32[$286 >> 2] | 0;
 $288 = $5;
 $289 = _mp_get_index($284, $287, $288, 0) | 0;
 $18 = $289;
 $290 = $7;
 $291 = HEAP32[$290 >> 2] | 0;
 $292 = ($291 | 0) == (13464 | 0);
 if ($292) {
  $293 = $7;
  $294 = $293 + 4 | 0;
  $295 = HEAP32[$294 >> 2] | 0;
  $296 = $295 >>> 8;
  $297 = $18;
  $298 = $297 + $296 | 0;
  $18 = $298;
  $299 = $6;
  $300 = ($299 | 0) != (4 | 0);
  if ($300) {
   $301 = $7;
   $302 = $301 + 4 | 0;
   $303 = HEAP32[$302 >> 2] | 0;
   $304 = $303 & 255;
   $305 = $304 & 128;
   $306 = ($305 | 0) != 0;
   if (!$306) {
    $3 = 0;
    $321 = $3;
    STACKTOP = sp;
    return $321 | 0;
   }
  }
 }
 $307 = $6;
 $308 = ($307 | 0) == (4 | 0);
 $309 = $7;
 $310 = $309 + 4 | 0;
 $311 = HEAP32[$310 >> 2] | 0;
 $312 = $311 & 255;
 $313 = $312 & 127;
 $314 = $313 & 255;
 $315 = $7;
 $316 = $315 + 12 | 0;
 $317 = HEAP32[$316 >> 2] | 0;
 $318 = $18;
 if ($308) {
  $319 = _mp_binary_get_val_array($314, $317, $318) | 0;
  $3 = $319;
  $321 = $3;
  STACKTOP = sp;
  return $321 | 0;
 } else {
  $320 = $6;
  _mp_binary_set_val_array($314, $317, $318, $320);
  $3 = 17668;
  $321 = $3;
  STACKTOP = sp;
  return $321 | 0;
 }
 return 0 | 0;
}

function _mp_call_prepare_args_n_kw_var($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $spec$store$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(144 | 0);
 $18 = sp + 76 | 0;
 $19 = sp + 72 | 0;
 $20 = sp + 56 | 0;
 $27 = sp + 16 | 0;
 $32 = $0 & 1;
 $4 = $32;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $33 = $6;
 $34 = $33 + 4 | 0;
 $6 = $34;
 $35 = HEAP32[$33 >> 2] | 0;
 $8 = $35;
 $9 = 0;
 $36 = $4;
 $37 = $36 & 1;
 if ($37) {
  $38 = $6;
  $39 = $38 + 4 | 0;
  $6 = $39;
  $40 = HEAP32[$38 >> 2] | 0;
  $9 = $40;
 }
 $41 = $5;
 $42 = $41 & 255;
 $10 = $42;
 $43 = $5;
 $44 = $43 >>> 8;
 $45 = $44 & 255;
 $11 = $45;
 $46 = $6;
 $47 = $10;
 $48 = $11;
 $49 = $48 << 1;
 $50 = $47 + $49 | 0;
 $51 = $46 + ($50 << 2) | 0;
 $52 = HEAP32[$51 >> 2] | 0;
 $12 = $52;
 $53 = $6;
 $54 = $10;
 $55 = $11;
 $56 = $55 << 1;
 $57 = $54 + $56 | 0;
 $58 = $57 + 1 | 0;
 $59 = $53 + ($58 << 2) | 0;
 $60 = HEAP32[$59 >> 2] | 0;
 $13 = $60;
 $16 = 0;
 $17 = 0;
 $61 = $13;
 $62 = ($61 | 0) != (0 | 0);
 if ($62) {
  $63 = $13;
  $64 = _mp_obj_is_obj_729($63) | 0;
  if ($64) {
   $65 = $13;
   $66 = HEAP32[$65 >> 2] | 0;
   $67 = ($66 | 0) == (14112 | 0);
   if ($67) {
    $68 = $13;
    $69 = _mp_obj_dict_len($68) | 0;
    $17 = $69;
   }
  }
 }
 $70 = $12;
 $71 = ($70 | 0) == (0 | 0);
 L9 : do {
  if ($71) {
   $72 = $10;
   $73 = 1 + $72 | 0;
   $74 = $11;
   $75 = $17;
   $76 = $74 + $75 | 0;
   $77 = $76 << 1;
   $78 = $73 + $77 | 0;
   $15 = $78;
   $79 = $15;
   $80 = $79 << 2;
   $81 = _mp_nonlocal_alloc($80) | 0;
   $14 = $81;
   $82 = $9;
   $83 = ($82 | 0) != (0 | 0);
   if ($83) {
    $84 = $9;
    $85 = $14;
    $86 = $16;
    $87 = $86 + 1 | 0;
    $16 = $87;
    $88 = $85 + ($86 << 2) | 0;
    HEAP32[$88 >> 2] = $84;
   }
   $89 = $14;
   $90 = $16;
   $91 = $89 + ($90 << 2) | 0;
   $92 = $6;
   $93 = $10;
   $94 = $93 << 2;
   _memcpy($91 | 0, $92 | 0, $94 | 0) | 0;
   $95 = $10;
   $96 = $16;
   $97 = $96 + $95 | 0;
   $16 = $97;
  } else {
   $98 = $12;
   $99 = _mp_obj_is_obj_729($98) | 0;
   if ($99) {
    $100 = $12;
    $101 = HEAP32[$100 >> 2] | 0;
    $102 = ($101 | 0) == (18952 | 0);
    if (!$102) {
     label = 13;
    }
   } else {
    label = 13;
   }
   do {
    if ((label | 0) == 13) {
     $103 = $12;
     $104 = _mp_obj_is_obj_729($103) | 0;
     if ($104) {
      $105 = $12;
      $106 = HEAP32[$105 >> 2] | 0;
      $107 = ($106 | 0) == (17028 | 0);
      if ($107) {
       break;
      }
     }
     $147 = $10;
     $148 = 1 + $147 | 0;
     $149 = $11;
     $150 = $17;
     $151 = $149 + $150 | 0;
     $152 = $151 << 1;
     $153 = $148 + $152 | 0;
     $154 = $153 + 3 | 0;
     $15 = $154;
     $155 = $15;
     $156 = $155 << 2;
     $157 = _mp_nonlocal_alloc($156) | 0;
     $14 = $157;
     $158 = $9;
     $159 = ($158 | 0) != (0 | 0);
     if ($159) {
      $160 = $9;
      $161 = $14;
      $162 = $16;
      $163 = $162 + 1 | 0;
      $16 = $163;
      $164 = $161 + ($162 << 2) | 0;
      HEAP32[$164 >> 2] = $160;
     }
     $165 = $14;
     $166 = $16;
     $167 = $165 + ($166 << 2) | 0;
     $168 = $6;
     $169 = $10;
     $170 = $169 << 2;
     _memcpy($167 | 0, $168 | 0, $170 | 0) | 0;
     $171 = $10;
     $172 = $16;
     $173 = $172 + $171 | 0;
     $16 = $173;
     $174 = $12;
     $175 = _mp_getiter($174, $20) | 0;
     $21 = $175;
     while (1) {
      $176 = $21;
      $177 = _mp_iternext($176) | 0;
      $22 = $177;
      $178 = ($177 | 0) != (0 | 0);
      if (!$178) {
       break L9;
      }
      $179 = $16;
      $180 = $15;
      $181 = $179 >>> 0 >= $180 >>> 0;
      if ($181) {
       $182 = $14;
       $183 = $15;
       $184 = $183 << 2;
       $185 = $15;
       $186 = $185 << 1;
       $187 = $186 << 2;
       $188 = _mp_nonlocal_realloc($182, $184, $187) | 0;
       $14 = $188;
       $189 = $15;
       $190 = $189 << 1;
       $15 = $190;
      }
      $191 = $22;
      $192 = $14;
      $193 = $16;
      $194 = $193 + 1 | 0;
      $16 = $194;
      $195 = $192 + ($193 << 2) | 0;
      HEAP32[$195 >> 2] = $191;
     }
    }
   } while (0);
   $108 = $12;
   _mp_obj_get_array($108, $18, $19);
   $109 = $10;
   $110 = 1 + $109 | 0;
   $111 = HEAP32[$18 >> 2] | 0;
   $112 = $110 + $111 | 0;
   $113 = $11;
   $114 = $17;
   $115 = $113 + $114 | 0;
   $116 = $115 << 1;
   $117 = $112 + $116 | 0;
   $15 = $117;
   $118 = $15;
   $119 = $118 << 2;
   $120 = _mp_nonlocal_alloc($119) | 0;
   $14 = $120;
   $121 = $9;
   $122 = ($121 | 0) != (0 | 0);
   if ($122) {
    $123 = $9;
    $124 = $14;
    $125 = $16;
    $126 = $125 + 1 | 0;
    $16 = $126;
    $127 = $124 + ($125 << 2) | 0;
    HEAP32[$127 >> 2] = $123;
   }
   $128 = $14;
   $129 = $16;
   $130 = $128 + ($129 << 2) | 0;
   $131 = $6;
   $132 = $10;
   $133 = $132 << 2;
   _memcpy($130 | 0, $131 | 0, $133 | 0) | 0;
   $134 = $14;
   $135 = $16;
   $136 = $134 + ($135 << 2) | 0;
   $137 = $10;
   $138 = $136 + ($137 << 2) | 0;
   $139 = HEAP32[$19 >> 2] | 0;
   $140 = HEAP32[$18 >> 2] | 0;
   $141 = $140 << 2;
   _memcpy($138 | 0, $139 | 0, $141 | 0) | 0;
   $142 = $10;
   $143 = HEAP32[$18 >> 2] | 0;
   $144 = $142 + $143 | 0;
   $145 = $16;
   $146 = $145 + $144 | 0;
   $16 = $146;
  }
 } while (0);
 $196 = $16;
 $23 = $196;
 $197 = $14;
 $198 = $16;
 $199 = $197 + ($198 << 2) | 0;
 $200 = $6;
 $201 = $10;
 $202 = $200 + ($201 << 2) | 0;
 $203 = $11;
 $204 = $203 << 1;
 $205 = $204 << 2;
 _memcpy($199 | 0, $202 | 0, $205 | 0) | 0;
 $206 = $11;
 $207 = $206 << 1;
 $208 = $16;
 $209 = $208 + $207 | 0;
 $16 = $209;
 $210 = $13;
 $211 = ($210 | 0) == (0 | 0);
 if ($211) {
  $294 = $8;
  $295 = $7;
  HEAP32[$295 >> 2] = $294;
  $296 = $14;
  $297 = $7;
  $298 = $297 + 16 | 0;
  HEAP32[$298 >> 2] = $296;
  $299 = $23;
  $300 = $7;
  $301 = $300 + 4 | 0;
  HEAP32[$301 >> 2] = $299;
  $302 = $16;
  $303 = $23;
  $304 = $302 - $303 | 0;
  $305 = ($304 >>> 0) / 2 & -1;
  $306 = $7;
  $307 = $306 + 8 | 0;
  HEAP32[$307 >> 2] = $305;
  $308 = $15;
  $309 = $7;
  $310 = $309 + 12 | 0;
  HEAP32[$310 >> 2] = $308;
  STACKTOP = sp;
  return;
 }
 $212 = $13;
 $213 = _mp_obj_is_obj_729($212) | 0;
 if ($213) {
  $214 = $13;
  $215 = HEAP32[$214 >> 2] | 0;
  $216 = ($215 | 0) == (14112 | 0);
  if ($216) {
   $217 = $13;
   $218 = _mp_obj_dict_get_map($217) | 0;
   $24 = $218;
   $25 = 0;
   while (1) {
    $219 = $25;
    $220 = $24;
    $221 = $220 + 4 | 0;
    $222 = HEAP32[$221 >> 2] | 0;
    $223 = $219 >>> 0 < $222 >>> 0;
    if (!$223) {
     break;
    }
    $224 = $24;
    $225 = $25;
    $226 = _mp_map_slot_is_filled($224, $225) | 0;
    if ($226) {
     $227 = $24;
     $228 = $227 + 8 | 0;
     $229 = HEAP32[$228 >> 2] | 0;
     $230 = $25;
     $231 = $229 + ($230 << 3) | 0;
     $232 = HEAP32[$231 >> 2] | 0;
     $26 = $232;
     $233 = $26;
     $234 = _mp_obj_is_qstr_728($233) | 0;
     if (!$234) {
      $235 = $26;
      $236 = _mp_obj_str_intern_checked($235) | 0;
      $26 = $236;
     }
     $237 = $26;
     $238 = $14;
     $239 = $16;
     $240 = $239 + 1 | 0;
     $16 = $240;
     $241 = $238 + ($239 << 2) | 0;
     HEAP32[$241 >> 2] = $237;
     $242 = $24;
     $243 = $242 + 8 | 0;
     $244 = HEAP32[$243 >> 2] | 0;
     $245 = $25;
     $246 = $244 + ($245 << 3) | 0;
     $247 = $246 + 4 | 0;
     $248 = HEAP32[$247 >> 2] | 0;
     $249 = $14;
     $250 = $16;
     $251 = $250 + 1 | 0;
     $16 = $251;
     $252 = $249 + ($250 << 2) | 0;
     HEAP32[$252 >> 2] = $248;
    }
    $253 = $25;
    $254 = $253 + 1 | 0;
    $25 = $254;
   }
   $294 = $8;
   $295 = $7;
   HEAP32[$295 >> 2] = $294;
   $296 = $14;
   $297 = $7;
   $298 = $297 + 16 | 0;
   HEAP32[$298 >> 2] = $296;
   $299 = $23;
   $300 = $7;
   $301 = $300 + 4 | 0;
   HEAP32[$301 >> 2] = $299;
   $302 = $16;
   $303 = $23;
   $304 = $302 - $303 | 0;
   $305 = ($304 >>> 0) / 2 & -1;
   $306 = $7;
   $307 = $306 + 8 | 0;
   HEAP32[$307 >> 2] = $305;
   $308 = $15;
   $309 = $7;
   $310 = $309 + 12 | 0;
   HEAP32[$310 >> 2] = $308;
   STACKTOP = sp;
   return;
  }
 }
 $255 = $13;
 _mp_load_method($255, 106, $27);
 $256 = _mp_call_method_n_kw(0, 0, $27) | 0;
 $257 = _mp_getiter($256, 0) | 0;
 $28 = $257;
 while (1) {
  $258 = $28;
  $259 = _mp_iternext($258) | 0;
  $29 = $259;
  $260 = ($259 | 0) != (0 | 0);
  if (!$260) {
   break;
  }
  $261 = $16;
  $262 = $261 + 1 | 0;
  $263 = $15;
  $264 = $262 >>> 0 >= $263 >>> 0;
  if ($264) {
   $265 = $15;
   $266 = $265 << 1;
   $30 = $266;
   $267 = $30;
   $268 = $267 >>> 0 < 4;
   $spec$store$select = $268 ? 4 : $266;
   $30 = $spec$store$select;
   $269 = $14;
   $270 = $15;
   $271 = $270 << 2;
   $272 = $30;
   $273 = $272 << 2;
   $274 = _mp_nonlocal_realloc($269, $271, $273) | 0;
   $14 = $274;
   $275 = $30;
   $15 = $275;
  }
  $276 = $29;
  $277 = _mp_obj_is_qstr_728($276) | 0;
  if (!$277) {
   $278 = $29;
   $279 = _mp_obj_str_intern_checked($278) | 0;
   $29 = $279;
  }
  $280 = $13;
  _mp_load_method($280, 15, $27);
  $281 = $29;
  $282 = $27 + 8 | 0;
  HEAP32[$282 >> 2] = $281;
  $283 = _mp_call_method_n_kw(1, 0, $27) | 0;
  $31 = $283;
  $284 = $29;
  $285 = $14;
  $286 = $16;
  $287 = $286 + 1 | 0;
  $16 = $287;
  $288 = $285 + ($286 << 2) | 0;
  HEAP32[$288 >> 2] = $284;
  $289 = $31;
  $290 = $14;
  $291 = $16;
  $292 = $291 + 1 | 0;
  $16 = $292;
  $293 = $290 + ($291 << 2) | 0;
  HEAP32[$293 >> 2] = $289;
 }
 $294 = $8;
 $295 = $7;
 HEAP32[$295 >> 2] = $294;
 $296 = $14;
 $297 = $7;
 $298 = $297 + 16 | 0;
 HEAP32[$298 >> 2] = $296;
 $299 = $23;
 $300 = $7;
 $301 = $300 + 4 | 0;
 HEAP32[$301 >> 2] = $299;
 $302 = $16;
 $303 = $23;
 $304 = $302 - $303 | 0;
 $305 = ($304 >>> 0) / 2 & -1;
 $306 = $7;
 $307 = $306 + 8 | 0;
 HEAP32[$307 >> 2] = $305;
 $308 = $15;
 $309 = $7;
 $310 = $309 + 12 | 0;
 HEAP32[$310 >> 2] = $308;
 STACKTOP = sp;
 return;
}

function _mod_ujson_load($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(96 | 0);
 $3 = sp + 56 | 0;
 $4 = sp + 40 | 0;
 $5 = sp + 24 | 0;
 $1 = $0;
 $16 = $1;
 $17 = _mp_get_stream_raise($16, 1) | 0;
 $2 = $17;
 $18 = $1;
 HEAP32[$3 >> 2] = $18;
 $19 = $3 + 4 | 0;
 $20 = $2;
 $21 = HEAP32[$20 >> 2] | 0;
 HEAP32[$19 >> 2] = $21;
 $22 = $3 + 8 | 0;
 HEAP32[$22 >> 2] = 0;
 $23 = $3 + 12 | 0;
 HEAP8[$23 >> 0] = 0;
 _vstr_init($4, 8);
 $24 = $5 + 8 | 0;
 HEAP32[$24 >> 2] = 0;
 $25 = $5 + 12 | 0;
 HEAP32[$25 >> 2] = 0;
 $6 = 0;
 $7 = 0;
 $8 = 0;
 _ujson_stream_next($3) | 0;
 L1 : while (1) {
  L3 : while (1) {
   $26 = $3 + 12 | 0;
   $27 = HEAP8[$26 >> 0] | 0;
   $28 = $27 & 255;
   $29 = ($28 | 0) == 0;
   if ($29) {
    label = 70;
    break L1;
   }
   $9 = 0;
   $10 = 0;
   $30 = $3 + 12 | 0;
   $31 = HEAP8[$30 >> 0] | 0;
   $11 = $31;
   _ujson_stream_next($3) | 0;
   $32 = $11;
   $33 = $32 & 255;
   switch ($33 | 0) {
   case 110:
    {
     label = 6;
     break L3;
     break;
    }
   case 102:
    {
     label = 10;
     break L3;
     break;
    }
   case 116:
    {
     label = 15;
     break L3;
     break;
    }
   case 34:
    {
     label = 19;
     break L3;
     break;
    }
   case 57:
   case 56:
   case 55:
   case 54:
   case 53:
   case 52:
   case 51:
   case 50:
   case 49:
   case 48:
   case 45:
    {
     label = 40;
     break L3;
     break;
    }
   case 91:
    {
     label = 52;
     break L3;
     break;
    }
   case 123:
    {
     label = 53;
     break L3;
     break;
    }
   case 13:
   case 10:
   case 9:
   case 32:
   case 58:
   case 44:
    {
     continue L3;
     break;
    }
   case 93:
   case 125:
    {
     break;
    }
   default:
    {
     label = 76;
     break L1;
    }
   }
   $144 = $6;
   $145 = ($144 | 0) == (0 | 0);
   if ($145) {
    label = 76;
    break L1;
   }
   $146 = $5 + 8 | 0;
   $147 = HEAP32[$146 >> 2] | 0;
   $148 = ($147 | 0) == 0;
   if ($148) {
    label = 70;
    break L1;
   }
   $149 = $5 + 8 | 0;
   $150 = HEAP32[$149 >> 2] | 0;
   $151 = $150 - 1 | 0;
   HEAP32[$149 >> 2] = $151;
   $152 = $5 + 12 | 0;
   $153 = HEAP32[$152 >> 2] | 0;
   $154 = $5 + 8 | 0;
   $155 = HEAP32[$154 >> 2] | 0;
   $156 = $153 + ($155 << 2) | 0;
   $157 = HEAP32[$156 >> 2] | 0;
   $6 = $157;
   $158 = $6;
   $159 = _mp_obj_get_type($158) | 0;
   $7 = $159;
  }
  do {
   if ((label | 0) == 6) {
    label = 0;
    $34 = $3 + 12 | 0;
    $35 = HEAP8[$34 >> 0] | 0;
    $36 = $35 & 255;
    $37 = ($36 | 0) == 117;
    if (!$37) {
     label = 76;
     break L1;
    }
    $38 = _ujson_stream_next($3) | 0;
    $39 = $38 & 255;
    $40 = ($39 | 0) == 108;
    if (!$40) {
     label = 76;
     break L1;
    }
    $41 = _ujson_stream_next($3) | 0;
    $42 = $41 & 255;
    $43 = ($42 | 0) == 108;
    if (!$43) {
     label = 76;
     break L1;
    }
    _ujson_stream_next($3) | 0;
    $9 = 17668;
   } else if ((label | 0) == 10) {
    label = 0;
    $44 = $3 + 12 | 0;
    $45 = HEAP8[$44 >> 0] | 0;
    $46 = $45 & 255;
    $47 = ($46 | 0) == 97;
    if (!$47) {
     label = 76;
     break L1;
    }
    $48 = _ujson_stream_next($3) | 0;
    $49 = $48 & 255;
    $50 = ($49 | 0) == 108;
    if (!$50) {
     label = 76;
     break L1;
    }
    $51 = _ujson_stream_next($3) | 0;
    $52 = $51 & 255;
    $53 = ($52 | 0) == 115;
    if (!$53) {
     label = 76;
     break L1;
    }
    $54 = _ujson_stream_next($3) | 0;
    $55 = $54 & 255;
    $56 = ($55 | 0) == 101;
    if (!$56) {
     label = 76;
     break L1;
    }
    _ujson_stream_next($3) | 0;
    $9 = 13856;
   } else if ((label | 0) == 15) {
    label = 0;
    $57 = $3 + 12 | 0;
    $58 = HEAP8[$57 >> 0] | 0;
    $59 = $58 & 255;
    $60 = ($59 | 0) == 114;
    if (!$60) {
     label = 76;
     break L1;
    }
    $61 = _ujson_stream_next($3) | 0;
    $62 = $61 & 255;
    $63 = ($62 | 0) == 117;
    if (!$63) {
     label = 76;
     break L1;
    }
    $64 = _ujson_stream_next($3) | 0;
    $65 = $64 & 255;
    $66 = ($65 | 0) == 101;
    if (!$66) {
     label = 76;
     break L1;
    }
    _ujson_stream_next($3) | 0;
    $9 = 13864;
   } else if ((label | 0) == 19) {
    label = 0;
    _vstr_reset_1488($4);
    while (1) {
     $67 = $3 + 12 | 0;
     $68 = HEAP8[$67 >> 0] | 0;
     $69 = $68 & 255;
     $70 = ($69 | 0) == 0;
     if ($70) {
      $205 = 0;
     } else {
      $71 = $3 + 12 | 0;
      $72 = HEAP8[$71 >> 0] | 0;
      $73 = $72 & 255;
      $74 = ($73 | 0) != 34;
      $205 = $74;
     }
     $75 = $3 + 12 | 0;
     $76 = HEAP8[$75 >> 0] | 0;
     if (!$205) {
      break;
     }
     $12 = $76;
     $77 = $12;
     $78 = $77 & 255;
     $79 = ($78 | 0) == 92;
     L32 : do {
      if ($79) {
       $80 = _ujson_stream_next($3) | 0;
       $12 = $80;
       $81 = $12;
       $82 = $81 & 255;
       switch ($82 | 0) {
       case 98:
        {
         $12 = 8;
         label = 36;
         break L32;
         break;
        }
       case 102:
        {
         $12 = 12;
         label = 36;
         break L32;
         break;
        }
       case 110:
        {
         $12 = 10;
         label = 36;
         break L32;
         break;
        }
       case 114:
        {
         $12 = 13;
         label = 36;
         break L32;
         break;
        }
       case 116:
        {
         $12 = 9;
         label = 36;
         break L32;
         break;
        }
       case 117:
        {
         $13 = 0;
         $14 = 0;
         while (1) {
          $83 = $14;
          $84 = ($83 | 0) < 4;
          if (!$84) {
           break;
          }
          $85 = _ujson_stream_next($3) | 0;
          $86 = $85 & 255;
          $87 = $86 | 32;
          $88 = $87 - 48 | 0;
          $89 = $88 & 255;
          $12 = $89;
          $90 = $12;
          $91 = $90 & 255;
          $92 = ($91 | 0) > 9;
          if ($92) {
           $93 = $12;
           $94 = $93 & 255;
           $95 = $94 - 39 | 0;
           $96 = $95 & 255;
           $12 = $96;
          }
          $97 = $13;
          $98 = $97 << 4;
          $99 = $12;
          $100 = $99 & 255;
          $101 = $98 | $100;
          $13 = $101;
          $102 = $14;
          $103 = $102 + 1 | 0;
          $14 = $103;
         }
         $104 = $13;
         _vstr_add_char($4, $104);
         break L32;
         break;
        }
       default:
        {
         label = 36;
         break L32;
        }
       }
      } else {
       label = 36;
      }
     } while (0);
     if ((label | 0) == 36) {
      label = 0;
      $105 = $12;
      _vstr_add_byte($4, $105);
     }
     _ujson_stream_next($3) | 0;
    }
    $106 = $76 & 255;
    $107 = ($106 | 0) == 0;
    if ($107) {
     label = 76;
     break L1;
    }
    _ujson_stream_next($3) | 0;
    $108 = $4 + 8 | 0;
    $109 = HEAP32[$108 >> 2] | 0;
    $110 = $4 + 4 | 0;
    $111 = HEAP32[$110 >> 2] | 0;
    $112 = _mp_obj_new_str($109, $111) | 0;
    $9 = $112;
   } else if ((label | 0) == 40) {
    label = 0;
    $15 = 0;
    _vstr_reset_1488($4);
    while (1) {
     $113 = $11;
     _vstr_add_byte($4, $113);
     $114 = $3 + 12 | 0;
     $115 = HEAP8[$114 >> 0] | 0;
     $11 = $115;
     $116 = $11;
     $117 = $116 & 255;
     $118 = ($117 | 0) == 46;
     if ($118) {
      label = 44;
     } else {
      $119 = $11;
      $120 = $119 & 255;
      $121 = ($120 | 0) == 69;
      if ($121) {
       label = 44;
      } else {
       $122 = $11;
       $123 = $122 & 255;
       $124 = ($123 | 0) == 101;
       if ($124) {
        label = 44;
       } else {
        $125 = $11;
        $126 = $125 & 255;
        $127 = ($126 | 0) == 43;
        if (!$127) {
         $128 = $11;
         $129 = $128 & 255;
         $130 = ($129 | 0) == 45;
         if (!$130) {
          $131 = $11;
          $132 = $131 & 255;
          $133 = _unichar_isdigit($132) | 0;
          if (!$133) {
           break;
          }
         }
        }
       }
      }
     }
     if ((label | 0) == 44) {
      label = 0;
      $15 = 1;
     }
     _ujson_stream_next($3) | 0;
    }
    $134 = $15;
    $135 = $134 & 1;
    $136 = $4 + 8 | 0;
    $137 = HEAP32[$136 >> 2] | 0;
    $138 = $4 + 4 | 0;
    $139 = HEAP32[$138 >> 2] | 0;
    if ($135) {
     $140 = _mp_parse_num_decimal($137, $139, 0, 0, 0) | 0;
     $9 = $140;
     break;
    } else {
     $141 = _mp_parse_num_integer($137, $139, 10, 0) | 0;
     $9 = $141;
     break;
    }
   } else if ((label | 0) == 52) {
    label = 0;
    $142 = _mp_obj_new_list(0, 0) | 0;
    $9 = $142;
    $10 = 1;
   } else if ((label | 0) == 53) {
    label = 0;
    $143 = _mp_obj_new_dict(0) | 0;
    $9 = $143;
    $10 = 1;
   }
  } while (0);
  $160 = $6;
  $161 = ($160 | 0) == (0 | 0);
  if ($161) {
   $162 = $9;
   $6 = $162;
   $163 = $6;
   $164 = _mp_obj_get_type($163) | 0;
   $7 = $164;
   $165 = $10;
   $166 = $165 & 1;
   if (!$166) {
    label = 70;
    break;
   }
  } else {
   $167 = $7;
   $168 = ($167 | 0) == (17028 | 0);
   do {
    if ($168) {
     $169 = $6;
     $170 = $9;
     _mp_obj_list_append($169, $170) | 0;
    } else {
     $171 = $8;
     $172 = ($171 | 0) == (0 | 0);
     if ($172) {
      $173 = $9;
      $8 = $173;
      $174 = $10;
      $175 = $174 & 1;
      if ($175) {
       label = 76;
       break L1;
      } else {
       break;
      }
     } else {
      $176 = $6;
      $177 = $8;
      $178 = $9;
      _mp_obj_dict_store($176, $177, $178) | 0;
      $8 = 0;
      break;
     }
    }
   } while (0);
   $179 = $10;
   $180 = $179 & 1;
   if ($180) {
    $181 = $5 + 12 | 0;
    $182 = HEAP32[$181 >> 2] | 0;
    $183 = ($182 | 0) == (0 | 0);
    if ($183) {
     _mp_obj_list_init($5, 1);
     $184 = $6;
     $185 = $5 + 12 | 0;
     $186 = HEAP32[$185 >> 2] | 0;
     HEAP32[$186 >> 2] = $184;
    } else {
     $187 = $6;
     _mp_obj_list_append($5, $187) | 0;
    }
    $188 = $9;
    $6 = $188;
    $189 = $6;
    $190 = _mp_obj_get_type($189) | 0;
    $7 = $190;
   }
  }
 }
 if ((label | 0) == 70) {
  while (1) {
   $191 = $3 + 12 | 0;
   $192 = HEAP8[$191 >> 0] | 0;
   $193 = $192 & 255;
   $194 = _unichar_isspace($193) | 0;
   if (!$194) {
    break;
   }
   _ujson_stream_next($3) | 0;
  }
  $195 = $3 + 12 | 0;
  $196 = HEAP8[$195 >> 0] | 0;
  $197 = $196 & 255;
  $198 = ($197 | 0) != 0;
  $199 = $6;
  $200 = ($199 | 0) == (0 | 0);
  $or$cond = $198 | $200;
  if ($or$cond) {
   _mp_raise_ValueError(34639);
  }
  $201 = $5 + 8 | 0;
  $202 = HEAP32[$201 >> 2] | 0;
  $203 = ($202 | 0) != 0;
  if ($203) {
   _mp_raise_ValueError(34639);
  } else {
   _vstr_clear($4);
   $204 = $6;
   STACKTOP = sp;
   return $204 | 0;
  }
 } else if ((label | 0) == 76) {
  _mp_raise_ValueError(34639);
 }
 return 0 | 0;
}

function _compile_expr_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $2 = $0;
 $3 = $1;
 $11 = $3;
 $12 = $11 + 8 | 0;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = ($14 | 0) == 0;
 if ($15) {
  $16 = $2;
  $17 = $16 + 4 | 0;
  $18 = HEAP8[$17 >> 0] | 0;
  $19 = $18 & 255;
  $20 = ($19 | 0) != 0;
  if ($20) {
   $21 = $2;
   $22 = $21 + 36 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   $24 = HEAP32[$23 >> 2] | 0;
   $25 = ($24 | 0) == 0;
   if ($25) {
    $26 = $2;
    _compile_load_id($26, 198);
    $27 = $2;
    $28 = $3;
    $29 = $28 + 8 | 0;
    $30 = HEAP32[$29 >> 2] | 0;
    _compile_node($27, $30);
    $31 = $2;
    $32 = $31 + 40 | 0;
    $33 = HEAP32[$32 >> 2] | 0;
    _mp_emit_bc_call_function($33, 1, 0, 0);
    $34 = $2;
    $35 = $34 + 40 | 0;
    $36 = HEAP32[$35 >> 2] | 0;
    _mp_emit_bc_pop_top($36);
    STACKTOP = sp;
    return;
   }
  }
  $37 = $3;
  $38 = $37 + 8 | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  $40 = $39 & 3;
  $41 = ($40 | 0) != 0;
  if ($41) {
   $42 = $3;
   $43 = $42 + 8 | 0;
   $44 = HEAP32[$43 >> 2] | 0;
   $45 = $44 & 15;
   $46 = ($45 | 0) == 2;
   if (!$46) {
    STACKTOP = sp;
    return;
   }
  }
  $47 = $3;
  $48 = $47 + 8 | 0;
  $49 = HEAP32[$48 >> 2] | 0;
  $50 = ($49 | 0) != 0;
  if ($50) {
   $51 = $3;
   $52 = $51 + 8 | 0;
   $53 = HEAP32[$52 >> 2] | 0;
   $54 = $53 & 3;
   $55 = ($54 | 0) == 0;
   if ($55) {
    $56 = $3;
    $57 = $56 + 8 | 0;
    $58 = HEAP32[$57 >> 2] | 0;
    $59 = $58;
    $60 = $59 + 4 | 0;
    $61 = HEAP32[$60 >> 2] | 0;
    $62 = $61 & 255;
    $63 = ($62 | 0) == 57;
    if ($63) {
     STACKTOP = sp;
     return;
    }
   }
  }
  $64 = $2;
  $65 = $3;
  $66 = $65 + 8 | 0;
  $67 = HEAP32[$66 >> 2] | 0;
  _compile_node($64, $67);
  $68 = $2;
  $69 = $68 + 40 | 0;
  $70 = HEAP32[$69 >> 2] | 0;
  _mp_emit_bc_pop_top($70);
  STACKTOP = sp;
  return;
 }
 $71 = $3;
 $72 = $71 + 8 | 0;
 $73 = $72 + 4 | 0;
 $74 = HEAP32[$73 >> 2] | 0;
 $75 = ($74 | 0) != 0;
 do {
  if ($75) {
   $76 = $3;
   $77 = $76 + 8 | 0;
   $78 = $77 + 4 | 0;
   $79 = HEAP32[$78 >> 2] | 0;
   $80 = $79 & 3;
   $81 = ($80 | 0) == 0;
   if ($81) {
    $82 = $3;
    $83 = $82 + 8 | 0;
    $84 = $83 + 4 | 0;
    $85 = HEAP32[$84 >> 2] | 0;
    $86 = $85;
    $4 = $86;
    $87 = $4;
    $88 = $87 + 4 | 0;
    $89 = HEAP32[$88 >> 2] | 0;
    $90 = $89 & 255;
    $5 = $90;
    $91 = $5;
    $92 = ($91 | 0) == 86;
    if (!$92) {
     $114 = $5;
     $115 = ($114 | 0) == 87;
     if (!$115) {
      break;
     }
     $116 = $4;
     $117 = $116 + 4 | 0;
     $118 = HEAP32[$117 >> 2] | 0;
     $119 = $118 >>> 8;
     $120 = $119 - 1 | 0;
     $7 = $120;
     $121 = $2;
     $122 = $4;
     $123 = $122 + 8 | 0;
     $124 = $7;
     $125 = $123 + ($124 << 2) | 0;
     $126 = HEAP32[$125 >> 2] | 0;
     _compile_node($121, $126);
     $127 = $7;
     $128 = ($127 | 0) > 0;
     if ($128) {
      $129 = $2;
      $130 = $129 + 40 | 0;
      $131 = HEAP32[$130 >> 2] | 0;
      _mp_emit_bc_dup_top($131);
     }
     $132 = $2;
     $133 = $3;
     $134 = $133 + 8 | 0;
     $135 = HEAP32[$134 >> 2] | 0;
     _c_assign($132, $135, 0);
     $8 = 0;
     while (1) {
      $136 = $8;
      $137 = $7;
      $138 = ($136 | 0) < ($137 | 0);
      if (!$138) {
       break;
      }
      $139 = $8;
      $140 = $139 + 1 | 0;
      $141 = $7;
      $142 = ($140 | 0) < ($141 | 0);
      if ($142) {
       $143 = $2;
       $144 = $143 + 40 | 0;
       $145 = HEAP32[$144 >> 2] | 0;
       _mp_emit_bc_dup_top($145);
      }
      $146 = $2;
      $147 = $4;
      $148 = $147 + 8 | 0;
      $149 = $8;
      $150 = $148 + ($149 << 2) | 0;
      $151 = HEAP32[$150 >> 2] | 0;
      _c_assign($146, $151, 0);
      $152 = $8;
      $153 = $152 + 1 | 0;
      $8 = $153;
     }
     STACKTOP = sp;
     return;
    }
    $93 = $2;
    $94 = $3;
    $95 = $94 + 8 | 0;
    $96 = HEAP32[$95 >> 2] | 0;
    _c_assign($93, $96, 1);
    $97 = $2;
    $98 = $4;
    $99 = $98 + 8 | 0;
    $100 = $99 + 4 | 0;
    $101 = HEAP32[$100 >> 2] | 0;
    _compile_node($97, $101);
    $102 = $4;
    $103 = $102 + 8 | 0;
    $104 = HEAP32[$103 >> 2] | 0;
    $105 = $104 >>> 4;
    do {
     switch ($105 | 0) {
     case 87:
      {
       $6 = 9;
       break;
      }
     case 88:
      {
       $6 = 10;
       break;
      }
     case 86:
      {
       $6 = 11;
       break;
      }
     case 90:
      {
       $6 = 12;
       break;
      }
     case 89:
      {
       $6 = 13;
       break;
      }
     case 80:
      {
       $6 = 14;
       break;
      }
     case 81:
      {
       $6 = 15;
       break;
      }
     case 82:
      {
       $6 = 16;
       break;
      }
     case 84:
      {
       $6 = 17;
       break;
      }
     case 83:
      {
       $6 = 18;
       break;
      }
     case 85:
      {
       $6 = 19;
       break;
      }
     default:
      {
       $6 = 20;
      }
     }
    } while (0);
    $106 = $2;
    $107 = $106 + 40 | 0;
    $108 = HEAP32[$107 >> 2] | 0;
    $109 = $6;
    _mp_emit_bc_binary_op($108, $109);
    $110 = $2;
    $111 = $3;
    $112 = $111 + 8 | 0;
    $113 = HEAP32[$112 >> 2] | 0;
    _c_assign($110, $113, 2);
    STACKTOP = sp;
    return;
   }
  }
 } while (0);
 $154 = $3;
 $155 = $154 + 8 | 0;
 $156 = $155 + 4 | 0;
 $157 = HEAP32[$156 >> 2] | 0;
 $158 = ($157 | 0) != 0;
 do {
  if ($158) {
   $159 = $3;
   $160 = $159 + 8 | 0;
   $161 = $160 + 4 | 0;
   $162 = HEAP32[$161 >> 2] | 0;
   $163 = $162 & 3;
   $164 = ($163 | 0) == 0;
   if ($164) {
    $165 = $3;
    $166 = $165 + 8 | 0;
    $167 = $166 + 4 | 0;
    $168 = HEAP32[$167 >> 2] | 0;
    $169 = $168;
    $170 = $169 + 4 | 0;
    $171 = HEAP32[$170 >> 2] | 0;
    $172 = $171 & 255;
    $173 = ($172 | 0) == 6;
    if ($173) {
     $174 = $3;
     $175 = $174 + 8 | 0;
     $176 = HEAP32[$175 >> 2] | 0;
     $177 = ($176 | 0) != 0;
     if ($177) {
      $178 = $3;
      $179 = $178 + 8 | 0;
      $180 = HEAP32[$179 >> 2] | 0;
      $181 = $180 & 3;
      $182 = ($181 | 0) == 0;
      if ($182) {
       $183 = $3;
       $184 = $183 + 8 | 0;
       $185 = HEAP32[$184 >> 2] | 0;
       $186 = $185;
       $187 = $186 + 4 | 0;
       $188 = HEAP32[$187 >> 2] | 0;
       $189 = $188 & 255;
       $190 = ($189 | 0) == 6;
       if ($190) {
        $191 = $3;
        $192 = $191 + 8 | 0;
        $193 = HEAP32[$192 >> 2] | 0;
        $194 = $193;
        $9 = $194;
        $195 = $3;
        $196 = $195 + 8 | 0;
        $197 = $196 + 4 | 0;
        $198 = HEAP32[$197 >> 2] | 0;
        $199 = $198;
        $4 = $199;
        $200 = $9;
        $201 = $200 + 4 | 0;
        $202 = HEAP32[$201 >> 2] | 0;
        $203 = $202 >>> 8;
        $10 = $203;
        $204 = $10;
        $205 = $4;
        $206 = $205 + 4 | 0;
        $207 = HEAP32[$206 >> 2] | 0;
        $208 = $207 >>> 8;
        $209 = ($204 | 0) == ($208 | 0);
        $210 = $10;
        $211 = ($210 | 0) == 2;
        $or$cond = $209 & $211;
        if ($or$cond) {
         $212 = $9;
         $213 = $212 + 8 | 0;
         $214 = HEAP32[$213 >> 2] | 0;
         $215 = ($214 | 0) != 0;
         if ($215) {
          $216 = $9;
          $217 = $216 + 8 | 0;
          $218 = HEAP32[$217 >> 2] | 0;
          $219 = $218 & 3;
          $220 = ($219 | 0) == 0;
          if ($220) {
           $221 = $9;
           $222 = $221 + 8 | 0;
           $223 = HEAP32[$222 >> 2] | 0;
           $224 = $223;
           $225 = $224 + 4 | 0;
           $226 = HEAP32[$225 >> 2] | 0;
           $227 = $226 & 255;
           $228 = ($227 | 0) == 33;
           if ($228) {
            break;
           }
          }
         }
         $229 = $9;
         $230 = $229 + 8 | 0;
         $231 = $230 + 4 | 0;
         $232 = HEAP32[$231 >> 2] | 0;
         $233 = ($232 | 0) != 0;
         if ($233) {
          $234 = $9;
          $235 = $234 + 8 | 0;
          $236 = $235 + 4 | 0;
          $237 = HEAP32[$236 >> 2] | 0;
          $238 = $237 & 3;
          $239 = ($238 | 0) == 0;
          if ($239) {
           $240 = $9;
           $241 = $240 + 8 | 0;
           $242 = $241 + 4 | 0;
           $243 = HEAP32[$242 >> 2] | 0;
           $244 = $243;
           $245 = $244 + 4 | 0;
           $246 = HEAP32[$245 >> 2] | 0;
           $247 = $246 & 255;
           $248 = ($247 | 0) == 33;
           if ($248) {
            break;
           }
          }
         }
         $249 = $2;
         $250 = $4;
         $251 = $250 + 8 | 0;
         $252 = HEAP32[$251 >> 2] | 0;
         _compile_node($249, $252);
         $253 = $2;
         $254 = $4;
         $255 = $254 + 8 | 0;
         $256 = $255 + 4 | 0;
         $257 = HEAP32[$256 >> 2] | 0;
         _compile_node($253, $257);
         $258 = $2;
         $259 = $258 + 40 | 0;
         $260 = HEAP32[$259 >> 2] | 0;
         _mp_emit_bc_rot_two($260);
         $261 = $2;
         $262 = $9;
         $263 = $262 + 8 | 0;
         $264 = HEAP32[$263 >> 2] | 0;
         _c_assign($261, $264, 0);
         $265 = $2;
         $266 = $9;
         $267 = $266 + 8 | 0;
         $268 = $267 + 4 | 0;
         $269 = HEAP32[$268 >> 2] | 0;
         _c_assign($265, $269, 0);
         STACKTOP = sp;
         return;
        }
       }
      }
     }
    }
   }
  }
 } while (0);
 $270 = $2;
 $271 = $3;
 $272 = $271 + 8 | 0;
 $273 = $272 + 4 | 0;
 $274 = HEAP32[$273 >> 2] | 0;
 _compile_node($270, $274);
 $275 = $2;
 $276 = $3;
 $277 = $276 + 8 | 0;
 $278 = HEAP32[$277 >> 2] | 0;
 _c_assign($275, $278, 0);
 STACKTOP = sp;
 return;
}

function ___lgamma_r($0, $1) {
 $0 = +$0;
 $1 = $1 | 0;
 var $$0174 = 0.0, $$0175 = 0.0, $$0176187 = 0.0, $$0176190 = 0.0, $$0176193 = 0.0, $$0178 = 0.0, $$0179186 = 0.0, $$0179189 = 0.0, $$0179192 = 0.0, $$0180 = 0.0, $$0181 = 0.0, $$1 = 0.0, $$1177 = 0.0, $$1182 = 0.0, $$2183 = 0.0, $$3 = 0.0, $$pn = 0.0, $10 = 0.0, $100 = 0.0, $101 = 0.0, $102 = 0.0, $103 = 0.0, $104 = 0.0, $105 = 0.0, $106 = 0.0, $107 = 0.0, $108 = 0.0, $109 = 0.0, $11 = 0.0, $110 = 0.0, $111 = 0.0, $112 = 0.0, $113 = 0.0, $114 = 0.0, $115 = 0.0, $116 = 0.0, $117 = 0.0, $118 = 0.0, $119 = 0.0, $12 = 0.0, $120 = 0, $121 = 0, $122 = 0.0, $123 = 0.0, $124 = 0.0, $125 = 0.0, $126 = 0.0, $127 = 0.0, $128 = 0.0, $129 = 0.0, $13 = 0.0, $130 = 0.0, $131 = 0.0, $132 = 0.0, $133 = 0.0, $134 = 0.0, $135 = 0.0, $136 = 0.0, $137 = 0.0, $138 = 0.0, $139 = 0.0, $14 = 0, $140 = 0.0, $141 = 0.0, $142 = 0.0, $143 = 0.0, $144 = 0.0, $145 = 0.0, $146 = 0.0, $147 = 0.0, $148 = 0.0, $149 = 0.0, $15 = 0.0, $150 = 0.0, $151 = 0.0, $152 = 0.0, $153 = 0.0, $154 = 0.0, $155 = 0.0, $156 = 0.0, $157 = 0.0, $158 = 0.0, $159 = 0.0, $16 = 0.0, $160 = 0.0, $161 = 0.0, $162 = 0.0, $163 = 0, $164 = 0.0, $165 = 0.0, $166 = 0.0, $167 = 0.0, $168 = 0.0, $169 = 0.0, $17 = 0, $170 = 0.0, $171 = 0.0, $172 = 0.0, $173 = 0.0, $174 = 0.0, $175 = 0.0, $176 = 0.0, $177 = 0.0, $178 = 0.0, $179 = 0.0, $18 = 0.0, $180 = 0.0, $181 = 0.0, $182 = 0.0, $183 = 0.0, $184 = 0.0, $185 = 0.0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0, $23 = 0, $24 = 0, $25 = 0.0, $26 = 0.0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0.0, $60 = 0.0, $61 = 0.0, $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0.0, $71 = 0.0, $72 = 0.0, $73 = 0.0, $74 = 0.0, $75 = 0.0, $76 = 0.0, $77 = 0.0, $78 = 0.0, $79 = 0.0, $8 = 0, $80 = 0.0, $81 = 0.0, $82 = 0.0, $83 = 0.0, $84 = 0.0, $85 = 0.0, $86 = 0.0, $87 = 0.0, $88 = 0.0, $89 = 0.0, $9 = 0.0, $90 = 0.0, $91 = 0.0, $92 = 0.0, $93 = 0.0, $94 = 0.0, $95 = 0.0, $96 = 0.0, $97 = 0.0, $98 = 0.0, $99 = 0.0, $spec$select = 0.0, $switch$split12D = 0, $switch$split2D = 0, $switch$split42D = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $2 = HEAP32[tempDoublePtr >> 2] | 0;
 $3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 HEAP32[$1 >> 2] = 1;
 $4 = $3 & 2147483647;
 $5 = $4 >>> 0 > 2146435071;
 do {
  if ($5) {
   $6 = $0 * $0;
   $$0174 = $6;
  } else {
   $7 = $4 >>> 0 < 999292928;
   $8 = ($3 | 0) < 0;
   if ($7) {
    if ($8) {
     $9 = -$0;
     HEAP32[$1 >> 2] = -1;
     $$0175 = $9;
    } else {
     $$0175 = $0;
    }
    $10 = +_log($$0175);
    $11 = -$10;
    $$0174 = $11;
    break;
   }
   if ($8) {
    $12 = -$0;
    $13 = +_sin_pi_61($12);
    $14 = $13 == 0.0;
    if ($14) {
     $15 = $0 - $0;
     $16 = 1.0 / $15;
     $$0174 = $16;
     break;
    }
    $17 = $13 > 0.0;
    if ($17) {
     HEAP32[$1 >> 2] = -1;
     $$0178 = $13;
    } else {
     $18 = -$13;
     $$0178 = $18;
    }
    $19 = $$0178 * $12;
    $20 = 3.141592653589793 / $19;
    $21 = +_log($20);
    $$0180 = $21;
    $$1 = $12;
   } else {
    $$0180 = 0.0;
    $$1 = $0;
   }
   $switch$split2D = ($3 | 0) < 1072693248;
   L20 : do {
    if ($switch$split2D) {
     $switch$split12D = ($3 | 0) < -1073741824;
     if ($switch$split12D) {
      switch ($3 | 0) {
      case -1074790400:
       {
        label = 15;
        break L20;
        break;
       }
      default:
       {
        label = 16;
        break L20;
       }
      }
     } else {
      switch ($3 | 0) {
      case -1073741824:
       {
        label = 15;
        break L20;
        break;
       }
      default:
       {
        label = 16;
        break L20;
       }
      }
     }
    } else {
     $switch$split42D = ($3 | 0) < 1073741824;
     if ($switch$split42D) {
      switch ($3 | 0) {
      case 1072693248:
       {
        label = 15;
        break L20;
        break;
       }
      default:
       {
        label = 16;
        break L20;
       }
      }
     } else {
      switch ($3 | 0) {
      case 1073741824:
       {
        label = 15;
        break L20;
        break;
       }
      default:
       {
        label = 16;
        break L20;
       }
      }
     }
    }
   } while (0);
   if ((label | 0) == 15) {
    $22 = ($2 | 0) == 0;
    if ($22) {
     $$1177 = 0.0;
    } else {
     label = 16;
    }
   }
   L31 : do {
    if ((label | 0) == 16) {
     $23 = $4 >>> 0 < 1073741824;
     if ($23) {
      $24 = $4 >>> 0 < 1072483533;
      do {
       if ($24) {
        $25 = +_log($$1);
        $26 = -$25;
        $27 = $4 >>> 0 > 1072130371;
        if ($27) {
         $$0176187 = $26;
         $$pn = 1.0;
         label = 24;
        } else {
         $32 = $4 >>> 0 > 1070442080;
         $33 = $$1 + -.46163214496836225;
         if ($32) {
          $$0176190 = $26;
          $$0179189 = $33;
          label = 25;
         } else {
          $$0176193 = $26;
          $$0179192 = $$1;
          label = 26;
         }
        }
       } else {
        $28 = $4 >>> 0 > 1073460418;
        if ($28) {
         $$0176187 = 0.0;
         $$pn = 2.0;
         label = 24;
        } else {
         $29 = $4 >>> 0 > 1072936131;
         if ($29) {
          $30 = $$1 + -1.4616321449683622;
          $$0176190 = 0.0;
          $$0179189 = $30;
          label = 25;
          break;
         } else {
          $31 = $$1 + -1.0;
          $$0176193 = 0.0;
          $$0179192 = $31;
          label = 26;
          break;
         }
        }
       }
      } while (0);
      if ((label | 0) == 24) {
       $$0179186 = $$pn - $$1;
       $34 = $$0179186 * $$0179186;
       $35 = $34 * 2.5214456545125733e-05;
       $36 = $35 + 2.2086279071390839e-04;
       $37 = $34 * $36;
       $38 = $37 + 1.1927076318336207e-03;
       $39 = $34 * $38;
       $40 = $39 + .007385550860814029;
       $41 = $34 * $40;
       $42 = $41 + .06735230105312927;
       $43 = $34 * $42;
       $44 = $43 + .07721566490153287;
       $45 = $34 * 4.4864094961891516e-05;
       $46 = $45 + 1.0801156724758394e-04;
       $47 = $34 * $46;
       $48 = $47 + 5.100697921535113e-04;
       $49 = $34 * $48;
       $50 = $49 + 2.8905138367341563e-03;
       $51 = $34 * $50;
       $52 = $51 + .020580808432516733;
       $53 = $34 * $52;
       $54 = $53 + .3224670334241136;
       $55 = $34 * $54;
       $56 = $$0179186 * $44;
       $57 = $56 + $55;
       $58 = $$0179186 * .5;
       $59 = $57 - $58;
       $60 = $$0176187 + $59;
       $$1177 = $60;
       break;
      } else if ((label | 0) == 25) {
       $61 = $$0179189 * $$0179189;
       $62 = $$0179189 * $61;
       $63 = $62 * 3.1563207090362595e-04;
       $64 = $63 + -1.4034646998923284e-03;
       $65 = $62 * $64;
       $66 = $65 + .006100538702462913;
       $67 = $62 * $66;
       $68 = $67 + -.032788541075985965;
       $69 = $62 * $68;
       $70 = $69 + .48383612272381005;
       $71 = $62 * 3.1275416837512086e-04;
       $72 = .000881081882437654 - $71;
       $73 = $62 * $72;
       $74 = $73 + -3.6845201678113826e-03;
       $75 = $62 * $74;
       $76 = $75 + .01797067508118204;
       $77 = $62 * $76;
       $78 = $77 + -.1475877229945939;
       $79 = $62 * 3.355291926355191e-04;
       $80 = $79 + -5.385953053567405e-04;
       $81 = $62 * $80;
       $82 = $81 + 2.2596478090061247e-03;
       $83 = $62 * $82;
       $84 = $83 + -.010314224129834144;
       $85 = $62 * $84;
       $86 = $85 + .06462494023913339;
       $87 = $61 * $70;
       $88 = $$0179189 * $86;
       $89 = $78 + $88;
       $90 = $62 * $89;
       $91 = -3.638676997039505e-18 - $90;
       $92 = $87 - $91;
       $93 = $92 + -.12148629053584961;
       $94 = $$0176190 + $93;
       $$1177 = $94;
       break;
      } else if ((label | 0) == 26) {
       $95 = $$0179192 * .013381091853678766;
       $96 = $95 + .22896372806469245;
       $97 = $$0179192 * $96;
       $98 = $97 + .9777175279633727;
       $99 = $$0179192 * $98;
       $100 = $99 + 1.4549225013723477;
       $101 = $$0179192 * $100;
       $102 = $101 + .6328270640250934;
       $103 = $$0179192 * $102;
       $104 = $103 + -.07721566490153287;
       $105 = $$0179192 * $104;
       $106 = $$0179192 * .003217092422824239;
       $107 = $106 + .10422264559336913;
       $108 = $$0179192 * $107;
       $109 = $108 + .7692851504566728;
       $110 = $$0179192 * $109;
       $111 = $110 + 2.128489763798934;
       $112 = $$0179192 * $111;
       $113 = $112 + 2.4559779371304113;
       $114 = $$0179192 * $113;
       $115 = $114 + 1.0;
       $116 = $$0179192 * .5;
       $117 = $105 / $115;
       $118 = $117 - $116;
       $119 = $$0176193 + $118;
       $$1177 = $119;
       break;
      }
     } else {
      $120 = $4 >>> 0 < 1075838976;
      if (!$120) {
       $163 = $4 >>> 0 < 1133510656;
       $164 = +_log($$1);
       if ($163) {
        $165 = 1.0 / $$1;
        $166 = $165 * $165;
        $167 = $166 * 1.6309293409657527e-03;
        $168 = 8.363399189962821e-04 - $167;
        $169 = $166 * $168;
        $170 = $169 + -.00059518755745034;
        $171 = $166 * $170;
        $172 = $171 + 7.936505586430196e-04;
        $173 = $166 * $172;
        $174 = $173 + -2.7777777772877554e-03;
        $175 = $166 * $174;
        $176 = $175 + .08333333333333297;
        $177 = $165 * $176;
        $178 = $177 + .4189385332046727;
        $179 = $$1 + -.5;
        $180 = $164 + -1.0;
        $181 = $179 * $180;
        $182 = $178 + $181;
        $$1177 = $182;
        break;
       } else {
        $183 = $164 + -1.0;
        $184 = $$1 * $183;
        $$1177 = $184;
        break;
       }
      }
      $121 = ~~$$1;
      $122 = +($121 | 0);
      $123 = $$1 - $122;
      $124 = $123 * 3.194753265841009e-05;
      $125 = $124 + 1.8402845140733772e-03;
      $126 = $123 * $125;
      $127 = $126 + .02664227030336386;
      $128 = $123 * $127;
      $129 = $128 + .14635047265246445;
      $130 = $123 * $129;
      $131 = $130 + .325778796408931;
      $132 = $123 * $131;
      $133 = $132 + .21498241596060885;
      $134 = $123 * $133;
      $135 = $134 + -.07721566490153287;
      $136 = $123 * $135;
      $137 = $123 * 7.326684307446256e-06;
      $138 = $137 + 7.779424963818936e-04;
      $139 = $123 * $138;
      $140 = $139 + .01864591917156529;
      $141 = $123 * $140;
      $142 = $141 + .17193386563280308;
      $143 = $123 * $142;
      $144 = $143 + .7219355475671381;
      $145 = $123 * $144;
      $146 = $145 + 1.3920053346762105;
      $147 = $123 * $146;
      $148 = $147 + 1.0;
      $149 = $123 * .5;
      $150 = $136 / $148;
      $151 = $149 + $150;
      switch ($121 | 0) {
      case 7:
       {
        $152 = $123 + 6.0;
        $$0181 = $152;
        label = 30;
        break;
       }
      case 6:
       {
        $$0181 = 1.0;
        label = 30;
        break;
       }
      case 5:
       {
        $$1182 = 1.0;
        label = 31;
        break;
       }
      case 4:
       {
        $$2183 = 1.0;
        label = 32;
        break;
       }
      case 3:
       {
        $$3 = 1.0;
        break;
       }
      default:
       {
        $$1177 = $151;
        break L31;
       }
      }
      if ((label | 0) == 30) {
       $153 = $123 + 5.0;
       $154 = $153 * $$0181;
       $$1182 = $154;
       label = 31;
      }
      if ((label | 0) == 31) {
       $155 = $123 + 4.0;
       $156 = $155 * $$1182;
       $$2183 = $156;
       label = 32;
      }
      if ((label | 0) == 32) {
       $157 = $123 + 3.0;
       $158 = $157 * $$2183;
       $$3 = $158;
      }
      $159 = $123 + 2.0;
      $160 = $159 * $$3;
      $161 = +_log($160);
      $162 = $151 + $161;
      $$1177 = $162;
      break;
     }
    }
   } while (0);
   $185 = $$0180 - $$1177;
   $spec$select = $8 ? $185 : $$1177;
   $$0174 = $spec$select;
  }
 } while (0);
 return +$$0174;
}

function _compile_scope($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $14 = $5;
 $15 = $14 & 255;
 $16 = $3;
 $17 = $16 + 5 | 0;
 HEAP8[$17 >> 0] = $15;
 $18 = $4;
 $19 = $3;
 $20 = $19 + 36 | 0;
 HEAP32[$20 >> 2] = $18;
 $21 = $3;
 $22 = $21 + 16 | 0;
 HEAP32[$22 >> 2] = 0;
 $23 = $3;
 $24 = $23 + 40 | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = $5;
 $27 = $4;
 _mp_emit_bc_start_pass($25, $26, $27);
 $28 = $3;
 $29 = $28 + 5 | 0;
 $30 = HEAP8[$29 >> 0] | 0;
 $31 = $30 & 255;
 $32 = ($31 | 0) == 1;
 if ($32) {
  $33 = $4;
  $34 = $33 + 36 | 0;
  HEAP16[$34 >> 1] = 0;
  $35 = $4;
  $36 = $35 + 38 | 0;
  HEAP16[$36 >> 1] = 0;
 }
 $37 = $4;
 $38 = $37 + 12 | 0;
 $39 = HEAP32[$38 >> 2] | 0;
 $40 = ($39 | 0) != 0;
 if ($40) {
  $41 = $4;
  $42 = $41 + 12 | 0;
  $43 = HEAP32[$42 >> 2] | 0;
  $44 = $43 & 3;
  $45 = ($44 | 0) == 0;
  if ($45) {
   $46 = $4;
   $47 = $46 + 12 | 0;
   $48 = HEAP32[$47 >> 2] | 0;
   $49 = $48;
   $50 = $49 + 4 | 0;
   $51 = HEAP32[$50 >> 2] | 0;
   $52 = $51 & 255;
   $53 = ($52 | 0) == 60;
   if ($53) {
    $54 = $4;
    $55 = $54 + 12 | 0;
    $56 = HEAP32[$55 >> 2] | 0;
    $57 = $56;
    $6 = $57;
    $58 = $3;
    $59 = $6;
    $60 = $59 + 8 | 0;
    $61 = HEAP32[$60 >> 2] | 0;
    _compile_node($58, $61);
    $62 = $3;
    $63 = $62 + 40 | 0;
    $64 = HEAP32[$63 >> 2] | 0;
    _mp_emit_bc_return_value($64);
    $284 = $3;
    $285 = $284 + 40 | 0;
    $286 = HEAP32[$285 >> 2] | 0;
    _mp_emit_bc_end_pass($286);
    STACKTOP = sp;
    return;
   }
  }
 }
 $65 = $4;
 $66 = HEAP32[$65 >> 2] | 0;
 $67 = ($66 | 0) == 0;
 if ($67) {
  $68 = $3;
  $69 = $68 + 4 | 0;
  $70 = HEAP8[$69 >> 0] | 0;
  $71 = $70 << 24 >> 24 != 0;
  if (!$71) {
   $72 = $3;
   $73 = $4;
   $74 = $73 + 12 | 0;
   $75 = HEAP32[$74 >> 2] | 0;
   _check_for_doc_string($72, $75);
  }
  $76 = $3;
  $77 = $4;
  $78 = $77 + 12 | 0;
  $79 = HEAP32[$78 >> 2] | 0;
  _compile_node($76, $79);
  $80 = $3;
  $81 = $80 + 40 | 0;
  $82 = HEAP32[$81 >> 2] | 0;
  _mp_emit_bc_load_const_tok($82, 14);
  $83 = $3;
  $84 = $83 + 40 | 0;
  $85 = HEAP32[$84 >> 2] | 0;
  _mp_emit_bc_return_value($85);
  $284 = $3;
  $285 = $284 + 40 | 0;
  $286 = HEAP32[$285 >> 2] | 0;
  _mp_emit_bc_end_pass($286);
  STACKTOP = sp;
  return;
 }
 $86 = $4;
 $87 = HEAP32[$86 >> 2] | 0;
 $88 = ($87 | 0) == 7;
 $89 = $4;
 if ($88) {
  $90 = $89 + 12 | 0;
  $91 = HEAP32[$90 >> 2] | 0;
  $92 = $91;
  $7 = $92;
  $93 = $3;
  $94 = $93 + 5 | 0;
  $95 = HEAP8[$94 >> 0] | 0;
  $96 = $95 & 255;
  $97 = ($96 | 0) == 1;
  if ($97) {
   $98 = $3;
   $99 = $98 + 6 | 0;
   HEAP8[$99 >> 0] = 0;
   $100 = $3;
   $101 = $7;
   $102 = $101 + 8 | 0;
   $103 = $102 + 4 | 0;
   $104 = HEAP32[$103 >> 2] | 0;
   _apply_to_single_or_list($100, $104, 67, 487);
  }
  $105 = $3;
  $106 = $7;
  $107 = $106 + 8 | 0;
  $108 = $107 + 12 | 0;
  $109 = HEAP32[$108 >> 2] | 0;
  _compile_node($105, $109);
  $110 = $3;
  $111 = $110 + 40 | 0;
  $112 = HEAP32[$111 >> 2] | 0;
  $113 = _mp_emit_bc_last_emit_was_return_value($112) | 0;
  if ($113) {
   $284 = $3;
   $285 = $284 + 40 | 0;
   $286 = HEAP32[$285 >> 2] | 0;
   _mp_emit_bc_end_pass($286);
   STACKTOP = sp;
   return;
  }
  $114 = $3;
  $115 = $114 + 40 | 0;
  $116 = HEAP32[$115 >> 2] | 0;
  _mp_emit_bc_load_const_tok($116, 14);
  $117 = $3;
  $118 = $117 + 40 | 0;
  $119 = HEAP32[$118 >> 2] | 0;
  _mp_emit_bc_return_value($119);
  $284 = $3;
  $285 = $284 + 40 | 0;
  $286 = HEAP32[$285 >> 2] | 0;
  _mp_emit_bc_end_pass($286);
  STACKTOP = sp;
  return;
 }
 $120 = HEAP32[$89 >> 2] | 0;
 $121 = ($120 | 0) == 2;
 $122 = $4;
 if ($121) {
  $123 = $122 + 12 | 0;
  $124 = HEAP32[$123 >> 2] | 0;
  $125 = $124;
  $8 = $125;
  $126 = $3;
  $127 = $126 + 5 | 0;
  $128 = HEAP8[$127 >> 0] | 0;
  $129 = $128 & 255;
  $130 = ($129 | 0) == 1;
  if ($130) {
   $131 = $3;
   $132 = $131 + 6 | 0;
   HEAP8[$132 >> 0] = 0;
   $133 = $3;
   $134 = $8;
   $135 = $134 + 8 | 0;
   $136 = HEAP32[$135 >> 2] | 0;
   _apply_to_single_or_list($133, $136, 75, 488);
  }
  $137 = $3;
  $138 = $8;
  $139 = $138 + 8 | 0;
  $140 = $139 + 4 | 0;
  $141 = HEAP32[$140 >> 2] | 0;
  _compile_node($137, $141);
  $142 = $4;
  $143 = $142 + 24 | 0;
  $144 = HEAP16[$143 >> 1] | 0;
  $145 = $144 & 65535;
  $146 = $145 & 4;
  $147 = ($146 | 0) != 0;
  if ($147) {
   $148 = $3;
   $149 = $148 + 40 | 0;
   $150 = HEAP32[$149 >> 2] | 0;
   _mp_emit_bc_pop_top($150);
   $151 = $3;
   $152 = $151 + 40 | 0;
   $153 = HEAP32[$152 >> 2] | 0;
   _mp_emit_bc_load_const_tok($153, 14);
  }
  $154 = $3;
  $155 = $154 + 40 | 0;
  $156 = HEAP32[$155 >> 2] | 0;
  _mp_emit_bc_return_value($156);
  $284 = $3;
  $285 = $284 + 40 | 0;
  $286 = HEAP32[$285 >> 2] | 0;
  _mp_emit_bc_end_pass($286);
  STACKTOP = sp;
  return;
 }
 $157 = HEAP32[$122 >> 2] | 0;
 $158 = ($157 | 0) == 3;
 if (!$158) {
  $159 = $4;
  $160 = HEAP32[$159 >> 2] | 0;
  $161 = ($160 | 0) == 4;
  if (!$161) {
   $162 = $4;
   $163 = HEAP32[$162 >> 2] | 0;
   $164 = ($163 | 0) == 5;
   if (!$164) {
    $165 = $4;
    $166 = HEAP32[$165 >> 2] | 0;
    $167 = ($166 | 0) == 6;
    if (!$167) {
     $238 = $4;
     $239 = $238 + 12 | 0;
     $240 = HEAP32[$239 >> 2] | 0;
     $241 = $240;
     $12 = $241;
     $242 = $3;
     $243 = $242 + 5 | 0;
     $244 = HEAP8[$243 >> 0] | 0;
     $245 = $244 & 255;
     $246 = ($245 | 0) == 1;
     if ($246) {
      $247 = $4;
      _scope_find_or_add_id($247, 10, 3) | 0;
     }
     $248 = $3;
     _compile_load_id($248, 23);
     $249 = $3;
     _compile_store_id($249, 22);
     $250 = $3;
     $251 = $250 + 40 | 0;
     $252 = HEAP32[$251 >> 2] | 0;
     $253 = $12;
     $254 = $253 + 8 | 0;
     $255 = HEAP32[$254 >> 2] | 0;
     $256 = $255 >>> 4;
     _mp_emit_bc_load_const_str($252, $256);
     $257 = $3;
     _compile_store_id($257, 26);
     $258 = $3;
     $259 = $12;
     $260 = $259 + 8 | 0;
     $261 = $260 + 8 | 0;
     $262 = HEAP32[$261 >> 2] | 0;
     _check_for_doc_string($258, $262);
     $263 = $3;
     $264 = $12;
     $265 = $264 + 8 | 0;
     $266 = $265 + 8 | 0;
     $267 = HEAP32[$266 >> 2] | 0;
     _compile_node($263, $267);
     $268 = $4;
     $269 = _scope_find($268, 10) | 0;
     $13 = $269;
     $270 = $13;
     $271 = HEAP8[$270 >> 0] | 0;
     $272 = $271 & 255;
     $273 = ($272 | 0) == 3;
     $274 = $3;
     $275 = $274 + 40 | 0;
     $276 = HEAP32[$275 >> 2] | 0;
     if ($273) {
      _mp_emit_bc_load_const_tok($276, 14);
     } else {
      $277 = $13;
      $278 = $277 + 2 | 0;
      $279 = HEAP16[$278 >> 1] | 0;
      $280 = $279 & 65535;
      _mp_emit_bc_load_local($276, 10, $280, 0);
     }
     $281 = $3;
     $282 = $281 + 40 | 0;
     $283 = HEAP32[$282 >> 2] | 0;
     _mp_emit_bc_return_value($283);
     $284 = $3;
     $285 = $284 + 40 | 0;
     $286 = HEAP32[$285 >> 2] | 0;
     _mp_emit_bc_end_pass($286);
     STACKTOP = sp;
     return;
    }
   }
  }
 }
 $168 = $4;
 $169 = $168 + 12 | 0;
 $170 = HEAP32[$169 >> 2] | 0;
 $171 = $170;
 $9 = $171;
 $172 = $9;
 $173 = $172 + 8 | 0;
 $174 = $173 + 4 | 0;
 $175 = HEAP32[$174 >> 2] | 0;
 $176 = $175;
 $10 = $176;
 $11 = 1;
 $177 = $3;
 $178 = $177 + 5 | 0;
 $179 = HEAP8[$178 >> 0] | 0;
 $180 = $179 & 255;
 $181 = ($180 | 0) == 1;
 if ($181) {
  $182 = $3;
  $183 = $182 + 36 | 0;
  $184 = HEAP32[$183 >> 2] | 0;
  $185 = $11;
  _scope_find_or_add_id($184, $185, 3) | 0;
  $186 = $4;
  $187 = $186 + 28 | 0;
  HEAP16[$187 >> 1] = 1;
 }
 $188 = $4;
 $189 = HEAP32[$188 >> 2] | 0;
 $190 = ($189 | 0) == 3;
 do {
  if ($190) {
   $191 = $3;
   $192 = $191 + 40 | 0;
   $193 = HEAP32[$192 >> 2] | 0;
   _mp_emit_bc_build($193, 0, 1);
  } else {
   $194 = $4;
   $195 = HEAP32[$194 >> 2] | 0;
   $196 = ($195 | 0) == 4;
   if ($196) {
    $197 = $3;
    $198 = $197 + 40 | 0;
    $199 = HEAP32[$198 >> 2] | 0;
    _mp_emit_bc_build($199, 0, 3);
    break;
   }
   $200 = $4;
   $201 = HEAP32[$200 >> 2] | 0;
   $202 = ($201 | 0) == 5;
   if ($202) {
    $203 = $3;
    $204 = $203 + 40 | 0;
    $205 = HEAP32[$204 >> 2] | 0;
    _mp_emit_bc_build($205, 0, 6);
   }
  }
 } while (0);
 $206 = $4;
 $207 = HEAP32[$206 >> 2] | 0;
 $208 = ($207 | 0) == 6;
 $209 = $3;
 if ($208) {
  $210 = $209 + 40 | 0;
  $211 = HEAP32[$210 >> 2] | 0;
  _mp_emit_bc_load_null($211);
  $212 = $3;
  $213 = $11;
  _compile_load_id($212, $213);
  $214 = $3;
  $215 = $214 + 40 | 0;
  $216 = HEAP32[$215 >> 2] | 0;
  _mp_emit_bc_load_null($216);
  $217 = $3;
  $218 = $217 + 40 | 0;
  $219 = HEAP32[$218 >> 2] | 0;
  _mp_emit_bc_load_null($219);
 } else {
  $220 = $11;
  _compile_load_id($209, $220);
  $221 = $3;
  $222 = $221 + 40 | 0;
  $223 = HEAP32[$222 >> 2] | 0;
  _mp_emit_bc_get_iter($223, 1);
 }
 $224 = $3;
 $225 = $10;
 $226 = $9;
 $227 = $226 + 8 | 0;
 $228 = HEAP32[$227 >> 2] | 0;
 _compile_scope_comp_iter($224, $225, $228, 0);
 $229 = $4;
 $230 = HEAP32[$229 >> 2] | 0;
 $231 = ($230 | 0) == 6;
 if ($231) {
  $232 = $3;
  $233 = $232 + 40 | 0;
  $234 = HEAP32[$233 >> 2] | 0;
  _mp_emit_bc_load_const_tok($234, 14);
 }
 $235 = $3;
 $236 = $235 + 40 | 0;
 $237 = HEAP32[$236 >> 2] | 0;
 _mp_emit_bc_return_value($237);
 $284 = $3;
 $285 = $284 + 40 | 0;
 $286 = HEAP32[$285 >> 2] | 0;
 _mp_emit_bc_end_pass($286);
 STACKTOP = sp;
 return;
}

function _mp_map_lookup($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $17 = $4;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $18 & 1;
 $20 = ($19 | 0) != 0;
 $21 = $20 & 1;
 $7 = $21;
 $22 = $7;
 $23 = $22 & 1;
 do {
  if ($23) {
   $24 = $5;
   $25 = _mp_obj_is_qstr_780($24) | 0;
   if (!$25) {
    $26 = $5;
    $27 = _mp_obj_is_obj_781($26) | 0;
    if ($27) {
     $28 = $5;
     $29 = HEAP32[$28 >> 2] | 0;
     $30 = ($29 | 0) == (18680 | 0);
     if ($30) {
      $7 = 0;
      break;
     }
    }
    $31 = $6;
    $32 = ($31 | 0) != 1;
    if ($32) {
     $3 = 0;
     $291 = $3;
     STACKTOP = sp;
     return $291 | 0;
    }
   }
  }
 } while (0);
 $33 = $4;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = $34 >>> 2;
 $36 = $35 & 1;
 $37 = ($36 | 0) != 0;
 $38 = $4;
 if ($37) {
  $39 = $38 + 8 | 0;
  $40 = HEAP32[$39 >> 2] | 0;
  $8 = $40;
  $41 = $4;
  $42 = $41 + 8 | 0;
  $43 = HEAP32[$42 >> 2] | 0;
  $44 = $4;
  $45 = HEAP32[$44 >> 2] | 0;
  $46 = $45 >>> 3;
  $47 = $43 + ($46 << 3) | 0;
  $9 = $47;
  while (1) {
   $48 = $8;
   $49 = $9;
   $50 = $48 >>> 0 < $49 >>> 0;
   if (!$50) {
    break;
   }
   $51 = $8;
   $52 = HEAP32[$51 >> 2] | 0;
   $53 = $5;
   $54 = ($52 | 0) == ($53 | 0);
   if ($54) {
    label = 14;
    break;
   }
   $55 = $7;
   $56 = $55 & 1;
   if (!$56) {
    $57 = $8;
    $58 = HEAP32[$57 >> 2] | 0;
    $59 = $5;
    $60 = _mp_obj_equal($58, $59) | 0;
    if ($60) {
     label = 14;
     break;
    }
   }
   $98 = $8;
   $99 = $98 + 8 | 0;
   $8 = $99;
  }
  if ((label | 0) == 14) {
   $61 = $6;
   $62 = ($61 | 0) == 2;
   if ($62) {
    $63 = $8;
    $64 = $63 + 4 | 0;
    $65 = HEAP32[$64 >> 2] | 0;
    $10 = $65;
    $66 = $4;
    $67 = HEAP32[$66 >> 2] | 0;
    $68 = $67 >>> 3;
    $69 = $68 + -1 | 0;
    $70 = HEAP32[$66 >> 2] | 0;
    $71 = $69 & 536870911;
    $72 = $71 << 3;
    $73 = $70 & 7;
    $74 = $73 | $72;
    HEAP32[$66 >> 2] = $74;
    $75 = $8;
    $76 = $8;
    $77 = $76 + 8 | 0;
    $78 = $9;
    $79 = $8;
    $80 = $78;
    $81 = $79;
    $82 = $80 - $81 | 0;
    $83 = ($82 | 0) / 8 & -1;
    $84 = $83 - 1 | 0;
    $85 = $84 << 3;
    _memmove($75 | 0, $77 | 0, $85 | 0) | 0;
    $86 = $4;
    $87 = $86 + 8 | 0;
    $88 = HEAP32[$87 >> 2] | 0;
    $89 = $4;
    $90 = HEAP32[$89 >> 2] | 0;
    $91 = $90 >>> 3;
    $92 = $88 + ($91 << 3) | 0;
    $8 = $92;
    $93 = $8;
    HEAP32[$93 >> 2] = 0;
    $94 = $10;
    $95 = $8;
    $96 = $95 + 4 | 0;
    HEAP32[$96 >> 2] = $94;
   }
   $97 = $8;
   $3 = $97;
   $291 = $3;
   STACKTOP = sp;
   return $291 | 0;
  }
  $100 = $6;
  $101 = ($100 | 0) != 1;
  if ($101) {
   $3 = 0;
   $291 = $3;
   STACKTOP = sp;
   return $291 | 0;
  }
  $102 = $4;
  $103 = HEAP32[$102 >> 2] | 0;
  $104 = $103 >>> 3;
  $105 = $4;
  $106 = $105 + 4 | 0;
  $107 = HEAP32[$106 >> 2] | 0;
  $108 = ($104 | 0) == ($107 | 0);
  if ($108) {
   $109 = $4;
   $110 = $109 + 4 | 0;
   $111 = HEAP32[$110 >> 2] | 0;
   $112 = $111 + 4 | 0;
   HEAP32[$110 >> 2] = $112;
   $113 = $4;
   $114 = $113 + 8 | 0;
   $115 = HEAP32[$114 >> 2] | 0;
   $116 = $4;
   $117 = $116 + 4 | 0;
   $118 = HEAP32[$117 >> 2] | 0;
   $119 = $118 << 3;
   $120 = _m_realloc($115, $119) | 0;
   $121 = $4;
   $122 = $121 + 8 | 0;
   HEAP32[$122 >> 2] = $120;
   $123 = $4;
   $124 = $123 + 8 | 0;
   $125 = HEAP32[$124 >> 2] | 0;
   $126 = $4;
   $127 = HEAP32[$126 >> 2] | 0;
   $128 = $127 >>> 3;
   $129 = $128 << 3;
   $130 = $125 + $129 | 0;
   $131 = $4;
   $132 = $131 + 4 | 0;
   $133 = HEAP32[$132 >> 2] | 0;
   $134 = $4;
   $135 = HEAP32[$134 >> 2] | 0;
   $136 = $135 >>> 3;
   $137 = $133 - $136 | 0;
   $138 = $137 << 3;
   _memset($130 | 0, 0, $138 | 0) | 0;
  }
  $139 = $4;
  $140 = $139 + 8 | 0;
  $141 = HEAP32[$140 >> 2] | 0;
  $142 = $4;
  $143 = HEAP32[$142 >> 2] | 0;
  $144 = $143 >>> 3;
  $145 = $144 + 1 | 0;
  $146 = HEAP32[$142 >> 2] | 0;
  $147 = $145 & 536870911;
  $148 = $147 << 3;
  $149 = $146 & 7;
  $150 = $149 | $148;
  HEAP32[$142 >> 2] = $150;
  $151 = $141 + ($144 << 3) | 0;
  $11 = $151;
  $152 = $5;
  $153 = $11;
  HEAP32[$153 >> 2] = $152;
  $154 = $5;
  $155 = _mp_obj_is_qstr_780($154) | 0;
  if (!$155) {
   $156 = $4;
   $157 = HEAP32[$156 >> 2] | 0;
   $158 = $157 & -2;
   HEAP32[$156 >> 2] = $158;
  }
  $159 = $11;
  $3 = $159;
  $291 = $3;
  STACKTOP = sp;
  return $291 | 0;
 }
 $160 = $38 + 4 | 0;
 $161 = HEAP32[$160 >> 2] | 0;
 $162 = ($161 | 0) == 0;
 do {
  if ($162) {
   $163 = $6;
   $164 = ($163 | 0) == 1;
   if ($164) {
    $165 = $4;
    _mp_map_rehash($165);
    break;
   }
   $3 = 0;
   $291 = $3;
   STACKTOP = sp;
   return $291 | 0;
  }
 } while (0);
 $166 = $5;
 $167 = _mp_obj_is_qstr_780($166) | 0;
 $168 = $5;
 if ($167) {
  $169 = $168;
  $170 = $169 >>> 2;
  $171 = _qstr_hash($170) | 0;
  $12 = $171;
 } else {
  $172 = _mp_unary_op(6, $168) | 0;
  $173 = $172;
  $174 = $173 >> 1;
  $12 = $174;
 }
 $175 = $12;
 $176 = $4;
 $177 = $176 + 4 | 0;
 $178 = HEAP32[$177 >> 2] | 0;
 $179 = ($175 >>> 0) % ($178 >>> 0) & -1;
 $13 = $179;
 $180 = $13;
 $14 = $180;
 $15 = 0;
 while (1) {
  $181 = $4;
  $182 = $181 + 8 | 0;
  $183 = HEAP32[$182 >> 2] | 0;
  $184 = $13;
  $185 = $183 + ($184 << 3) | 0;
  $16 = $185;
  $186 = $16;
  $187 = HEAP32[$186 >> 2] | 0;
  $188 = ($187 | 0) == (0 | 0);
  if ($188) {
   label = 34;
   break;
  }
  $213 = $16;
  $214 = HEAP32[$213 >> 2] | 0;
  $215 = ($214 | 0) == (4 | 0);
  if ($215) {
   $216 = $15;
   $217 = ($216 | 0) == (0 | 0);
   if ($217) {
    $218 = $16;
    $15 = $218;
   }
  } else {
   $219 = $16;
   $220 = HEAP32[$219 >> 2] | 0;
   $221 = $5;
   $222 = ($220 | 0) == ($221 | 0);
   if ($222) {
    label = 47;
    break;
   }
   $223 = $7;
   $224 = $223 & 1;
   if (!$224) {
    $225 = $16;
    $226 = HEAP32[$225 >> 2] | 0;
    $227 = $5;
    $228 = _mp_obj_equal($226, $227) | 0;
    if ($228) {
     label = 47;
     break;
    }
   }
  }
  $254 = $13;
  $255 = $254 + 1 | 0;
  $256 = $4;
  $257 = $256 + 4 | 0;
  $258 = HEAP32[$257 >> 2] | 0;
  $259 = ($255 >>> 0) % ($258 >>> 0) & -1;
  $13 = $259;
  $260 = $13;
  $261 = $14;
  $262 = ($260 | 0) == ($261 | 0);
  if ($262) {
   $263 = $6;
   $264 = ($263 | 0) == 1;
   if (!$264) {
    label = 59;
    break;
   }
   $265 = $15;
   $266 = ($265 | 0) != (0 | 0);
   $267 = $4;
   if ($266) {
    label = 55;
    break;
   }
   _mp_map_rehash($267);
   $286 = $12;
   $287 = $4;
   $288 = $287 + 4 | 0;
   $289 = HEAP32[$288 >> 2] | 0;
   $290 = ($286 >>> 0) % ($289 >>> 0) & -1;
   $13 = $290;
   $14 = $290;
  }
 }
 if ((label | 0) == 34) {
  $189 = $6;
  $190 = ($189 | 0) == 1;
  if (!$190) {
   $3 = 0;
   $291 = $3;
   STACKTOP = sp;
   return $291 | 0;
  }
  $191 = $4;
  $192 = HEAP32[$191 >> 2] | 0;
  $193 = $192 >>> 3;
  $194 = $193 + 1 | 0;
  $195 = HEAP32[$191 >> 2] | 0;
  $196 = $194 & 536870911;
  $197 = $196 << 3;
  $198 = $195 & 7;
  $199 = $198 | $197;
  HEAP32[$191 >> 2] = $199;
  $200 = $15;
  $201 = ($200 | 0) == (0 | 0);
  if ($201) {
   $202 = $16;
   $15 = $202;
  }
  $203 = $5;
  $204 = $15;
  HEAP32[$204 >> 2] = $203;
  $205 = $15;
  $206 = $205 + 4 | 0;
  HEAP32[$206 >> 2] = 0;
  $207 = $5;
  $208 = _mp_obj_is_qstr_780($207) | 0;
  if (!$208) {
   $209 = $4;
   $210 = HEAP32[$209 >> 2] | 0;
   $211 = $210 & -2;
   HEAP32[$209 >> 2] = $211;
  }
  $212 = $15;
  $3 = $212;
  $291 = $3;
  STACKTOP = sp;
  return $291 | 0;
 } else if ((label | 0) == 47) {
  $229 = $6;
  $230 = ($229 | 0) == 2;
  do {
   if ($230) {
    $231 = $4;
    $232 = HEAP32[$231 >> 2] | 0;
    $233 = $232 >>> 3;
    $234 = $233 + -1 | 0;
    $235 = HEAP32[$231 >> 2] | 0;
    $236 = $234 & 536870911;
    $237 = $236 << 3;
    $238 = $235 & 7;
    $239 = $238 | $237;
    HEAP32[$231 >> 2] = $239;
    $240 = $4;
    $241 = $240 + 8 | 0;
    $242 = HEAP32[$241 >> 2] | 0;
    $243 = $13;
    $244 = $243 + 1 | 0;
    $245 = $4;
    $246 = $245 + 4 | 0;
    $247 = HEAP32[$246 >> 2] | 0;
    $248 = ($244 >>> 0) % ($247 >>> 0) & -1;
    $249 = $242 + ($248 << 3) | 0;
    $250 = HEAP32[$249 >> 2] | 0;
    $251 = ($250 | 0) == (0 | 0);
    $252 = $16;
    if ($251) {
     HEAP32[$252 >> 2] = 0;
     break;
    } else {
     HEAP32[$252 >> 2] = 4;
     break;
    }
   }
  } while (0);
  $253 = $16;
  $3 = $253;
  $291 = $3;
  STACKTOP = sp;
  return $291 | 0;
 } else if ((label | 0) == 55) {
  $268 = HEAP32[$267 >> 2] | 0;
  $269 = $268 >>> 3;
  $270 = $269 + 1 | 0;
  $271 = HEAP32[$267 >> 2] | 0;
  $272 = $270 & 536870911;
  $273 = $272 << 3;
  $274 = $271 & 7;
  $275 = $274 | $273;
  HEAP32[$267 >> 2] = $275;
  $276 = $5;
  $277 = $15;
  HEAP32[$277 >> 2] = $276;
  $278 = $15;
  $279 = $278 + 4 | 0;
  HEAP32[$279 >> 2] = 0;
  $280 = $5;
  $281 = _mp_obj_is_qstr_780($280) | 0;
  if (!$281) {
   $282 = $4;
   $283 = HEAP32[$282 >> 2] | 0;
   $284 = $283 & -2;
   HEAP32[$282 >> 2] = $284;
  }
  $285 = $15;
  $3 = $285;
  $291 = $3;
  STACKTOP = sp;
  return $291 | 0;
 } else if ((label | 0) == 59) {
  $3 = 0;
  $291 = $3;
  STACKTOP = sp;
  return $291 | 0;
 }
 return 0 | 0;
}

function _mp_parse_num_decimal($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0.0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0.0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0.0, $16 = 0, $160 = 0, $161 = 0.0, $162 = 0.0, $163 = 0, $164 = 0.0, $165 = 0.0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0.0, $221 = 0.0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0.0, $229 = 0.0, $23 = 0, $230 = 0.0, $231 = 0.0, $232 = 0.0, $233 = 0.0, $234 = 0.0, $235 = 0.0, $236 = 0, $237 = 0, $238 = 0.0, $239 = 0.0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0.0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0.0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, $or$cond5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $6 = $0;
 $7 = $1;
 $21 = $2 & 1;
 $8 = $21;
 $22 = $3 & 1;
 $9 = $22;
 $10 = $4;
 $23 = $6;
 $24 = $7;
 $25 = $23 + $24 | 0;
 $11 = $25;
 $12 = 0.0;
 $13 = 0;
 $14 = 0;
 while (1) {
  $26 = $6;
  $27 = $11;
  $28 = $26 >>> 0 < $27 >>> 0;
  if (!$28) {
   break;
  }
  $29 = $6;
  $30 = HEAP8[$29 >> 0] | 0;
  $31 = $30 << 24 >> 24;
  $32 = _unichar_isspace($31) | 0;
  if (!$32) {
   break;
  }
  $33 = $6;
  $34 = $33 + 1 | 0;
  $6 = $34;
 }
 $35 = $6;
 $36 = $11;
 $37 = $35 >>> 0 < $36 >>> 0;
 do {
  if ($37) {
   $38 = $6;
   $39 = HEAP8[$38 >> 0] | 0;
   $40 = $39 << 24 >> 24;
   $41 = ($40 | 0) == 43;
   $42 = $6;
   if ($41) {
    $43 = $42 + 1 | 0;
    $6 = $43;
    break;
   }
   $44 = HEAP8[$42 >> 0] | 0;
   $45 = $44 << 24 >> 24;
   $46 = ($45 | 0) == 45;
   if ($46) {
    $47 = $6;
    $48 = $47 + 1 | 0;
    $6 = $48;
    $13 = 1;
   }
  }
 } while (0);
 $49 = $6;
 $15 = $49;
 $50 = $6;
 $51 = $11;
 $52 = $50 >>> 0 < $51 >>> 0;
 if ($52) {
  $53 = $6;
  $54 = HEAP8[$53 >> 0] | 0;
  $55 = $54 << 24 >> 24;
  $56 = $55 | 32;
  $57 = ($56 | 0) == 105;
  if ($57) {
   $58 = $6;
   $59 = $58 + 2 | 0;
   $60 = $11;
   $61 = $59 >>> 0 < $60 >>> 0;
   if ($61) {
    $62 = $6;
    $63 = $62 + 1 | 0;
    $64 = HEAP8[$63 >> 0] | 0;
    $65 = $64 << 24 >> 24;
    $66 = $65 | 32;
    $67 = ($66 | 0) == 110;
    if ($67) {
     $68 = $6;
     $69 = $68 + 2 | 0;
     $70 = HEAP8[$69 >> 0] | 0;
     $71 = $70 << 24 >> 24;
     $72 = $71 | 32;
     $73 = ($72 | 0) == 102;
     if ($73) {
      $74 = $6;
      $75 = $74 + 3 | 0;
      $6 = $75;
      $12 = inf;
      $76 = $6;
      $77 = $76 + 4 | 0;
      $78 = $11;
      $79 = $77 >>> 0 < $78 >>> 0;
      if ($79) {
       $80 = $6;
       $81 = HEAP8[$80 >> 0] | 0;
       $82 = $81 << 24 >> 24;
       $83 = $82 | 32;
       $84 = ($83 | 0) == 105;
       if ($84) {
        $85 = $6;
        $86 = $85 + 1 | 0;
        $87 = HEAP8[$86 >> 0] | 0;
        $88 = $87 << 24 >> 24;
        $89 = $88 | 32;
        $90 = ($89 | 0) == 110;
        if ($90) {
         $91 = $6;
         $92 = $91 + 2 | 0;
         $93 = HEAP8[$92 >> 0] | 0;
         $94 = $93 << 24 >> 24;
         $95 = $94 | 32;
         $96 = ($95 | 0) == 105;
         if ($96) {
          $97 = $6;
          $98 = $97 + 3 | 0;
          $99 = HEAP8[$98 >> 0] | 0;
          $100 = $99 << 24 >> 24;
          $101 = $100 | 32;
          $102 = ($101 | 0) == 116;
          if ($102) {
           $103 = $6;
           $104 = $103 + 4 | 0;
           $105 = HEAP8[$104 >> 0] | 0;
           $106 = $105 << 24 >> 24;
           $107 = $106 | 32;
           $108 = ($107 | 0) == 121;
           if ($108) {
            $109 = $6;
            $110 = $109 + 5 | 0;
            $6 = $110;
           }
          }
         }
        }
       }
      }
     }
    }
   }
  } else {
   label = 22;
  }
 } else {
  label = 22;
 }
 do {
  if ((label | 0) == 22) {
   $111 = $6;
   $112 = $11;
   $113 = $111 >>> 0 < $112 >>> 0;
   if ($113) {
    $114 = $6;
    $115 = HEAP8[$114 >> 0] | 0;
    $116 = $115 << 24 >> 24;
    $117 = $116 | 32;
    $118 = ($117 | 0) == 110;
    if ($118) {
     $119 = $6;
     $120 = $119 + 2 | 0;
     $121 = $11;
     $122 = $120 >>> 0 < $121 >>> 0;
     if (!$122) {
      break;
     }
     $123 = $6;
     $124 = $123 + 1 | 0;
     $125 = HEAP8[$124 >> 0] | 0;
     $126 = $125 << 24 >> 24;
     $127 = $126 | 32;
     $128 = ($127 | 0) == 97;
     if (!$128) {
      break;
     }
     $129 = $6;
     $130 = $129 + 2 | 0;
     $131 = HEAP8[$130 >> 0] | 0;
     $132 = $131 << 24 >> 24;
     $133 = $132 | 32;
     $134 = ($133 | 0) == 110;
     if (!$134) {
      break;
     }
     $135 = $6;
     $136 = $135 + 3 | 0;
     $6 = $136;
     $137 = +_nan(41653);
     $12 = $137;
     break;
    }
   }
   $16 = 0;
   $17 = 0;
   $18 = 0;
   $19 = 0;
   L34 : while (1) {
    $138 = $6;
    $139 = $11;
    $140 = $138 >>> 0 < $139 >>> 0;
    if (!$140) {
     break;
    }
    $141 = $6;
    $142 = $141 + 1 | 0;
    $6 = $142;
    $143 = HEAP8[$141 >> 0] | 0;
    $144 = $143 << 24 >> 24;
    $20 = $144;
    $145 = $20;
    $146 = 48 <= $145 >>> 0;
    $147 = $20;
    $148 = $147 >>> 0 <= 57;
    $or$cond = $146 & $148;
    do {
     if ($or$cond) {
      $149 = $20;
      $150 = $149 - 48 | 0;
      $20 = $150;
      $151 = $16;
      $152 = ($151 | 0) == 2;
      if ($152) {
       $153 = $18;
       $154 = ($153 | 0) < 107374181;
       if (!$154) {
        break;
       }
       $155 = $18;
       $156 = $155 * 10 | 0;
       $157 = $20;
       $158 = $156 + $157 | 0;
       $18 = $158;
       break;
      }
      $159 = $12;
      $160 = $159 < 1.e+200;
      if ($160) {
       $161 = $12;
       $162 = 10.0 * $161;
       $163 = $20;
       $164 = +($163 >>> 0);
       $165 = $162 + $164;
       $12 = $165;
       $166 = $16;
       $167 = ($166 | 0) == 1;
       if (!$167) {
        break;
       }
       $168 = $19;
       $169 = $168 + -1 | 0;
       $19 = $169;
       break;
      } else {
       $170 = $16;
       $171 = ($170 | 0) == 0;
       if (!$171) {
        break;
       }
       $172 = $19;
       $173 = $172 + 1 | 0;
       $19 = $173;
       break;
      }
     } else {
      $174 = $16;
      $175 = ($174 | 0) == 0;
      $176 = $20;
      $177 = ($176 | 0) == 46;
      $or$cond3 = $175 & $177;
      if ($or$cond3) {
       $16 = 1;
       break;
      }
      $178 = $16;
      $179 = ($178 | 0) != 2;
      if ($179) {
       $180 = $20;
       $181 = $180 | 32;
       $182 = ($181 | 0) == 101;
       if ($182) {
        $16 = 2;
        $183 = $6;
        $184 = $11;
        $185 = $183 >>> 0 < $184 >>> 0;
        do {
         if ($185) {
          $186 = $6;
          $187 = HEAP8[$186 >> 0] | 0;
          $188 = $187 << 24 >> 24;
          $189 = ($188 | 0) == 43;
          $190 = $6;
          if ($189) {
           $191 = $190 + 1 | 0;
           $6 = $191;
           break;
          }
          $192 = HEAP8[$190 >> 0] | 0;
          $193 = $192 << 24 >> 24;
          $194 = ($193 | 0) == 45;
          if ($194) {
           $195 = $6;
           $196 = $195 + 1 | 0;
           $6 = $196;
           $17 = 1;
          }
         }
        } while (0);
        $197 = $6;
        $198 = $11;
        $199 = ($197 | 0) == ($198 | 0);
        if ($199) {
         label = 76;
         break L34;
        } else {
         break;
        }
       }
      }
      $200 = $8;
      $201 = $200 & 1;
      if ($201) {
       $202 = $20;
       $203 = $202 | 32;
       $204 = ($203 | 0) == 106;
       if ($204) {
        label = 51;
        break L34;
       }
      }
      $205 = $20;
      $206 = ($205 | 0) == 95;
      if (!$206) {
       label = 54;
       break L34;
      }
      continue L34;
     }
    } while (0);
   }
   if ((label | 0) == 51) {
    $14 = 1;
   } else if ((label | 0) == 54) {
    $207 = $6;
    $208 = $207 + -1 | 0;
    $6 = $208;
   } else if ((label | 0) == 76) {
    $264 = _mp_obj_new_exception_msg(16072, 29534) | 0;
    $265 = $10;
    _raise_exc($264, $265);
   }
   $209 = $17;
   $210 = $209 & 1;
   if ($210) {
    $211 = $18;
    $212 = 0 - $211 | 0;
    $18 = $212;
   }
   $213 = $19;
   $214 = $18;
   $215 = $214 + $213 | 0;
   $18 = $215;
   $216 = $18;
   $217 = ($216 | 0) < -307;
   if ($217) {
    $218 = $18;
    $219 = $218 - -307 | 0;
    $18 = $219;
    $220 = $12;
    $221 = $220 * 1.0e-307;
    $12 = $221;
   }
   $222 = $18;
   $223 = ($222 | 0) < 0;
   $224 = $18;
   $225 = ($224 | 0) >= -22;
   $or$cond5 = $223 & $225;
   $226 = $18;
   if ($or$cond5) {
    $227 = 0 - $226 | 0;
    $228 = +($227 | 0);
    $229 = +Math_pow(10.0, +$228);
    $230 = $12;
    $231 = $230 / $229;
    $12 = $231;
    break;
   } else {
    $232 = +($226 | 0);
    $233 = +Math_pow(10.0, +$232);
    $234 = $12;
    $235 = $234 * $233;
    $12 = $235;
    break;
   }
  }
 } while (0);
 $236 = $13;
 $237 = $236 & 1;
 if ($237) {
  $238 = $12;
  $239 = -$238;
  $12 = $239;
 }
 $240 = $6;
 $241 = $15;
 $242 = ($240 | 0) == ($241 | 0);
 if ($242) {
  $264 = _mp_obj_new_exception_msg(16072, 29534) | 0;
  $265 = $10;
  _raise_exc($264, $265);
 }
 while (1) {
  $243 = $6;
  $244 = $11;
  $245 = $243 >>> 0 < $244 >>> 0;
  if (!$245) {
   break;
  }
  $246 = $6;
  $247 = HEAP8[$246 >> 0] | 0;
  $248 = $247 << 24 >> 24;
  $249 = _unichar_isspace($248) | 0;
  if (!$249) {
   break;
  }
  $250 = $6;
  $251 = $250 + 1 | 0;
  $6 = $251;
 }
 $252 = $6;
 $253 = $11;
 $254 = ($252 | 0) != ($253 | 0);
 if ($254) {
  $264 = _mp_obj_new_exception_msg(16072, 29534) | 0;
  $265 = $10;
  _raise_exc($264, $265);
 }
 $255 = $14;
 $256 = $255 & 1;
 if ($256) {
  $257 = $12;
  $258 = _mp_obj_new_complex(0.0, $257) | 0;
  $5 = $258;
  $266 = $5;
  STACKTOP = sp;
  return $266 | 0;
 }
 $259 = $9;
 $260 = $259 & 1;
 $261 = $12;
 if ($260) {
  $262 = _mp_obj_new_complex($261, 0.0) | 0;
  $5 = $262;
  $266 = $5;
  STACKTOP = sp;
  return $266 | 0;
 } else {
  $263 = _mp_obj_new_float($261) | 0;
  $5 = $263;
  $266 = $5;
  STACKTOP = sp;
  return $266 | 0;
 }
 return 0 | 0;
}

function _mpn_div($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $288 = 0, $289 = 0, $29 = 0, $290 = 0, $291 = 0, $292 = 0, $293 = 0, $294 = 0, $295 = 0, $296 = 0, $297 = 0, $298 = 0, $299 = 0, $30 = 0, $300 = 0, $301 = 0, $302 = 0, $303 = 0, $304 = 0, $305 = 0, $306 = 0, $307 = 0, $308 = 0, $309 = 0, $31 = 0, $310 = 0, $311 = 0, $312 = 0, $313 = 0, $314 = 0, $315 = 0, $316 = 0, $317 = 0, $318 = 0, $319 = 0, $32 = 0, $320 = 0, $321 = 0, $322 = 0, $323 = 0, $324 = 0, $325 = 0, $326 = 0, $327 = 0, $328 = 0, $329 = 0, $33 = 0, $330 = 0, $331 = 0, $332 = 0, $333 = 0, $334 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(96 | 0);
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 $32 = $6;
 $12 = $32;
 $33 = $10;
 $13 = $33;
 $14 = 0;
 $34 = $6;
 $35 = $7;
 $36 = HEAP32[$35 >> 2] | 0;
 $37 = $8;
 $38 = $9;
 $39 = _mpn_cmp($34, $36, $37, $38) | 0;
 $16 = $39;
 $40 = $16;
 $41 = ($40 | 0) == 0;
 if ($41) {
  $42 = $7;
  HEAP32[$42 >> 2] = 0;
  $43 = $10;
  HEAP16[$43 >> 1] = 1;
  $44 = $11;
  HEAP32[$44 >> 2] = 1;
  STACKTOP = sp;
  return;
 }
 $45 = $16;
 $46 = ($45 | 0) < 0;
 if ($46) {
  $47 = $11;
  HEAP32[$47 >> 2] = 0;
  STACKTOP = sp;
  return;
 }
 $48 = $8;
 $49 = $9;
 $50 = $49 - 1 | 0;
 $51 = $48 + ($50 << 1) | 0;
 $52 = HEAP16[$51 >> 1] | 0;
 $17 = $52;
 while (1) {
  $53 = $17;
  $54 = $53 & 65535;
  $55 = $54 & 32768;
  $56 = ($55 | 0) == 0;
  if (!$56) {
   break;
  }
  $57 = $17;
  $58 = $57 & 65535;
  $59 = $58 << 1;
  $60 = $59 & 65535;
  $17 = $60;
  $61 = $14;
  $62 = $61 + 1 << 16 >> 16;
  $14 = $62;
 }
 $63 = $6;
 $64 = $7;
 $65 = HEAP32[$64 >> 2] | 0;
 $66 = $63 + ($65 << 1) | 0;
 HEAP16[$66 >> 1] = 0;
 $67 = $7;
 $68 = HEAP32[$67 >> 2] | 0;
 $69 = $68 + 1 | 0;
 HEAP32[$67 >> 2] = $69;
 $70 = $6;
 $18 = $70;
 $19 = 0;
 while (1) {
  $71 = $18;
  $72 = $6;
  $73 = $7;
  $74 = HEAP32[$73 >> 2] | 0;
  $75 = $72 + ($74 << 1) | 0;
  $76 = $71 >>> 0 < $75 >>> 0;
  if (!$76) {
   break;
  }
  $77 = $18;
  $78 = HEAP16[$77 >> 1] | 0;
  $20 = $78;
  $79 = $20;
  $80 = $79 & 65535;
  $81 = $14;
  $82 = $81 & 65535;
  $83 = $80 << $82;
  $84 = $19;
  $85 = $84 & 65535;
  $86 = $83 | $85;
  $87 = $86 & 65535;
  $88 = $87 & 65535;
  $89 = $18;
  HEAP16[$89 >> 1] = $88;
  $90 = $20;
  $91 = $90 & 65535;
  $92 = $14;
  $93 = $92 & 65535;
  $94 = 16 - $93 | 0;
  $95 = $91 >>> $94;
  $96 = $95 & 65535;
  $19 = $96;
  $97 = $18;
  $98 = $97 + 2 | 0;
  $18 = $98;
 }
 $99 = $8;
 $100 = $9;
 $101 = $100 - 1 | 0;
 $102 = $99 + ($101 << 1) | 0;
 $103 = HEAP16[$102 >> 1] | 0;
 $104 = $103 & 65535;
 $105 = $14;
 $106 = $105 & 65535;
 $107 = $104 << $106;
 $15 = $107;
 $108 = $9;
 $109 = $108 >>> 0 >= 2;
 if ($109) {
  $110 = $8;
  $111 = $9;
  $112 = $111 - 2 | 0;
  $113 = $110 + ($112 << 1) | 0;
  $114 = HEAP16[$113 >> 1] | 0;
  $115 = $114 & 65535;
  $116 = $14;
  $117 = $116 & 65535;
  $118 = 16 - $117 | 0;
  $119 = $115 >>> $118;
  $120 = $15;
  $121 = $120 | $119;
  $15 = $121;
 }
 $122 = $7;
 $123 = HEAP32[$122 >> 2] | 0;
 $124 = $123 - 1 | 0;
 $125 = $6;
 $126 = $125 + ($124 << 1) | 0;
 $6 = $126;
 $127 = $7;
 $128 = HEAP32[$127 >> 2] | 0;
 $129 = $9;
 $130 = $128 - $129 | 0;
 $131 = $11;
 HEAP32[$131 >> 2] = $130;
 $132 = $11;
 $133 = HEAP32[$132 >> 2] | 0;
 $134 = $133 - 1 | 0;
 $135 = $10;
 $136 = $135 + ($134 << 1) | 0;
 $10 = $136;
 while (1) {
  $137 = $7;
  $138 = HEAP32[$137 >> 2] | 0;
  $139 = $9;
  $140 = $138 >>> 0 > $139 >>> 0;
  if (!$140) {
   break;
  }
  $141 = $6;
  $142 = HEAP16[$141 >> 1] | 0;
  $143 = $142 & 65535;
  $144 = $143 << 16;
  $145 = $6;
  $146 = $145 + -2 | 0;
  $147 = HEAP16[$146 >> 1] | 0;
  $148 = $147 & 65535;
  $149 = $144 | $148;
  $21 = $149;
  $150 = $15;
  $151 = $21;
  $152 = ($151 >>> 0) / ($150 >>> 0) & -1;
  $21 = $152;
  $153 = $8;
  $22 = $153;
  $23 = 0;
  $24 = 0;
  $154 = $6;
  $155 = $9;
  $156 = 0 - $155 | 0;
  $157 = $154 + ($156 << 1) | 0;
  $25 = $157;
  while (1) {
   $158 = $25;
   $159 = $6;
   $160 = $158 >>> 0 < $159 >>> 0;
   if (!$160) {
    break;
   }
   $161 = $22;
   $162 = HEAP16[$161 >> 1] | 0;
   $163 = $162 & 65535;
   $164 = $14;
   $165 = $164 & 65535;
   $166 = $163 << $165;
   $167 = $23;
   $168 = $167 >>> 16;
   $169 = $166 | $168;
   $23 = $169;
   $170 = $21;
   $171 = $23;
   $172 = $171 & 65535;
   $173 = Math_imul($170, $172) | 0;
   $26 = $173;
   $174 = $26;
   $175 = $25;
   $176 = HEAP16[$175 >> 1] | 0;
   $177 = $176 & 65535;
   $178 = $174 >>> 0 >= $177 >>> 0;
   if ($178) {
    label = 19;
   } else {
    $179 = $25;
    $180 = HEAP16[$179 >> 1] | 0;
    $181 = $180 & 65535;
    $182 = $26;
    $183 = $181 - $182 | 0;
    $184 = $24;
    $185 = $183 >>> 0 <= $184 >>> 0;
    if ($185) {
     label = 19;
    } else {
     $205 = $25;
     $206 = HEAP16[$205 >> 1] | 0;
     $207 = $206 & 65535;
     $208 = $26;
     $209 = $207 - $208 | 0;
     $210 = $24;
     $211 = $209 - $210 | 0;
     $212 = $211 & 65535;
     $213 = $212 & 65535;
     $214 = $25;
     HEAP16[$214 >> 1] = $213;
     $24 = 0;
    }
   }
   if ((label | 0) == 19) {
    label = 0;
    $186 = $26;
    $187 = $25;
    $188 = HEAP16[$187 >> 1] | 0;
    $189 = $188 & 65535;
    $190 = $186 - $189 | 0;
    $191 = $24;
    $192 = $191 + $190 | 0;
    $24 = $192;
    $193 = $24;
    $194 = 0 - $193 | 0;
    $195 = $194 & 65535;
    $196 = $195 & 65535;
    $197 = $25;
    HEAP16[$197 >> 1] = $196;
    $198 = $24;
    $199 = $198 >>> 16;
    $200 = $24;
    $201 = $200 & 65535;
    $202 = ($201 | 0) == 0;
    $203 = $202 ? 0 : 1;
    $204 = $199 + $203 | 0;
    $24 = $204;
   }
   $215 = $25;
   $216 = $215 + 2 | 0;
   $25 = $216;
   $217 = $22;
   $218 = $217 + 2 | 0;
   $22 = $218;
  }
  $219 = $6;
  $220 = HEAP16[$219 >> 1] | 0;
  $221 = $220 & 65535;
  $222 = $24;
  $223 = $222 - $221 | 0;
  $24 = $223;
  while (1) {
   $224 = $24;
   $225 = ($224 | 0) != 0;
   if (!$225) {
    break;
   }
   $226 = $8;
   $22 = $226;
   $23 = 0;
   $27 = 0;
   $227 = $6;
   $228 = $9;
   $229 = 0 - $228 | 0;
   $230 = $227 + ($229 << 1) | 0;
   $28 = $230;
   while (1) {
    $231 = $28;
    $232 = $6;
    $233 = $231 >>> 0 < $232 >>> 0;
    if (!$233) {
     break;
    }
    $234 = $22;
    $235 = HEAP16[$234 >> 1] | 0;
    $236 = $235 & 65535;
    $237 = $14;
    $238 = $237 & 65535;
    $239 = $236 << $238;
    $240 = $23;
    $241 = $240 >>> 16;
    $242 = $239 | $241;
    $23 = $242;
    $243 = $28;
    $244 = HEAP16[$243 >> 1] | 0;
    $245 = $244 & 65535;
    $246 = $23;
    $247 = $246 & 65535;
    $248 = $245 + $247 | 0;
    $249 = $27;
    $250 = $249 + $248 | 0;
    $27 = $250;
    $251 = $27;
    $252 = $251 & 65535;
    $253 = $252 & 65535;
    $254 = $28;
    HEAP16[$254 >> 1] = $253;
    $255 = $27;
    $256 = $255 >>> 16;
    $27 = $256;
    $257 = $28;
    $258 = $257 + 2 | 0;
    $28 = $258;
    $259 = $22;
    $260 = $259 + 2 | 0;
    $22 = $260;
   }
   $261 = $27;
   $262 = $24;
   $263 = $262 - $261 | 0;
   $24 = $263;
   $264 = $21;
   $265 = $264 + -1 | 0;
   $21 = $265;
  }
  $266 = $21;
  $267 = $266 & 65535;
  $268 = $267 & 65535;
  $269 = $10;
  HEAP16[$269 >> 1] = $268;
  $270 = $10;
  $271 = $270 + -2 | 0;
  $10 = $271;
  $272 = $6;
  $273 = $272 + -2 | 0;
  $6 = $273;
  $274 = $7;
  $275 = HEAP32[$274 >> 2] | 0;
  $276 = $275 + -1 | 0;
  HEAP32[$274 >> 2] = $276;
 }
 $277 = $12;
 $278 = $7;
 $279 = HEAP32[$278 >> 2] | 0;
 $280 = $277 + ($279 << 1) | 0;
 $281 = $280 + -2 | 0;
 $29 = $281;
 $30 = 0;
 while (1) {
  $282 = $29;
  $283 = $12;
  $284 = $282 >>> 0 >= $283 >>> 0;
  if (!$284) {
   break;
  }
  $285 = $29;
  $286 = HEAP16[$285 >> 1] | 0;
  $31 = $286;
  $287 = $31;
  $288 = $287 & 65535;
  $289 = $14;
  $290 = $289 & 65535;
  $291 = $288 >> $290;
  $292 = $30;
  $293 = $292 & 65535;
  $294 = $291 | $293;
  $295 = $294 & 65535;
  $296 = $295 & 65535;
  $297 = $29;
  HEAP16[$297 >> 1] = $296;
  $298 = $31;
  $299 = $298 & 65535;
  $300 = $14;
  $301 = $300 & 65535;
  $302 = 16 - $301 | 0;
  $303 = $299 << $302;
  $304 = $303 & 65535;
  $30 = $304;
  $305 = $29;
  $306 = $305 + -2 | 0;
  $29 = $306;
 }
 while (1) {
  $307 = $11;
  $308 = HEAP32[$307 >> 2] | 0;
  $309 = $308 >>> 0 > 0;
  if (!$309) {
   break;
  }
  $310 = $13;
  $311 = $11;
  $312 = HEAP32[$311 >> 2] | 0;
  $313 = $312 - 1 | 0;
  $314 = $310 + ($313 << 1) | 0;
  $315 = HEAP16[$314 >> 1] | 0;
  $316 = $315 & 65535;
  $317 = ($316 | 0) == 0;
  if (!$317) {
   break;
  }
  $318 = $11;
  $319 = HEAP32[$318 >> 2] | 0;
  $320 = $319 + -1 | 0;
  HEAP32[$318 >> 2] = $320;
 }
 while (1) {
  $321 = $7;
  $322 = HEAP32[$321 >> 2] | 0;
  $323 = $322 >>> 0 > 0;
  if (!$323) {
   label = 40;
   break;
  }
  $324 = $12;
  $325 = $7;
  $326 = HEAP32[$325 >> 2] | 0;
  $327 = $326 - 1 | 0;
  $328 = $324 + ($327 << 1) | 0;
  $329 = HEAP16[$328 >> 1] | 0;
  $330 = $329 & 65535;
  $331 = ($330 | 0) == 0;
  if (!$331) {
   label = 40;
   break;
  }
  $332 = $7;
  $333 = HEAP32[$332 >> 2] | 0;
  $334 = $333 + -1 | 0;
  HEAP32[$332 >> 2] = $334;
 }
 if ((label | 0) == 40) {
  STACKTOP = sp;
  return;
 }
}

function _list_subscr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112 | 0);
 $8 = sp + 68 | 0;
 $10 = sp + 56 | 0;
 $12 = sp + 36 | 0;
 $16 = sp + 20 | 0;
 $17 = sp + 16 | 0;
 $18 = sp + 4 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $20 = $6;
 $21 = ($20 | 0) == (0 | 0);
 if ($21) {
  $22 = $5;
  $23 = _mp_obj_is_obj_1061($22) | 0;
  if ($23) {
   $24 = $5;
   $25 = HEAP32[$24 >> 2] | 0;
   $26 = ($25 | 0) == (18228 | 0);
   if ($26) {
    $27 = $4;
    $7 = $27;
    $28 = $7;
    $29 = $28 + 8 | 0;
    $30 = HEAP32[$29 >> 2] | 0;
    $31 = $5;
    $32 = _mp_seq_get_fast_slice_indexes($30, $31, $8) | 0;
    if (!$32) {
     _mp_raise_NotImplementedError(0);
    }
    $33 = HEAP32[$8 >> 2] | 0;
    $34 = $8 + 4 | 0;
    $35 = HEAP32[$34 >> 2] | 0;
    $36 = $33 - $35 | 0;
    $9 = $36;
    $37 = $7;
    $38 = $37 + 12 | 0;
    $39 = HEAP32[$38 >> 2] | 0;
    $40 = HEAP32[$8 >> 2] | 0;
    $41 = $40 << 2;
    $42 = $39 + $41 | 0;
    $43 = $7;
    $44 = $43 + 12 | 0;
    $45 = HEAP32[$44 >> 2] | 0;
    $46 = $7;
    $47 = $46 + 12 | 0;
    $48 = HEAP32[$47 >> 2] | 0;
    $49 = HEAP32[$8 >> 2] | 0;
    $50 = $49 + 0 | 0;
    $51 = $50 << 2;
    $52 = $48 + $51 | 0;
    $53 = $7;
    $54 = $53 + 12 | 0;
    $55 = HEAP32[$54 >> 2] | 0;
    $56 = $8 + 4 | 0;
    $57 = HEAP32[$56 >> 2] | 0;
    $58 = $57 << 2;
    $59 = $55 + $58 | 0;
    $60 = $7;
    $61 = $60 + 8 | 0;
    $62 = HEAP32[$61 >> 2] | 0;
    $63 = $8 + 4 | 0;
    $64 = HEAP32[$63 >> 2] | 0;
    $65 = $62 - $64 | 0;
    $66 = $65 << 2;
    _memmove($52 | 0, $59 | 0, $66 | 0) | 0;
    $67 = $7;
    $68 = $67 + 12 | 0;
    $69 = HEAP32[$68 >> 2] | 0;
    $70 = $7;
    $71 = $70 + 8 | 0;
    $72 = HEAP32[$71 >> 2] | 0;
    $73 = $9;
    $74 = $72 + $73 | 0;
    $75 = $74 << 2;
    $76 = $69 + $75 | 0;
    $77 = $7;
    $78 = $77 + 8 | 0;
    $79 = HEAP32[$78 >> 2] | 0;
    $80 = $7;
    $81 = $80 + 8 | 0;
    $82 = HEAP32[$81 >> 2] | 0;
    $83 = $9;
    $84 = $82 + $83 | 0;
    $85 = $79 - $84 | 0;
    $86 = $85 << 2;
    _memset($76 | 0, 0, $86 | 0) | 0;
    $87 = $9;
    $88 = $7;
    $89 = $88 + 8 | 0;
    $90 = HEAP32[$89 >> 2] | 0;
    $91 = $90 + $87 | 0;
    HEAP32[$89 >> 2] = $91;
    $3 = 17668;
    $286 = $3;
    STACKTOP = sp;
    return $286 | 0;
   }
  }
  $92 = $4;
  HEAP32[$10 >> 2] = $92;
  $93 = $10 + 4 | 0;
  $94 = $5;
  HEAP32[$93 >> 2] = $94;
  _list_pop(2, $10) | 0;
  $3 = 17668;
  $286 = $3;
  STACKTOP = sp;
  return $286 | 0;
 }
 $95 = $6;
 $96 = ($95 | 0) == (4 | 0);
 if ($96) {
  $97 = $4;
  $11 = $97;
  $98 = $5;
  $99 = _mp_obj_is_obj_1061($98) | 0;
  if ($99) {
   $100 = $5;
   $101 = HEAP32[$100 >> 2] | 0;
   $102 = ($101 | 0) == (18228 | 0);
   if ($102) {
    $103 = $11;
    $104 = $103 + 8 | 0;
    $105 = HEAP32[$104 >> 2] | 0;
    $106 = $5;
    $107 = _mp_seq_get_fast_slice_indexes($105, $106, $12) | 0;
    if ($107) {
     $115 = $12 + 4 | 0;
     $116 = HEAP32[$115 >> 2] | 0;
     $117 = HEAP32[$12 >> 2] | 0;
     $118 = $116 - $117 | 0;
     $119 = _list_new($118) | 0;
     $13 = $119;
     $120 = $13;
     $121 = $120 + 12 | 0;
     $122 = HEAP32[$121 >> 2] | 0;
     $123 = $11;
     $124 = $123 + 12 | 0;
     $125 = HEAP32[$124 >> 2] | 0;
     $126 = HEAP32[$12 >> 2] | 0;
     $127 = $125 + ($126 << 2) | 0;
     $128 = $13;
     $129 = $128 + 8 | 0;
     $130 = HEAP32[$129 >> 2] | 0;
     $131 = $130 << 2;
     _memcpy($122 | 0, $127 | 0, $131 | 0) | 0;
     $132 = $13;
     $3 = $132;
     $286 = $3;
     STACKTOP = sp;
     return $286 | 0;
    } else {
     $108 = $11;
     $109 = $108 + 8 | 0;
     $110 = HEAP32[$109 >> 2] | 0;
     $111 = $11;
     $112 = $111 + 12 | 0;
     $113 = HEAP32[$112 >> 2] | 0;
     $114 = _mp_seq_extract_slice($110, $113, $12) | 0;
     $3 = $114;
     $286 = $3;
     STACKTOP = sp;
     return $286 | 0;
    }
   }
  }
  $133 = $11;
  $134 = HEAP32[$133 >> 2] | 0;
  $135 = $11;
  $136 = $135 + 8 | 0;
  $137 = HEAP32[$136 >> 2] | 0;
  $138 = $5;
  $139 = _mp_get_index($134, $137, $138, 0) | 0;
  $14 = $139;
  $140 = $11;
  $141 = $140 + 12 | 0;
  $142 = HEAP32[$141 >> 2] | 0;
  $143 = $14;
  $144 = $142 + ($143 << 2) | 0;
  $145 = HEAP32[$144 >> 2] | 0;
  $3 = $145;
  $286 = $3;
  STACKTOP = sp;
  return $286 | 0;
 }
 $146 = $5;
 $147 = _mp_obj_is_obj_1061($146) | 0;
 if ($147) {
  $148 = $5;
  $149 = HEAP32[$148 >> 2] | 0;
  $150 = ($149 | 0) == (18228 | 0);
  if ($150) {
   $151 = $4;
   $15 = $151;
   $152 = $6;
   _mp_obj_get_array($152, $16, $17);
   $153 = $15;
   $154 = $153 + 8 | 0;
   $155 = HEAP32[$154 >> 2] | 0;
   $156 = $5;
   $157 = _mp_seq_get_fast_slice_indexes($155, $156, $18) | 0;
   if (!$157) {
    _mp_raise_NotImplementedError(0);
   }
   $158 = HEAP32[$16 >> 2] | 0;
   $159 = $18 + 4 | 0;
   $160 = HEAP32[$159 >> 2] | 0;
   $161 = HEAP32[$18 >> 2] | 0;
   $162 = $160 - $161 | 0;
   $163 = $158 - $162 | 0;
   $19 = $163;
   $164 = $19;
   $165 = ($164 | 0) > 0;
   $166 = $15;
   if ($165) {
    $167 = $166 + 8 | 0;
    $168 = HEAP32[$167 >> 2] | 0;
    $169 = $19;
    $170 = $168 + $169 | 0;
    $171 = $15;
    $172 = $171 + 4 | 0;
    $173 = HEAP32[$172 >> 2] | 0;
    $174 = $170 >>> 0 > $173 >>> 0;
    if ($174) {
     $175 = $15;
     $176 = $175 + 12 | 0;
     $177 = HEAP32[$176 >> 2] | 0;
     $178 = $15;
     $179 = $178 + 8 | 0;
     $180 = HEAP32[$179 >> 2] | 0;
     $181 = $19;
     $182 = $180 + $181 | 0;
     $183 = $182 << 2;
     $184 = _m_realloc($177, $183) | 0;
     $185 = $15;
     $186 = $185 + 12 | 0;
     HEAP32[$186 >> 2] = $184;
     $187 = $15;
     $188 = $187 + 8 | 0;
     $189 = HEAP32[$188 >> 2] | 0;
     $190 = $19;
     $191 = $189 + $190 | 0;
     $192 = $15;
     $193 = $192 + 4 | 0;
     HEAP32[$193 >> 2] = $191;
    }
    $194 = $15;
    $195 = $194 + 12 | 0;
    $196 = HEAP32[$195 >> 2] | 0;
    $197 = HEAP32[$18 >> 2] | 0;
    $198 = HEAP32[$16 >> 2] | 0;
    $199 = $197 + $198 | 0;
    $200 = $199 << 2;
    $201 = $196 + $200 | 0;
    $202 = $15;
    $203 = $202 + 12 | 0;
    $204 = HEAP32[$203 >> 2] | 0;
    $205 = $18 + 4 | 0;
    $206 = HEAP32[$205 >> 2] | 0;
    $207 = $206 << 2;
    $208 = $204 + $207 | 0;
    $209 = $15;
    $210 = $209 + 8 | 0;
    $211 = HEAP32[$210 >> 2] | 0;
    $212 = $19;
    $213 = $211 + $212 | 0;
    $214 = HEAP32[$18 >> 2] | 0;
    $215 = HEAP32[$16 >> 2] | 0;
    $216 = $214 + $215 | 0;
    $217 = $213 - $216 | 0;
    $218 = $217 << 2;
    _memmove($201 | 0, $208 | 0, $218 | 0) | 0;
    $219 = $15;
    $220 = $219 + 12 | 0;
    $221 = HEAP32[$220 >> 2] | 0;
    $222 = HEAP32[$18 >> 2] | 0;
    $223 = $222 << 2;
    $224 = $221 + $223 | 0;
    $225 = HEAP32[$17 >> 2] | 0;
    $226 = HEAP32[$16 >> 2] | 0;
    $227 = $226 << 2;
    _memmove($224 | 0, $225 | 0, $227 | 0) | 0;
   } else {
    $228 = $166 + 12 | 0;
    $229 = HEAP32[$228 >> 2] | 0;
    $230 = HEAP32[$18 >> 2] | 0;
    $231 = $230 << 2;
    $232 = $229 + $231 | 0;
    $233 = HEAP32[$17 >> 2] | 0;
    $234 = HEAP32[$16 >> 2] | 0;
    $235 = $234 << 2;
    _memcpy($232 | 0, $233 | 0, $235 | 0) | 0;
    $236 = $15;
    $237 = $236 + 12 | 0;
    $238 = HEAP32[$237 >> 2] | 0;
    $239 = HEAP32[$18 >> 2] | 0;
    $240 = HEAP32[$16 >> 2] | 0;
    $241 = $239 + $240 | 0;
    $242 = $241 << 2;
    $243 = $238 + $242 | 0;
    $244 = $15;
    $245 = $244 + 12 | 0;
    $246 = HEAP32[$245 >> 2] | 0;
    $247 = $18 + 4 | 0;
    $248 = HEAP32[$247 >> 2] | 0;
    $249 = $248 << 2;
    $250 = $246 + $249 | 0;
    $251 = $15;
    $252 = $251 + 8 | 0;
    $253 = HEAP32[$252 >> 2] | 0;
    $254 = $18 + 4 | 0;
    $255 = HEAP32[$254 >> 2] | 0;
    $256 = $253 - $255 | 0;
    $257 = $256 << 2;
    _memmove($243 | 0, $250 | 0, $257 | 0) | 0;
    $258 = $15;
    $259 = $258 + 12 | 0;
    $260 = HEAP32[$259 >> 2] | 0;
    $261 = $15;
    $262 = $261 + 8 | 0;
    $263 = HEAP32[$262 >> 2] | 0;
    $264 = $19;
    $265 = $263 + $264 | 0;
    $266 = $265 << 2;
    $267 = $260 + $266 | 0;
    $268 = $15;
    $269 = $268 + 8 | 0;
    $270 = HEAP32[$269 >> 2] | 0;
    $271 = $15;
    $272 = $271 + 8 | 0;
    $273 = HEAP32[$272 >> 2] | 0;
    $274 = $19;
    $275 = $273 + $274 | 0;
    $276 = $270 - $275 | 0;
    $277 = $276 << 2;
    _memset($267 | 0, 0, $277 | 0) | 0;
   }
   $278 = $19;
   $279 = $15;
   $280 = $279 + 8 | 0;
   $281 = HEAP32[$280 >> 2] | 0;
   $282 = $281 + $278 | 0;
   HEAP32[$280 >> 2] = $282;
   $3 = 17668;
   $286 = $3;
   STACKTOP = sp;
   return $286 | 0;
  }
 }
 $283 = $4;
 $284 = $5;
 $285 = $6;
 _mp_obj_list_store($283, $284, $285);
 $3 = 17668;
 $286 = $3;
 STACKTOP = sp;
 return $286 | 0;
}

function _mp_builtin___import__($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 416 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(416 | 0);
 $vararg_buffer = sp + 256 | 0;
 $8 = sp + 372 | 0;
 $14 = sp + 352 | 0;
 $16 = sp + 344 | 0;
 $25 = sp + 296 | 0;
 $26 = sp;
 $3 = $0;
 $4 = $1;
 $36 = $4;
 $37 = HEAP32[$36 >> 2] | 0;
 $5 = $37;
 $6 = 17668;
 $7 = 0;
 $38 = $3;
 $39 = $38 >>> 0 >= 4;
 if ($39) {
  $40 = $4;
  $41 = $40 + 12 | 0;
  $42 = HEAP32[$41 >> 2] | 0;
  $6 = $42;
  $43 = $3;
  $44 = $43 >>> 0 >= 5;
  if ($44) {
   $45 = $4;
   $46 = $45 + 16 | 0;
   $47 = HEAP32[$46 >> 2] | 0;
   $48 = $47;
   $49 = $48 >> 1;
   $7 = $49;
   $50 = $7;
   $51 = ($50 | 0) < 0;
   if ($51) {
    _mp_raise_ValueError(0);
   }
  }
 }
 $52 = $5;
 $53 = _mp_obj_str_get_data($52, $8) | 0;
 $9 = $53;
 $54 = $7;
 $55 = ($54 | 0) != 0;
 if ($55) {
  $56 = $7;
  $57 = $56 + -1 | 0;
  $7 = $57;
  $58 = _mp_globals_get_1350() | 0;
  $59 = _mp_obj_dict_get($58, 94) | 0;
  $10 = $59;
  $60 = $10;
  $61 = $60;
  $62 = $61 >>> 2;
  $63 = ($62 | 0) == 21;
  if ($63) {
   $64 = _mp_globals_get_1350() | 0;
   $65 = _mp_obj_dict_get($64, 86) | 0;
   $10 = $65;
  }
  $66 = _mp_globals_get_1350() | 0;
  $67 = $66 + 4 | 0;
  $11 = $67;
  $68 = $11;
  $69 = _mp_map_lookup($68, 782, 0) | 0;
  $12 = $69;
  $70 = $12;
  $71 = ($70 | 0) != (0 | 0);
  $72 = $71 & 1;
  $13 = $72;
  $73 = $10;
  $74 = _mp_obj_str_get_data($73, $14) | 0;
  $15 = $74;
  $75 = $15;
  $76 = HEAP32[$14 >> 2] | 0;
  $77 = $75 + $76 | 0;
  HEAP32[$16 >> 2] = $77;
  $78 = $13;
  $79 = $78 & 1;
  if (!$79) {
   $80 = $15;
   _chop_component($80, $16);
  }
  while (1) {
   $81 = $7;
   $82 = $81 + -1 | 0;
   $7 = $82;
   $83 = ($81 | 0) != 0;
   if (!$83) {
    break;
   }
   $84 = $15;
   _chop_component($84, $16);
  }
  $85 = HEAP32[$16 >> 2] | 0;
  $86 = $15;
  $87 = ($85 | 0) == ($86 | 0);
  if ($87) {
   _mp_raise_ValueError(33515);
  }
  $88 = HEAP32[$8 >> 2] | 0;
  $89 = ($88 | 0) == 0;
  $90 = HEAP32[$16 >> 2] | 0;
  $91 = $15;
  $92 = $90;
  $93 = $91;
  $94 = $92 - $93 | 0;
  if ($89) {
   $98 = $94;
  } else {
   $95 = $94 + 1 | 0;
   $96 = HEAP32[$8 >> 2] | 0;
   $97 = $95 + $96 | 0;
   $98 = $97;
  }
  $17 = $98;
  $99 = $17;
  $100 = _mp_local_alloc_1352($99) | 0;
  $18 = $100;
  $101 = $18;
  $102 = $15;
  $103 = HEAP32[$16 >> 2] | 0;
  $104 = $15;
  $105 = $103;
  $106 = $104;
  $107 = $105 - $106 | 0;
  _memcpy($101 | 0, $102 | 0, $107 | 0) | 0;
  $108 = HEAP32[$8 >> 2] | 0;
  $109 = ($108 | 0) != 0;
  if ($109) {
   $110 = $18;
   $111 = HEAP32[$16 >> 2] | 0;
   $112 = $15;
   $113 = $111;
   $114 = $112;
   $115 = $113 - $114 | 0;
   $116 = $110 + $115 | 0;
   HEAP8[$116 >> 0] = 46;
   $117 = $18;
   $118 = HEAP32[$16 >> 2] | 0;
   $119 = $15;
   $120 = $118;
   $121 = $119;
   $122 = $120 - $121 | 0;
   $123 = $117 + $122 | 0;
   $124 = $123 + 1 | 0;
   $125 = $9;
   $126 = HEAP32[$8 >> 2] | 0;
   _memcpy($124 | 0, $125 | 0, $126 | 0) | 0;
  }
  $127 = $18;
  $128 = $17;
  $129 = _qstr_from_strn($127, $128) | 0;
  $19 = $129;
  $130 = $18;
  _mp_local_free_1353($130);
  $131 = $19;
  $132 = $131 << 2;
  $133 = $132 | 2;
  $134 = $133;
  $5 = $134;
  $135 = $19;
  $136 = _qstr_str($135) | 0;
  $9 = $136;
  $137 = $17;
  HEAP32[$8 >> 2] = $137;
 }
 $138 = $5;
 $139 = _mp_obj_str_get_qstr($138) | 0;
 $20 = $139;
 $140 = $20;
 $141 = _mp_module_get($140) | 0;
 $21 = $141;
 $142 = $21;
 $143 = ($142 | 0) != (0 | 0);
 if ($143) {
  $144 = $9;
  $145 = _strchr($144, 46) | 0;
  $22 = $145;
  $146 = $22;
  $147 = ($146 | 0) == (0 | 0);
  if ($147) {
   $148 = $21;
   $2 = $148;
   $269 = $2;
   STACKTOP = sp;
   return $269 | 0;
  }
  $149 = $6;
  $150 = ($149 | 0) != (17668 | 0);
  if ($150) {
   $151 = $21;
   $2 = $151;
   $269 = $2;
   STACKTOP = sp;
   return $269 | 0;
  } else {
   $152 = $9;
   $153 = $22;
   $154 = $9;
   $155 = $153;
   $156 = $154;
   $157 = $155 - $156 | 0;
   $158 = _qstr_from_strn($152, $157) | 0;
   $23 = $158;
   $159 = $23;
   $160 = _mp_module_get($159) | 0;
   $2 = $160;
   $269 = $2;
   STACKTOP = sp;
   return $269 | 0;
  }
 }
 $24 = 0;
 _vstr_init_fixed_buf($25, 256, $26);
 $21 = 0;
 $27 = 0;
 $28 = 0;
 $29 = 1;
 while (1) {
  $161 = $29;
  $162 = HEAP32[$8 >> 2] | 0;
  $163 = $161 >>> 0 <= $162 >>> 0;
  if (!$163) {
   label = 53;
   break;
  }
  $164 = $29;
  $165 = HEAP32[$8 >> 2] | 0;
  $166 = ($164 | 0) == ($165 | 0);
  if ($166) {
   label = 30;
  } else {
   $167 = $9;
   $168 = $29;
   $169 = $167 + $168 | 0;
   $170 = HEAP8[$169 >> 0] | 0;
   $171 = $170 << 24 >> 24;
   $172 = ($171 | 0) == 46;
   if ($172) {
    label = 30;
   }
  }
  if ((label | 0) == 30) {
   label = 0;
   $173 = $9;
   $174 = $29;
   $175 = _qstr_from_strn($173, $174) | 0;
   $30 = $175;
   $176 = _vstr_len($25) | 0;
   $177 = ($176 | 0) == 0;
   if ($177) {
    $178 = $9;
    $179 = $29;
    $180 = _find_file($178, $179, $25) | 0;
    $31 = $180;
   } else {
    _vstr_add_char($25, 47);
    $181 = $9;
    $182 = $24;
    $183 = $181 + $182 | 0;
    $184 = $29;
    $185 = $24;
    $186 = $184 - $185 | 0;
    _vstr_add_strn($25, $183, $186);
    $187 = _stat_dir_or_file($25) | 0;
    $31 = $187;
   }
   $188 = $31;
   $189 = ($188 | 0) == 0;
   if ($189) {
    $190 = $29;
    $191 = HEAP32[$8 >> 2] | 0;
    $192 = ($190 | 0) == ($191 | 0);
    if (!$192) {
     label = 37;
     break;
    }
    $193 = $30;
    $194 = $193 << 2;
    $195 = $194 | 2;
    $196 = $195;
    $197 = _mp_map_lookup(17336, $196, 0) | 0;
    $32 = $197;
    $198 = $32;
    $199 = ($198 | 0) == (0 | 0);
    if ($199) {
     label = 37;
     break;
    }
    $200 = $32;
    $201 = $200 + 4 | 0;
    $202 = HEAP32[$201 >> 2] | 0;
    $21 = $202;
    $203 = $30;
    $204 = $21;
    _mp_module_call_init_1354($203, $204);
   } else {
    $207 = $30;
    $208 = _mp_module_get($207) | 0;
    $21 = $208;
   }
   $209 = $21;
   $210 = ($209 | 0) == (0 | 0);
   do {
    if ($210) {
     $211 = $30;
     $212 = _mp_obj_new_module($211) | 0;
     $21 = $212;
     $213 = $29;
     $214 = HEAP32[$8 >> 2] | 0;
     $215 = ($213 | 0) == ($214 | 0);
     $216 = $6;
     $217 = ($216 | 0) == (13856 | 0);
     $or$cond = $215 & $217;
     $218 = $31;
     $219 = ($218 | 0) != 1;
     $or$cond3 = $or$cond & $219;
     if ($or$cond3) {
      $220 = $21;
      $33 = $220;
      $221 = $33;
      $222 = $221 + 4 | 0;
      $223 = HEAP32[$222 >> 2] | 0;
      _mp_obj_dict_store($223, 94, 86) | 0;
      $224 = $21;
      _mp_obj_dict_store(40608, 86, $224) | 0;
      $225 = $33;
      $226 = $225 + 4 | 0;
      $227 = HEAP32[$226 >> 2] | 0;
      $228 = $30;
      $229 = $228 << 2;
      $230 = $229 | 2;
      $231 = $230;
      _mp_obj_dict_store($227, 86, $231) | 0;
     }
     $232 = $31;
     $233 = ($232 | 0) == 1;
     $234 = $21;
     if (!$233) {
      _do_load($234, $25);
      break;
     }
     $235 = _vstr_str($25) | 0;
     $236 = _vstr_len($25) | 0;
     $237 = _mp_obj_new_str($235, $236) | 0;
     _mp_store_attr($234, 195, $237);
     $238 = $25 + 4 | 0;
     $239 = HEAP32[$238 >> 2] | 0;
     $34 = $239;
     _vstr_add_char($25, 47);
     _vstr_add_str($25, 33567);
     $240 = _stat_file_py_or_mpy($25) | 0;
     $241 = ($240 | 0) != 2;
     if (!$241) {
      $242 = $21;
      _do_load($242, $25);
     }
     $243 = $34;
     $244 = $25 + 4 | 0;
     HEAP32[$244 >> 2] = $243;
    }
   } while (0);
   $245 = $28;
   $246 = ($245 | 0) != (0 | 0);
   if ($246) {
    $247 = $9;
    $248 = $24;
    $249 = $247 + $248 | 0;
    $250 = $29;
    $251 = $24;
    $252 = $250 - $251 | 0;
    $253 = _qstr_from_strn($249, $252) | 0;
    $35 = $253;
    $254 = $28;
    $255 = $35;
    $256 = $21;
    _mp_store_attr($254, $255, $256);
   }
   $257 = $21;
   $28 = $257;
   $258 = $27;
   $259 = ($258 | 0) == (0 | 0);
   if ($259) {
    $260 = $21;
    $27 = $260;
   }
   $261 = $29;
   $262 = $261 + 1 | 0;
   $24 = $262;
  }
  $263 = $29;
  $264 = $263 + 1 | 0;
  $29 = $264;
 }
 if ((label | 0) == 37) {
  $205 = $30;
  HEAP32[$vararg_buffer >> 2] = $205;
  $206 = _mp_obj_new_exception_msg_varg(15412, 33546, $vararg_buffer) | 0;
  _nlr_jump($206);
 } else if ((label | 0) == 53) {
  $265 = $6;
  $266 = ($265 | 0) != (17668 | 0);
  if ($266) {
   $267 = $21;
   $2 = $267;
   $269 = $2;
   STACKTOP = sp;
   return $269 | 0;
  } else {
   $268 = $27;
   $2 = $268;
   $269 = $2;
   STACKTOP = sp;
   return $269 | 0;
  }
 }
 return 0 | 0;
}

function _compile_for_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond11 = 0, $or$cond13 = 0, $or$cond3 = 0, $or$cond5 = 0, $or$cond7 = 0, $or$cond9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $5 = sp + 40 | 0;
 $6 = sp + 36 | 0;
 $2 = $0;
 $3 = $1;
 $20 = $3;
 $21 = $20 + 8 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = $22 & 15;
 $24 = ($23 | 0) == 2;
 if ($24) {
  $25 = $3;
  $26 = $25 + 8 | 0;
  $27 = $26 + 4 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = ($28 | 0) != 0;
  if ($29) {
   $30 = $3;
   $31 = $30 + 8 | 0;
   $32 = $31 + 4 | 0;
   $33 = HEAP32[$32 >> 2] | 0;
   $34 = $33 & 3;
   $35 = ($34 | 0) == 0;
   if ($35) {
    $36 = $3;
    $37 = $36 + 8 | 0;
    $38 = $37 + 4 | 0;
    $39 = HEAP32[$38 >> 2] | 0;
    $40 = $39;
    $41 = $40 + 4 | 0;
    $42 = HEAP32[$41 >> 2] | 0;
    $43 = $42 & 255;
    $44 = ($43 | 0) == 43;
    if ($44) {
     $45 = $3;
     $46 = $45 + 8 | 0;
     $47 = $46 + 4 | 0;
     $48 = HEAP32[$47 >> 2] | 0;
     $49 = $48;
     $4 = $49;
     $50 = $4;
     $51 = $50 + 8 | 0;
     $52 = HEAP32[$51 >> 2] | 0;
     $53 = $52 & 15;
     $54 = ($53 | 0) == 2;
     if ($54) {
      $55 = $4;
      $56 = $55 + 8 | 0;
      $57 = HEAP32[$56 >> 2] | 0;
      $58 = $57 >>> 4;
      $59 = ($58 | 0) == 124;
      if ($59) {
       $60 = $4;
       $61 = $60 + 8 | 0;
       $62 = $61 + 4 | 0;
       $63 = HEAP32[$62 >> 2] | 0;
       $64 = $63;
       $65 = $64 + 4 | 0;
       $66 = HEAP32[$65 >> 2] | 0;
       $67 = $66 & 255;
       $68 = ($67 | 0) == 47;
       if ($68) {
        $69 = $4;
        $70 = $69 + 8 | 0;
        $71 = $70 + 4 | 0;
        $72 = HEAP32[$71 >> 2] | 0;
        $73 = $72;
        $74 = $73 + 8 | 0;
        $75 = HEAP32[$74 >> 2] | 0;
        HEAP32[$5 >> 2] = $75;
        $76 = _mp_parse_node_extract_list($5, 163, $6) | 0;
        $7 = $76;
        $11 = 0;
        $77 = $7;
        $78 = 1 <= ($77 | 0);
        $79 = $7;
        $80 = ($79 | 0) <= 3;
        $or$cond = $78 & $80;
        if ($or$cond) {
         $11 = 1;
         $81 = $7;
         $82 = ($81 | 0) == 1;
         do {
          if ($82) {
           $83 = _mp_parse_node_new_small_int_582(0) | 0;
           $8 = $83;
           $84 = HEAP32[$6 >> 2] | 0;
           $85 = HEAP32[$84 >> 2] | 0;
           $9 = $85;
           $86 = _mp_parse_node_new_small_int_582(1) | 0;
           $10 = $86;
          } else {
           $87 = $7;
           $88 = ($87 | 0) == 2;
           $89 = HEAP32[$6 >> 2] | 0;
           $90 = HEAP32[$89 >> 2] | 0;
           $8 = $90;
           $91 = HEAP32[$6 >> 2] | 0;
           $92 = $91 + 4 | 0;
           $93 = HEAP32[$92 >> 2] | 0;
           $9 = $93;
           if ($88) {
            $94 = _mp_parse_node_new_small_int_582(1) | 0;
            $10 = $94;
            break;
           }
           $95 = HEAP32[$6 >> 2] | 0;
           $96 = $95 + 8 | 0;
           $97 = HEAP32[$96 >> 2] | 0;
           $10 = $97;
           $98 = $10;
           $99 = $98 & 1;
           $100 = ($99 | 0) == 1;
           if ($100) {
            $101 = $10;
            $102 = $101 >> 1;
            $103 = ($102 | 0) == 0;
            if (!$103) {
             break;
            }
           }
           $11 = 0;
          }
         } while (0);
         $104 = $11;
         $105 = $104 & 1;
         $106 = $8;
         $107 = ($106 | 0) != 0;
         $or$cond3 = $105 & $107;
         if ($or$cond3) {
          $108 = $8;
          $109 = $108 & 3;
          $110 = ($109 | 0) == 0;
          if ($110) {
           $111 = $8;
           $112 = $111;
           $113 = $112 + 4 | 0;
           $114 = HEAP32[$113 >> 2] | 0;
           $115 = $114 & 255;
           $12 = $115;
           $116 = $12;
           $117 = ($116 | 0) == 165;
           $118 = $12;
           $119 = ($118 | 0) == 166;
           $or$cond5 = $117 | $119;
           $120 = $12;
           $121 = ($120 | 0) == 167;
           $or$cond7 = $or$cond5 | $121;
           if ($or$cond7) {
            $11 = 0;
           }
          }
         }
         $122 = $11;
         $123 = $122 & 1;
         $124 = $9;
         $125 = ($124 | 0) != 0;
         $or$cond9 = $123 & $125;
         if ($or$cond9) {
          $126 = $9;
          $127 = $126 & 3;
          $128 = ($127 | 0) == 0;
          if ($128) {
           $129 = $9;
           $130 = $129;
           $131 = $130 + 4 | 0;
           $132 = HEAP32[$131 >> 2] | 0;
           $133 = $132 & 255;
           $13 = $133;
           $134 = $13;
           $135 = ($134 | 0) == 165;
           $136 = $13;
           $137 = ($136 | 0) == 166;
           $or$cond11 = $135 | $137;
           $138 = $13;
           $139 = ($138 | 0) == 167;
           $or$cond13 = $or$cond11 | $139;
           if ($or$cond13) {
            $11 = 0;
           }
          }
         }
        }
        $140 = $11;
        $141 = $140 & 1;
        if ($141) {
         $142 = $2;
         $143 = $3;
         $144 = $143 + 8 | 0;
         $145 = HEAP32[$144 >> 2] | 0;
         $146 = $8;
         $147 = $9;
         $148 = $10;
         $149 = $3;
         $150 = $149 + 8 | 0;
         $151 = $150 + 8 | 0;
         $152 = HEAP32[$151 >> 2] | 0;
         $153 = $3;
         $154 = $153 + 8 | 0;
         $155 = $154 + 12 | 0;
         $156 = HEAP32[$155 >> 2] | 0;
         _compile_for_stmt_optimised_range($142, $145, $146, $147, $148, $152, $156);
         STACKTOP = sp;
         return;
        }
       }
      }
     }
    }
   }
  }
 }
 $157 = $2;
 $158 = $157 + 24 | 0;
 $159 = HEAP16[$158 >> 1] | 0;
 $14 = $159;
 $160 = $2;
 $161 = $160 + 26 | 0;
 $162 = HEAP16[$161 >> 1] | 0;
 $15 = $162;
 $163 = $2;
 $164 = $163 + 30 | 0;
 $165 = HEAP16[$164 >> 1] | 0;
 $16 = $165;
 $166 = $2;
 $167 = _comp_next_label($166) | 0;
 $17 = $167;
 $168 = $2;
 $169 = _comp_next_label($168) | 0;
 $18 = $169;
 $170 = $17;
 $171 = $170 & 65535;
 $172 = $2;
 $173 = $172 + 24 | 0;
 HEAP16[$173 >> 1] = $171;
 $174 = $18;
 $175 = $174 & 65535;
 $176 = $2;
 $177 = $176 + 26 | 0;
 HEAP16[$177 >> 1] = $175;
 $178 = $2;
 $179 = $178 + 28 | 0;
 $180 = HEAP16[$179 >> 1] | 0;
 $181 = $2;
 $182 = $181 + 30 | 0;
 HEAP16[$182 >> 1] = $180;
 $183 = $2;
 $184 = $183 + 24 | 0;
 $185 = HEAP16[$184 >> 1] | 0;
 $186 = $185 & 65535;
 $187 = $186 | 32768;
 $188 = $187 & 65535;
 HEAP16[$184 >> 1] = $188;
 $189 = $2;
 $190 = _comp_next_label($189) | 0;
 $19 = $190;
 $191 = $2;
 $192 = $3;
 $193 = $192 + 8 | 0;
 $194 = $193 + 4 | 0;
 $195 = HEAP32[$194 >> 2] | 0;
 _compile_node($191, $195);
 $196 = $2;
 $197 = $196 + 40 | 0;
 $198 = HEAP32[$197 >> 2] | 0;
 _mp_emit_bc_get_iter($198, 1);
 $199 = $2;
 $200 = $199 + 40 | 0;
 $201 = HEAP32[$200 >> 2] | 0;
 $202 = $18;
 _mp_emit_bc_label_assign($201, $202);
 $203 = $2;
 $204 = $203 + 40 | 0;
 $205 = HEAP32[$204 >> 2] | 0;
 $206 = $19;
 _mp_emit_bc_for_iter($205, $206);
 $207 = $2;
 $208 = $3;
 $209 = $208 + 8 | 0;
 $210 = HEAP32[$209 >> 2] | 0;
 _c_assign($207, $210, 0);
 $211 = $2;
 $212 = $3;
 $213 = $212 + 8 | 0;
 $214 = $213 + 8 | 0;
 $215 = HEAP32[$214 >> 2] | 0;
 _compile_node($211, $215);
 $216 = $2;
 $217 = $216 + 40 | 0;
 $218 = HEAP32[$217 >> 2] | 0;
 $219 = _mp_emit_bc_last_emit_was_return_value($218) | 0;
 if (!$219) {
  $220 = $2;
  $221 = $220 + 40 | 0;
  $222 = HEAP32[$221 >> 2] | 0;
  $223 = $18;
  _mp_emit_bc_jump($222, $223);
 }
 $224 = $2;
 $225 = $224 + 40 | 0;
 $226 = HEAP32[$225 >> 2] | 0;
 $227 = $19;
 _mp_emit_bc_label_assign($226, $227);
 $228 = $2;
 $229 = $228 + 40 | 0;
 $230 = HEAP32[$229 >> 2] | 0;
 _mp_emit_bc_for_iter_end($230);
 $231 = $14;
 $232 = $2;
 $233 = $232 + 24 | 0;
 HEAP16[$233 >> 1] = $231;
 $234 = $15;
 $235 = $2;
 $236 = $235 + 26 | 0;
 HEAP16[$236 >> 1] = $234;
 $237 = $16;
 $238 = $2;
 $239 = $238 + 30 | 0;
 HEAP16[$239 >> 1] = $237;
 $240 = $2;
 $241 = $3;
 $242 = $241 + 8 | 0;
 $243 = $242 + 12 | 0;
 $244 = HEAP32[$243 >> 2] | 0;
 _compile_node($240, $244);
 $245 = $2;
 $246 = $245 + 40 | 0;
 $247 = HEAP32[$246 >> 2] | 0;
 $248 = $17;
 _mp_emit_bc_label_assign($247, $248);
 STACKTOP = sp;
 return;
}

function _uctypes_struct_attr_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, $or$cond5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $20 = sp + 4 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $22 = $4;
 $7 = $22;
 $23 = $7;
 $24 = $23 + 4 | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = _mp_obj_is_obj_1471($25) | 0;
 if ($26) {
  $27 = $7;
  $28 = $27 + 4 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = ($30 | 0) == (14112 | 0);
  if (!$31) {
   label = 3;
  }
 } else {
  label = 3;
 }
 if ((label | 0) == 3) {
  $32 = $7;
  $33 = $32 + 4 | 0;
  $34 = HEAP32[$33 >> 2] | 0;
  $35 = _mp_obj_is_obj_1471($34) | 0;
  if (!$35) {
   _mp_raise_TypeError(34579);
  }
  $36 = $7;
  $37 = $36 + 4 | 0;
  $38 = HEAP32[$37 >> 2] | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  $40 = ($39 | 0) == (14436 | 0);
  if (!$40) {
   _mp_raise_TypeError(34579);
  }
 }
 $41 = $7;
 $42 = $41 + 4 | 0;
 $43 = HEAP32[$42 >> 2] | 0;
 $44 = $5;
 $45 = $44 << 2;
 $46 = $45 | 2;
 $47 = $46;
 $48 = _mp_obj_dict_get($43, $47) | 0;
 $8 = $48;
 $49 = $8;
 $50 = _mp_obj_is_small_int_1472($49) | 0;
 $51 = $8;
 if (!$50) {
  $185 = _mp_obj_is_obj_1471($51) | 0;
  if (!$185) {
   _syntax_error();
  }
  $186 = $8;
  $187 = HEAP32[$186 >> 2] | 0;
  $188 = ($187 | 0) == (18952 | 0);
  if (!$188) {
   _syntax_error();
  }
  $189 = $6;
  $190 = ($189 | 0) != (0 | 0);
  if ($190) {
   _syntax_error();
  }
  $191 = $8;
  $16 = $191;
  $192 = $16;
  $193 = $192 + 8 | 0;
  $194 = HEAP32[$193 >> 2] | 0;
  $195 = $194;
  $196 = $195 >> 1;
  $17 = $196;
  $197 = $17;
  $198 = $197 >> 29;
  $199 = $198 & 3;
  $18 = $199;
  $200 = $17;
  $201 = $200 & 536870911;
  $17 = $201;
  $202 = $18;
  switch ($202 | 0) {
  case 0:
   {
    $203 = _m_malloc(16) | 0;
    $19 = $203;
    $204 = $19;
    HEAP32[$204 >> 2] = 20948;
    $205 = $16;
    $206 = $205 + 8 | 0;
    $207 = $206 + 4 | 0;
    $208 = HEAP32[$207 >> 2] | 0;
    $209 = $19;
    $210 = $209 + 4 | 0;
    HEAP32[$210 >> 2] = $208;
    $211 = $7;
    $212 = $211 + 8 | 0;
    $213 = HEAP32[$212 >> 2] | 0;
    $214 = $17;
    $215 = $213 + $214 | 0;
    $216 = $19;
    $217 = $216 + 8 | 0;
    HEAP32[$217 >> 2] = $215;
    $218 = $7;
    $219 = $218 + 12 | 0;
    $220 = HEAP32[$219 >> 2] | 0;
    $221 = $19;
    $222 = $221 + 12 | 0;
    HEAP32[$222 >> 2] = $220;
    $223 = $19;
    $3 = $223;
    $266 = $3;
    STACKTOP = sp;
    return $266 | 0;
    break;
   }
  case 2:
   {
    $224 = $16;
    $225 = $224 + 4 | 0;
    $226 = HEAP32[$225 >> 2] | 0;
    $227 = ($226 | 0) == 2;
    if ($227) {
     $228 = $16;
     $229 = $228 + 8 | 0;
     $230 = $229 + 4 | 0;
     $231 = HEAP32[$230 >> 2] | 0;
     $232 = $231;
     $233 = $232 >> 1;
     $234 = $233 >> 27;
     $235 = $234 & 15;
     $236 = ($235 | 0) == 0;
     if ($236) {
      $237 = $16;
      $238 = $7;
      $239 = $238 + 12 | 0;
      $240 = HEAP32[$239 >> 2] | 0;
      $241 = _uctypes_struct_agg_size($237, $240, $20) | 0;
      $242 = $7;
      $243 = $242 + 8 | 0;
      $244 = HEAP32[$243 >> 2] | 0;
      $245 = $17;
      $246 = $244 + $245 | 0;
      $247 = _mp_obj_new_bytearray_by_ref($241, $246) | 0;
      $3 = $247;
      $266 = $3;
      STACKTOP = sp;
      return $266 | 0;
     }
    }
    break;
   }
  case 1:
   {
    break;
   }
  default:
   {
    $3 = 0;
    $266 = $3;
    STACKTOP = sp;
    return $266 | 0;
   }
  }
  $248 = _m_malloc(16) | 0;
  $21 = $248;
  $249 = $21;
  HEAP32[$249 >> 2] = 20948;
  $250 = $16;
  $251 = $21;
  $252 = $251 + 4 | 0;
  HEAP32[$252 >> 2] = $250;
  $253 = $7;
  $254 = $253 + 8 | 0;
  $255 = HEAP32[$254 >> 2] | 0;
  $256 = $17;
  $257 = $255 + $256 | 0;
  $258 = $21;
  $259 = $258 + 8 | 0;
  HEAP32[$259 >> 2] = $257;
  $260 = $7;
  $261 = $260 + 12 | 0;
  $262 = HEAP32[$261 >> 2] | 0;
  $263 = $21;
  $264 = $263 + 12 | 0;
  HEAP32[$264 >> 2] = $262;
  $265 = $21;
  $3 = $265;
  $266 = $3;
  STACKTOP = sp;
  return $266 | 0;
 }
 $52 = $51;
 $53 = $52 >> 1;
 $9 = $53;
 $54 = $9;
 $55 = $54 >> 27;
 $56 = $55 & 15;
 $10 = $56;
 $57 = $9;
 $58 = $57 & 134217727;
 $9 = $58;
 $59 = $10;
 $60 = $59 >>> 0 <= 7;
 $61 = $10;
 $62 = ($61 | 0) == 14;
 $or$cond = $60 | $62;
 $63 = $10;
 $64 = ($63 | 0) == 15;
 $or$cond3 = $or$cond | $64;
 if ($or$cond3) {
  $65 = $7;
  $66 = $65 + 12 | 0;
  $67 = HEAP32[$66 >> 2] | 0;
  $68 = ($67 | 0) == 2;
  $69 = $6;
  $70 = ($69 | 0) == (0 | 0);
  $71 = $10;
  $72 = $7;
  $73 = $72 + 8 | 0;
  $74 = HEAP32[$73 >> 2] | 0;
  $75 = $9;
  $76 = $74 + $75 | 0;
  if ($68) {
   if ($70) {
    $77 = _get_aligned($71, $76, 0) | 0;
    $3 = $77;
    $266 = $3;
    STACKTOP = sp;
    return $266 | 0;
   } else {
    $78 = $6;
    _set_aligned($71, $76, 0, $78);
    $79 = $6;
    $3 = $79;
    $266 = $3;
    STACKTOP = sp;
    return $266 | 0;
   }
  } else {
   $80 = $7;
   $81 = $80 + 12 | 0;
   $82 = HEAP32[$81 >> 2] | 0;
   if ($70) {
    $83 = _get_unaligned($71, $76, $82) | 0;
    $3 = $83;
    $266 = $3;
    STACKTOP = sp;
    return $266 | 0;
   } else {
    $84 = $6;
    _set_unaligned($71, $76, $82, $84);
    $85 = $6;
    $3 = $85;
    $266 = $3;
    STACKTOP = sp;
    return $266 | 0;
   }
  }
 }
 $86 = $10;
 $87 = $86 >>> 0 >= 8;
 $88 = $10;
 $89 = $88 >>> 0 <= 13;
 $or$cond5 = $87 & $89;
 if (!$or$cond5) {
  $3 = 0;
  $266 = $3;
  STACKTOP = sp;
  return $266 | 0;
 }
 $90 = $9;
 $91 = $90 >> 17;
 $92 = $91 & 31;
 $11 = $92;
 $93 = $9;
 $94 = $93 >> 22;
 $95 = $94 & 31;
 $12 = $95;
 $96 = $9;
 $97 = $96 & 131071;
 $9 = $97;
 $98 = $7;
 $99 = $98 + 12 | 0;
 $100 = HEAP32[$99 >> 2] | 0;
 $101 = ($100 | 0) == 2;
 $102 = $10;
 if ($101) {
  $103 = $102 & 6;
  $104 = $7;
  $105 = $104 + 8 | 0;
  $106 = HEAP32[$105 >> 2] | 0;
  $107 = $9;
  $108 = $106 + $107 | 0;
  $109 = _get_aligned_basic($103, $108) | 0;
  $13 = $109;
 } else {
  $110 = $102 & 7;
  $111 = $110 >>> 1;
  $112 = 1 << $111;
  $113 = $10;
  $114 = $113 & 1;
  $115 = ($114 | 0) != 0;
  $116 = $7;
  $117 = $116 + 12 | 0;
  $118 = HEAP32[$117 >> 2] | 0;
  $119 = ($118 | 0) != 0;
  $120 = $7;
  $121 = $120 + 8 | 0;
  $122 = HEAP32[$121 >> 2] | 0;
  $123 = $9;
  $124 = $122 + $123 | 0;
  $125 = _mp_binary_get_int($112, $115, $119, $124) | 0;
  $126 = getTempRet0() | 0;
  $13 = $125;
 }
 $127 = $6;
 $128 = ($127 | 0) == (0 | 0);
 if ($128) {
  $129 = $11;
  $130 = $13;
  $131 = $130 >>> $129;
  $13 = $131;
  $132 = $12;
  $133 = 1 << $132;
  $134 = $133 - 1 | 0;
  $135 = $13;
  $136 = $135 & $134;
  $13 = $136;
  $137 = $13;
  $138 = _mp_obj_new_int($137) | 0;
  $3 = $138;
  $266 = $3;
  STACKTOP = sp;
  return $266 | 0;
 }
 $139 = $6;
 $140 = _mp_obj_get_int($139) | 0;
 $14 = $140;
 $141 = $12;
 $142 = 1 << $141;
 $143 = $142 - 1 | 0;
 $15 = $143;
 $144 = $15;
 $145 = $14;
 $146 = $145 & $144;
 $14 = $146;
 $147 = $11;
 $148 = $14;
 $149 = $148 << $147;
 $14 = $149;
 $150 = $11;
 $151 = $15;
 $152 = $151 << $150;
 $15 = $152;
 $153 = $13;
 $154 = $15;
 $155 = $154 ^ -1;
 $156 = $153 & $155;
 $157 = $14;
 $158 = $156 | $157;
 $13 = $158;
 $159 = $7;
 $160 = $159 + 12 | 0;
 $161 = HEAP32[$160 >> 2] | 0;
 $162 = ($161 | 0) == 2;
 $163 = $10;
 if ($162) {
  $164 = $163 & 6;
  $165 = $7;
  $166 = $165 + 8 | 0;
  $167 = HEAP32[$166 >> 2] | 0;
  $168 = $9;
  $169 = $167 + $168 | 0;
  $170 = $13;
  _set_aligned_basic($164, $169, $170);
 } else {
  $171 = $163 & 7;
  $172 = $171 >>> 1;
  $173 = 1 << $172;
  $174 = $7;
  $175 = $174 + 12 | 0;
  $176 = HEAP32[$175 >> 2] | 0;
  $177 = ($176 | 0) == 1;
  $178 = $7;
  $179 = $178 + 8 | 0;
  $180 = HEAP32[$179 >> 2] | 0;
  $181 = $9;
  $182 = $180 + $181 | 0;
  $183 = $13;
  _mp_binary_set_int($173, $177, $182, $183);
 }
 $184 = $6;
 $3 = $184;
 $266 = $3;
 STACKTOP = sp;
 return $266 | 0;
}

function _compile_atom_expr_normal($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $2 = $0;
 $3 = $1;
 $15 = $2;
 $16 = $3;
 $17 = $16 + 8 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 _compile_node($15, $18);
 $19 = $3;
 $20 = $19 + 8 | 0;
 $21 = $20 + 4 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = ($22 | 0) == 0;
 if ($23) {
  STACKTOP = sp;
  return;
 }
 $4 = 1;
 $24 = $3;
 $25 = $24 + 8 | 0;
 $26 = $25 + 4 | 0;
 $5 = $26;
 $27 = $5;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = $28 + 4 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = $30 & 255;
 $32 = ($31 | 0) == 140;
 if ($32) {
  $33 = $5;
  $34 = HEAP32[$33 >> 2] | 0;
  $35 = $34 + 4 | 0;
  $36 = HEAP32[$35 >> 2] | 0;
  $37 = $36 >>> 8;
  $4 = $37;
  $38 = $5;
  $39 = HEAP32[$38 >> 2] | 0;
  $40 = $39 + 8 | 0;
  $5 = $40;
 }
 $6 = 0;
 $41 = $2;
 $42 = $41 + 36 | 0;
 $43 = HEAP32[$42 >> 2] | 0;
 $44 = HEAP32[$43 >> 2] | 0;
 $45 = ($44 | 0) == 7;
 do {
  if ($45) {
   $46 = $3;
   $47 = $46 + 8 | 0;
   $48 = HEAP32[$47 >> 2] | 0;
   $49 = $48 & 15;
   $50 = ($49 | 0) == 2;
   if ($50) {
    $51 = $3;
    $52 = $51 + 8 | 0;
    $53 = HEAP32[$52 >> 2] | 0;
    $54 = $53 >>> 4;
    $55 = ($54 | 0) == 154;
    if ($55) {
     $56 = $5;
     $57 = HEAP32[$56 >> 2] | 0;
     $58 = $57 + 4 | 0;
     $59 = HEAP32[$58 >> 2] | 0;
     $60 = $59 & 255;
     $61 = ($60 | 0) == 47;
     if ($61) {
      $62 = $5;
      $63 = HEAP32[$62 >> 2] | 0;
      $64 = $63 + 8 | 0;
      $65 = HEAP32[$64 >> 2] | 0;
      $66 = ($65 | 0) == 0;
      if ($66) {
       $67 = $2;
       _compile_load_id($67, 10);
       $7 = 0;
       $68 = $2;
       $69 = $68 + 36 | 0;
       $70 = HEAP32[$69 >> 2] | 0;
       $71 = $70 + 44 | 0;
       $72 = HEAP32[$71 >> 2] | 0;
       $8 = $72;
       $73 = $2;
       $74 = $73 + 36 | 0;
       $75 = HEAP32[$74 >> 2] | 0;
       $76 = $75 + 42 | 0;
       $77 = HEAP16[$76 >> 1] | 0;
       $78 = $77 & 65535;
       $9 = $78;
       while (1) {
        $79 = $9;
        $80 = $79 >>> 0 > 0;
        if (!$80) {
         break;
        }
        $81 = $8;
        $82 = $81 + 1 | 0;
        $83 = HEAP8[$82 >> 0] | 0;
        $84 = $83 & 255;
        $85 = $84 & 1;
        $86 = ($85 | 0) != 0;
        if ($86) {
         label = 12;
         break;
        }
        $91 = $9;
        $92 = $91 + -1 | 0;
        $9 = $92;
        $93 = $8;
        $94 = $93 + 8 | 0;
        $8 = $94;
       }
       if ((label | 0) == 12) {
        $87 = $2;
        $88 = $8;
        $89 = $88 + 4 | 0;
        $90 = HEAP32[$89 >> 2] | 0;
        _compile_load_id($87, $90);
        $7 = 1;
       }
       $95 = $7;
       $96 = $95 & 1;
       if (!$96) {
        $97 = $2;
        $98 = $5;
        $99 = HEAP32[$98 >> 2] | 0;
        $100 = $99;
        _compile_syntax_error($97, $100, 29049);
        STACKTOP = sp;
        return;
       }
       $101 = $4;
       $102 = $101 >>> 0 >= 3;
       if ($102) {
        $103 = $5;
        $104 = $103 + 4 | 0;
        $105 = HEAP32[$104 >> 2] | 0;
        $106 = $105 + 4 | 0;
        $107 = HEAP32[$106 >> 2] | 0;
        $108 = $107 & 255;
        $109 = ($108 | 0) == 49;
        if ($109) {
         $110 = $5;
         $111 = $110 + 8 | 0;
         $112 = HEAP32[$111 >> 2] | 0;
         $113 = $112 + 4 | 0;
         $114 = HEAP32[$113 >> 2] | 0;
         $115 = $114 & 255;
         $116 = ($115 | 0) == 47;
         if ($116) {
          $117 = $5;
          $118 = $117 + 4 | 0;
          $119 = HEAP32[$118 >> 2] | 0;
          $10 = $119;
          $120 = $5;
          $121 = $120 + 8 | 0;
          $122 = HEAP32[$121 >> 2] | 0;
          $11 = $122;
          $123 = $2;
          $124 = $123 + 40 | 0;
          $125 = HEAP32[$124 >> 2] | 0;
          $126 = $10;
          $127 = $126 + 8 | 0;
          $128 = HEAP32[$127 >> 2] | 0;
          $129 = $128 >>> 4;
          _mp_emit_bc_load_method($125, $129, 1);
          $130 = $2;
          $131 = $11;
          $132 = $131 + 8 | 0;
          $133 = HEAP32[$132 >> 2] | 0;
          _compile_trailer_paren_helper($130, $133, 1, 0);
          $6 = 3;
          break;
         }
        }
       }
       $134 = $2;
       $135 = $134 + 40 | 0;
       $136 = HEAP32[$135 >> 2] | 0;
       _mp_emit_bc_call_function($136, 2, 0, 0);
       $6 = 1;
      } else {
       label = 21;
      }
     } else {
      label = 21;
     }
    } else {
     label = 21;
    }
   } else {
    label = 21;
   }
  } else {
   label = 21;
  }
 } while (0);
 if ((label | 0) == 21) {
  $137 = $3;
  $138 = $137 + 8 | 0;
  $139 = HEAP32[$138 >> 2] | 0;
  $140 = $139 & 15;
  $141 = ($140 | 0) == 2;
  if ($141) {
   $142 = $3;
   $143 = $142 + 8 | 0;
   $144 = HEAP32[$143 >> 2] | 0;
   $145 = $144 >>> 4;
   $146 = ($145 | 0) == 272;
   if ($146) {
    $147 = $5;
    $148 = HEAP32[$147 >> 2] | 0;
    $149 = $148 + 4 | 0;
    $150 = HEAP32[$149 >> 2] | 0;
    $151 = $150 & 255;
    $152 = ($151 | 0) == 47;
    if ($152) {
     $153 = $5;
     $154 = HEAP32[$153 >> 2] | 0;
     $155 = $154 + 8 | 0;
     $156 = HEAP32[$155 >> 2] | 0;
     $157 = ($156 | 0) != 0;
     if ($157) {
      $158 = $5;
      $159 = HEAP32[$158 >> 2] | 0;
      $160 = $159 + 8 | 0;
      $161 = HEAP32[$160 >> 2] | 0;
      $162 = $161 & 3;
      $163 = ($162 | 0) == 0;
      if ($163) {
       $164 = $5;
       $165 = HEAP32[$164 >> 2] | 0;
       $166 = $165 + 8 | 0;
       $167 = HEAP32[$166 >> 2] | 0;
       $168 = $167;
       $169 = $168 + 4 | 0;
       $170 = HEAP32[$169 >> 2] | 0;
       $171 = $170 & 255;
       $172 = ($171 | 0) == 46;
       if ($172) {
        $173 = $2;
        $174 = $173 + 40 | 0;
        $175 = HEAP32[$174 >> 2] | 0;
        _mp_emit_bc_call_function($175, 0, 0, 0);
        $176 = $5;
        $177 = HEAP32[$176 >> 2] | 0;
        $178 = $177 + 8 | 0;
        $179 = HEAP32[$178 >> 2] | 0;
        $180 = $179;
        $12 = $180;
        $181 = $2;
        $182 = $12;
        _compile_atom_brace_helper($181, $182, 0);
        $6 = 1;
       }
      }
     }
    }
   }
  }
 }
 while (1) {
  $183 = $6;
  $184 = $4;
  $185 = $183 >>> 0 < $184 >>> 0;
  if (!$185) {
   break;
  }
  $186 = $6;
  $187 = $186 + 1 | 0;
  $188 = $4;
  $189 = $187 >>> 0 < $188 >>> 0;
  if ($189) {
   $190 = $5;
   $191 = $6;
   $192 = $190 + ($191 << 2) | 0;
   $193 = HEAP32[$192 >> 2] | 0;
   $194 = $193 + 4 | 0;
   $195 = HEAP32[$194 >> 2] | 0;
   $196 = $195 & 255;
   $197 = ($196 | 0) == 49;
   if ($197) {
    $198 = $5;
    $199 = $6;
    $200 = $199 + 1 | 0;
    $201 = $198 + ($200 << 2) | 0;
    $202 = HEAP32[$201 >> 2] | 0;
    $203 = $202 + 4 | 0;
    $204 = HEAP32[$203 >> 2] | 0;
    $205 = $204 & 255;
    $206 = ($205 | 0) == 47;
    if ($206) {
     $207 = $5;
     $208 = $6;
     $209 = $207 + ($208 << 2) | 0;
     $210 = HEAP32[$209 >> 2] | 0;
     $13 = $210;
     $211 = $5;
     $212 = $6;
     $213 = $212 + 1 | 0;
     $214 = $211 + ($213 << 2) | 0;
     $215 = HEAP32[$214 >> 2] | 0;
     $14 = $215;
     $216 = $2;
     $217 = $216 + 40 | 0;
     $218 = HEAP32[$217 >> 2] | 0;
     $219 = $13;
     $220 = $219 + 8 | 0;
     $221 = HEAP32[$220 >> 2] | 0;
     $222 = $221 >>> 4;
     _mp_emit_bc_load_method($218, $222, 0);
     $223 = $2;
     $224 = $14;
     $225 = $224 + 8 | 0;
     $226 = HEAP32[$225 >> 2] | 0;
     _compile_trailer_paren_helper($223, $226, 1, 0);
     $227 = $6;
     $228 = $227 + 1 | 0;
     $6 = $228;
    } else {
     label = 34;
    }
   } else {
    label = 34;
   }
  } else {
   label = 34;
  }
  if ((label | 0) == 34) {
   label = 0;
   $229 = $2;
   $230 = $5;
   $231 = $6;
   $232 = $230 + ($231 << 2) | 0;
   $233 = HEAP32[$232 >> 2] | 0;
   $234 = $233;
   _compile_node($229, $234);
  }
  $235 = $6;
  $236 = $235 + 1 | 0;
  $6 = $236;
 }
 STACKTOP = sp;
 return;
}

function _mp_repl_autocomplete($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(128 | 0);
 $vararg_buffer = sp;
 $14 = sp + 72 | 0;
 $23 = sp + 36 | 0;
 $28 = sp + 16 | 0;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $32 = $5;
 $9 = $32;
 $33 = $5;
 $34 = $6;
 $35 = $33 + $34 | 0;
 $10 = $35;
 $36 = $10;
 $11 = $36;
 while (1) {
  $37 = $11;
  $38 = $37 + -1 | 0;
  $11 = $38;
  $39 = $5;
  $40 = $38 >>> 0 >= $39 >>> 0;
  if (!$40) {
   break;
  }
  $41 = $11;
  $42 = HEAP8[$41 >> 0] | 0;
  $43 = $42 << 24 >> 24;
  $44 = _unichar_isalpha($43) | 0;
  if (!$44) {
   $45 = $11;
   $46 = HEAP8[$45 >> 0] | 0;
   $47 = $46 << 24 >> 24;
   $48 = _unichar_isdigit($47) | 0;
   if (!$48) {
    $49 = $11;
    $50 = HEAP8[$49 >> 0] | 0;
    $51 = $50 << 24 >> 24;
    $52 = ($51 | 0) == 95;
    if (!$52) {
     $53 = $11;
     $54 = HEAP8[$53 >> 0] | 0;
     $55 = $54 << 24 >> 24;
     $56 = ($55 | 0) == 46;
     if (!$56) {
      label = 7;
      break;
     }
    }
   }
  }
 }
 if ((label | 0) == 7) {
  $57 = $11;
  $58 = $57 + 1 | 0;
  $11 = $58;
  $59 = $11;
  $5 = $59;
 }
 $60 = HEAP32[40572 >> 2] | 0;
 $61 = $60 + 4 | 0;
 $62 = HEAP32[$61 >> 2] | 0;
 $63 = HEAP32[40572 >> 2] | 0;
 $64 = $63 + 12 | 0;
 $65 = HEAP32[$64 >> 2] | 0;
 $66 = $62 + $65 | 0;
 $12 = $66;
 $13 = 13376;
 while (1) {
  $67 = $5;
  $15 = $67;
  while (1) {
   $68 = $5;
   $69 = $10;
   $70 = $68 >>> 0 < $69 >>> 0;
   if ($70) {
    $71 = $5;
    $72 = HEAP8[$71 >> 0] | 0;
    $73 = $72 << 24 >> 24;
    $74 = ($73 | 0) != 46;
    $224 = $74;
   } else {
    $224 = 0;
   }
   $75 = $5;
   if (!$224) {
    break;
   }
   $76 = $75 + 1 | 0;
   $5 = $76;
  }
  $77 = $15;
  $78 = $75;
  $79 = $77;
  $80 = $78 - $79 | 0;
  $16 = $80;
  $81 = $5;
  $82 = $10;
  $83 = $81 >>> 0 < $82 >>> 0;
  if (!$83) {
   label = 21;
   break;
  }
  $84 = $15;
  $85 = $16;
  $86 = _qstr_find_strn($84, $85) | 0;
  $17 = $86;
  $87 = $17;
  $88 = ($87 | 0) == 0;
  if ($88) {
   label = 17;
   break;
  }
  $89 = $13;
  $90 = $17;
  _mp_load_method_protected($89, $90, $14, 1);
  $91 = HEAP32[$14 >> 2] | 0;
  $13 = $91;
  $92 = $13;
  $93 = ($92 | 0) == (0 | 0);
  if ($93) {
   label = 19;
   break;
  }
  $94 = $5;
  $95 = $94 + 1 | 0;
  $5 = $95;
 }
 if ((label | 0) == 17) {
  $4 = 0;
  $223 = $4;
  STACKTOP = sp;
  return $223 | 0;
 } else if ((label | 0) == 19) {
  $4 = 0;
  $223 = $4;
  STACKTOP = sp;
  return $223 | 0;
 } else if ((label | 0) == 21) {
  $18 = 0;
  $19 = 0;
  $20 = 0;
  $21 = 0;
  $22 = 2;
  while (1) {
   $96 = $22;
   $97 = $12;
   $98 = $96 >>> 0 < $97 >>> 0;
   if (!$98) {
    break;
   }
   $99 = $22;
   $100 = _qstr_data($99, $23) | 0;
   $24 = $100;
   $101 = $16;
   $102 = HEAP32[$23 >> 2] | 0;
   $103 = $101 >>> 0 <= $102 >>> 0;
   if ($103) {
    $104 = $15;
    $105 = $24;
    $106 = $16;
    $107 = _strncmp($104, $105, $106) | 0;
    $108 = ($107 | 0) == 0;
    if ($108) {
     $109 = $13;
     $110 = $22;
     _mp_load_method_protected($109, $110, $14, 1);
     $111 = HEAP32[$14 >> 2] | 0;
     $112 = ($111 | 0) != (0 | 0);
     if ($112) {
      $113 = $18;
      $114 = ($113 | 0) == (0 | 0);
      L37 : do {
       if ($114) {
        $115 = $24;
        $18 = $115;
        $116 = HEAP32[$23 >> 2] | 0;
        $19 = $116;
       } else {
        $117 = $16;
        $25 = $117;
        while (1) {
         $118 = $25;
         $119 = $19;
         $120 = $118 >>> 0 <= $119 >>> 0;
         if (!$120) {
          break L37;
         }
         $121 = $25;
         $122 = HEAP32[$23 >> 2] | 0;
         $123 = $121 >>> 0 <= $122 >>> 0;
         if (!$123) {
          break L37;
         }
         $124 = $18;
         $125 = $25;
         $126 = $124 + $125 | 0;
         $127 = HEAP8[$126 >> 0] | 0;
         $128 = $127 << 24 >> 24;
         $129 = $24;
         $130 = $25;
         $131 = $129 + $130 | 0;
         $132 = HEAP8[$131 >> 0] | 0;
         $133 = $132 << 24 >> 24;
         $134 = ($128 | 0) != ($133 | 0);
         $135 = $25;
         if ($134) {
          break;
         }
         $136 = $135 + 1 | 0;
         $25 = $136;
        }
        $19 = $135;
       }
      } while (0);
      $137 = $20;
      $138 = ($137 | 0) == 0;
      if ($138) {
       $139 = $22;
       $20 = $139;
      }
      $140 = $22;
      $21 = $140;
     }
    }
   }
   $141 = $22;
   $142 = $141 + 1 | 0;
   $22 = $142;
  }
  $143 = $20;
  $144 = ($143 | 0) == 0;
  if ($144) {
   $145 = $15;
   $146 = $9;
   $147 = ($145 | 0) == ($146 | 0);
   if ($147) {
    $148 = $15;
    $149 = $16;
    $150 = _memcmp($148, 34443, $149) | 0;
    $151 = ($150 | 0) == 0;
    if ($151) {
     $152 = $16;
     $153 = 34443 + $152 | 0;
     $154 = $8;
     HEAP32[$154 >> 2] = $153;
     $155 = $16;
     $156 = 7 - $155 | 0;
     $4 = $156;
     $223 = $4;
     STACKTOP = sp;
     return $223 | 0;
    }
   }
   $4 = 0;
   $223 = $4;
   STACKTOP = sp;
   return $223 | 0;
  }
  $157 = $20;
  $158 = $21;
  $159 = ($157 | 0) == ($158 | 0);
  if (!$159) {
   $160 = $19;
   $161 = $16;
   $162 = $160 >>> 0 > $161 >>> 0;
   if (!$162) {
    $26 = 64;
    $170 = $20;
    $27 = $170;
    while (1) {
     $171 = $27;
     $172 = $21;
     $173 = $171 >>> 0 <= $172 >>> 0;
     if (!$173) {
      break;
     }
     $174 = $27;
     $175 = _qstr_data($174, $28) | 0;
     $29 = $175;
     $176 = $16;
     $177 = HEAP32[$28 >> 2] | 0;
     $178 = $176 >>> 0 <= $177 >>> 0;
     do {
      if ($178) {
       $179 = $15;
       $180 = $29;
       $181 = $16;
       $182 = _strncmp($179, $180, $181) | 0;
       $183 = ($182 | 0) == 0;
       if ($183) {
        $184 = $13;
        $185 = $27;
        _mp_load_method_protected($184, $185, $14, 1);
        $186 = HEAP32[$14 >> 2] | 0;
        $187 = ($186 | 0) != (0 | 0);
        if ($187) {
         $188 = $26;
         $189 = $188 + 16 | 0;
         $190 = $189 - 1 | 0;
         $191 = ($190 | 0) / 16 & -1;
         $192 = $191 << 4;
         $193 = $26;
         $194 = $192 - $193 | 0;
         $30 = $194;
         $195 = $30;
         $196 = ($195 | 0) < 2;
         if ($196) {
          $197 = $30;
          $198 = $197 + 16 | 0;
          $30 = $198;
         }
         $199 = $26;
         $200 = $30;
         $201 = $199 + $200 | 0;
         $202 = HEAP32[$28 >> 2] | 0;
         $203 = $201 + $202 | 0;
         $204 = $203 >>> 0 <= 64;
         if (!$204) {
          $217 = $7;
          $218 = $29;
          HEAP32[$vararg_buffer >> 2] = $218;
          _mp_printf($217, 34453, $vararg_buffer) | 0;
          $219 = HEAP32[$28 >> 2] | 0;
          $26 = $219;
          break;
         }
         $31 = 0;
         while (1) {
          $205 = $31;
          $206 = $30;
          $207 = ($205 | 0) < ($206 | 0);
          $208 = $7;
          if (!$207) {
           break;
          }
          _mp_print_str($208, 34451) | 0;
          $209 = $31;
          $210 = $209 + 1 | 0;
          $31 = $210;
         }
         $211 = $29;
         _mp_print_str($208, $211) | 0;
         $212 = $30;
         $213 = HEAP32[$28 >> 2] | 0;
         $214 = $212 + $213 | 0;
         $215 = $26;
         $216 = $215 + $214 | 0;
         $26 = $216;
        }
       }
      }
     } while (0);
     $220 = $27;
     $221 = $220 + 1 | 0;
     $27 = $221;
    }
    $222 = $7;
    _mp_print_str($222, 34812) | 0;
    $4 = -1;
    $223 = $4;
    STACKTOP = sp;
    return $223 | 0;
   }
  }
  $163 = $18;
  $164 = $16;
  $165 = $163 + $164 | 0;
  $166 = $8;
  HEAP32[$166 >> 2] = $165;
  $167 = $19;
  $168 = $16;
  $169 = $167 - $168 | 0;
  $4 = $169;
  $223 = $4;
  STACKTOP = sp;
  return $223 | 0;
 }
 return 0 | 0;
}

function _scope_compute_things($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $5 = sp + 48 | 0;
 $1 = $0;
 $17 = $1;
 $18 = $17 + 24 | 0;
 $19 = HEAP16[$18 >> 1] | 0;
 $20 = $19 & 65535;
 $21 = $20 & 1;
 $22 = ($21 | 0) != 0;
 L1 : do {
  if ($22) {
   $2 = 0;
   $23 = $1;
   $24 = $23 + 42 | 0;
   $25 = HEAP16[$24 >> 1] | 0;
   $26 = $25 & 65535;
   $27 = $26 - 1 | 0;
   $3 = $27;
   while (1) {
    $28 = $3;
    $29 = ($28 | 0) >= 0;
    if (!$29) {
     break L1;
    }
    $30 = $1;
    $31 = $30 + 44 | 0;
    $32 = HEAP32[$31 >> 2] | 0;
    $33 = $3;
    $34 = $32 + ($33 << 3) | 0;
    $4 = $34;
    $35 = $4;
    $36 = $35 + 1 | 0;
    $37 = HEAP8[$36 >> 0] | 0;
    $38 = $37 & 255;
    $39 = $38 & 2;
    $40 = ($39 | 0) != 0;
    $41 = $2;
    if ($40) {
     break;
    }
    $47 = ($41 | 0) == (0 | 0);
    if ($47) {
     $48 = $4;
     $49 = $48 + 1 | 0;
     $50 = HEAP8[$49 >> 0] | 0;
     $51 = $50 & 255;
     $52 = ($51 | 0) == 1;
     if ($52) {
      $53 = $4;
      $2 = $53;
     }
    }
    $54 = $3;
    $55 = $54 + -1 | 0;
    $3 = $55;
   }
   $42 = ($41 | 0) != (0 | 0);
   if ($42) {
    $43 = $2;
    HEAP32[$5 >> 2] = HEAP32[$43 >> 2] | 0;
    HEAP32[$5 + 4 >> 2] = HEAP32[$43 + 4 >> 2] | 0;
    $44 = $2;
    $45 = $4;
    HEAP32[$44 >> 2] = HEAP32[$45 >> 2] | 0;
    HEAP32[$44 + 4 >> 2] = HEAP32[$45 + 4 >> 2] | 0;
    $46 = $4;
    HEAP32[$46 >> 2] = HEAP32[$5 >> 2] | 0;
    HEAP32[$46 + 4 >> 2] = HEAP32[$5 + 4 >> 2] | 0;
   }
  }
 } while (0);
 $56 = $1;
 $57 = $56 + 34 | 0;
 HEAP16[$57 >> 1] = 0;
 $6 = 0;
 while (1) {
  $58 = $6;
  $59 = $1;
  $60 = $59 + 42 | 0;
  $61 = HEAP16[$60 >> 1] | 0;
  $62 = $61 & 65535;
  $63 = ($58 | 0) < ($62 | 0);
  if (!$63) {
   break;
  }
  $64 = $1;
  $65 = $64 + 44 | 0;
  $66 = HEAP32[$65 >> 2] | 0;
  $67 = $6;
  $68 = $66 + ($67 << 3) | 0;
  $7 = $68;
  $69 = $1;
  $70 = HEAP32[$69 >> 2] | 0;
  $71 = ($70 | 0) == 1;
  if ($71) {
   $72 = $7;
   $73 = $72 + 4 | 0;
   $74 = HEAP32[$73 >> 2] | 0;
   $75 = ($74 | 0) == 10;
   if (!$75) {
    label = 15;
   }
  } else {
   label = 15;
  }
  do {
   if ((label | 0) == 15) {
    label = 0;
    $76 = $1;
    $77 = HEAP32[$76 >> 2] | 0;
    $78 = $77 >>> 0 >= 2;
    if ($78) {
     $79 = $7;
     $80 = HEAP8[$79 >> 0] | 0;
     $81 = $80 & 255;
     $82 = ($81 | 0) == 1;
     if ($82) {
      $83 = $7;
      HEAP8[$83 >> 0] = 2;
     }
    }
    $84 = $7;
    $85 = HEAP8[$84 >> 0] | 0;
    $86 = $85 & 255;
    $87 = ($86 | 0) == 3;
    if (!$87) {
     $88 = $7;
     $89 = $88 + 1 | 0;
     $90 = HEAP8[$89 >> 0] | 0;
     $91 = $90 & 255;
     $92 = $91 & 1;
     $93 = ($92 | 0) != 0;
     if (!$93) {
      break;
     }
    }
    $94 = $1;
    $95 = $94 + 34 | 0;
    $96 = HEAP16[$95 >> 1] | 0;
    $97 = $96 + 1 << 16 >> 16;
    HEAP16[$95 >> 1] = $97;
    $98 = $7;
    $99 = $98 + 2 | 0;
    HEAP16[$99 >> 1] = $96;
   }
  } while (0);
  $100 = $6;
  $101 = $100 + 1 | 0;
  $6 = $101;
 }
 $8 = 0;
 while (1) {
  $102 = $8;
  $103 = $1;
  $104 = $103 + 42 | 0;
  $105 = HEAP16[$104 >> 1] | 0;
  $106 = $105 & 65535;
  $107 = ($102 | 0) < ($106 | 0);
  $108 = $1;
  if (!$107) {
   break;
  }
  $109 = $108 + 44 | 0;
  $110 = HEAP32[$109 >> 2] | 0;
  $111 = $8;
  $112 = $110 + ($111 << 3) | 0;
  $9 = $112;
  $113 = $9;
  $114 = HEAP8[$113 >> 0] | 0;
  $115 = $114 & 255;
  $116 = ($115 | 0) == 4;
  if ($116) {
   $117 = $9;
   $118 = $117 + 1 | 0;
   $119 = HEAP8[$118 >> 0] | 0;
   $120 = $119 & 255;
   $121 = $120 & 1;
   $122 = ($121 | 0) != 0;
   if (!$122) {
    $123 = $1;
    $124 = $123 + 34 | 0;
    $125 = HEAP16[$124 >> 1] | 0;
    $126 = $9;
    $127 = $126 + 2 | 0;
    HEAP16[$127 >> 1] = $125;
    $128 = $1;
    $129 = $128 + 34 | 0;
    $130 = HEAP16[$129 >> 1] | 0;
    $131 = $130 & 65535;
    $132 = $131 + 1 | 0;
    $133 = $132 & 65535;
    HEAP16[$129 >> 1] = $133;
   }
  }
  $134 = $8;
  $135 = $134 + 1 | 0;
  $8 = $135;
 }
 $136 = $108 + 4 | 0;
 $137 = HEAP32[$136 >> 2] | 0;
 $138 = ($137 | 0) != (0 | 0);
 if (!$138) {
  STACKTOP = sp;
  return;
 }
 $10 = 0;
 $11 = 0;
 while (1) {
  $139 = $11;
  $140 = $1;
  $141 = $140 + 4 | 0;
  $142 = HEAP32[$141 >> 2] | 0;
  $143 = $142 + 42 | 0;
  $144 = HEAP16[$143 >> 1] | 0;
  $145 = $144 & 65535;
  $146 = ($139 | 0) < ($145 | 0);
  if (!$146) {
   break;
  }
  $147 = $1;
  $148 = $147 + 4 | 0;
  $149 = HEAP32[$148 >> 2] | 0;
  $150 = $149 + 44 | 0;
  $151 = HEAP32[$150 >> 2] | 0;
  $152 = $11;
  $153 = $151 + ($152 << 3) | 0;
  $12 = $153;
  $154 = $12;
  $155 = HEAP8[$154 >> 0] | 0;
  $156 = $155 & 255;
  $157 = ($156 | 0) == 4;
  if ($157) {
   label = 33;
  } else {
   $158 = $12;
   $159 = HEAP8[$158 >> 0] | 0;
   $160 = $159 & 255;
   $161 = ($160 | 0) == 5;
   if ($161) {
    label = 33;
   }
  }
  L46 : do {
   if ((label | 0) == 33) {
    label = 0;
    $13 = 0;
    while (1) {
     $162 = $13;
     $163 = $1;
     $164 = $163 + 42 | 0;
     $165 = HEAP16[$164 >> 1] | 0;
     $166 = $165 & 65535;
     $167 = ($162 | 0) < ($166 | 0);
     if (!$167) {
      break L46;
     }
     $168 = $1;
     $169 = $168 + 44 | 0;
     $170 = HEAP32[$169 >> 2] | 0;
     $171 = $13;
     $172 = $170 + ($171 << 3) | 0;
     $14 = $172;
     $173 = $14;
     $174 = HEAP8[$173 >> 0] | 0;
     $175 = $174 & 255;
     $176 = ($175 | 0) == 5;
     if ($176) {
      $177 = $12;
      $178 = $177 + 4 | 0;
      $179 = HEAP32[$178 >> 2] | 0;
      $180 = $14;
      $181 = $180 + 4 | 0;
      $182 = HEAP32[$181 >> 2] | 0;
      $183 = ($179 | 0) == ($182 | 0);
      if ($183) {
       $184 = $10;
       $185 = $184 & 65535;
       $186 = $14;
       $187 = $186 + 2 | 0;
       HEAP16[$187 >> 1] = $185;
       $188 = $10;
       $189 = $188 + 1 | 0;
       $10 = $189;
      }
     }
     $190 = $13;
     $191 = $190 + 1 | 0;
     $13 = $191;
    }
   }
  } while (0);
  $192 = $11;
  $193 = $192 + 1 | 0;
  $11 = $193;
 }
 $194 = $10;
 $195 = ($194 | 0) > 0;
 if (!$195) {
  STACKTOP = sp;
  return;
 }
 $15 = 0;
 while (1) {
  $196 = $15;
  $197 = $1;
  $198 = $197 + 42 | 0;
  $199 = HEAP16[$198 >> 1] | 0;
  $200 = $199 & 65535;
  $201 = ($196 | 0) < ($200 | 0);
  if (!$201) {
   break;
  }
  $202 = $1;
  $203 = $202 + 44 | 0;
  $204 = HEAP32[$203 >> 2] | 0;
  $205 = $15;
  $206 = $204 + ($205 << 3) | 0;
  $16 = $206;
  $207 = $16;
  $208 = HEAP8[$207 >> 0] | 0;
  $209 = $208 & 255;
  $210 = ($209 | 0) != 5;
  if ($210) {
   label = 45;
  } else {
   $211 = $16;
   $212 = $211 + 1 | 0;
   $213 = HEAP8[$212 >> 0] | 0;
   $214 = $213 & 255;
   $215 = $214 & 1;
   $216 = ($215 | 0) != 0;
   if ($216) {
    label = 45;
   }
  }
  if ((label | 0) == 45) {
   label = 0;
   $217 = $10;
   $218 = $16;
   $219 = $218 + 2 | 0;
   $220 = HEAP16[$219 >> 1] | 0;
   $221 = $220 & 65535;
   $222 = $221 + $217 | 0;
   $223 = $222 & 65535;
   HEAP16[$219 >> 1] = $223;
  }
  $224 = $15;
  $225 = $224 + 1 | 0;
  $15 = $225;
 }
 $226 = $10;
 $227 = $1;
 $228 = $227 + 28 | 0;
 $229 = HEAP16[$228 >> 1] | 0;
 $230 = $229 & 65535;
 $231 = $230 + $226 | 0;
 $232 = $231 & 65535;
 HEAP16[$228 >> 1] = $232;
 $233 = $10;
 $234 = $1;
 $235 = $234 + 34 | 0;
 $236 = HEAP16[$235 >> 1] | 0;
 $237 = $236 & 65535;
 $238 = $237 + $233 | 0;
 $239 = $238 & 65535;
 HEAP16[$235 >> 1] = $239;
 STACKTOP = sp;
 return;
}

function _sha256_transform($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $264 = 0, $265 = 0, $266 = 0, $267 = 0, $268 = 0, $269 = 0, $27 = 0, $270 = 0, $271 = 0, $272 = 0, $273 = 0, $274 = 0, $275 = 0, $276 = 0, $277 = 0, $278 = 0, $279 = 0, $28 = 0, $280 = 0, $281 = 0, $282 = 0, $283 = 0, $284 = 0, $285 = 0, $286 = 0, $287 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 320 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(320 | 0);
 $16 = sp;
 $2 = $0;
 $3 = $1;
 $12 = 0;
 $13 = 0;
 while (1) {
  $17 = $12;
  $18 = $17 >>> 0 < 16;
  if (!$18) {
   break;
  }
  $19 = $3;
  $20 = $13;
  $21 = $19 + $20 | 0;
  $22 = HEAP8[$21 >> 0] | 0;
  $23 = $22 & 255;
  $24 = $23 << 24;
  $25 = $3;
  $26 = $13;
  $27 = $26 + 1 | 0;
  $28 = $25 + $27 | 0;
  $29 = HEAP8[$28 >> 0] | 0;
  $30 = $29 & 255;
  $31 = $30 << 16;
  $32 = $24 | $31;
  $33 = $3;
  $34 = $13;
  $35 = $34 + 2 | 0;
  $36 = $33 + $35 | 0;
  $37 = HEAP8[$36 >> 0] | 0;
  $38 = $37 & 255;
  $39 = $38 << 8;
  $40 = $32 | $39;
  $41 = $3;
  $42 = $13;
  $43 = $42 + 3 | 0;
  $44 = $41 + $43 | 0;
  $45 = HEAP8[$44 >> 0] | 0;
  $46 = $45 & 255;
  $47 = $40 | $46;
  $48 = $12;
  $49 = $16 + ($48 << 2) | 0;
  HEAP32[$49 >> 2] = $47;
  $50 = $12;
  $51 = $50 + 1 | 0;
  $12 = $51;
  $52 = $13;
  $53 = $52 + 4 | 0;
  $13 = $53;
 }
 while (1) {
  $54 = $12;
  $55 = $54 >>> 0 < 64;
  if (!$55) {
   break;
  }
  $56 = $12;
  $57 = $56 - 2 | 0;
  $58 = $16 + ($57 << 2) | 0;
  $59 = HEAP32[$58 >> 2] | 0;
  $60 = $59 >>> 17;
  $61 = $12;
  $62 = $61 - 2 | 0;
  $63 = $16 + ($62 << 2) | 0;
  $64 = HEAP32[$63 >> 2] | 0;
  $65 = $64 << 15;
  $66 = $60 | $65;
  $67 = $12;
  $68 = $67 - 2 | 0;
  $69 = $16 + ($68 << 2) | 0;
  $70 = HEAP32[$69 >> 2] | 0;
  $71 = $70 >>> 19;
  $72 = $12;
  $73 = $72 - 2 | 0;
  $74 = $16 + ($73 << 2) | 0;
  $75 = HEAP32[$74 >> 2] | 0;
  $76 = $75 << 13;
  $77 = $71 | $76;
  $78 = $66 ^ $77;
  $79 = $12;
  $80 = $79 - 2 | 0;
  $81 = $16 + ($80 << 2) | 0;
  $82 = HEAP32[$81 >> 2] | 0;
  $83 = $82 >>> 10;
  $84 = $78 ^ $83;
  $85 = $12;
  $86 = $85 - 7 | 0;
  $87 = $16 + ($86 << 2) | 0;
  $88 = HEAP32[$87 >> 2] | 0;
  $89 = $84 + $88 | 0;
  $90 = $12;
  $91 = $90 - 15 | 0;
  $92 = $16 + ($91 << 2) | 0;
  $93 = HEAP32[$92 >> 2] | 0;
  $94 = $93 >>> 7;
  $95 = $12;
  $96 = $95 - 15 | 0;
  $97 = $16 + ($96 << 2) | 0;
  $98 = HEAP32[$97 >> 2] | 0;
  $99 = $98 << 25;
  $100 = $94 | $99;
  $101 = $12;
  $102 = $101 - 15 | 0;
  $103 = $16 + ($102 << 2) | 0;
  $104 = HEAP32[$103 >> 2] | 0;
  $105 = $104 >>> 18;
  $106 = $12;
  $107 = $106 - 15 | 0;
  $108 = $16 + ($107 << 2) | 0;
  $109 = HEAP32[$108 >> 2] | 0;
  $110 = $109 << 14;
  $111 = $105 | $110;
  $112 = $100 ^ $111;
  $113 = $12;
  $114 = $113 - 15 | 0;
  $115 = $16 + ($114 << 2) | 0;
  $116 = HEAP32[$115 >> 2] | 0;
  $117 = $116 >>> 3;
  $118 = $112 ^ $117;
  $119 = $89 + $118 | 0;
  $120 = $12;
  $121 = $120 - 16 | 0;
  $122 = $16 + ($121 << 2) | 0;
  $123 = HEAP32[$122 >> 2] | 0;
  $124 = $119 + $123 | 0;
  $125 = $12;
  $126 = $16 + ($125 << 2) | 0;
  HEAP32[$126 >> 2] = $124;
  $127 = $12;
  $128 = $127 + 1 | 0;
  $12 = $128;
 }
 $129 = $2;
 $130 = $129 + 80 | 0;
 $131 = HEAP32[$130 >> 2] | 0;
 $4 = $131;
 $132 = $2;
 $133 = $132 + 80 | 0;
 $134 = $133 + 4 | 0;
 $135 = HEAP32[$134 >> 2] | 0;
 $5 = $135;
 $136 = $2;
 $137 = $136 + 80 | 0;
 $138 = $137 + 8 | 0;
 $139 = HEAP32[$138 >> 2] | 0;
 $6 = $139;
 $140 = $2;
 $141 = $140 + 80 | 0;
 $142 = $141 + 12 | 0;
 $143 = HEAP32[$142 >> 2] | 0;
 $7 = $143;
 $144 = $2;
 $145 = $144 + 80 | 0;
 $146 = $145 + 16 | 0;
 $147 = HEAP32[$146 >> 2] | 0;
 $8 = $147;
 $148 = $2;
 $149 = $148 + 80 | 0;
 $150 = $149 + 20 | 0;
 $151 = HEAP32[$150 >> 2] | 0;
 $9 = $151;
 $152 = $2;
 $153 = $152 + 80 | 0;
 $154 = $153 + 24 | 0;
 $155 = HEAP32[$154 >> 2] | 0;
 $10 = $155;
 $156 = $2;
 $157 = $156 + 80 | 0;
 $158 = $157 + 28 | 0;
 $159 = HEAP32[$158 >> 2] | 0;
 $11 = $159;
 $12 = 0;
 while (1) {
  $160 = $12;
  $161 = $160 >>> 0 < 64;
  if (!$161) {
   break;
  }
  $162 = $11;
  $163 = $8;
  $164 = $163 >>> 6;
  $165 = $8;
  $166 = $165 << 26;
  $167 = $164 | $166;
  $168 = $8;
  $169 = $168 >>> 11;
  $170 = $8;
  $171 = $170 << 21;
  $172 = $169 | $171;
  $173 = $167 ^ $172;
  $174 = $8;
  $175 = $174 >>> 25;
  $176 = $8;
  $177 = $176 << 7;
  $178 = $175 | $177;
  $179 = $173 ^ $178;
  $180 = $162 + $179 | 0;
  $181 = $8;
  $182 = $9;
  $183 = $181 & $182;
  $184 = $8;
  $185 = $184 ^ -1;
  $186 = $10;
  $187 = $185 & $186;
  $188 = $183 ^ $187;
  $189 = $180 + $188 | 0;
  $190 = $12;
  $191 = 7952 + ($190 << 2) | 0;
  $192 = HEAP32[$191 >> 2] | 0;
  $193 = $189 + $192 | 0;
  $194 = $12;
  $195 = $16 + ($194 << 2) | 0;
  $196 = HEAP32[$195 >> 2] | 0;
  $197 = $193 + $196 | 0;
  $14 = $197;
  $198 = $4;
  $199 = $198 >>> 2;
  $200 = $4;
  $201 = $200 << 30;
  $202 = $199 | $201;
  $203 = $4;
  $204 = $203 >>> 13;
  $205 = $4;
  $206 = $205 << 19;
  $207 = $204 | $206;
  $208 = $202 ^ $207;
  $209 = $4;
  $210 = $209 >>> 22;
  $211 = $4;
  $212 = $211 << 10;
  $213 = $210 | $212;
  $214 = $208 ^ $213;
  $215 = $4;
  $216 = $5;
  $217 = $215 & $216;
  $218 = $4;
  $219 = $6;
  $220 = $218 & $219;
  $221 = $217 ^ $220;
  $222 = $5;
  $223 = $6;
  $224 = $222 & $223;
  $225 = $221 ^ $224;
  $226 = $214 + $225 | 0;
  $15 = $226;
  $227 = $10;
  $11 = $227;
  $228 = $9;
  $10 = $228;
  $229 = $8;
  $9 = $229;
  $230 = $7;
  $231 = $14;
  $232 = $230 + $231 | 0;
  $8 = $232;
  $233 = $6;
  $7 = $233;
  $234 = $5;
  $6 = $234;
  $235 = $4;
  $5 = $235;
  $236 = $14;
  $237 = $15;
  $238 = $236 + $237 | 0;
  $4 = $238;
  $239 = $12;
  $240 = $239 + 1 | 0;
  $12 = $240;
 }
 $241 = $4;
 $242 = $2;
 $243 = $242 + 80 | 0;
 $244 = HEAP32[$243 >> 2] | 0;
 $245 = $244 + $241 | 0;
 HEAP32[$243 >> 2] = $245;
 $246 = $5;
 $247 = $2;
 $248 = $247 + 80 | 0;
 $249 = $248 + 4 | 0;
 $250 = HEAP32[$249 >> 2] | 0;
 $251 = $250 + $246 | 0;
 HEAP32[$249 >> 2] = $251;
 $252 = $6;
 $253 = $2;
 $254 = $253 + 80 | 0;
 $255 = $254 + 8 | 0;
 $256 = HEAP32[$255 >> 2] | 0;
 $257 = $256 + $252 | 0;
 HEAP32[$255 >> 2] = $257;
 $258 = $7;
 $259 = $2;
 $260 = $259 + 80 | 0;
 $261 = $260 + 12 | 0;
 $262 = HEAP32[$261 >> 2] | 0;
 $263 = $262 + $258 | 0;
 HEAP32[$261 >> 2] = $263;
 $264 = $8;
 $265 = $2;
 $266 = $265 + 80 | 0;
 $267 = $266 + 16 | 0;
 $268 = HEAP32[$267 >> 2] | 0;
 $269 = $268 + $264 | 0;
 HEAP32[$267 >> 2] = $269;
 $270 = $9;
 $271 = $2;
 $272 = $271 + 80 | 0;
 $273 = $272 + 20 | 0;
 $274 = HEAP32[$273 >> 2] | 0;
 $275 = $274 + $270 | 0;
 HEAP32[$273 >> 2] = $275;
 $276 = $10;
 $277 = $2;
 $278 = $277 + 80 | 0;
 $279 = $278 + 24 | 0;
 $280 = HEAP32[$279 >> 2] | 0;
 $281 = $280 + $276 | 0;
 HEAP32[$279 >> 2] = $281;
 $282 = $11;
 $283 = $2;
 $284 = $283 + 80 | 0;
 $285 = $284 + 28 | 0;
 $286 = HEAP32[$285 >> 2] | 0;
 $287 = $286 + $282 | 0;
 HEAP32[$285 >> 2] = $287;
 STACKTOP = sp;
 return;
}

function _sha256_final($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $2 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $216 = 0, $217 = 0, $218 = 0, $219 = 0, $22 = 0, $220 = 0, $221 = 0, $222 = 0, $223 = 0, $224 = 0, $225 = 0, $226 = 0, $227 = 0, $228 = 0, $229 = 0, $23 = 0, $230 = 0, $231 = 0, $232 = 0, $233 = 0, $234 = 0, $235 = 0, $236 = 0, $237 = 0, $238 = 0, $239 = 0, $24 = 0, $240 = 0, $241 = 0, $242 = 0, $243 = 0, $244 = 0, $245 = 0, $246 = 0, $247 = 0, $248 = 0, $249 = 0, $25 = 0, $250 = 0, $251 = 0, $252 = 0, $253 = 0, $254 = 0, $255 = 0, $256 = 0, $257 = 0, $258 = 0, $259 = 0, $26 = 0, $260 = 0, $261 = 0, $262 = 0, $263 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, dest = 0, label = 0, sp = 0, stop = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = $5 + 64 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $4 = $7;
 $8 = $2;
 $9 = $8 + 64 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $10 >>> 0 < 56;
 $12 = $2;
 $13 = $4;
 $14 = $13 + 1 | 0;
 $4 = $14;
 $15 = $12 + $13 | 0;
 HEAP8[$15 >> 0] = -128;
 L1 : do {
  if ($11) {
   while (1) {
    $16 = $4;
    $17 = $16 >>> 0 < 56;
    if (!$17) {
     break L1;
    }
    $18 = $2;
    $19 = $4;
    $20 = $19 + 1 | 0;
    $4 = $20;
    $21 = $18 + $19 | 0;
    HEAP8[$21 >> 0] = 0;
   }
  } else {
   while (1) {
    $22 = $4;
    $23 = $22 >>> 0 < 64;
    $24 = $2;
    if (!$23) {
     break;
    }
    $25 = $4;
    $26 = $25 + 1 | 0;
    $4 = $26;
    $27 = $24 + $25 | 0;
    HEAP8[$27 >> 0] = 0;
   }
   $28 = $2;
   _sha256_transform($24, $28);
   $29 = $2;
   dest = $29;
   stop = dest + 56 | 0;
   do {
    HEAP32[dest >> 2] = 0 | 0;
    dest = dest + 4 | 0;
   } while ((dest | 0) < (stop | 0));
  }
 } while (0);
 $30 = $2;
 $31 = $30 + 64 | 0;
 $32 = HEAP32[$31 >> 2] | 0;
 $33 = $32 << 3;
 $34 = $2;
 $35 = $34 + 72 | 0;
 $36 = $35;
 $37 = $36;
 $38 = HEAP32[$37 >> 2] | 0;
 $39 = $36 + 4 | 0;
 $40 = $39;
 $41 = HEAP32[$40 >> 2] | 0;
 $42 = _i64Add($38 | 0, $41 | 0, $33 | 0, 0) | 0;
 $43 = getTempRet0() | 0;
 $44 = $35;
 $45 = $44;
 HEAP32[$45 >> 2] = $42;
 $46 = $44 + 4 | 0;
 $47 = $46;
 HEAP32[$47 >> 2] = $43;
 $48 = $2;
 $49 = $48 + 72 | 0;
 $50 = $49;
 $51 = $50;
 $52 = HEAP32[$51 >> 2] | 0;
 $53 = $50 + 4 | 0;
 $54 = $53;
 $55 = HEAP32[$54 >> 2] | 0;
 $56 = $52 & 255;
 $57 = $2;
 $58 = $57 + 63 | 0;
 HEAP8[$58 >> 0] = $56;
 $59 = $2;
 $60 = $59 + 72 | 0;
 $61 = $60;
 $62 = $61;
 $63 = HEAP32[$62 >> 2] | 0;
 $64 = $61 + 4 | 0;
 $65 = $64;
 $66 = HEAP32[$65 >> 2] | 0;
 $67 = _bitshift64Lshr($63 | 0, $66 | 0, 8) | 0;
 $68 = getTempRet0() | 0;
 $69 = $67 & 255;
 $70 = $2;
 $71 = $70 + 62 | 0;
 HEAP8[$71 >> 0] = $69;
 $72 = $2;
 $73 = $72 + 72 | 0;
 $74 = $73;
 $75 = $74;
 $76 = HEAP32[$75 >> 2] | 0;
 $77 = $74 + 4 | 0;
 $78 = $77;
 $79 = HEAP32[$78 >> 2] | 0;
 $80 = _bitshift64Lshr($76 | 0, $79 | 0, 16) | 0;
 $81 = getTempRet0() | 0;
 $82 = $80 & 255;
 $83 = $2;
 $84 = $83 + 61 | 0;
 HEAP8[$84 >> 0] = $82;
 $85 = $2;
 $86 = $85 + 72 | 0;
 $87 = $86;
 $88 = $87;
 $89 = HEAP32[$88 >> 2] | 0;
 $90 = $87 + 4 | 0;
 $91 = $90;
 $92 = HEAP32[$91 >> 2] | 0;
 $93 = _bitshift64Lshr($89 | 0, $92 | 0, 24) | 0;
 $94 = getTempRet0() | 0;
 $95 = $93 & 255;
 $96 = $2;
 $97 = $96 + 60 | 0;
 HEAP8[$97 >> 0] = $95;
 $98 = $2;
 $99 = $98 + 72 | 0;
 $100 = $99;
 $101 = $100;
 $102 = HEAP32[$101 >> 2] | 0;
 $103 = $100 + 4 | 0;
 $104 = $103;
 $105 = HEAP32[$104 >> 2] | 0;
 $106 = $105 & 255;
 $107 = $2;
 $108 = $107 + 59 | 0;
 HEAP8[$108 >> 0] = $106;
 $109 = $2;
 $110 = $109 + 72 | 0;
 $111 = $110;
 $112 = $111;
 $113 = HEAP32[$112 >> 2] | 0;
 $114 = $111 + 4 | 0;
 $115 = $114;
 $116 = HEAP32[$115 >> 2] | 0;
 $117 = _bitshift64Lshr($113 | 0, $116 | 0, 40) | 0;
 $118 = getTempRet0() | 0;
 $119 = $117 & 255;
 $120 = $2;
 $121 = $120 + 58 | 0;
 HEAP8[$121 >> 0] = $119;
 $122 = $2;
 $123 = $122 + 72 | 0;
 $124 = $123;
 $125 = $124;
 $126 = HEAP32[$125 >> 2] | 0;
 $127 = $124 + 4 | 0;
 $128 = $127;
 $129 = HEAP32[$128 >> 2] | 0;
 $130 = _bitshift64Lshr($126 | 0, $129 | 0, 48) | 0;
 $131 = getTempRet0() | 0;
 $132 = $130 & 255;
 $133 = $2;
 $134 = $133 + 57 | 0;
 HEAP8[$134 >> 0] = $132;
 $135 = $2;
 $136 = $135 + 72 | 0;
 $137 = $136;
 $138 = $137;
 $139 = HEAP32[$138 >> 2] | 0;
 $140 = $137 + 4 | 0;
 $141 = $140;
 $142 = HEAP32[$141 >> 2] | 0;
 $143 = _bitshift64Lshr($139 | 0, $142 | 0, 56) | 0;
 $144 = getTempRet0() | 0;
 $145 = $143 & 255;
 $146 = $2;
 $147 = $146 + 56 | 0;
 HEAP8[$147 >> 0] = $145;
 $148 = $2;
 $149 = $2;
 _sha256_transform($148, $149);
 $4 = 0;
 while (1) {
  $150 = $4;
  $151 = $150 >>> 0 < 4;
  if (!$151) {
   break;
  }
  $152 = $2;
  $153 = $152 + 80 | 0;
  $154 = HEAP32[$153 >> 2] | 0;
  $155 = $4;
  $156 = $155 << 3;
  $157 = 24 - $156 | 0;
  $158 = $154 >>> $157;
  $159 = $158 & 255;
  $160 = $159 & 255;
  $161 = $3;
  $162 = $4;
  $163 = $161 + $162 | 0;
  HEAP8[$163 >> 0] = $160;
  $164 = $2;
  $165 = $164 + 80 | 0;
  $166 = $165 + 4 | 0;
  $167 = HEAP32[$166 >> 2] | 0;
  $168 = $4;
  $169 = $168 << 3;
  $170 = 24 - $169 | 0;
  $171 = $167 >>> $170;
  $172 = $171 & 255;
  $173 = $172 & 255;
  $174 = $3;
  $175 = $4;
  $176 = $175 + 4 | 0;
  $177 = $174 + $176 | 0;
  HEAP8[$177 >> 0] = $173;
  $178 = $2;
  $179 = $178 + 80 | 0;
  $180 = $179 + 8 | 0;
  $181 = HEAP32[$180 >> 2] | 0;
  $182 = $4;
  $183 = $182 << 3;
  $184 = 24 - $183 | 0;
  $185 = $181 >>> $184;
  $186 = $185 & 255;
  $187 = $186 & 255;
  $188 = $3;
  $189 = $4;
  $190 = $189 + 8 | 0;
  $191 = $188 + $190 | 0;
  HEAP8[$191 >> 0] = $187;
  $192 = $2;
  $193 = $192 + 80 | 0;
  $194 = $193 + 12 | 0;
  $195 = HEAP32[$194 >> 2] | 0;
  $196 = $4;
  $197 = $196 << 3;
  $198 = 24 - $197 | 0;
  $199 = $195 >>> $198;
  $200 = $199 & 255;
  $201 = $200 & 255;
  $202 = $3;
  $203 = $4;
  $204 = $203 + 12 | 0;
  $205 = $202 + $204 | 0;
  HEAP8[$205 >> 0] = $201;
  $206 = $2;
  $207 = $206 + 80 | 0;
  $208 = $207 + 16 | 0;
  $209 = HEAP32[$208 >> 2] | 0;
  $210 = $4;
  $211 = $210 << 3;
  $212 = 24 - $211 | 0;
  $213 = $209 >>> $212;
  $214 = $213 & 255;
  $215 = $214 & 255;
  $216 = $3;
  $217 = $4;
  $218 = $217 + 16 | 0;
  $219 = $216 + $218 | 0;
  HEAP8[$219 >> 0] = $215;
  $220 = $2;
  $221 = $220 + 80 | 0;
  $222 = $221 + 20 | 0;
  $223 = HEAP32[$222 >> 2] | 0;
  $224 = $4;
  $225 = $224 << 3;
  $226 = 24 - $225 | 0;
  $227 = $223 >>> $226;
  $228 = $227 & 255;
  $229 = $228 & 255;
  $230 = $3;
  $231 = $4;
  $232 = $231 + 20 | 0;
  $233 = $230 + $232 | 0;
  HEAP8[$233 >> 0] = $229;
  $234 = $2;
  $235 = $234 + 80 | 0;
  $236 = $235 + 24 | 0;
  $237 = HEAP32[$236 >> 2] | 0;
  $238 = $4;
  $239 = $238 << 3;
  $240 = 24 - $239 | 0;
  $241 = $237 >>> $240;
  $242 = $241 & 255;
  $243 = $242 & 255;
  $244 = $3;
  $245 = $4;
  $246 = $245 + 24 | 0;
  $247 = $244 + $246 | 0;
  HEAP8[$247 >> 0] = $243;
  $248 = $2;
  $249 = $248 + 80 | 0;
  $250 = $249 + 28 | 0;
  $251 = HEAP32[$250 >> 2] | 0;
  $252 = $4;
  $253 = $252 << 3;
  $254 = 24 - $253 | 0;
  $255 = $251 >>> $254;
  $256 = $255 & 255;
  $257 = $256 & 255;
  $258 = $3;
  $259 = $4;
  $260 = $259 + 28 | 0;
  $261 = $258 + $260 | 0;
  HEAP8[$261 >> 0] = $257;
  $262 = $4;
  $263 = $262 + 1 | 0;
  $4 = $263;
 }
 STACKTOP = sp;
 return;
}

function ___udivmoddi4($a$0, $a$1, $b$0, $b$1, $rem) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 $rem = $rem | 0;
 var $n_sroa_0_0_extract_trunc = 0, $n_sroa_1_4_extract_shift$0 = 0, $n_sroa_1_4_extract_trunc = 0, $d_sroa_0_0_extract_trunc = 0, $d_sroa_1_4_extract_shift$0 = 0, $d_sroa_1_4_extract_trunc = 0, $4 = 0, $17 = 0, $37 = 0, $49 = 0, $51 = 0, $57 = 0, $58 = 0, $66 = 0, $78 = 0, $86 = 0, $88 = 0, $89 = 0, $91 = 0, $92 = 0, $95 = 0, $105 = 0, $117 = 0, $119 = 0, $125 = 0, $126 = 0, $130 = 0, $q_sroa_1_1_ph = 0, $q_sroa_0_1_ph = 0, $r_sroa_1_1_ph = 0, $r_sroa_0_1_ph = 0, $sr_1_ph = 0, $d_sroa_0_0_insert_insert99$0 = 0, $d_sroa_0_0_insert_insert99$1 = 0, $137$0 = 0, $137$1 = 0, $carry_0203 = 0, $sr_1202 = 0, $r_sroa_0_1201 = 0, $r_sroa_1_1200 = 0, $q_sroa_0_1199 = 0, $q_sroa_1_1198 = 0, $147 = 0, $149 = 0, $r_sroa_0_0_insert_insert42$0 = 0, $r_sroa_0_0_insert_insert42$1 = 0, $150$1 = 0, $151$0 = 0, $152 = 0, $154$0 = 0, $r_sroa_0_0_extract_trunc = 0, $r_sroa_1_4_extract_trunc = 0, $155 = 0, $carry_0_lcssa$0 = 0, $carry_0_lcssa$1 = 0, $r_sroa_0_1_lcssa = 0, $r_sroa_1_1_lcssa = 0, $q_sroa_0_1_lcssa = 0, $q_sroa_1_1_lcssa = 0, $q_sroa_0_0_insert_ext75$0 = 0, $q_sroa_0_0_insert_ext75$1 = 0, $q_sroa_0_0_insert_insert77$1 = 0, $_0$0 = 0, $_0$1 = 0;
 $n_sroa_0_0_extract_trunc = $a$0;
 $n_sroa_1_4_extract_shift$0 = $a$1;
 $n_sroa_1_4_extract_trunc = $n_sroa_1_4_extract_shift$0;
 $d_sroa_0_0_extract_trunc = $b$0;
 $d_sroa_1_4_extract_shift$0 = $b$1;
 $d_sroa_1_4_extract_trunc = $d_sroa_1_4_extract_shift$0;
 if (($n_sroa_1_4_extract_trunc | 0) == 0) {
  $4 = ($rem | 0) != 0;
  if (($d_sroa_1_4_extract_trunc | 0) == 0) {
   if ($4) {
    HEAP32[$rem >> 2] = ($n_sroa_0_0_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0);
    HEAP32[$rem + 4 >> 2] = 0;
   }
   $_0$1 = 0;
   $_0$0 = ($n_sroa_0_0_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0;
   return (setTempRet0($_0$1 | 0), $_0$0) | 0;
  } else {
   if (!$4) {
    $_0$1 = 0;
    $_0$0 = 0;
    return (setTempRet0($_0$1 | 0), $_0$0) | 0;
   }
   HEAP32[$rem >> 2] = $a$0 & -1;
   HEAP32[$rem + 4 >> 2] = $a$1 & 0;
   $_0$1 = 0;
   $_0$0 = 0;
   return (setTempRet0($_0$1 | 0), $_0$0) | 0;
  }
 }
 $17 = ($d_sroa_1_4_extract_trunc | 0) == 0;
 do {
  if (($d_sroa_0_0_extract_trunc | 0) == 0) {
   if ($17) {
    if (($rem | 0) != 0) {
     HEAP32[$rem >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_0_0_extract_trunc >>> 0);
     HEAP32[$rem + 4 >> 2] = 0;
    }
    $_0$1 = 0;
    $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_0_0_extract_trunc >>> 0) >>> 0;
    return (setTempRet0($_0$1 | 0), $_0$0) | 0;
   }
   if (($n_sroa_0_0_extract_trunc | 0) == 0) {
    if (($rem | 0) != 0) {
     HEAP32[$rem >> 2] = 0;
     HEAP32[$rem + 4 >> 2] = ($n_sroa_1_4_extract_trunc >>> 0) % ($d_sroa_1_4_extract_trunc >>> 0);
    }
    $_0$1 = 0;
    $_0$0 = ($n_sroa_1_4_extract_trunc >>> 0) / ($d_sroa_1_4_extract_trunc >>> 0) >>> 0;
    return (setTempRet0($_0$1 | 0), $_0$0) | 0;
   }
   $37 = $d_sroa_1_4_extract_trunc - 1 | 0;
   if (($37 & $d_sroa_1_4_extract_trunc | 0) == 0) {
    if (($rem | 0) != 0) {
     HEAP32[$rem >> 2] = 0 | $a$0 & -1;
     HEAP32[$rem + 4 >> 2] = $37 & $n_sroa_1_4_extract_trunc | $a$1 & 0;
    }
    $_0$1 = 0;
    $_0$0 = $n_sroa_1_4_extract_trunc >>> ((_llvm_cttz_i32($d_sroa_1_4_extract_trunc | 0) | 0) >>> 0);
    return (setTempRet0($_0$1 | 0), $_0$0) | 0;
   }
   $49 = Math_clz32($d_sroa_1_4_extract_trunc | 0) | 0;
   $51 = $49 - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
   if ($51 >>> 0 <= 30) {
    $57 = $51 + 1 | 0;
    $58 = 31 - $51 | 0;
    $sr_1_ph = $57;
    $r_sroa_0_1_ph = $n_sroa_1_4_extract_trunc << $58 | $n_sroa_0_0_extract_trunc >>> ($57 >>> 0);
    $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($57 >>> 0);
    $q_sroa_0_1_ph = 0;
    $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $58;
    break;
   }
   if (($rem | 0) == 0) {
    $_0$1 = 0;
    $_0$0 = 0;
    return (setTempRet0($_0$1 | 0), $_0$0) | 0;
   }
   HEAP32[$rem >> 2] = 0 | $a$0 & -1;
   HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
   $_0$1 = 0;
   $_0$0 = 0;
   return (setTempRet0($_0$1 | 0), $_0$0) | 0;
  } else {
   if (!$17) {
    $117 = Math_clz32($d_sroa_1_4_extract_trunc | 0) | 0;
    $119 = $117 - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
    if ($119 >>> 0 <= 31) {
     $125 = $119 + 1 | 0;
     $126 = 31 - $119 | 0;
     $130 = $119 - 31 >> 31;
     $sr_1_ph = $125;
     $r_sroa_0_1_ph = $n_sroa_0_0_extract_trunc >>> ($125 >>> 0) & $130 | $n_sroa_1_4_extract_trunc << $126;
     $r_sroa_1_1_ph = $n_sroa_1_4_extract_trunc >>> ($125 >>> 0) & $130;
     $q_sroa_0_1_ph = 0;
     $q_sroa_1_1_ph = $n_sroa_0_0_extract_trunc << $126;
     break;
    }
    if (($rem | 0) == 0) {
     $_0$1 = 0;
     $_0$0 = 0;
     return (setTempRet0($_0$1 | 0), $_0$0) | 0;
    }
    HEAP32[$rem >> 2] = 0 | $a$0 & -1;
    HEAP32[$rem + 4 >> 2] = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
    $_0$1 = 0;
    $_0$0 = 0;
    return (setTempRet0($_0$1 | 0), $_0$0) | 0;
   }
   $66 = $d_sroa_0_0_extract_trunc - 1 | 0;
   if (($66 & $d_sroa_0_0_extract_trunc | 0) != 0) {
    $86 = (Math_clz32($d_sroa_0_0_extract_trunc | 0) | 0) + 33 | 0;
    $88 = $86 - (Math_clz32($n_sroa_1_4_extract_trunc | 0) | 0) | 0;
    $89 = 64 - $88 | 0;
    $91 = 32 - $88 | 0;
    $92 = $91 >> 31;
    $95 = $88 - 32 | 0;
    $105 = $95 >> 31;
    $sr_1_ph = $88;
    $r_sroa_0_1_ph = $91 - 1 >> 31 & $n_sroa_1_4_extract_trunc >>> ($95 >>> 0) | ($n_sroa_1_4_extract_trunc << $91 | $n_sroa_0_0_extract_trunc >>> ($88 >>> 0)) & $105;
    $r_sroa_1_1_ph = $105 & $n_sroa_1_4_extract_trunc >>> ($88 >>> 0);
    $q_sroa_0_1_ph = $n_sroa_0_0_extract_trunc << $89 & $92;
    $q_sroa_1_1_ph = ($n_sroa_1_4_extract_trunc << $89 | $n_sroa_0_0_extract_trunc >>> ($95 >>> 0)) & $92 | $n_sroa_0_0_extract_trunc << $91 & $88 - 33 >> 31;
    break;
   }
   if (($rem | 0) != 0) {
    HEAP32[$rem >> 2] = $66 & $n_sroa_0_0_extract_trunc;
    HEAP32[$rem + 4 >> 2] = 0;
   }
   if (($d_sroa_0_0_extract_trunc | 0) == 1) {
    $_0$1 = $n_sroa_1_4_extract_shift$0 | $a$1 & 0;
    $_0$0 = 0 | $a$0 & -1;
    return (setTempRet0($_0$1 | 0), $_0$0) | 0;
   } else {
    $78 = _llvm_cttz_i32($d_sroa_0_0_extract_trunc | 0) | 0;
    $_0$1 = 0 | $n_sroa_1_4_extract_trunc >>> ($78 >>> 0);
    $_0$0 = $n_sroa_1_4_extract_trunc << 32 - $78 | $n_sroa_0_0_extract_trunc >>> ($78 >>> 0) | 0;
    return (setTempRet0($_0$1 | 0), $_0$0) | 0;
   }
  }
 } while (0);
 if (($sr_1_ph | 0) == 0) {
  $q_sroa_1_1_lcssa = $q_sroa_1_1_ph;
  $q_sroa_0_1_lcssa = $q_sroa_0_1_ph;
  $r_sroa_1_1_lcssa = $r_sroa_1_1_ph;
  $r_sroa_0_1_lcssa = $r_sroa_0_1_ph;
  $carry_0_lcssa$1 = 0;
  $carry_0_lcssa$0 = 0;
 } else {
  $d_sroa_0_0_insert_insert99$0 = 0 | $b$0 & -1;
  $d_sroa_0_0_insert_insert99$1 = $d_sroa_1_4_extract_shift$0 | $b$1 & 0;
  $137$0 = _i64Add($d_sroa_0_0_insert_insert99$0 | 0, $d_sroa_0_0_insert_insert99$1 | 0, -1, -1) | 0;
  $137$1 = getTempRet0() | 0;
  $q_sroa_1_1198 = $q_sroa_1_1_ph;
  $q_sroa_0_1199 = $q_sroa_0_1_ph;
  $r_sroa_1_1200 = $r_sroa_1_1_ph;
  $r_sroa_0_1201 = $r_sroa_0_1_ph;
  $sr_1202 = $sr_1_ph;
  $carry_0203 = 0;
  while (1) {
   $147 = $q_sroa_0_1199 >>> 31 | $q_sroa_1_1198 << 1;
   $149 = $carry_0203 | $q_sroa_0_1199 << 1;
   $r_sroa_0_0_insert_insert42$0 = 0 | ($r_sroa_0_1201 << 1 | $q_sroa_1_1198 >>> 31);
   $r_sroa_0_0_insert_insert42$1 = $r_sroa_0_1201 >>> 31 | $r_sroa_1_1200 << 1 | 0;
   _i64Subtract($137$0 | 0, $137$1 | 0, $r_sroa_0_0_insert_insert42$0 | 0, $r_sroa_0_0_insert_insert42$1 | 0) | 0;
   $150$1 = getTempRet0() | 0;
   $151$0 = $150$1 >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1;
   $152 = $151$0 & 1;
   $154$0 = _i64Subtract($r_sroa_0_0_insert_insert42$0 | 0, $r_sroa_0_0_insert_insert42$1 | 0, $151$0 & $d_sroa_0_0_insert_insert99$0 | 0, ((($150$1 | 0) < 0 ? -1 : 0) >> 31 | (($150$1 | 0) < 0 ? -1 : 0) << 1) & $d_sroa_0_0_insert_insert99$1 | 0) | 0;
   $r_sroa_0_0_extract_trunc = $154$0;
   $r_sroa_1_4_extract_trunc = getTempRet0() | 0;
   $155 = $sr_1202 - 1 | 0;
   if (($155 | 0) == 0) {
    break;
   } else {
    $q_sroa_1_1198 = $147;
    $q_sroa_0_1199 = $149;
    $r_sroa_1_1200 = $r_sroa_1_4_extract_trunc;
    $r_sroa_0_1201 = $r_sroa_0_0_extract_trunc;
    $sr_1202 = $155;
    $carry_0203 = $152;
   }
  }
  $q_sroa_1_1_lcssa = $147;
  $q_sroa_0_1_lcssa = $149;
  $r_sroa_1_1_lcssa = $r_sroa_1_4_extract_trunc;
  $r_sroa_0_1_lcssa = $r_sroa_0_0_extract_trunc;
  $carry_0_lcssa$1 = 0;
  $carry_0_lcssa$0 = $152;
 }
 $q_sroa_0_0_insert_ext75$0 = $q_sroa_0_1_lcssa;
 $q_sroa_0_0_insert_ext75$1 = 0;
 $q_sroa_0_0_insert_insert77$1 = $q_sroa_1_1_lcssa | $q_sroa_0_0_insert_ext75$1;
 if (($rem | 0) != 0) {
  HEAP32[$rem >> 2] = 0 | $r_sroa_0_1_lcssa;
  HEAP32[$rem + 4 >> 2] = $r_sroa_1_1_lcssa | 0;
 }
 $_0$1 = (0 | $q_sroa_0_0_insert_ext75$0) >>> 31 | $q_sroa_0_0_insert_insert77$1 << 1 | ($q_sroa_0_0_insert_ext75$1 << 1 | $q_sroa_0_0_insert_ext75$0 >>> 31) & 0 | $carry_0_lcssa$1;
 $_0$0 = ($q_sroa_0_0_insert_ext75$0 << 1 | 0 >>> 31) & -2 | $carry_0_lcssa$0;
 return (setTempRet0($_0$1 | 0), $_0$0) | 0;
}

function _pop_arg($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $$mask = 0, $$mask31 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0.0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $arglist_current = 0, $arglist_current11 = 0, $arglist_current14 = 0, $arglist_current17 = 0, $arglist_current2 = 0, $arglist_current20 = 0, $arglist_current23 = 0, $arglist_current5 = 0, $arglist_current8 = 0, $arglist_next = 0, $arglist_next12 = 0, $arglist_next15 = 0, $arglist_next18 = 0, $arglist_next21 = 0, $arglist_next24 = 0, $arglist_next3 = 0, $arglist_next6 = 0, $arglist_next9 = 0, $expanded = 0, $expanded25 = 0, $expanded27 = 0, $expanded28 = 0, $expanded29 = 0, $expanded31 = 0, $expanded32 = 0, $expanded34 = 0, $expanded35 = 0, $expanded36 = 0, $expanded38 = 0, $expanded39 = 0, $expanded41 = 0, $expanded42 = 0, $expanded43 = 0, $expanded45 = 0, $expanded46 = 0, $expanded48 = 0, $expanded49 = 0, $expanded50 = 0, $expanded52 = 0, $expanded53 = 0, $expanded55 = 0, $expanded56 = 0, $expanded57 = 0, $expanded59 = 0, $expanded60 = 0, $expanded62 = 0, $expanded63 = 0, $expanded64 = 0, $expanded66 = 0, $expanded67 = 0, $expanded69 = 0, $expanded70 = 0, $expanded71 = 0, $expanded73 = 0, $expanded74 = 0, $expanded76 = 0, $expanded77 = 0, $expanded78 = 0, $expanded80 = 0, $expanded81 = 0, $expanded83 = 0, $expanded84 = 0, $expanded85 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $4 = $1 >>> 0 > 20;
 L1 : do {
  if (!$4) {
   do {
    switch ($1 | 0) {
    case 9:
     {
      $arglist_current = HEAP32[$2 >> 2] | 0;
      $5 = $arglist_current;
      $6 = 0 + 4 | 0;
      $expanded25 = $6;
      $expanded = $expanded25 - 1 | 0;
      $7 = $5 + $expanded | 0;
      $8 = 0 + 4 | 0;
      $expanded29 = $8;
      $expanded28 = $expanded29 - 1 | 0;
      $expanded27 = $expanded28 ^ -1;
      $9 = $7 & $expanded27;
      $10 = $9;
      $11 = HEAP32[$10 >> 2] | 0;
      $arglist_next = $10 + 4 | 0;
      HEAP32[$2 >> 2] = $arglist_next;
      HEAP32[$0 >> 2] = $11;
      break L1;
      break;
     }
    case 10:
     {
      $arglist_current2 = HEAP32[$2 >> 2] | 0;
      $12 = $arglist_current2;
      $13 = 0 + 4 | 0;
      $expanded32 = $13;
      $expanded31 = $expanded32 - 1 | 0;
      $14 = $12 + $expanded31 | 0;
      $15 = 0 + 4 | 0;
      $expanded36 = $15;
      $expanded35 = $expanded36 - 1 | 0;
      $expanded34 = $expanded35 ^ -1;
      $16 = $14 & $expanded34;
      $17 = $16;
      $18 = HEAP32[$17 >> 2] | 0;
      $arglist_next3 = $17 + 4 | 0;
      HEAP32[$2 >> 2] = $arglist_next3;
      $19 = ($18 | 0) < 0;
      $20 = $19 << 31 >> 31;
      $21 = $0;
      $22 = $21;
      HEAP32[$22 >> 2] = $18;
      $23 = $21 + 4 | 0;
      $24 = $23;
      HEAP32[$24 >> 2] = $20;
      break L1;
      break;
     }
    case 11:
     {
      $arglist_current5 = HEAP32[$2 >> 2] | 0;
      $25 = $arglist_current5;
      $26 = 0 + 4 | 0;
      $expanded39 = $26;
      $expanded38 = $expanded39 - 1 | 0;
      $27 = $25 + $expanded38 | 0;
      $28 = 0 + 4 | 0;
      $expanded43 = $28;
      $expanded42 = $expanded43 - 1 | 0;
      $expanded41 = $expanded42 ^ -1;
      $29 = $27 & $expanded41;
      $30 = $29;
      $31 = HEAP32[$30 >> 2] | 0;
      $arglist_next6 = $30 + 4 | 0;
      HEAP32[$2 >> 2] = $arglist_next6;
      $32 = $0;
      $33 = $32;
      HEAP32[$33 >> 2] = $31;
      $34 = $32 + 4 | 0;
      $35 = $34;
      HEAP32[$35 >> 2] = 0;
      break L1;
      break;
     }
    case 12:
     {
      $arglist_current8 = HEAP32[$2 >> 2] | 0;
      $36 = $arglist_current8;
      $37 = 0 + 8 | 0;
      $expanded46 = $37;
      $expanded45 = $expanded46 - 1 | 0;
      $38 = $36 + $expanded45 | 0;
      $39 = 0 + 8 | 0;
      $expanded50 = $39;
      $expanded49 = $expanded50 - 1 | 0;
      $expanded48 = $expanded49 ^ -1;
      $40 = $38 & $expanded48;
      $41 = $40;
      $42 = $41;
      $43 = $42;
      $44 = HEAP32[$43 >> 2] | 0;
      $45 = $42 + 4 | 0;
      $46 = $45;
      $47 = HEAP32[$46 >> 2] | 0;
      $arglist_next9 = $41 + 8 | 0;
      HEAP32[$2 >> 2] = $arglist_next9;
      $48 = $0;
      $49 = $48;
      HEAP32[$49 >> 2] = $44;
      $50 = $48 + 4 | 0;
      $51 = $50;
      HEAP32[$51 >> 2] = $47;
      break L1;
      break;
     }
    case 13:
     {
      $arglist_current11 = HEAP32[$2 >> 2] | 0;
      $52 = $arglist_current11;
      $53 = 0 + 4 | 0;
      $expanded53 = $53;
      $expanded52 = $expanded53 - 1 | 0;
      $54 = $52 + $expanded52 | 0;
      $55 = 0 + 4 | 0;
      $expanded57 = $55;
      $expanded56 = $expanded57 - 1 | 0;
      $expanded55 = $expanded56 ^ -1;
      $56 = $54 & $expanded55;
      $57 = $56;
      $58 = HEAP32[$57 >> 2] | 0;
      $arglist_next12 = $57 + 4 | 0;
      HEAP32[$2 >> 2] = $arglist_next12;
      $59 = $58 & 65535;
      $60 = $59 << 16 >> 16;
      $61 = ($60 | 0) < 0;
      $62 = $61 << 31 >> 31;
      $63 = $0;
      $64 = $63;
      HEAP32[$64 >> 2] = $60;
      $65 = $63 + 4 | 0;
      $66 = $65;
      HEAP32[$66 >> 2] = $62;
      break L1;
      break;
     }
    case 14:
     {
      $arglist_current14 = HEAP32[$2 >> 2] | 0;
      $67 = $arglist_current14;
      $68 = 0 + 4 | 0;
      $expanded60 = $68;
      $expanded59 = $expanded60 - 1 | 0;
      $69 = $67 + $expanded59 | 0;
      $70 = 0 + 4 | 0;
      $expanded64 = $70;
      $expanded63 = $expanded64 - 1 | 0;
      $expanded62 = $expanded63 ^ -1;
      $71 = $69 & $expanded62;
      $72 = $71;
      $73 = HEAP32[$72 >> 2] | 0;
      $arglist_next15 = $72 + 4 | 0;
      HEAP32[$2 >> 2] = $arglist_next15;
      $$mask31 = $73 & 65535;
      $74 = $0;
      $75 = $74;
      HEAP32[$75 >> 2] = $$mask31;
      $76 = $74 + 4 | 0;
      $77 = $76;
      HEAP32[$77 >> 2] = 0;
      break L1;
      break;
     }
    case 15:
     {
      $arglist_current17 = HEAP32[$2 >> 2] | 0;
      $78 = $arglist_current17;
      $79 = 0 + 4 | 0;
      $expanded67 = $79;
      $expanded66 = $expanded67 - 1 | 0;
      $80 = $78 + $expanded66 | 0;
      $81 = 0 + 4 | 0;
      $expanded71 = $81;
      $expanded70 = $expanded71 - 1 | 0;
      $expanded69 = $expanded70 ^ -1;
      $82 = $80 & $expanded69;
      $83 = $82;
      $84 = HEAP32[$83 >> 2] | 0;
      $arglist_next18 = $83 + 4 | 0;
      HEAP32[$2 >> 2] = $arglist_next18;
      $85 = $84 & 255;
      $86 = $85 << 24 >> 24;
      $87 = ($86 | 0) < 0;
      $88 = $87 << 31 >> 31;
      $89 = $0;
      $90 = $89;
      HEAP32[$90 >> 2] = $86;
      $91 = $89 + 4 | 0;
      $92 = $91;
      HEAP32[$92 >> 2] = $88;
      break L1;
      break;
     }
    case 16:
     {
      $arglist_current20 = HEAP32[$2 >> 2] | 0;
      $93 = $arglist_current20;
      $94 = 0 + 4 | 0;
      $expanded74 = $94;
      $expanded73 = $expanded74 - 1 | 0;
      $95 = $93 + $expanded73 | 0;
      $96 = 0 + 4 | 0;
      $expanded78 = $96;
      $expanded77 = $expanded78 - 1 | 0;
      $expanded76 = $expanded77 ^ -1;
      $97 = $95 & $expanded76;
      $98 = $97;
      $99 = HEAP32[$98 >> 2] | 0;
      $arglist_next21 = $98 + 4 | 0;
      HEAP32[$2 >> 2] = $arglist_next21;
      $$mask = $99 & 255;
      $100 = $0;
      $101 = $100;
      HEAP32[$101 >> 2] = $$mask;
      $102 = $100 + 4 | 0;
      $103 = $102;
      HEAP32[$103 >> 2] = 0;
      break L1;
      break;
     }
    case 17:
     {
      $arglist_current23 = HEAP32[$2 >> 2] | 0;
      $104 = $arglist_current23;
      $105 = 0 + 8 | 0;
      $expanded81 = $105;
      $expanded80 = $expanded81 - 1 | 0;
      $106 = $104 + $expanded80 | 0;
      $107 = 0 + 8 | 0;
      $expanded85 = $107;
      $expanded84 = $expanded85 - 1 | 0;
      $expanded83 = $expanded84 ^ -1;
      $108 = $106 & $expanded83;
      $109 = $108;
      $110 = +HEAPF64[$109 >> 3];
      $arglist_next24 = $109 + 8 | 0;
      HEAP32[$2 >> 2] = $arglist_next24;
      HEAPF64[$0 >> 3] = $110;
      break L1;
      break;
     }
    case 18:
     {
      FUNCTION_TABLE_vii[$3 & 1023]($0, $2);
      break L1;
      break;
     }
    default:
     {
      break L1;
     }
    }
   } while (0);
  }
 } while (0);
 return;
}

function _code_execute($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$0 = 0, $$0$phi = 0, $$reg2mem39$0 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, $cond42 = 0, $cond43 = 0, $cond44 = 0, $cond45 = 0, $cond46 = 0, $cond47 = 0, $cond48 = 0, $cond49 = 0, $cond50 = 0, $cond51 = 0, $cond52 = 0, $cond53 = 0, _setjmpTable = 0, _setjmpTableSize = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 176 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(176 | 0);
 _setjmpTableSize = 4;
 _setjmpTable = _malloc(40) | 0;
 HEAP32[_setjmpTable >> 2] = 0;
 $3 = sp;
 __THREW__ = 0;
 $4 = invoke_i(537) | 0;
 $5 = __THREW__;
 __THREW__ = 0;
 if (($5 | 0) != 0 & (threwValue | 0) != 0) {
  $6 = _testSetjmp(HEAP32[$5 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  if (($6 | 0) == 0) {
   _longjmp($5 | 0, threwValue | 0);
  }
  setTempRet0(threwValue | 0);
 } else {
  $6 = -1;
 }
 $7 = getTempRet0() | 0;
 $cond = ($6 | 0) == 1;
 if ($cond) {
  $$0 = 0;
  $$reg2mem39$0 = $7;
 } else {
  __THREW__ = 0;
  $8 = invoke_i(538) | 0;
  $9 = __THREW__;
  __THREW__ = 0;
  if (($9 | 0) != 0 & (threwValue | 0) != 0) {
   $10 = _testSetjmp(HEAP32[$9 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($10 | 0) == 0) {
    _longjmp($9 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $10 = -1;
  }
  $11 = getTempRet0() | 0;
  $cond42 = ($10 | 0) == 1;
  if ($cond42) {
   $$0 = 0;
   $$reg2mem39$0 = $11;
  } else {
   __THREW__ = 0;
   invoke_vi(539, $1 | 0);
   $12 = __THREW__;
   __THREW__ = 0;
   if (($12 | 0) != 0 & (threwValue | 0) != 0) {
    $13 = _testSetjmp(HEAP32[$12 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($13 | 0) == 0) {
     _longjmp($12 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $13 = -1;
   }
   $14 = getTempRet0() | 0;
   $cond43 = ($13 | 0) == 1;
   if ($cond43) {
    $$0 = $8;
    $$reg2mem39$0 = $14;
   } else {
    __THREW__ = 0;
    invoke_vi(540, $2 | 0);
    $15 = __THREW__;
    __THREW__ = 0;
    if (($15 | 0) != 0 & (threwValue | 0) != 0) {
     $16 = _testSetjmp(HEAP32[$15 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($16 | 0) == 0) {
      _longjmp($15 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $16 = -1;
    }
    $17 = getTempRet0() | 0;
    $cond44 = ($16 | 0) == 1;
    if ($cond44) {
     $$0 = $8;
     $$reg2mem39$0 = $17;
    } else {
     $18 = $0 + 4 | 0;
     $19 = HEAP32[$18 >> 2] | 0;
     __THREW__ = 0;
     $20 = invoke_ii(541, $19 | 0) | 0;
     $21 = __THREW__;
     __THREW__ = 0;
     if (($21 | 0) != 0 & (threwValue | 0) != 0) {
      $22 = _testSetjmp(HEAP32[$21 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($22 | 0) == 0) {
       _longjmp($21 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $22 = -1;
     }
     $23 = getTempRet0() | 0;
     $cond45 = ($22 | 0) == 1;
     if ($cond45) {
      $$0 = $8;
      $$reg2mem39$0 = $23;
     } else {
      if ($20) {
       $24 = $0 + 4 | 0;
       $25 = HEAP32[$24 >> 2] | 0;
       $26 = HEAP32[$25 >> 2] | 0;
       $27 = ($26 | 0) == (16612 | 0);
       if ($27) {
        $28 = $0 + 4 | 0;
        $29 = HEAP32[$28 >> 2] | 0;
        $30 = $29 + 4 | 0;
        HEAP32[$30 >> 2] = $1;
       }
      }
      __THREW__ = 0;
      invoke_ii(496, $3 | 0) | 0;
      $31 = __THREW__;
      __THREW__ = 0;
      if (($31 | 0) != 0 & (threwValue | 0) != 0) {
       $32 = _testSetjmp(HEAP32[$31 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
       if (($32 | 0) == 0) {
        _longjmp($31 | 0, threwValue | 0);
       }
       setTempRet0(threwValue | 0);
      } else {
       $32 = -1;
      }
      $33 = getTempRet0() | 0;
      $cond46 = ($32 | 0) == 1;
      if ($cond46) {
       $$0 = $8;
       $$reg2mem39$0 = $33;
      } else {
       $34 = $3 + 8 | 0;
       _setjmpTable = _saveSetjmp($34, 1, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
       _setjmpTableSize = getTempRet0() | 0;
       __THREW__ = 0;
       $35 = __THREW__;
       __THREW__ = 0;
       if (($35 | 0) != 0 & (threwValue | 0) != 0) {
        $36 = _testSetjmp(HEAP32[$35 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
        if (($36 | 0) == 0) {
         _longjmp($35 | 0, threwValue | 0);
        }
        setTempRet0(threwValue | 0);
       } else {
        $36 = -1;
       }
       $37 = getTempRet0() | 0;
       $cond47 = ($36 | 0) == 1;
       if ($cond47) {
        $$0 = $8;
        $$reg2mem39$0 = $37;
       } else {
        $$0 = $8;
        $$reg2mem39$0 = 0;
       }
      }
     }
    }
   }
  }
 }
 while (1) {
  $38 = ($$reg2mem39$0 | 0) == 0;
  if (!$38) {
   __THREW__ = 0;
   invoke_vi(539, $4 | 0);
   $54 = __THREW__;
   __THREW__ = 0;
   if (($54 | 0) != 0 & (threwValue | 0) != 0) {
    $55 = _testSetjmp(HEAP32[$54 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($55 | 0) == 0) {
     _longjmp($54 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $55 = -1;
   }
   $56 = getTempRet0() | 0;
   $cond48 = ($55 | 0) == 1;
   if ($cond48) {
    $$0$phi = $$0;
    $$reg2mem39$0 = $56;
    $$0 = $$0$phi;
    continue;
   }
   __THREW__ = 0;
   invoke_vi(540, $$0 | 0);
   $57 = __THREW__;
   __THREW__ = 0;
   if (($57 | 0) != 0 & (threwValue | 0) != 0) {
    $58 = _testSetjmp(HEAP32[$57 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($58 | 0) == 0) {
     _longjmp($57 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $58 = -1;
   }
   $59 = getTempRet0() | 0;
   $cond49 = ($58 | 0) == 1;
   if ($cond49) {
    $$0$phi = $$0;
    $$reg2mem39$0 = $59;
    $$0 = $$0$phi;
    continue;
   }
   $60 = $3 + 4 | 0;
   $61 = HEAP32[$60 >> 2] | 0;
   __THREW__ = 0;
   invoke_vi(500, $61 | 0);
   $62 = __THREW__;
   __THREW__ = 0;
   if (($62 | 0) != 0 & (threwValue | 0) != 0) {
    $63 = _testSetjmp(HEAP32[$62 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($63 | 0) == 0) {
     _longjmp($62 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $63 = -1;
   }
   $64 = getTempRet0() | 0;
   $$0$phi = $$0;
   $$reg2mem39$0 = $64;
   $$0 = $$0$phi;
   continue;
  }
  $39 = $0 + 4 | 0;
  $40 = HEAP32[$39 >> 2] | 0;
  __THREW__ = 0;
  $41 = invoke_ii(509, $40 | 0) | 0;
  $42 = __THREW__;
  __THREW__ = 0;
  if (($42 | 0) != 0 & (threwValue | 0) != 0) {
   $43 = _testSetjmp(HEAP32[$42 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($43 | 0) == 0) {
    _longjmp($42 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $43 = -1;
  }
  $44 = getTempRet0() | 0;
  $cond50 = ($43 | 0) == 1;
  if ($cond50) {
   $$0$phi = $$0;
   $$reg2mem39$0 = $44;
   $$0 = $$0$phi;
   continue;
  }
  __THREW__ = 0;
  invoke_v(498);
  $45 = __THREW__;
  __THREW__ = 0;
  if (($45 | 0) != 0 & (threwValue | 0) != 0) {
   $46 = _testSetjmp(HEAP32[$45 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($46 | 0) == 0) {
    _longjmp($45 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $46 = -1;
  }
  $47 = getTempRet0() | 0;
  $cond51 = ($46 | 0) == 1;
  if ($cond51) {
   $$0$phi = $$0;
   $$reg2mem39$0 = $47;
   $$0 = $$0$phi;
   continue;
  }
  __THREW__ = 0;
  invoke_vi(539, $4 | 0);
  $48 = __THREW__;
  __THREW__ = 0;
  if (($48 | 0) != 0 & (threwValue | 0) != 0) {
   $49 = _testSetjmp(HEAP32[$48 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($49 | 0) == 0) {
    _longjmp($48 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $49 = -1;
  }
  $50 = getTempRet0() | 0;
  $cond52 = ($49 | 0) == 1;
  if ($cond52) {
   $$0$phi = $$0;
   $$reg2mem39$0 = $50;
   $$0 = $$0$phi;
   continue;
  }
  __THREW__ = 0;
  invoke_vi(540, $$0 | 0);
  $51 = __THREW__;
  __THREW__ = 0;
  if (($51 | 0) != 0 & (threwValue | 0) != 0) {
   $52 = _testSetjmp(HEAP32[$51 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($52 | 0) == 0) {
    _longjmp($51 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $52 = -1;
  }
  $53 = getTempRet0() | 0;
  $cond53 = ($52 | 0) == 1;
  if ($cond53) {
   $$0$phi = $$0;
   $$reg2mem39$0 = $53;
   $$0 = $$0$phi;
  } else {
   break;
  }
 }
 _free(_setjmpTable | 0);
 STACKTOP = sp;
 return $41 | 0;
}

function _mp_obj_int_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0.0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0.0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0.0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0.0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0.0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0.0, $71 = 0, $72 = 0.0, $73 = 0.0, $74 = 0.0, $75 = 0.0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, $or$cond5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112 | 0);
 $9 = sp + 68 | 0;
 $10 = sp + 104 | 0;
 $14 = sp + 52 | 0;
 $15 = sp + 40 | 0;
 $18 = sp + 24 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $20 = $5;
 $21 = _mp_obj_is_small_int_1030($20) | 0;
 if ($21) {
  $22 = $5;
  $23 = $22;
  $24 = $23 >> 1;
  _mpz_init_fixed_from_int($9, $10, 2, $24);
  $7 = $9;
 } else {
  $25 = $5;
  $26 = $25 + 4 | 0;
  $7 = $26;
 }
 $27 = $6;
 $28 = _mp_obj_is_small_int_1030($27) | 0;
 do {
  if ($28) {
   $29 = $6;
   $30 = $29;
   $31 = $30 >> 1;
   _mpz_init_fixed_from_int($9, $10, 2, $31);
   $8 = $9;
  } else {
   $32 = $6;
   $33 = _mp_obj_is_obj_1037($32) | 0;
   if ($33) {
    $34 = $6;
    $35 = HEAP32[$34 >> 2] | 0;
    $36 = ($35 | 0) == (16904 | 0);
    if ($36) {
     $37 = $6;
     $38 = $37 + 4 | 0;
     $8 = $38;
     break;
    }
   }
   $39 = $6;
   $40 = _mp_obj_is_obj_1037($39) | 0;
   if ($40) {
    $41 = $6;
    $42 = HEAP32[$41 >> 2] | 0;
    $43 = ($42 | 0) == (16252 | 0);
    if ($43) {
     $44 = $4;
     $45 = $7;
     $46 = +_mpz_as_float($45);
     $47 = $6;
     $48 = _mp_obj_float_binary_op($44, $46, $47) | 0;
     $3 = $48;
     $180 = $3;
     STACKTOP = sp;
     return $180 | 0;
    }
   }
   $49 = $6;
   $50 = _mp_obj_is_obj_1037($49) | 0;
   if ($50) {
    $51 = $6;
    $52 = HEAP32[$51 >> 2] | 0;
    $53 = ($52 | 0) == (14052 | 0);
    if ($53) {
     $54 = $4;
     $55 = $7;
     $56 = +_mpz_as_float($55);
     $57 = $6;
     $58 = _mp_obj_complex_binary_op($54, $56, 0.0, $57) | 0;
     $3 = $58;
     $180 = $3;
     STACKTOP = sp;
     return $180 | 0;
    }
   }
   $59 = $4;
   $60 = $5;
   $61 = $6;
   $62 = _mp_obj_int_binary_op_extra_cases($59, $60, $61) | 0;
   $3 = $62;
   $180 = $3;
   STACKTOP = sp;
   return $180 | 0;
  }
 } while (0);
 $63 = $4;
 $64 = ($63 | 0) == 30;
 $65 = $4;
 $66 = ($65 | 0) == 18;
 $or$cond = $64 | $66;
 if ($or$cond) {
  $67 = $8;
  $68 = _mpz_is_zero_1033($67) | 0;
  if ($68) {
   _mp_raise_msg(15172, 33845);
  }
  $69 = $7;
  $70 = +_mpz_as_float($69);
  $11 = $70;
  $71 = $8;
  $72 = +_mpz_as_float($71);
  $12 = $72;
  $73 = $11;
  $74 = $12;
  $75 = $73 / $74;
  $76 = _mp_obj_new_float($75) | 0;
  $3 = $76;
  $180 = $3;
  STACKTOP = sp;
  return $180 | 0;
 }
 $77 = $4;
 $78 = $77 >>> 0 >= 9;
 $79 = $4;
 $80 = $79 >>> 0 < 34;
 $or$cond3 = $78 & $80;
 if (!$or$cond3) {
  $156 = $7;
  $157 = $8;
  $158 = _mpz_cmp($156, $157) | 0;
  $19 = $158;
  $159 = $4;
  switch ($159 | 0) {
  case 0:
   {
    $160 = $19;
    $161 = ($160 | 0) < 0;
    $162 = $161 & 1;
    $163 = _mp_obj_new_bool_1034($162) | 0;
    $3 = $163;
    $180 = $3;
    STACKTOP = sp;
    return $180 | 0;
    break;
   }
  case 1:
   {
    $164 = $19;
    $165 = ($164 | 0) > 0;
    $166 = $165 & 1;
    $167 = _mp_obj_new_bool_1034($166) | 0;
    $3 = $167;
    $180 = $3;
    STACKTOP = sp;
    return $180 | 0;
    break;
   }
  case 3:
   {
    $168 = $19;
    $169 = ($168 | 0) <= 0;
    $170 = $169 & 1;
    $171 = _mp_obj_new_bool_1034($170) | 0;
    $3 = $171;
    $180 = $3;
    STACKTOP = sp;
    return $180 | 0;
    break;
   }
  case 4:
   {
    $172 = $19;
    $173 = ($172 | 0) >= 0;
    $174 = $173 & 1;
    $175 = _mp_obj_new_bool_1034($174) | 0;
    $3 = $175;
    $180 = $3;
    STACKTOP = sp;
    return $180 | 0;
    break;
   }
  case 2:
   {
    $176 = $19;
    $177 = ($176 | 0) == 0;
    $178 = $177 & 1;
    $179 = _mp_obj_new_bool_1034($178) | 0;
    $3 = $179;
    $180 = $3;
    STACKTOP = sp;
    return $180 | 0;
    break;
   }
  default:
   {
    $3 = 0;
    $180 = $3;
    STACKTOP = sp;
    return $180 | 0;
   }
  }
 }
 $81 = _mp_obj_int_new_mpz() | 0;
 $13 = $81;
 $82 = $4;
 L47 : do {
  switch ($82 | 0) {
  case 14:
  case 26:
   {
    $83 = $13;
    $84 = $83 + 4 | 0;
    $85 = $7;
    $86 = $8;
    _mpz_add_inpl($84, $85, $86);
    break;
   }
  case 15:
  case 27:
   {
    $87 = $13;
    $88 = $87 + 4 | 0;
    $89 = $7;
    $90 = $8;
    _mpz_sub_inpl($88, $89, $90);
    break;
   }
  case 16:
  case 28:
   {
    $91 = $13;
    $92 = $91 + 4 | 0;
    $93 = $7;
    $94 = $8;
    _mpz_mul_inpl($92, $93, $94);
    break;
   }
  case 17:
  case 29:
   {
    $95 = $8;
    $96 = _mpz_is_zero_1033($95) | 0;
    if ($96) {
     _mp_raise_msg(15172, 33845);
    } else {
     _mpz_init_zero($14);
     $97 = $13;
     $98 = $97 + 4 | 0;
     $99 = $7;
     $100 = $8;
     _mpz_divmod_inpl($98, $14, $99, $100);
     _mpz_deinit($14);
     break L47;
    }
    break;
   }
  case 19:
  case 31:
   {
    $101 = $8;
    $102 = _mpz_is_zero_1033($101) | 0;
    if ($102) {
     _mp_raise_msg(15172, 33845);
    } else {
     _mpz_init_zero($15);
     $103 = $13;
     $104 = $103 + 4 | 0;
     $105 = $7;
     $106 = $8;
     _mpz_divmod_inpl($15, $104, $105, $106);
     _mpz_deinit($15);
     break L47;
    }
    break;
   }
  case 11:
  case 23:
   {
    $107 = $13;
    $108 = $107 + 4 | 0;
    $109 = $7;
    $110 = $8;
    _mpz_and_inpl($108, $109, $110);
    break;
   }
  case 9:
  case 21:
   {
    $111 = $13;
    $112 = $111 + 4 | 0;
    $113 = $7;
    $114 = $8;
    _mpz_or_inpl($112, $113, $114);
    break;
   }
  case 10:
  case 22:
   {
    $115 = $13;
    $116 = $115 + 4 | 0;
    $117 = $7;
    $118 = $8;
    _mpz_xor_inpl($116, $117, $118);
    break;
   }
  case 13:
  case 25:
  case 12:
  case 24:
   {
    $119 = $6;
    $120 = _mp_obj_int_get_checked($119) | 0;
    $16 = $120;
    $121 = $16;
    $122 = ($121 | 0) < 0;
    if ($122) {
     _mp_raise_ValueError(31400);
    }
    $123 = $4;
    $124 = ($123 | 0) == 24;
    $125 = $4;
    $126 = ($125 | 0) == 12;
    $or$cond5 = $124 | $126;
    $127 = $13;
    $128 = $127 + 4 | 0;
    $129 = $7;
    $130 = $16;
    if ($or$cond5) {
     _mpz_shl_inpl($128, $129, $130);
     break L47;
    } else {
     _mpz_shr_inpl($128, $129, $130);
     break L47;
    }
    break;
   }
  case 20:
  case 32:
   {
    $131 = $8;
    $132 = _mpz_is_neg($131) | 0;
    if (!$132) {
     $138 = $13;
     $139 = $138 + 4 | 0;
     $140 = $7;
     $141 = $8;
     _mpz_pow_inpl($139, $140, $141);
     break L47;
    }
    $133 = $4;
    $134 = $7;
    $135 = +_mpz_as_float($134);
    $136 = $6;
    $137 = _mp_obj_float_binary_op($133, $135, $136) | 0;
    $3 = $137;
    $180 = $3;
    STACKTOP = sp;
    return $180 | 0;
    break;
   }
  default:
   {
    $142 = $8;
    $143 = _mpz_is_zero_1033($142) | 0;
    if ($143) {
     _mp_raise_msg(15172, 33845);
    }
    $144 = _mp_obj_int_new_mpz() | 0;
    $17 = $144;
    $145 = $17;
    $146 = $145 + 4 | 0;
    $147 = $13;
    $148 = $147 + 4 | 0;
    $149 = $7;
    $150 = $8;
    _mpz_divmod_inpl($146, $148, $149, $150);
    $151 = $17;
    HEAP32[$18 >> 2] = $151;
    $152 = $18 + 4 | 0;
    $153 = $13;
    HEAP32[$152 >> 2] = $153;
    $154 = _mp_obj_new_tuple(2, $18) | 0;
    $3 = $154;
    $180 = $3;
    STACKTOP = sp;
    return $180 | 0;
   }
  }
 } while (0);
 $155 = $13;
 $3 = $155;
 $180 = $3;
 STACKTOP = sp;
 return $180 | 0;
}

function _fmod($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $$070 = 0.0, $$071$lcssa = 0, $$07194 = 0, $$073$lcssa = 0, $$073100 = 0, $$172 = 0, $$174 = 0, $$275$lcssa = 0, $$27585 = 0, $$376$lcssa = 0, $$37682 = 0, $$lcssa = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0.0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0.0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0.0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0.0, $28 = 0.0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0.0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $spec$select = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $2 = HEAP32[tempDoublePtr >> 2] | 0;
 $3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 HEAPF64[tempDoublePtr >> 3] = $1;
 $4 = HEAP32[tempDoublePtr >> 2] | 0;
 $5 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $6 = _bitshift64Lshr($2 | 0, $3 | 0, 52) | 0;
 $7 = getTempRet0() | 0;
 $8 = $6 & 2047;
 $9 = _bitshift64Lshr($4 | 0, $5 | 0, 52) | 0;
 $10 = getTempRet0() | 0;
 $11 = $9 & 2047;
 $12 = $3 & -2147483648;
 $13 = _bitshift64Shl($4 | 0, $5 | 0, 1) | 0;
 $14 = getTempRet0() | 0;
 $15 = ($13 | 0) == 0;
 $16 = ($14 | 0) == 0;
 $17 = $15 & $16;
 L1 : do {
  if ($17) {
   label = 3;
  } else {
   $18 = ___DOUBLE_BITS_15($1) | 0;
   $19 = getTempRet0() | 0;
   $20 = $19 & 2147483647;
   $21 = $20 >>> 0 > 2146435072;
   $22 = $18 >>> 0 > 0;
   $23 = ($20 | 0) == 2146435072;
   $24 = $23 & $22;
   $25 = $21 | $24;
   $26 = ($8 | 0) == 2047;
   $or$cond = $26 | $25;
   if ($or$cond) {
    label = 3;
   } else {
    $29 = _bitshift64Shl($2 | 0, $3 | 0, 1) | 0;
    $30 = getTempRet0() | 0;
    $31 = $30 >>> 0 > $14 >>> 0;
    $32 = $29 >>> 0 > $13 >>> 0;
    $33 = ($30 | 0) == ($14 | 0);
    $34 = $33 & $32;
    $35 = $31 | $34;
    if (!$35) {
     $36 = ($29 | 0) == ($13 | 0);
     $37 = ($30 | 0) == ($14 | 0);
     $38 = $36 & $37;
     $39 = $0 * 0.0;
     $spec$select = $38 ? $39 : $0;
     return +$spec$select;
    }
    $40 = ($8 | 0) == 0;
    if ($40) {
     $41 = _bitshift64Shl($2 | 0, $3 | 0, 12) | 0;
     $42 = getTempRet0() | 0;
     $43 = ($42 | 0) > -1;
     $44 = $41 >>> 0 > 4294967295;
     $45 = ($42 | 0) == -1;
     $46 = $45 & $44;
     $47 = $43 | $46;
     if ($47) {
      $$073100 = 0;
      $49 = $41;
      $50 = $42;
      while (1) {
       $48 = $$073100 + -1 | 0;
       $51 = _bitshift64Shl($49 | 0, $50 | 0, 1) | 0;
       $52 = getTempRet0() | 0;
       $53 = ($52 | 0) > -1;
       $54 = $51 >>> 0 > 4294967295;
       $55 = ($52 | 0) == -1;
       $56 = $55 & $54;
       $57 = $53 | $56;
       if ($57) {
        $$073100 = $48;
        $49 = $51;
        $50 = $52;
       } else {
        $$073$lcssa = $48;
        break;
       }
      }
     } else {
      $$073$lcssa = 0;
     }
     $58 = 1 - $$073$lcssa | 0;
     $59 = _bitshift64Shl($2 | 0, $3 | 0, $58 | 0) | 0;
     $60 = getTempRet0() | 0;
     $$174 = $$073$lcssa;
     $87 = $59;
     $88 = $60;
    } else {
     $61 = $3 & 1048575;
     $62 = $61 | 1048576;
     $$174 = $8;
     $87 = $2;
     $88 = $62;
    }
    $63 = ($11 | 0) == 0;
    if ($63) {
     $64 = _bitshift64Shl($4 | 0, $5 | 0, 12) | 0;
     $65 = getTempRet0() | 0;
     $66 = ($65 | 0) > -1;
     $67 = $64 >>> 0 > 4294967295;
     $68 = ($65 | 0) == -1;
     $69 = $68 & $67;
     $70 = $66 | $69;
     if ($70) {
      $$07194 = 0;
      $72 = $64;
      $73 = $65;
      while (1) {
       $71 = $$07194 + -1 | 0;
       $74 = _bitshift64Shl($72 | 0, $73 | 0, 1) | 0;
       $75 = getTempRet0() | 0;
       $76 = ($75 | 0) > -1;
       $77 = $74 >>> 0 > 4294967295;
       $78 = ($75 | 0) == -1;
       $79 = $78 & $77;
       $80 = $76 | $79;
       if ($80) {
        $$07194 = $71;
        $72 = $74;
        $73 = $75;
       } else {
        $$071$lcssa = $71;
        break;
       }
      }
     } else {
      $$071$lcssa = 0;
     }
     $81 = 1 - $$071$lcssa | 0;
     $82 = _bitshift64Shl($4 | 0, $5 | 0, $81 | 0) | 0;
     $83 = getTempRet0() | 0;
     $$172 = $$071$lcssa;
     $89 = $82;
     $90 = $83;
    } else {
     $84 = $5 & 1048575;
     $85 = $84 | 1048576;
     $$172 = $11;
     $89 = $4;
     $90 = $85;
    }
    $86 = ($$174 | 0) > ($$172 | 0);
    $91 = _i64Subtract($87 | 0, $88 | 0, $89 | 0, $90 | 0) | 0;
    $92 = getTempRet0() | 0;
    $93 = ($92 | 0) > -1;
    $94 = $91 >>> 0 > 4294967295;
    $95 = ($92 | 0) == -1;
    $96 = $95 & $94;
    $97 = $93 | $96;
    L25 : do {
     if ($86) {
      $$27585 = $$174;
      $100 = $92;
      $158 = $97;
      $159 = $87;
      $160 = $88;
      $98 = $91;
      while (1) {
       if ($158) {
        $99 = ($98 | 0) == 0;
        $101 = ($100 | 0) == 0;
        $102 = $99 & $101;
        if ($102) {
         break;
        } else {
         $104 = $98;
         $105 = $100;
        }
       } else {
        $104 = $159;
        $105 = $160;
       }
       $106 = _bitshift64Shl($104 | 0, $105 | 0, 1) | 0;
       $107 = getTempRet0() | 0;
       $108 = $$27585 + -1 | 0;
       $109 = ($108 | 0) > ($$172 | 0);
       $110 = _i64Subtract($106 | 0, $107 | 0, $89 | 0, $90 | 0) | 0;
       $111 = getTempRet0() | 0;
       $112 = ($111 | 0) > -1;
       $113 = $110 >>> 0 > 4294967295;
       $114 = ($111 | 0) == -1;
       $115 = $114 & $113;
       $116 = $112 | $115;
       if ($109) {
        $$27585 = $108;
        $100 = $111;
        $158 = $116;
        $159 = $106;
        $160 = $107;
        $98 = $110;
       } else {
        $$275$lcssa = $108;
        $$lcssa = $116;
        $117 = $110;
        $119 = $111;
        $156 = $106;
        $157 = $107;
        break L25;
       }
      }
      $103 = $0 * 0.0;
      $$070 = $103;
      break L1;
     } else {
      $$275$lcssa = $$174;
      $$lcssa = $97;
      $117 = $91;
      $119 = $92;
      $156 = $87;
      $157 = $88;
     }
    } while (0);
    if ($$lcssa) {
     $118 = ($117 | 0) == 0;
     $120 = ($119 | 0) == 0;
     $121 = $118 & $120;
     if ($121) {
      $122 = $0 * 0.0;
      $$070 = $122;
      break;
     } else {
      $123 = $119;
      $125 = $117;
     }
    } else {
     $123 = $157;
     $125 = $156;
    }
    $124 = $123 >>> 0 < 1048576;
    $126 = $125 >>> 0 < 0;
    $127 = ($123 | 0) == 1048576;
    $128 = $127 & $126;
    $129 = $124 | $128;
    if ($129) {
     $$37682 = $$275$lcssa;
     $130 = $125;
     $131 = $123;
     while (1) {
      $132 = _bitshift64Shl($130 | 0, $131 | 0, 1) | 0;
      $133 = getTempRet0() | 0;
      $134 = $$37682 + -1 | 0;
      $135 = $133 >>> 0 < 1048576;
      $136 = $132 >>> 0 < 0;
      $137 = ($133 | 0) == 1048576;
      $138 = $137 & $136;
      $139 = $135 | $138;
      if ($139) {
       $$37682 = $134;
       $130 = $132;
       $131 = $133;
      } else {
       $$376$lcssa = $134;
       $141 = $132;
       $142 = $133;
       break;
      }
     }
    } else {
     $$376$lcssa = $$275$lcssa;
     $141 = $125;
     $142 = $123;
    }
    $140 = ($$376$lcssa | 0) > 0;
    if ($140) {
     $143 = _i64Add($141 | 0, $142 | 0, 0, -1048576) | 0;
     $144 = getTempRet0() | 0;
     $145 = _bitshift64Shl($$376$lcssa | 0, 0, 52) | 0;
     $146 = getTempRet0() | 0;
     $147 = $143 | $145;
     $148 = $144 | $146;
     $153 = $148;
     $155 = $147;
    } else {
     $149 = 1 - $$376$lcssa | 0;
     $150 = _bitshift64Lshr($141 | 0, $142 | 0, $149 | 0) | 0;
     $151 = getTempRet0() | 0;
     $153 = $151;
     $155 = $150;
    }
    $152 = $153 | $12;
    HEAP32[tempDoublePtr >> 2] = $155;
    HEAP32[tempDoublePtr + 4 >> 2] = $152;
    $154 = +HEAPF64[tempDoublePtr >> 3];
    $$070 = $154;
   }
  }
 } while (0);
 if ((label | 0) == 3) {
  $27 = $0 * $1;
  $28 = $27 / $27;
  $$070 = $28;
 }
 return +$$070;
}

function _mp_parse_compile_execute($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $$0 = 0, $$reg2mem45$0 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, $cond50 = 0, $cond51 = 0, $cond52 = 0, $cond53 = 0, $cond54 = 0, $cond55 = 0, $cond56 = 0, $cond57 = 0, $cond58 = 0, $cond59 = 0, $cond60 = 0, $cond61 = 0, $cond62 = 0, _setjmpTable = 0, _setjmpTableSize = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 192 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(192 | 0);
 _setjmpTableSize = 4;
 _setjmpTable = _malloc(40) | 0;
 HEAP32[_setjmpTable >> 2] = 0;
 $6 = sp + 8 | 0;
 $7 = sp;
 __THREW__ = 0;
 $8 = invoke_i(503) | 0;
 $9 = __THREW__;
 __THREW__ = 0;
 if (($9 | 0) != 0 & (threwValue | 0) != 0) {
  $10 = _testSetjmp(HEAP32[$9 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  if (($10 | 0) == 0) {
   _longjmp($9 | 0, threwValue | 0);
  }
  setTempRet0(threwValue | 0);
 } else {
  $10 = -1;
 }
 $11 = getTempRet0() | 0;
 $cond = ($10 | 0) == 1;
 if ($cond) {
  $$reg2mem45$0 = $11;
 } else {
  $4 = $8;
  __THREW__ = 0;
  $12 = invoke_i(504) | 0;
  $13 = __THREW__;
  __THREW__ = 0;
  if (($13 | 0) != 0 & (threwValue | 0) != 0) {
   $14 = _testSetjmp(HEAP32[$13 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($14 | 0) == 0) {
    _longjmp($13 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $14 = -1;
  }
  $15 = getTempRet0() | 0;
  $cond50 = ($14 | 0) == 1;
  if ($cond50) {
   $$reg2mem45$0 = $15;
  } else {
   $5 = $12;
   __THREW__ = 0;
   invoke_vi(505, $2 | 0);
   $16 = __THREW__;
   __THREW__ = 0;
   if (($16 | 0) != 0 & (threwValue | 0) != 0) {
    $17 = _testSetjmp(HEAP32[$16 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($17 | 0) == 0) {
     _longjmp($16 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $17 = -1;
   }
   $18 = getTempRet0() | 0;
   $cond51 = ($17 | 0) == 1;
   if ($cond51) {
    $$reg2mem45$0 = $18;
   } else {
    __THREW__ = 0;
    invoke_vi(506, $3 | 0);
    $19 = __THREW__;
    __THREW__ = 0;
    if (($19 | 0) != 0 & (threwValue | 0) != 0) {
     $20 = _testSetjmp(HEAP32[$19 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($20 | 0) == 0) {
      _longjmp($19 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $20 = -1;
    }
    $21 = getTempRet0() | 0;
    $cond52 = ($20 | 0) == 1;
    if ($cond52) {
     $$reg2mem45$0 = $21;
    } else {
     __THREW__ = 0;
     invoke_ii(496, $6 | 0) | 0;
     $22 = __THREW__;
     __THREW__ = 0;
     if (($22 | 0) != 0 & (threwValue | 0) != 0) {
      $23 = _testSetjmp(HEAP32[$22 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($23 | 0) == 0) {
       _longjmp($22 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $23 = -1;
     }
     $24 = getTempRet0() | 0;
     $cond53 = ($23 | 0) == 1;
     if ($cond53) {
      $$reg2mem45$0 = $24;
     } else {
      $25 = $6 + 8 | 0;
      _setjmpTable = _saveSetjmp($25, 1, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      _setjmpTableSize = getTempRet0() | 0;
      __THREW__ = 0;
      $26 = __THREW__;
      __THREW__ = 0;
      if (($26 | 0) != 0 & (threwValue | 0) != 0) {
       $27 = _testSetjmp(HEAP32[$26 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
       if (($27 | 0) == 0) {
        _longjmp($26 | 0, threwValue | 0);
       }
       setTempRet0(threwValue | 0);
      } else {
       $27 = -1;
      }
      $28 = getTempRet0() | 0;
      $cond54 = ($27 | 0) == 1;
      if ($cond54) {
       $$reg2mem45$0 = $28;
      } else {
       $$reg2mem45$0 = 0;
      }
     }
    }
   }
  }
 }
 while (1) {
  $29 = ($$reg2mem45$0 | 0) == 0;
  if (!$29) {
   $54 = $4;
   __THREW__ = 0;
   invoke_vi(505, $54 | 0);
   $55 = __THREW__;
   __THREW__ = 0;
   if (($55 | 0) != 0 & (threwValue | 0) != 0) {
    $56 = _testSetjmp(HEAP32[$55 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($56 | 0) == 0) {
     _longjmp($55 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $56 = -1;
   }
   $57 = getTempRet0() | 0;
   $cond55 = ($56 | 0) == 1;
   if ($cond55) {
    $$reg2mem45$0 = $57;
    continue;
   }
   $58 = $5;
   __THREW__ = 0;
   invoke_vi(506, $58 | 0);
   $59 = __THREW__;
   __THREW__ = 0;
   if (($59 | 0) != 0 & (threwValue | 0) != 0) {
    $60 = _testSetjmp(HEAP32[$59 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($60 | 0) == 0) {
     _longjmp($59 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $60 = -1;
   }
   $61 = getTempRet0() | 0;
   $cond56 = ($60 | 0) == 1;
   if ($cond56) {
    $$reg2mem45$0 = $61;
    continue;
   }
   $62 = $6 + 4 | 0;
   $63 = HEAP32[$62 >> 2] | 0;
   __THREW__ = 0;
   invoke_vi(500, $63 | 0);
   $64 = __THREW__;
   __THREW__ = 0;
   if (($64 | 0) != 0 & (threwValue | 0) != 0) {
    $65 = _testSetjmp(HEAP32[$64 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($65 | 0) == 0) {
     _longjmp($64 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $65 = -1;
   }
   $66 = getTempRet0() | 0;
   $$reg2mem45$0 = $66;
   continue;
  }
  $30 = HEAP32[$0 >> 2] | 0;
  __THREW__ = 0;
  invoke_viii(507, $7 | 0, $0 | 0, $1 | 0);
  $31 = __THREW__;
  __THREW__ = 0;
  if (($31 | 0) != 0 & (threwValue | 0) != 0) {
   $32 = _testSetjmp(HEAP32[$31 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($32 | 0) == 0) {
    _longjmp($31 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $32 = -1;
  }
  $33 = getTempRet0() | 0;
  $cond57 = ($32 | 0) == 1;
  if ($cond57) {
   $$reg2mem45$0 = $33;
   continue;
  }
  __THREW__ = 0;
  $34 = invoke_iiiii(508, $7 | 0, $30 | 0, 0, 0) | 0;
  $35 = __THREW__;
  __THREW__ = 0;
  if (($35 | 0) != 0 & (threwValue | 0) != 0) {
   $36 = _testSetjmp(HEAP32[$35 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($36 | 0) == 0) {
    _longjmp($35 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $36 = -1;
  }
  $37 = getTempRet0() | 0;
  $cond58 = ($36 | 0) == 1;
  if ($cond58) {
   $$reg2mem45$0 = $37;
   continue;
  }
  $38 = ($2 | 0) == (0 | 0);
  if ($38) {
   $$0 = $34;
  } else {
   __THREW__ = 0;
   $39 = invoke_ii(509, $34 | 0) | 0;
   $40 = __THREW__;
   __THREW__ = 0;
   if (($40 | 0) != 0 & (threwValue | 0) != 0) {
    $41 = _testSetjmp(HEAP32[$40 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($41 | 0) == 0) {
     _longjmp($40 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $41 = -1;
   }
   $42 = getTempRet0() | 0;
   $cond59 = ($41 | 0) == 1;
   if ($cond59) {
    $$reg2mem45$0 = $42;
    continue;
   }
   $$0 = $39;
  }
  __THREW__ = 0;
  invoke_v(498);
  $43 = __THREW__;
  __THREW__ = 0;
  if (($43 | 0) != 0 & (threwValue | 0) != 0) {
   $44 = _testSetjmp(HEAP32[$43 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($44 | 0) == 0) {
    _longjmp($43 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $44 = -1;
  }
  $45 = getTempRet0() | 0;
  $cond60 = ($44 | 0) == 1;
  if ($cond60) {
   $$reg2mem45$0 = $45;
   continue;
  }
  $46 = $4;
  __THREW__ = 0;
  invoke_vi(505, $46 | 0);
  $47 = __THREW__;
  __THREW__ = 0;
  if (($47 | 0) != 0 & (threwValue | 0) != 0) {
   $48 = _testSetjmp(HEAP32[$47 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($48 | 0) == 0) {
    _longjmp($47 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $48 = -1;
  }
  $49 = getTempRet0() | 0;
  $cond61 = ($48 | 0) == 1;
  if ($cond61) {
   $$reg2mem45$0 = $49;
   continue;
  }
  $50 = $5;
  __THREW__ = 0;
  invoke_vi(506, $50 | 0);
  $51 = __THREW__;
  __THREW__ = 0;
  if (($51 | 0) != 0 & (threwValue | 0) != 0) {
   $52 = _testSetjmp(HEAP32[$51 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($52 | 0) == 0) {
    _longjmp($51 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $52 = -1;
  }
  $53 = getTempRet0() | 0;
  $cond62 = ($52 | 0) == 1;
  if ($cond62) {
   $$reg2mem45$0 = $53;
  } else {
   break;
  }
 }
 _free(_setjmpTable | 0);
 STACKTOP = sp;
 return $$0 | 0;
}

function _mp_repl_continue_with_input($0) {
 $0 = $0 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val17 = 0, $$expand_i1_val19 = 0, $$expand_i1_val21 = 0, $$expand_i1_val23 = 0, $$expand_i1_val25 = 0, $$pre_trunc = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond11 = 0, $or$cond13 = 0, $or$cond15 = 0, $or$cond3 = 0, $or$cond5 = 0, $or$cond7 = 0, $or$cond9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $1 = sp + 25 | 0;
 $2 = $0;
 $9 = $2;
 $10 = HEAP8[$9 >> 0] | 0;
 $11 = $10 << 24 >> 24;
 $12 = ($11 | 0) == 0;
 if ($12) {
  $$expand_i1_val = 0;
  HEAP8[$1 >> 0] = $$expand_i1_val;
  $$pre_trunc = HEAP8[$1 >> 0] | 0;
  $161 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $161 | 0;
 }
 $13 = $2;
 $14 = HEAP8[$13 >> 0] | 0;
 $15 = $14 << 24 >> 24;
 $16 = ($15 | 0) == 64;
 if ($16) {
  $34 = 1;
 } else {
  $17 = $2;
  $18 = _str_startswith_word($17, 34405) | 0;
  if ($18) {
   $34 = 1;
  } else {
   $19 = $2;
   $20 = _str_startswith_word($19, 34408) | 0;
   if ($20) {
    $34 = 1;
   } else {
    $21 = $2;
    $22 = _str_startswith_word($21, 34414) | 0;
    if ($22) {
     $34 = 1;
    } else {
     $23 = $2;
     $24 = _str_startswith_word($23, 34418) | 0;
     if ($24) {
      $34 = 1;
     } else {
      $25 = $2;
      $26 = _str_startswith_word($25, 34422) | 0;
      if ($26) {
       $34 = 1;
      } else {
       $27 = $2;
       $28 = _str_startswith_word($27, 34427) | 0;
       if ($28) {
        $34 = 1;
       } else {
        $29 = $2;
        $30 = _str_startswith_word($29, 34431) | 0;
        if ($30) {
         $34 = 1;
        } else {
         $31 = $2;
         $32 = _str_startswith_word($31, 34437) | 0;
         $34 = $32;
        }
       }
      }
     }
    }
   }
  }
 }
 $33 = $34 & 1;
 $3 = $33;
 $4 = 0;
 $5 = 0;
 $6 = 0;
 $7 = 0;
 $35 = $2;
 $8 = $35;
 while (1) {
  $36 = $8;
  $37 = HEAP8[$36 >> 0] | 0;
  $38 = $37 << 24 >> 24 != 0;
  if (!$38) {
   break;
  }
  $39 = $8;
  $40 = HEAP8[$39 >> 0] | 0;
  $41 = $40 << 24 >> 24;
  $42 = ($41 | 0) == 39;
  L18 : do {
   if ($42) {
    $43 = $7;
    $44 = ($43 | 0) == 0;
    $45 = $7;
    $46 = ($45 | 0) == 3;
    $or$cond = $44 | $46;
    if ($or$cond) {
     $47 = $8;
     $48 = $47 + 1 | 0;
     $49 = HEAP8[$48 >> 0] | 0;
     $50 = $49 << 24 >> 24;
     $51 = ($50 | 0) == 39;
     if ($51) {
      $52 = $8;
      $53 = $52 + 2 | 0;
      $54 = HEAP8[$53 >> 0] | 0;
      $55 = $54 << 24 >> 24;
      $56 = ($55 | 0) == 39;
      if ($56) {
       $57 = $8;
       $58 = $57 + 2 | 0;
       $8 = $58;
       $59 = $7;
       $60 = 3 - $59 | 0;
       $7 = $60;
       break;
      }
     }
    }
    $61 = $7;
    $62 = ($61 | 0) == 0;
    $63 = $7;
    $64 = ($63 | 0) == 1;
    $or$cond3 = $62 | $64;
    if ($or$cond3) {
     $65 = $7;
     $66 = 1 - $65 | 0;
     $7 = $66;
    }
   } else {
    $67 = $8;
    $68 = HEAP8[$67 >> 0] | 0;
    $69 = $68 << 24 >> 24;
    $70 = ($69 | 0) == 34;
    if ($70) {
     $71 = $7;
     $72 = ($71 | 0) == 0;
     $73 = $7;
     $74 = ($73 | 0) == 4;
     $or$cond5 = $72 | $74;
     if ($or$cond5) {
      $75 = $8;
      $76 = $75 + 1 | 0;
      $77 = HEAP8[$76 >> 0] | 0;
      $78 = $77 << 24 >> 24;
      $79 = ($78 | 0) == 34;
      if ($79) {
       $80 = $8;
       $81 = $80 + 2 | 0;
       $82 = HEAP8[$81 >> 0] | 0;
       $83 = $82 << 24 >> 24;
       $84 = ($83 | 0) == 34;
       if ($84) {
        $85 = $8;
        $86 = $85 + 2 | 0;
        $8 = $86;
        $87 = $7;
        $88 = 4 - $87 | 0;
        $7 = $88;
        break;
       }
      }
     }
     $89 = $7;
     $90 = ($89 | 0) == 0;
     $91 = $7;
     $92 = ($91 | 0) == 2;
     $or$cond7 = $90 | $92;
     if (!$or$cond7) {
      break;
     }
     $93 = $7;
     $94 = 2 - $93 | 0;
     $7 = $94;
     break;
    }
    $95 = $8;
    $96 = HEAP8[$95 >> 0] | 0;
    $97 = $96 << 24 >> 24;
    $98 = ($97 | 0) == 92;
    do {
     if ($98) {
      $99 = $8;
      $100 = $99 + 1 | 0;
      $101 = HEAP8[$100 >> 0] | 0;
      $102 = $101 << 24 >> 24;
      $103 = ($102 | 0) == 39;
      if (!$103) {
       $104 = $8;
       $105 = $104 + 1 | 0;
       $106 = HEAP8[$105 >> 0] | 0;
       $107 = $106 << 24 >> 24;
       $108 = ($107 | 0) == 34;
       if (!$108) {
        $109 = $8;
        $110 = $109 + 1 | 0;
        $111 = HEAP8[$110 >> 0] | 0;
        $112 = $111 << 24 >> 24;
        $113 = ($112 | 0) == 92;
        if (!$113) {
         break;
        }
       }
      }
      $114 = $7;
      $115 = ($114 | 0) != 0;
      if (!$115) {
       break L18;
      }
      $116 = $8;
      $117 = $116 + 1 | 0;
      $8 = $117;
      break L18;
     }
    } while (0);
    $118 = $7;
    $119 = ($118 | 0) == 0;
    if ($119) {
     $120 = $8;
     $121 = HEAP8[$120 >> 0] | 0;
     $122 = $121 << 24 >> 24;
     switch ($122 | 0) {
     case 40:
      {
       $123 = $4;
       $124 = $123 + 1 | 0;
       $4 = $124;
       break L18;
       break;
      }
     case 41:
      {
       $125 = $4;
       $126 = $125 - 1 | 0;
       $4 = $126;
       break L18;
       break;
      }
     case 91:
      {
       $127 = $5;
       $128 = $127 + 1 | 0;
       $5 = $128;
       break L18;
       break;
      }
     case 93:
      {
       $129 = $5;
       $130 = $129 - 1 | 0;
       $5 = $130;
       break L18;
       break;
      }
     case 123:
      {
       $131 = $6;
       $132 = $131 + 1 | 0;
       $6 = $132;
       break L18;
       break;
      }
     case 125:
      {
       $133 = $6;
       $134 = $133 - 1 | 0;
       $6 = $134;
       break L18;
       break;
      }
     default:
      {
       break L18;
      }
     }
    }
   }
  } while (0);
  $135 = $8;
  $136 = $135 + 1 | 0;
  $8 = $136;
 }
 $137 = $7;
 $138 = ($137 | 0) == 3;
 $139 = $7;
 $140 = ($139 | 0) == 4;
 $or$cond9 = $138 | $140;
 if ($or$cond9) {
  $$expand_i1_val17 = 1;
  HEAP8[$1 >> 0] = $$expand_i1_val17;
  $$pre_trunc = HEAP8[$1 >> 0] | 0;
  $161 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $161 | 0;
 }
 $141 = $4;
 $142 = ($141 | 0) > 0;
 $143 = $5;
 $144 = ($143 | 0) > 0;
 $or$cond11 = $142 | $144;
 $145 = $6;
 $146 = ($145 | 0) > 0;
 $or$cond13 = $or$cond11 | $146;
 $147 = $7;
 $148 = ($147 | 0) == 0;
 $or$cond15 = $or$cond13 & $148;
 if ($or$cond15) {
  $$expand_i1_val19 = 1;
  HEAP8[$1 >> 0] = $$expand_i1_val19;
  $$pre_trunc = HEAP8[$1 >> 0] | 0;
  $161 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $161 | 0;
 }
 $149 = $8;
 $150 = $149 + -1 | 0;
 $151 = HEAP8[$150 >> 0] | 0;
 $152 = $151 << 24 >> 24;
 $153 = ($152 | 0) == 92;
 if ($153) {
  $$expand_i1_val21 = 1;
  HEAP8[$1 >> 0] = $$expand_i1_val21;
  $$pre_trunc = HEAP8[$1 >> 0] | 0;
  $161 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $161 | 0;
 }
 $154 = $3;
 $155 = $154 & 1;
 if ($155) {
  $156 = $8;
  $157 = $156 + -1 | 0;
  $158 = HEAP8[$157 >> 0] | 0;
  $159 = $158 << 24 >> 24;
  $160 = ($159 | 0) != 10;
  if ($160) {
   $$expand_i1_val23 = 1;
   HEAP8[$1 >> 0] = $$expand_i1_val23;
   $$pre_trunc = HEAP8[$1 >> 0] | 0;
   $161 = $$pre_trunc & 1;
   STACKTOP = sp;
   return $161 | 0;
  }
 }
 $$expand_i1_val25 = 0;
 HEAP8[$1 >> 0] = $$expand_i1_val25;
 $$pre_trunc = HEAP8[$1 >> 0] | 0;
 $161 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $161 | 0;
}

function _do_str($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$0 = 0, $$reg2mem50$0 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, $cond54 = 0, $cond55 = 0, $cond56 = 0, $cond57 = 0, $cond58 = 0, $cond59 = 0, $cond60 = 0, $cond61 = 0, $cond62 = 0, $cond63 = 0, $cond64 = 0, $cond65 = 0, _setjmpTable = 0, _setjmpTableSize = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 192 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(192 | 0);
 _setjmpTableSize = 4;
 _setjmpTable = _malloc(40) | 0;
 HEAP32[_setjmpTable >> 2] = 0;
 $2 = sp + 16 | 0;
 $3 = sp + 8 | 0;
 $4 = sp;
 __THREW__ = 0;
 invoke_ii(496, $2 | 0) | 0;
 $5 = __THREW__;
 __THREW__ = 0;
 if (($5 | 0) != 0 & (threwValue | 0) != 0) {
  $6 = _testSetjmp(HEAP32[$5 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  if (($6 | 0) == 0) {
   _longjmp($5 | 0, threwValue | 0);
  }
  setTempRet0(threwValue | 0);
 } else {
  $6 = -1;
 }
 $7 = getTempRet0() | 0;
 $cond = ($6 | 0) == 1;
 if ($cond) {
  $$reg2mem50$0 = $7;
 } else {
  $8 = $2 + 8 | 0;
  _setjmpTable = _saveSetjmp($8, 1, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  _setjmpTableSize = getTempRet0() | 0;
  __THREW__ = 0;
  $9 = __THREW__;
  __THREW__ = 0;
  if (($9 | 0) != 0 & (threwValue | 0) != 0) {
   $10 = _testSetjmp(HEAP32[$9 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($10 | 0) == 0) {
    _longjmp($9 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $10 = -1;
  }
  $11 = getTempRet0() | 0;
  $cond54 = ($10 | 0) == 1;
  if ($cond54) {
   $$reg2mem50$0 = $11;
  } else {
   $$reg2mem50$0 = 0;
  }
 }
 while (1) {
  $12 = ($$reg2mem50$0 | 0) == 0;
  if ($12) {
   __THREW__ = 0;
   $13 = invoke_ii(625, $0 | 0) | 0;
   $14 = __THREW__;
   __THREW__ = 0;
   if (($14 | 0) != 0 & (threwValue | 0) != 0) {
    $15 = _testSetjmp(HEAP32[$14 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($15 | 0) == 0) {
     _longjmp($14 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $15 = -1;
   }
   $16 = getTempRet0() | 0;
   $cond60 = ($15 | 0) == 1;
   if ($cond60) {
    $$reg2mem50$0 = $16;
    continue;
   }
   __THREW__ = 0;
   $17 = invoke_iiiii(616, 215, $0 | 0, $13 | 0, 0) | 0;
   $18 = __THREW__;
   __THREW__ = 0;
   if (($18 | 0) != 0 & (threwValue | 0) != 0) {
    $19 = _testSetjmp(HEAP32[$18 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($19 | 0) == 0) {
     _longjmp($18 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $19 = -1;
   }
   $20 = getTempRet0() | 0;
   $cond61 = ($19 | 0) == 1;
   if ($cond61) {
    $$reg2mem50$0 = $20;
    continue;
   }
   $21 = HEAP32[$17 >> 2] | 0;
   __THREW__ = 0;
   invoke_viii(507, $3 | 0, $17 | 0, $1 | 0);
   $22 = __THREW__;
   __THREW__ = 0;
   if (($22 | 0) != 0 & (threwValue | 0) != 0) {
    $23 = _testSetjmp(HEAP32[$22 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($23 | 0) == 0) {
     _longjmp($22 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $23 = -1;
   }
   $24 = getTempRet0() | 0;
   $cond62 = ($23 | 0) == 1;
   if ($cond62) {
    $$reg2mem50$0 = $24;
    continue;
   }
   __THREW__ = 0;
   $25 = invoke_iiiii(508, $3 | 0, $21 | 0, 0, 0) | 0;
   $26 = __THREW__;
   __THREW__ = 0;
   if (($26 | 0) != 0 & (threwValue | 0) != 0) {
    $27 = _testSetjmp(HEAP32[$26 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($27 | 0) == 0) {
     _longjmp($26 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $27 = -1;
   }
   $28 = getTempRet0() | 0;
   $cond63 = ($27 | 0) == 1;
   if ($cond63) {
    $$reg2mem50$0 = $28;
    continue;
   }
   __THREW__ = 0;
   invoke_ii(509, $25 | 0) | 0;
   $29 = __THREW__;
   __THREW__ = 0;
   if (($29 | 0) != 0 & (threwValue | 0) != 0) {
    $30 = _testSetjmp(HEAP32[$29 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($30 | 0) == 0) {
     _longjmp($29 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $30 = -1;
   }
   $31 = getTempRet0() | 0;
   $cond64 = ($30 | 0) == 1;
   if ($cond64) {
    $$reg2mem50$0 = $31;
    continue;
   }
   __THREW__ = 0;
   invoke_v(498);
   $32 = __THREW__;
   __THREW__ = 0;
   if (($32 | 0) != 0 & (threwValue | 0) != 0) {
    $33 = _testSetjmp(HEAP32[$32 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($33 | 0) == 0) {
     _longjmp($32 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $33 = -1;
   }
   $34 = getTempRet0() | 0;
   $cond65 = ($33 | 0) == 1;
   if ($cond65) {
    $$reg2mem50$0 = $34;
    continue;
   } else {
    label = 11;
    break;
   }
  }
  $35 = $2 + 4 | 0;
  $36 = HEAP32[$35 >> 2] | 0;
  __THREW__ = 0;
  $37 = invoke_ii(494, $36 | 0) | 0;
  $38 = __THREW__;
  __THREW__ = 0;
  if (($38 | 0) != 0 & (threwValue | 0) != 0) {
   $39 = _testSetjmp(HEAP32[$38 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($39 | 0) == 0) {
    _longjmp($38 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $39 = -1;
  }
  $40 = getTempRet0() | 0;
  $cond55 = ($39 | 0) == 1;
  if ($cond55) {
   $$reg2mem50$0 = $40;
   continue;
  }
  __THREW__ = 0;
  $41 = invoke_iii(499, $37 | 0, 14872 | 0) | 0;
  $42 = __THREW__;
  __THREW__ = 0;
  if (($42 | 0) != 0 & (threwValue | 0) != 0) {
   $43 = _testSetjmp(HEAP32[$42 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($43 | 0) == 0) {
    _longjmp($42 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $43 = -1;
  }
  $44 = getTempRet0() | 0;
  $cond56 = ($43 | 0) == 1;
  if ($cond56) {
   $$reg2mem50$0 = $44;
   continue;
  }
  $45 = $2 + 4 | 0;
  $46 = HEAP32[$45 >> 2] | 0;
  if (!$41) {
   __THREW__ = 0;
   invoke_vii(511, 13344 | 0, $46 | 0);
   $58 = __THREW__;
   __THREW__ = 0;
   if (($58 | 0) != 0 & (threwValue | 0) != 0) {
    $59 = _testSetjmp(HEAP32[$58 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($59 | 0) == 0) {
     _longjmp($58 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $59 = -1;
   }
   $60 = getTempRet0() | 0;
   $cond57 = ($59 | 0) == 1;
   if ($cond57) {
    $$reg2mem50$0 = $60;
    continue;
   } else {
    label = 22;
    break;
   }
  }
  __THREW__ = 0;
  $47 = invoke_ii(605, $46 | 0) | 0;
  $48 = __THREW__;
  __THREW__ = 0;
  if (($48 | 0) != 0 & (threwValue | 0) != 0) {
   $49 = _testSetjmp(HEAP32[$48 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($49 | 0) == 0) {
    _longjmp($48 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $49 = -1;
  }
  $50 = getTempRet0() | 0;
  $cond58 = ($49 | 0) == 1;
  if ($cond58) {
   $$reg2mem50$0 = $50;
   continue;
  }
  $51 = ($47 | 0) != (17668 | 0);
  if (!$51) {
   $$0 = 0;
   label = 23;
   break;
  }
  __THREW__ = 0;
  $52 = invoke_iii(626, $47 | 0, $4 | 0) | 0;
  $53 = __THREW__;
  __THREW__ = 0;
  if (($53 | 0) != 0 & (threwValue | 0) != 0) {
   $54 = _testSetjmp(HEAP32[$53 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($54 | 0) == 0) {
    _longjmp($53 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $54 = -1;
  }
  $55 = getTempRet0() | 0;
  $cond59 = ($54 | 0) == 1;
  if ($cond59) {
   $$reg2mem50$0 = $55;
  } else {
   label = 18;
   break;
  }
 }
 if ((label | 0) == 11) {
  $$0 = 0;
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$0 | 0;
 } else if ((label | 0) == 18) {
  if ($52) {
   $56 = HEAP32[$4 >> 2] | 0;
   $57 = $56 & 255;
   $$0 = $57;
   _free(_setjmpTable | 0);
   STACKTOP = sp;
   return $$0 | 0;
  } else {
   $$0 = 1;
   _free(_setjmpTable | 0);
   STACKTOP = sp;
   return $$0 | 0;
  }
 } else if ((label | 0) == 22) {
  $$0 = 1;
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$0 | 0;
 } else if ((label | 0) == 23) {
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$0 | 0;
 }
 return 0 | 0;
}

function _mp_print_mp_int($0, $1, $2, $3, $4, $5, $6, $7) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 $7 = $7 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $199 = 0, $20 = 0, $200 = 0, $201 = 0, $202 = 0, $203 = 0, $204 = 0, $205 = 0, $206 = 0, $207 = 0, $208 = 0, $209 = 0, $21 = 0, $210 = 0, $211 = 0, $212 = 0, $213 = 0, $214 = 0, $215 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $spec$store$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(96 | 0);
 $16 = sp + 88 | 0;
 $20 = sp;
 $21 = sp + 44 | 0;
 $22 = sp + 40 | 0;
 $23 = sp + 36 | 0;
 $25 = sp + 84 | 0;
 $8 = $0;
 $9 = $1;
 $10 = $2;
 $11 = $3;
 $12 = $4;
 $13 = $5;
 $14 = $6;
 $15 = $7;
 $30 = $9;
 $31 = _mp_obj_is_small_int($30) | 0;
 do {
  if (!$31) {
   $32 = $9;
   $33 = _mp_obj_is_obj($32) | 0;
   if ($33) {
    $34 = $9;
    $35 = HEAP32[$34 >> 2] | 0;
    $36 = ($35 | 0) == (16904 | 0);
    if ($36) {
     break;
    }
   }
   $37 = $9;
   $38 = _mp_obj_get_int($37) | 0;
   $39 = $38 << 1;
   $40 = $39 | 1;
   $41 = $40;
   $9 = $41;
  }
 } while (0);
 $42 = $12;
 $43 = $42 & 129;
 $44 = ($43 | 0) == 0;
 if ($44) {
  $45 = $13;
  $46 = $45 << 24 >> 24;
  $47 = ($46 | 0) == 48;
  if ($47) {
   $48 = $15;
   $49 = $14;
   $50 = ($48 | 0) > ($49 | 0);
   if ($50) {
    $51 = $15;
    $14 = $51;
   }
   $15 = 0;
  }
 }
 $17 = $16;
 $52 = $9;
 $53 = _mp_obj_int_sign($52) | 0;
 $54 = ($53 | 0) >= 0;
 do {
  if ($54) {
   $55 = $12;
   $56 = $55 & 2;
   $57 = ($56 | 0) != 0;
   if ($57) {
    $58 = $17;
    $59 = $58 + 1 | 0;
    $17 = $59;
    HEAP8[$58 >> 0] = 43;
    break;
   }
   $60 = $12;
   $61 = $60 & 4;
   $62 = ($61 | 0) != 0;
   if ($62) {
    $63 = $17;
    $64 = $63 + 1 | 0;
    $17 = $64;
    HEAP8[$63 >> 0] = 32;
   }
  }
 } while (0);
 $65 = $12;
 $66 = $65 & 16;
 $67 = ($66 | 0) != 0;
 do {
  if ($67) {
   $68 = $10;
   $69 = ($68 | 0) == 2;
   if ($69) {
    $70 = $17;
    $71 = $70 + 1 | 0;
    $17 = $71;
    HEAP8[$70 >> 0] = 48;
    $72 = $11;
    $73 = $72 + 98 | 0;
    $74 = $73 - 97 | 0;
    $75 = $74 & 255;
    $76 = $17;
    $77 = $76 + 1 | 0;
    $17 = $77;
    HEAP8[$76 >> 0] = $75;
    break;
   }
   $78 = $10;
   $79 = ($78 | 0) == 8;
   if ($79) {
    $80 = $17;
    $81 = $80 + 1 | 0;
    $17 = $81;
    HEAP8[$80 >> 0] = 48;
    $82 = $12;
    $83 = $82 & 512;
    $84 = ($83 | 0) != 0;
    if (!$84) {
     break;
    }
    $85 = $11;
    $86 = $85 + 111 | 0;
    $87 = $86 - 97 | 0;
    $88 = $87 & 255;
    $89 = $17;
    $90 = $89 + 1 | 0;
    $17 = $90;
    HEAP8[$89 >> 0] = $88;
    break;
   } else {
    $91 = $10;
    $92 = ($91 | 0) == 16;
    if (!$92) {
     break;
    }
    $93 = $17;
    $94 = $93 + 1 | 0;
    $17 = $94;
    HEAP8[$93 >> 0] = 48;
    $95 = $11;
    $96 = $95 + 120 | 0;
    $97 = $96 - 97 | 0;
    $98 = $97 & 255;
    $99 = $17;
    $100 = $99 + 1 | 0;
    $17 = $100;
    HEAP8[$99 >> 0] = $98;
    break;
   }
  }
 } while (0);
 $101 = $17;
 HEAP8[$101 >> 0] = 0;
 $102 = $17;
 $103 = $102;
 $104 = $16;
 $105 = $103 - $104 | 0;
 $18 = $105;
 $17 = $16;
 $19 = 0;
 $106 = $12;
 $107 = $106 & 32;
 $108 = ($107 | 0) != 0;
 $spec$store$select = $108 ? 44 : 0;
 $19 = $spec$store$select;
 HEAP32[$21 >> 2] = $20;
 HEAP32[$22 >> 2] = 16;
 HEAP32[$23 >> 2] = 0;
 $109 = $15;
 $110 = ($109 | 0) > 1;
 if ($110) {
  $111 = $12;
  $112 = $111 | 64;
  $12 = $112;
 }
 HEAP8[$25 >> 0] = 0;
 $113 = $12;
 $114 = $113 & 64;
 $115 = ($114 | 0) != 0;
 $116 = $9;
 $117 = $10;
 if ($115) {
  $118 = $11;
  $119 = $118 & 255;
  $120 = $19;
  $121 = _mp_obj_int_formatted($21, $22, $23, $116, $117, 0, $119, $120) | 0;
  $24 = $121;
  $122 = $24;
  $123 = HEAP8[$122 >> 0] | 0;
  $124 = $123 << 24 >> 24;
  $125 = ($124 | 0) == 45;
  if ($125) {
   $126 = $24;
   $127 = $126 + 1 | 0;
   $24 = $127;
   $128 = HEAP8[$126 >> 0] | 0;
   HEAP8[$25 >> 0] = $128;
   $129 = HEAP32[$23 >> 2] | 0;
   $130 = $129 + -1 | 0;
   HEAP32[$23 >> 2] = $130;
  }
 } else {
  $131 = $17;
  $132 = $11;
  $133 = $132 & 255;
  $134 = $19;
  $135 = _mp_obj_int_formatted($21, $22, $23, $116, $117, $131, $133, $134) | 0;
  $24 = $135;
 }
 $26 = 0;
 $27 = 0;
 $136 = $15;
 $137 = ($136 | 0) > 1;
 if ($137) {
  $138 = HEAP32[$23 >> 2] | 0;
  $28 = $138;
  $139 = $28;
  $140 = $15;
  $141 = ($139 | 0) < ($140 | 0);
  if ($141) {
   $142 = $15;
   $28 = $142;
  }
  $143 = $12;
  $144 = $143 & 64;
  $145 = ($144 | 0) != 0;
  if ($145) {
   $146 = HEAP8[$25 >> 0] | 0;
   $147 = $146 << 24 >> 24 != 0;
   if ($147) {
    $148 = $28;
    $149 = $148 + 1 | 0;
    $28 = $149;
   }
   $150 = $18;
   $151 = $28;
   $152 = $151 + $150 | 0;
   $28 = $152;
  }
  $153 = $28;
  $154 = $14;
  $155 = ($153 | 0) < ($154 | 0);
  do {
   if ($155) {
    $156 = $12;
    $157 = $156 & 1;
    $158 = ($157 | 0) != 0;
    $159 = $14;
    $160 = $28;
    $161 = $159 - $160 | 0;
    if ($158) {
     $27 = $161;
     break;
    } else {
     $26 = $161;
     break;
    }
   }
  } while (0);
  $13 = 48;
  $162 = $12;
  $163 = $162 & -2;
  $12 = $163;
 }
 $29 = 0;
 $164 = $26;
 $165 = ($164 | 0) != 0;
 if ($165) {
  $166 = $8;
  $167 = $26;
  $168 = _mp_print_strn($166, 41653, 0, 0, 32, $167) | 0;
  $169 = $29;
  $170 = $169 + $168 | 0;
  $29 = $170;
 }
 $171 = $12;
 $172 = $171 & 64;
 $173 = ($172 | 0) != 0;
 if ($173) {
  $174 = HEAP8[$25 >> 0] | 0;
  $175 = $174 << 24 >> 24 != 0;
  if ($175) {
   $176 = $8;
   $177 = _mp_print_strn($176, $25, 1, 0, 0, 1) | 0;
   $178 = $29;
   $179 = $178 + $177 | 0;
   $29 = $179;
   $180 = $14;
   $181 = $180 + -1 | 0;
   $14 = $181;
  }
  $182 = $18;
  $183 = ($182 | 0) != 0;
  if ($183) {
   $184 = $8;
   $185 = $17;
   $186 = $18;
   $187 = _mp_print_strn($184, $185, $186, 0, 0, 1) | 0;
   $188 = $29;
   $189 = $188 + $187 | 0;
   $29 = $189;
   $190 = $18;
   $191 = $14;
   $192 = $191 - $190 | 0;
   $14 = $192;
  }
 }
 $193 = $15;
 $194 = ($193 | 0) > 1;
 if ($194) {
  $195 = $15;
  $14 = $195;
 }
 $196 = $8;
 $197 = $24;
 $198 = HEAP32[$23 >> 2] | 0;
 $199 = $12;
 $200 = $13;
 $201 = $14;
 $202 = _mp_print_strn($196, $197, $198, $199, $200, $201) | 0;
 $203 = $29;
 $204 = $203 + $202 | 0;
 $29 = $204;
 $205 = $27;
 $206 = ($205 | 0) != 0;
 if ($206) {
  $207 = $8;
  $208 = $27;
  $209 = _mp_print_strn($207, 41653, 0, 0, 32, $208) | 0;
  $210 = $29;
  $211 = $210 + $209 | 0;
  $29 = $211;
 }
 $212 = HEAP32[$21 >> 2] | 0;
 $213 = ($212 | 0) != ($20 | 0);
 if (!$213) {
  $215 = $29;
  STACKTOP = sp;
  return $215 | 0;
 }
 $214 = HEAP32[$21 >> 2] | 0;
 _m_free($214);
 $215 = $29;
 STACKTOP = sp;
 return $215 | 0;
}

function _mp_obj_new_type($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $vararg_buffer = sp;
 $7 = sp + 44 | 0;
 $8 = sp + 40 | 0;
 $14 = sp + 16 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $18 = $4;
 $19 = _mp_obj_is_obj_1260($18) | 0;
 if (!$19) {
  _mp_raise_TypeError(0);
 }
 $20 = $4;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = ($21 | 0) == (18952 | 0);
 if (!$22) {
  _mp_raise_TypeError(0);
 }
 $23 = $5;
 $24 = _mp_obj_is_obj_1260($23) | 0;
 if (!$24) {
  _mp_raise_TypeError(0);
 }
 $25 = $5;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = ($26 | 0) == (14112 | 0);
 if (!$27) {
  _mp_raise_TypeError(0);
 }
 $6 = 0;
 $28 = $4;
 _mp_obj_tuple_get($28, $7, $8);
 $9 = 0;
 while (1) {
  $29 = $9;
  $30 = HEAP32[$7 >> 2] | 0;
  $31 = $29 >>> 0 < $30 >>> 0;
  if (!$31) {
   label = 17;
   break;
  }
  $32 = HEAP32[$8 >> 2] | 0;
  $33 = $9;
  $34 = $32 + ($33 << 2) | 0;
  $35 = HEAP32[$34 >> 2] | 0;
  $36 = _mp_obj_is_obj_1260($35) | 0;
  if (!$36) {
   label = 11;
   break;
  }
  $37 = HEAP32[$8 >> 2] | 0;
  $38 = $9;
  $39 = $37 + ($38 << 2) | 0;
  $40 = HEAP32[$39 >> 2] | 0;
  $41 = HEAP32[$40 >> 2] | 0;
  $42 = ($41 | 0) == (19048 | 0);
  if (!$42) {
   label = 11;
   break;
  }
  $43 = HEAP32[$8 >> 2] | 0;
  $44 = $9;
  $45 = $43 + ($44 << 2) | 0;
  $46 = HEAP32[$45 >> 2] | 0;
  $10 = $46;
  $47 = $10;
  $48 = $47 + 12 | 0;
  $49 = HEAP32[$48 >> 2] | 0;
  $50 = ($49 | 0) == (0 | 0);
  $51 = $10;
  if ($50) {
   label = 13;
   break;
  }
  $56 = $51 + 12 | 0;
  $57 = HEAP32[$56 >> 2] | 0;
  $58 = ($57 | 0) == (515 | 0);
  if ($58) {
   $59 = $10;
   $60 = $59 + 4 | 0;
   $61 = HEAP16[$60 >> 1] | 0;
   $62 = $61 & 65535;
   $63 = $62 | 1;
   $64 = $63 & 65535;
   HEAP16[$60 >> 1] = $64;
   $65 = $10;
   $66 = $65 + 4 | 0;
   $67 = HEAP16[$66 >> 1] | 0;
   $68 = $67 & 65535;
   $69 = $68 & 2;
   $70 = $6;
   $71 = $70 & 65535;
   $72 = $71 | $69;
   $73 = $72 & 65535;
   $6 = $73;
  }
  $74 = $9;
  $75 = $74 + 1 | 0;
  $9 = $75;
 }
 if ((label | 0) == 11) {
  _mp_raise_TypeError(0);
 } else if ((label | 0) == 13) {
  $52 = $51 + 6 | 0;
  $53 = HEAP16[$52 >> 1] | 0;
  $54 = $53 & 65535;
  HEAP32[$vararg_buffer >> 2] = $54;
  $55 = _mp_obj_new_exception_msg_varg(16012, 33153, $vararg_buffer) | 0;
  _nlr_jump($55);
 } else if ((label | 0) == 17) {
  $76 = _m_malloc0(60) | 0;
  $11 = $76;
  $77 = $11;
  HEAP32[$77 >> 2] = 19048;
  $78 = $6;
  $79 = $11;
  $80 = $79 + 4 | 0;
  HEAP16[$80 >> 1] = $78;
  $81 = $3;
  $82 = $81 & 65535;
  $83 = $11;
  $84 = $83 + 6 | 0;
  HEAP16[$84 >> 1] = $82;
  $85 = $11;
  $86 = $85 + 8 | 0;
  HEAP32[$86 >> 2] = 530;
  $87 = $11;
  $88 = $87 + 12 | 0;
  HEAP32[$88 >> 2] = 515;
  $89 = $11;
  $90 = $89 + 16 | 0;
  HEAP32[$90 >> 2] = 512;
  $91 = $11;
  $92 = $91 + 20 | 0;
  HEAP32[$92 >> 2] = 531;
  $93 = $11;
  $94 = $93 + 24 | 0;
  HEAP32[$94 >> 2] = 532;
  $95 = $11;
  $96 = $95 + 28 | 0;
  HEAP32[$96 >> 2] = 533;
  $97 = $11;
  $98 = $97 + 32 | 0;
  HEAP32[$98 >> 2] = 534;
  $99 = $11;
  $100 = $99 + 36 | 0;
  HEAP32[$100 >> 2] = 535;
  $101 = $11;
  $102 = $101 + 44 | 0;
  HEAP32[$102 >> 2] = 536;
  $103 = HEAP32[$7 >> 2] | 0;
  $104 = $103 >>> 0 > 0;
  do {
   if ($104) {
    $105 = HEAP32[$8 >> 2] | 0;
    $106 = HEAP32[$105 >> 2] | 0;
    $107 = $106 + 48 | 0;
    $108 = HEAP32[$107 >> 2] | 0;
    $109 = $11;
    $110 = $109 + 48 | 0;
    HEAP32[$110 >> 2] = $108;
    $111 = HEAP32[$7 >> 2] | 0;
    $112 = $111 >>> 0 >= 2;
    if ($112) {
     $113 = $4;
     $114 = $11;
     $115 = $114 + 52 | 0;
     HEAP32[$115 >> 2] = $113;
     break;
    } else {
     $116 = HEAP32[$8 >> 2] | 0;
     $117 = HEAP32[$116 >> 2] | 0;
     $118 = $11;
     $119 = $118 + 52 | 0;
     HEAP32[$119 >> 2] = $117;
     break;
    }
   }
  } while (0);
  $120 = $5;
  $121 = $11;
  $122 = $121 + 56 | 0;
  HEAP32[$122 >> 2] = $120;
  $123 = $11;
  $124 = $123 + 4 | 0;
  $125 = HEAP16[$124 >> 1] | 0;
  $126 = $125 & 65535;
  $127 = $126 & 2;
  $128 = ($127 | 0) != 0;
  L30 : do {
   if (!$128) {
    $12 = 0;
    while (1) {
     $129 = $12;
     $130 = $11;
     $131 = $130 + 56 | 0;
     $132 = HEAP32[$131 >> 2] | 0;
     $133 = $132 + 4 | 0;
     $134 = $133 + 4 | 0;
     $135 = HEAP32[$134 >> 2] | 0;
     $136 = $129 >>> 0 < $135 >>> 0;
     if (!$136) {
      break L30;
     }
     $137 = $11;
     $138 = $137 + 56 | 0;
     $139 = HEAP32[$138 >> 2] | 0;
     $140 = $139 + 4 | 0;
     $141 = $12;
     $142 = _mp_map_slot_is_filled_1272($140, $141) | 0;
     if ($142) {
      $143 = $11;
      $144 = $143 + 56 | 0;
      $145 = HEAP32[$144 >> 2] | 0;
      $146 = $145 + 4 | 0;
      $147 = $146 + 8 | 0;
      $148 = HEAP32[$147 >> 2] | 0;
      $149 = $12;
      $150 = $148 + ($149 << 3) | 0;
      $13 = $150;
      $151 = $13;
      $152 = HEAP32[$151 >> 2] | 0;
      $153 = $13;
      $154 = $153 + 4 | 0;
      $155 = HEAP32[$154 >> 2] | 0;
      $156 = _check_for_special_accessors($152, $155) | 0;
      if ($156) {
       break;
      }
     }
     $163 = $12;
     $164 = $163 + 1 | 0;
     $12 = $164;
    }
    $157 = $11;
    $158 = $157 + 4 | 0;
    $159 = HEAP16[$158 >> 1] | 0;
    $160 = $159 & 65535;
    $161 = $160 | 2;
    $162 = $161 & 65535;
    HEAP16[$158 >> 1] = $162;
   }
  } while (0);
  $165 = $11;
  $166 = _instance_count_native_bases($165, $14) | 0;
  $15 = $166;
  $167 = $15;
  $168 = $167 >>> 0 > 1;
  if ($168) {
   _mp_raise_TypeError(33193);
  }
  $169 = $11;
  $170 = $169 + 56 | 0;
  $171 = HEAP32[$170 >> 2] | 0;
  $172 = $171 + 4 | 0;
  $16 = $172;
  $173 = $16;
  $174 = _mp_map_lookup($173, 98, 0) | 0;
  $17 = $174;
  $175 = $17;
  $176 = ($175 | 0) != (0 | 0);
  if (!$176) {
   $194 = $11;
   STACKTOP = sp;
   return $194 | 0;
  }
  $177 = $17;
  $178 = $177 + 4 | 0;
  $179 = HEAP32[$178 >> 2] | 0;
  $180 = _mp_obj_is_obj_1260($179) | 0;
  if (!$180) {
   $194 = $11;
   STACKTOP = sp;
   return $194 | 0;
  }
  $181 = $17;
  $182 = $181 + 4 | 0;
  $183 = HEAP32[$182 >> 2] | 0;
  $184 = HEAP32[$183 >> 2] | 0;
  $185 = $184 + 6 | 0;
  $186 = HEAP16[$185 >> 1] | 0;
  $187 = $186 & 65535;
  $188 = ($187 | 0) == 365;
  if (!$188) {
   $194 = $11;
   STACKTOP = sp;
   return $194 | 0;
  }
  $189 = $17;
  $190 = $189 + 4 | 0;
  $191 = _static_class_method_make_new(19120, 1, 0, $190) | 0;
  $192 = $17;
  $193 = $192 + 4 | 0;
  HEAP32[$193 >> 2] = $191;
  $194 = $11;
  STACKTOP = sp;
  return $194 | 0;
 }
 return 0 | 0;
}

function ___rem_pio2($0, $1) {
 $0 = +$0;
 $1 = $1 | 0;
 var $$0144 = 0, $$0145148 = 0.0, $$0146 = 0.0, $$0147 = 0.0, $$0149 = 0, $$1$lcssa = 0, $$phi$trans$insert = 0, $$pre = 0.0, $10 = 0, $100 = 0.0, $101 = 0, $102 = 0, $103 = 0.0, $104 = 0, $105 = 0, $106 = 0, $107 = 0.0, $108 = 0, $109 = 0.0, $11 = 0, $110 = 0, $111 = 0.0, $112 = 0.0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0.0, $125 = 0.0, $126 = 0, $127 = 0.0, $128 = 0.0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0.0, $133 = 0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0, $6 = 0, $60 = 0, $61 = 0.0, $62 = 0.0, $63 = 0.0, $64 = 0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0.0, $78 = 0.0, $79 = 0.0, $8 = 0, $80 = 0.0, $81 = 0.0, $82 = 0.0, $83 = 0.0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0.0, $92 = 0.0, $93 = 0.0, $94 = 0.0, $95 = 0.0, $96 = 0.0, $97 = 0.0, $98 = 0.0, $99 = 0.0, $exitcond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $2 = sp + 16 | 0;
 $3 = sp;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $4 = HEAP32[tempDoublePtr >> 2] | 0;
 $5 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $6 = _bitshift64Lshr($4 | 0, $5 | 0, 63) | 0;
 $7 = getTempRet0() | 0;
 $8 = $5 & 2147483647;
 $9 = $8 >>> 0 < 1074752123;
 do {
  if ($9) {
   $10 = $5 & 1048575;
   $11 = ($10 | 0) == 598523;
   if ($11) {
    label = 21;
   } else {
    $12 = $8 >>> 0 < 1073928573;
    $13 = ($6 | 0) != 0;
    if ($12) {
     if ($13) {
      $19 = $0 + 1.5707963267341256;
      $20 = $19 + 6.077100506506192e-11;
      HEAPF64[$1 >> 3] = $20;
      $21 = $19 - $20;
      $22 = $21 + 6.077100506506192e-11;
      $23 = $1 + 8 | 0;
      HEAPF64[$23 >> 3] = $22;
      $$0144 = -1;
      break;
     } else {
      $14 = $0 + -1.5707963267341256;
      $15 = $14 + -6.077100506506192e-11;
      HEAPF64[$1 >> 3] = $15;
      $16 = $14 - $15;
      $17 = $16 + -6.077100506506192e-11;
      $18 = $1 + 8 | 0;
      HEAPF64[$18 >> 3] = $17;
      $$0144 = 1;
      break;
     }
    } else {
     if ($13) {
      $29 = $0 + 3.1415926534682512;
      $30 = $29 + 1.2154201013012384e-10;
      HEAPF64[$1 >> 3] = $30;
      $31 = $29 - $30;
      $32 = $31 + 1.2154201013012384e-10;
      $33 = $1 + 8 | 0;
      HEAPF64[$33 >> 3] = $32;
      $$0144 = -2;
      break;
     } else {
      $24 = $0 + -3.1415926534682512;
      $25 = $24 + -1.2154201013012384e-10;
      HEAPF64[$1 >> 3] = $25;
      $26 = $24 - $25;
      $27 = $26 + -1.2154201013012384e-10;
      $28 = $1 + 8 | 0;
      HEAPF64[$28 >> 3] = $27;
      $$0144 = 2;
      break;
     }
    }
   }
  } else {
   $34 = $8 >>> 0 < 1075594812;
   if ($34) {
    $35 = $8 >>> 0 < 1075183037;
    if ($35) {
     $36 = ($8 | 0) == 1074977148;
     if ($36) {
      label = 21;
      break;
     }
     $37 = ($6 | 0) == 0;
     if ($37) {
      $38 = $0 + -4.712388980202377;
      $39 = $38 + -1.8231301519518578e-10;
      HEAPF64[$1 >> 3] = $39;
      $40 = $38 - $39;
      $41 = $40 + -1.8231301519518578e-10;
      $42 = $1 + 8 | 0;
      HEAPF64[$42 >> 3] = $41;
      $$0144 = 3;
      break;
     } else {
      $43 = $0 + 4.712388980202377;
      $44 = $43 + 1.8231301519518578e-10;
      HEAPF64[$1 >> 3] = $44;
      $45 = $43 - $44;
      $46 = $45 + 1.8231301519518578e-10;
      $47 = $1 + 8 | 0;
      HEAPF64[$47 >> 3] = $46;
      $$0144 = -3;
      break;
     }
    } else {
     $48 = ($8 | 0) == 1075388923;
     if ($48) {
      label = 21;
      break;
     }
     $49 = ($6 | 0) == 0;
     if ($49) {
      $50 = $0 + -6.2831853069365025;
      $51 = $50 + -2.430840202602477e-10;
      HEAPF64[$1 >> 3] = $51;
      $52 = $50 - $51;
      $53 = $52 + -2.430840202602477e-10;
      $54 = $1 + 8 | 0;
      HEAPF64[$54 >> 3] = $53;
      $$0144 = 4;
      break;
     } else {
      $55 = $0 + 6.2831853069365025;
      $56 = $55 + 2.430840202602477e-10;
      HEAPF64[$1 >> 3] = $56;
      $57 = $55 - $56;
      $58 = $57 + 2.430840202602477e-10;
      $59 = $1 + 8 | 0;
      HEAPF64[$59 >> 3] = $58;
      $$0144 = -4;
      break;
     }
    }
   }
   $60 = $8 >>> 0 < 1094263291;
   if ($60) {
    label = 21;
   } else {
    $102 = $8 >>> 0 > 2146435071;
    if ($102) {
     $103 = $0 - $0;
     $104 = $1 + 8 | 0;
     HEAPF64[$104 >> 3] = $103;
     HEAPF64[$1 >> 3] = $103;
     $$0144 = 0;
     break;
    }
    $105 = $5 & 1048575;
    $106 = $105 | 1096810496;
    HEAP32[tempDoublePtr >> 2] = $4;
    HEAP32[tempDoublePtr + 4 >> 2] = $106;
    $107 = +HEAPF64[tempDoublePtr >> 3];
    $$0145148 = $107;
    $$0149 = 0;
    while (1) {
     $108 = ~~$$0145148;
     $109 = +($108 | 0);
     $110 = $2 + ($$0149 << 3) | 0;
     HEAPF64[$110 >> 3] = $109;
     $111 = $$0145148 - $109;
     $112 = $111 * 16777216.0;
     $113 = $$0149 + 1 | 0;
     $exitcond = ($113 | 0) == 2;
     if ($exitcond) {
      break;
     } else {
      $$0145148 = $112;
      $$0149 = $113;
     }
    }
    $114 = $2 + 16 | 0;
    HEAPF64[$114 >> 3] = $112;
    $115 = $112 == 0.0;
    if ($115) {
     $116 = 1;
     while (1) {
      $$phi$trans$insert = $2 + ($116 << 3) | 0;
      $$pre = +HEAPF64[$$phi$trans$insert >> 3];
      $117 = $$pre == 0.0;
      $118 = $116 + -1 | 0;
      if ($117) {
       $116 = $118;
      } else {
       $$1$lcssa = $116;
       break;
      }
     }
    } else {
     $$1$lcssa = 2;
    }
    $119 = $8 >>> 20;
    $120 = $119 + -1046 | 0;
    $121 = $$1$lcssa + 1 | 0;
    $122 = ___rem_pio2_large($2, $3, $120, $121, 1) | 0;
    $123 = ($6 | 0) == 0;
    $124 = +HEAPF64[$3 >> 3];
    if ($123) {
     HEAPF64[$1 >> 3] = $124;
     $131 = $3 + 8 | 0;
     $132 = +HEAPF64[$131 >> 3];
     $133 = $1 + 8 | 0;
     HEAPF64[$133 >> 3] = $132;
     $$0144 = $122;
     break;
    } else {
     $125 = -$124;
     HEAPF64[$1 >> 3] = $125;
     $126 = $3 + 8 | 0;
     $127 = +HEAPF64[$126 >> 3];
     $128 = -$127;
     $129 = $1 + 8 | 0;
     HEAPF64[$129 >> 3] = $128;
     $130 = 0 - $122 | 0;
     $$0144 = $130;
     break;
    }
   }
  }
 } while (0);
 if ((label | 0) == 21) {
  $61 = $0 * .6366197723675814;
  $62 = $61 + 6755399441055744.0;
  $63 = $62 + -6755399441055744.0;
  $64 = ~~$63;
  $65 = $63 * 1.5707963267341256;
  $66 = $0 - $65;
  $67 = $63 * 6.077100506506192e-11;
  $68 = $66 - $67;
  HEAPF64[$1 >> 3] = $68;
  HEAPF64[tempDoublePtr >> 3] = $68;
  $69 = HEAP32[tempDoublePtr >> 2] | 0;
  $70 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  $71 = _bitshift64Lshr($69 | 0, $70 | 0, 52) | 0;
  $72 = getTempRet0() | 0;
  $73 = $71 & 2047;
  $74 = $8 >>> 20;
  $75 = $74 - $73 | 0;
  $76 = ($75 | 0) > 16;
  if ($76) {
   $77 = $63 * 6.077100506303966e-11;
   $78 = $66 - $77;
   $79 = $63 * 2.0222662487959506e-21;
   $80 = $66 - $78;
   $81 = $80 - $77;
   $82 = $79 - $81;
   $83 = $78 - $82;
   HEAPF64[$1 >> 3] = $83;
   HEAPF64[tempDoublePtr >> 3] = $83;
   $84 = HEAP32[tempDoublePtr >> 2] | 0;
   $85 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
   $86 = _bitshift64Lshr($84 | 0, $85 | 0, 52) | 0;
   $87 = getTempRet0() | 0;
   $88 = $86 & 2047;
   $89 = $74 - $88 | 0;
   $90 = ($89 | 0) > 49;
   $91 = $63 * 2.0222662487111665e-21;
   $92 = $78 - $91;
   $93 = $63 * 8.4784276603689e-32;
   $94 = $78 - $92;
   $95 = $94 - $91;
   $96 = $93 - $95;
   if ($90) {
    $97 = $92 - $96;
    HEAPF64[$1 >> 3] = $97;
    $$0146 = $96;
    $$0147 = $92;
    $99 = $97;
   } else {
    $$0146 = $82;
    $$0147 = $78;
    $99 = $83;
   }
  } else {
   $$0146 = $67;
   $$0147 = $66;
   $99 = $68;
  }
  $98 = $$0147 - $99;
  $100 = $98 - $$0146;
  $101 = $1 + 8 | 0;
  HEAPF64[$101 >> 3] = $100;
  $$0144 = $64;
 }
 STACKTOP = sp;
 return $$0144 | 0;
}

function _try_realloc_chunk($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$1245 = 0, $$1245$be = 0, $$1245$ph = 0, $$1248 = 0, $$1248$be = 0, $$1248$ph = 0, $$2 = 0, $$3 = 0, $$sink = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $cond = 0, $storemerge = 0, $storemerge1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = $0 + 4 | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 $4 = $3 & -8;
 $5 = $0 + $4 | 0;
 $6 = $3 & 3;
 $7 = ($6 | 0) == 0;
 if ($7) {
  $8 = $1 >>> 0 < 256;
  if ($8) {
   $$2 = 0;
   return $$2 | 0;
  }
  $9 = $1 + 4 | 0;
  $10 = $4 >>> 0 < $9 >>> 0;
  if (!$10) {
   $11 = $4 - $1 | 0;
   $12 = HEAP32[41520 >> 2] | 0;
   $13 = $12 << 1;
   $14 = $11 >>> 0 > $13 >>> 0;
   if (!$14) {
    $$2 = $0;
    return $$2 | 0;
   }
  }
  $$2 = 0;
  return $$2 | 0;
 }
 $15 = $4 >>> 0 < $1 >>> 0;
 if (!$15) {
  $16 = $4 - $1 | 0;
  $17 = $16 >>> 0 > 15;
  if (!$17) {
   $$2 = $0;
   return $$2 | 0;
  }
  $18 = $0 + $1 | 0;
  $19 = $3 & 1;
  $20 = $19 | $1;
  $21 = $20 | 2;
  HEAP32[$2 >> 2] = $21;
  $22 = $18 + 4 | 0;
  $23 = $16 | 3;
  HEAP32[$22 >> 2] = $23;
  $24 = $5 + 4 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = $25 | 1;
  HEAP32[$24 >> 2] = $26;
  _dispose_chunk($18, $16);
  $$2 = $0;
  return $$2 | 0;
 }
 $27 = HEAP32[41064 >> 2] | 0;
 $28 = ($27 | 0) == ($5 | 0);
 if ($28) {
  $29 = HEAP32[41052 >> 2] | 0;
  $30 = $29 + $4 | 0;
  $31 = $30 >>> 0 > $1 >>> 0;
  $32 = $30 - $1 | 0;
  $33 = $0 + $1 | 0;
  if (!$31) {
   $$2 = 0;
   return $$2 | 0;
  }
  $34 = $32 | 1;
  $35 = $33 + 4 | 0;
  $36 = $3 & 1;
  $37 = $36 | $1;
  $38 = $37 | 2;
  HEAP32[$2 >> 2] = $38;
  HEAP32[$35 >> 2] = $34;
  HEAP32[41064 >> 2] = $33;
  HEAP32[41052 >> 2] = $32;
  $$2 = $0;
  return $$2 | 0;
 }
 $39 = HEAP32[41060 >> 2] | 0;
 $40 = ($39 | 0) == ($5 | 0);
 if ($40) {
  $41 = HEAP32[41048 >> 2] | 0;
  $42 = $41 + $4 | 0;
  $43 = $42 >>> 0 < $1 >>> 0;
  if ($43) {
   $$2 = 0;
   return $$2 | 0;
  }
  $44 = $42 - $1 | 0;
  $45 = $44 >>> 0 > 15;
  if ($45) {
   $46 = $0 + $1 | 0;
   $47 = $0 + $42 | 0;
   $48 = $3 & 1;
   $49 = $48 | $1;
   $50 = $49 | 2;
   HEAP32[$2 >> 2] = $50;
   $51 = $46 + 4 | 0;
   $52 = $44 | 1;
   HEAP32[$51 >> 2] = $52;
   HEAP32[$47 >> 2] = $44;
   $53 = $47 + 4 | 0;
   $54 = HEAP32[$53 >> 2] | 0;
   $55 = $54 & -2;
   HEAP32[$53 >> 2] = $55;
   $storemerge = $46;
   $storemerge1 = $44;
  } else {
   $56 = $3 & 1;
   $57 = $56 | $42;
   $58 = $57 | 2;
   HEAP32[$2 >> 2] = $58;
   $59 = $0 + $42 | 0;
   $60 = $59 + 4 | 0;
   $61 = HEAP32[$60 >> 2] | 0;
   $62 = $61 | 1;
   HEAP32[$60 >> 2] = $62;
   $storemerge = 0;
   $storemerge1 = 0;
  }
  HEAP32[41048 >> 2] = $storemerge1;
  HEAP32[41060 >> 2] = $storemerge;
  $$2 = $0;
  return $$2 | 0;
 }
 $63 = $5 + 4 | 0;
 $64 = HEAP32[$63 >> 2] | 0;
 $65 = $64 & 2;
 $66 = ($65 | 0) == 0;
 if (!$66) {
  $$2 = 0;
  return $$2 | 0;
 }
 $67 = $64 & -8;
 $68 = $67 + $4 | 0;
 $69 = $68 >>> 0 < $1 >>> 0;
 if ($69) {
  $$2 = 0;
  return $$2 | 0;
 }
 $70 = $68 - $1 | 0;
 $71 = $64 >>> 3;
 $72 = $64 >>> 0 < 256;
 do {
  if ($72) {
   $73 = $5 + 8 | 0;
   $74 = HEAP32[$73 >> 2] | 0;
   $75 = $5 + 12 | 0;
   $76 = HEAP32[$75 >> 2] | 0;
   $77 = ($76 | 0) == ($74 | 0);
   if ($77) {
    $78 = 1 << $71;
    $79 = $78 ^ -1;
    $80 = HEAP32[10260] | 0;
    $81 = $80 & $79;
    HEAP32[10260] = $81;
    break;
   } else {
    $82 = $74 + 12 | 0;
    HEAP32[$82 >> 2] = $76;
    $83 = $76 + 8 | 0;
    HEAP32[$83 >> 2] = $74;
    break;
   }
  } else {
   $84 = $5 + 24 | 0;
   $85 = HEAP32[$84 >> 2] | 0;
   $86 = $5 + 12 | 0;
   $87 = HEAP32[$86 >> 2] | 0;
   $88 = ($87 | 0) == ($5 | 0);
   do {
    if ($88) {
     $93 = $5 + 16 | 0;
     $94 = $93 + 4 | 0;
     $95 = HEAP32[$94 >> 2] | 0;
     $96 = ($95 | 0) == (0 | 0);
     if ($96) {
      $97 = HEAP32[$93 >> 2] | 0;
      $98 = ($97 | 0) == (0 | 0);
      if ($98) {
       $$3 = 0;
       break;
      } else {
       $$1245$ph = $97;
       $$1248$ph = $93;
      }
     } else {
      $$1245$ph = $95;
      $$1248$ph = $94;
     }
     $$1245 = $$1245$ph;
     $$1248 = $$1248$ph;
     while (1) {
      $99 = $$1245 + 20 | 0;
      $100 = HEAP32[$99 >> 2] | 0;
      $101 = ($100 | 0) == (0 | 0);
      if ($101) {
       $102 = $$1245 + 16 | 0;
       $103 = HEAP32[$102 >> 2] | 0;
       $104 = ($103 | 0) == (0 | 0);
       if ($104) {
        break;
       } else {
        $$1245$be = $103;
        $$1248$be = $102;
       }
      } else {
       $$1245$be = $100;
       $$1248$be = $99;
      }
      $$1245 = $$1245$be;
      $$1248 = $$1248$be;
     }
     HEAP32[$$1248 >> 2] = 0;
     $$3 = $$1245;
    } else {
     $89 = $5 + 8 | 0;
     $90 = HEAP32[$89 >> 2] | 0;
     $91 = $90 + 12 | 0;
     HEAP32[$91 >> 2] = $87;
     $92 = $87 + 8 | 0;
     HEAP32[$92 >> 2] = $90;
     $$3 = $87;
    }
   } while (0);
   $105 = ($85 | 0) == (0 | 0);
   if (!$105) {
    $106 = $5 + 28 | 0;
    $107 = HEAP32[$106 >> 2] | 0;
    $108 = 41344 + ($107 << 2) | 0;
    $109 = HEAP32[$108 >> 2] | 0;
    $110 = ($109 | 0) == ($5 | 0);
    if ($110) {
     HEAP32[$108 >> 2] = $$3;
     $cond = ($$3 | 0) == (0 | 0);
     if ($cond) {
      $111 = 1 << $107;
      $112 = $111 ^ -1;
      $113 = HEAP32[41044 >> 2] | 0;
      $114 = $113 & $112;
      HEAP32[41044 >> 2] = $114;
      break;
     }
    } else {
     $115 = $85 + 16 | 0;
     $116 = HEAP32[$115 >> 2] | 0;
     $117 = ($116 | 0) == ($5 | 0);
     $118 = $85 + 20 | 0;
     $$sink = $117 ? $115 : $118;
     HEAP32[$$sink >> 2] = $$3;
     $119 = ($$3 | 0) == (0 | 0);
     if ($119) {
      break;
     }
    }
    $120 = $$3 + 24 | 0;
    HEAP32[$120 >> 2] = $85;
    $121 = $5 + 16 | 0;
    $122 = HEAP32[$121 >> 2] | 0;
    $123 = ($122 | 0) == (0 | 0);
    if (!$123) {
     $124 = $$3 + 16 | 0;
     HEAP32[$124 >> 2] = $122;
     $125 = $122 + 24 | 0;
     HEAP32[$125 >> 2] = $$3;
    }
    $126 = $121 + 4 | 0;
    $127 = HEAP32[$126 >> 2] | 0;
    $128 = ($127 | 0) == (0 | 0);
    if (!$128) {
     $129 = $$3 + 20 | 0;
     HEAP32[$129 >> 2] = $127;
     $130 = $127 + 24 | 0;
     HEAP32[$130 >> 2] = $$3;
    }
   }
  }
 } while (0);
 $131 = $70 >>> 0 < 16;
 if ($131) {
  $132 = $3 & 1;
  $133 = $132 | $68;
  $134 = $133 | 2;
  HEAP32[$2 >> 2] = $134;
  $135 = $0 + $68 | 0;
  $136 = $135 + 4 | 0;
  $137 = HEAP32[$136 >> 2] | 0;
  $138 = $137 | 1;
  HEAP32[$136 >> 2] = $138;
  $$2 = $0;
  return $$2 | 0;
 } else {
  $139 = $0 + $1 | 0;
  $140 = $3 & 1;
  $141 = $140 | $1;
  $142 = $141 | 2;
  HEAP32[$2 >> 2] = $142;
  $143 = $139 + 4 | 0;
  $144 = $70 | 3;
  HEAP32[$143 >> 2] = $144;
  $145 = $0 + $68 | 0;
  $146 = $145 + 4 | 0;
  $147 = HEAP32[$146 >> 2] | 0;
  $148 = $147 | 1;
  HEAP32[$146 >> 2] = $148;
  _dispose_chunk($139, $70);
  $$2 = $0;
  return $$2 | 0;
 }
 return 0 | 0;
}

function _tinf_inflate_block_data($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $10 = $4;
 $11 = $10 + 48 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = ($12 | 0) == 0;
 do {
  if ($13) {
   $14 = $4;
   $15 = $5;
   $16 = _tinf_decode_symbol($14, $15) | 0;
   $9 = $16;
   $17 = $4;
   $18 = $17 + 37 | 0;
   $19 = HEAP8[$18 >> 0] | 0;
   $20 = $19 & 1;
   if ($20) {
    $3 = -3;
    $197 = $3;
    STACKTOP = sp;
    return $197 | 0;
   }
   $21 = $9;
   $22 = ($21 | 0) < 256;
   $23 = $9;
   if ($22) {
    $24 = $23 & 255;
    $25 = $4;
    $26 = $25 + 24 | 0;
    $27 = HEAP32[$26 >> 2] | 0;
    $28 = $27 + 1 | 0;
    HEAP32[$26 >> 2] = $28;
    HEAP8[$27 >> 0] = $24;
    $29 = $4;
    $30 = $29 + 56 | 0;
    $31 = HEAP32[$30 >> 2] | 0;
    $32 = ($31 | 0) != (0 | 0);
    if ($32) {
     $33 = $9;
     $34 = $33 & 255;
     $35 = $4;
     $36 = $35 + 56 | 0;
     $37 = HEAP32[$36 >> 2] | 0;
     $38 = $4;
     $39 = $38 + 64 | 0;
     $40 = HEAP32[$39 >> 2] | 0;
     $41 = $40 + 1 | 0;
     HEAP32[$39 >> 2] = $41;
     $42 = $37 + $40 | 0;
     HEAP8[$42 >> 0] = $34;
     $43 = $4;
     $44 = $43 + 64 | 0;
     $45 = HEAP32[$44 >> 2] | 0;
     $46 = $4;
     $47 = $46 + 60 | 0;
     $48 = HEAP32[$47 >> 2] | 0;
     $49 = ($45 | 0) == ($48 | 0);
     if ($49) {
      $50 = $4;
      $51 = $50 + 64 | 0;
      HEAP32[$51 >> 2] = 0;
     }
    }
    $3 = 0;
    $197 = $3;
    STACKTOP = sp;
    return $197 | 0;
   }
   $52 = ($23 | 0) == 256;
   if ($52) {
    $3 = 1;
    $197 = $3;
    STACKTOP = sp;
    return $197 | 0;
   }
   $53 = $9;
   $54 = $53 - 257 | 0;
   $9 = $54;
   $55 = $9;
   $56 = ($55 | 0) >= 29;
   if ($56) {
    $3 = -3;
    $197 = $3;
    STACKTOP = sp;
    return $197 | 0;
   }
   $57 = $4;
   $58 = $9;
   $59 = 7664 + $58 | 0;
   $60 = HEAP8[$59 >> 0] | 0;
   $61 = $60 & 255;
   $62 = $9;
   $63 = 7696 + ($62 << 1) | 0;
   $64 = HEAP16[$63 >> 1] | 0;
   $65 = $64 & 65535;
   $66 = _tinf_read_bits($57, $61, $65) | 0;
   $67 = $4;
   $68 = $67 + 48 | 0;
   HEAP32[$68 >> 2] = $66;
   $69 = $4;
   $70 = $6;
   $71 = _tinf_decode_symbol($69, $70) | 0;
   $8 = $71;
   $72 = $8;
   $73 = ($72 | 0) >= 30;
   if ($73) {
    $3 = -3;
    $197 = $3;
    STACKTOP = sp;
    return $197 | 0;
   }
   $74 = $4;
   $75 = $8;
   $76 = 7760 + $75 | 0;
   $77 = HEAP8[$76 >> 0] | 0;
   $78 = $77 & 255;
   $79 = $8;
   $80 = 7792 + ($79 << 1) | 0;
   $81 = HEAP16[$80 >> 1] | 0;
   $82 = $81 & 65535;
   $83 = _tinf_read_bits($74, $78, $82) | 0;
   $7 = $83;
   $84 = $4;
   $85 = $84 + 56 | 0;
   $86 = HEAP32[$85 >> 2] | 0;
   $87 = ($86 | 0) != (0 | 0);
   $88 = $7;
   $89 = $4;
   if (!$87) {
    $111 = $89 + 24 | 0;
    $112 = HEAP32[$111 >> 2] | 0;
    $113 = $4;
    $114 = $113 + 20 | 0;
    $115 = HEAP32[$114 >> 2] | 0;
    $116 = $112;
    $117 = $115;
    $118 = $116 - $117 | 0;
    $119 = $88 >>> 0 > $118 >>> 0;
    if (!$119) {
     $120 = $7;
     $121 = 0 - $120 | 0;
     $122 = $4;
     $123 = $122 + 52 | 0;
     HEAP32[$123 >> 2] = $121;
     break;
    }
    $3 = -3;
    $197 = $3;
    STACKTOP = sp;
    return $197 | 0;
   }
   $90 = $89 + 60 | 0;
   $91 = HEAP32[$90 >> 2] | 0;
   $92 = $88 >>> 0 > $91 >>> 0;
   if ($92) {
    $3 = -5;
    $197 = $3;
    STACKTOP = sp;
    return $197 | 0;
   } else {
    $93 = $4;
    $94 = $93 + 64 | 0;
    $95 = HEAP32[$94 >> 2] | 0;
    $96 = $7;
    $97 = $95 - $96 | 0;
    $98 = $4;
    $99 = $98 + 52 | 0;
    HEAP32[$99 >> 2] = $97;
    $100 = $4;
    $101 = $100 + 52 | 0;
    $102 = HEAP32[$101 >> 2] | 0;
    $103 = ($102 | 0) < 0;
    if (!$103) {
     break;
    }
    $104 = $4;
    $105 = $104 + 60 | 0;
    $106 = HEAP32[$105 >> 2] | 0;
    $107 = $4;
    $108 = $107 + 52 | 0;
    $109 = HEAP32[$108 >> 2] | 0;
    $110 = $109 + $106 | 0;
    HEAP32[$108 >> 2] = $110;
    break;
   }
  }
 } while (0);
 $124 = $4;
 $125 = $124 + 56 | 0;
 $126 = HEAP32[$125 >> 2] | 0;
 $127 = ($126 | 0) != (0 | 0);
 $128 = $4;
 if ($127) {
  $129 = $128 + 56 | 0;
  $130 = HEAP32[$129 >> 2] | 0;
  $131 = $4;
  $132 = $131 + 52 | 0;
  $133 = HEAP32[$132 >> 2] | 0;
  $134 = $130 + $133 | 0;
  $135 = HEAP8[$134 >> 0] | 0;
  $136 = $4;
  $137 = $136 + 24 | 0;
  $138 = HEAP32[$137 >> 2] | 0;
  $139 = $138 + 1 | 0;
  HEAP32[$137 >> 2] = $139;
  HEAP8[$138 >> 0] = $135;
  $140 = $4;
  $141 = $140 + 56 | 0;
  $142 = HEAP32[$141 >> 2] | 0;
  $143 = ($142 | 0) != (0 | 0);
  if ($143) {
   $144 = $4;
   $145 = $144 + 56 | 0;
   $146 = HEAP32[$145 >> 2] | 0;
   $147 = $4;
   $148 = $147 + 52 | 0;
   $149 = HEAP32[$148 >> 2] | 0;
   $150 = $146 + $149 | 0;
   $151 = HEAP8[$150 >> 0] | 0;
   $152 = $4;
   $153 = $152 + 56 | 0;
   $154 = HEAP32[$153 >> 2] | 0;
   $155 = $4;
   $156 = $155 + 64 | 0;
   $157 = HEAP32[$156 >> 2] | 0;
   $158 = $157 + 1 | 0;
   HEAP32[$156 >> 2] = $158;
   $159 = $154 + $157 | 0;
   HEAP8[$159 >> 0] = $151;
   $160 = $4;
   $161 = $160 + 64 | 0;
   $162 = HEAP32[$161 >> 2] | 0;
   $163 = $4;
   $164 = $163 + 60 | 0;
   $165 = HEAP32[$164 >> 2] | 0;
   $166 = ($162 | 0) == ($165 | 0);
   if ($166) {
    $167 = $4;
    $168 = $167 + 64 | 0;
    HEAP32[$168 >> 2] = 0;
   }
  }
  $169 = $4;
  $170 = $169 + 52 | 0;
  $171 = HEAP32[$170 >> 2] | 0;
  $172 = $171 + 1 | 0;
  HEAP32[$170 >> 2] = $172;
  $173 = $4;
  $174 = $173 + 60 | 0;
  $175 = HEAP32[$174 >> 2] | 0;
  $176 = ($172 | 0) == ($175 | 0);
  if ($176) {
   $177 = $4;
   $178 = $177 + 52 | 0;
   HEAP32[$178 >> 2] = 0;
  }
 } else {
  $179 = $128 + 24 | 0;
  $180 = HEAP32[$179 >> 2] | 0;
  $181 = $4;
  $182 = $181 + 52 | 0;
  $183 = HEAP32[$182 >> 2] | 0;
  $184 = $180 + $183 | 0;
  $185 = HEAP8[$184 >> 0] | 0;
  $186 = $4;
  $187 = $186 + 24 | 0;
  $188 = HEAP32[$187 >> 2] | 0;
  HEAP8[$188 >> 0] = $185;
  $189 = $4;
  $190 = $189 + 24 | 0;
  $191 = HEAP32[$190 >> 2] | 0;
  $192 = $191 + 1 | 0;
  HEAP32[$190 >> 2] = $192;
 }
 $193 = $4;
 $194 = $193 + 48 | 0;
 $195 = HEAP32[$194 >> 2] | 0;
 $196 = $195 + -1 | 0;
 HEAP32[$194 >> 2] = $196;
 $3 = 0;
 $197 = $3;
 STACKTOP = sp;
 return $197 | 0;
}

function _c_del_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $2 = $0;
 $3 = $1;
 $12 = $3;
 $13 = $12 & 15;
 $14 = ($13 | 0) == 2;
 if ($14) {
  $15 = $2;
  $16 = $3;
  $17 = $16 >>> 4;
  _compile_delete_id($15, $17);
  STACKTOP = sp;
  return;
 }
 $18 = $3;
 $19 = ($18 | 0) != 0;
 if ($19) {
  $20 = $3;
  $21 = $20 & 3;
  $22 = ($21 | 0) == 0;
  if ($22) {
   $23 = $3;
   $24 = $23;
   $25 = $24 + 4 | 0;
   $26 = HEAP32[$25 >> 2] | 0;
   $27 = $26 & 255;
   $28 = ($27 | 0) == 43;
   if ($28) {
    $29 = $3;
    $30 = $29;
    $4 = $30;
    $31 = $2;
    $32 = $4;
    $33 = $32 + 8 | 0;
    $34 = HEAP32[$33 >> 2] | 0;
    _compile_node($31, $34);
    $35 = $4;
    $36 = $35 + 8 | 0;
    $37 = $36 + 4 | 0;
    $38 = HEAP32[$37 >> 2] | 0;
    $39 = ($38 | 0) != 0;
    if ($39) {
     $40 = $4;
     $41 = $40 + 8 | 0;
     $42 = $41 + 4 | 0;
     $43 = HEAP32[$42 >> 2] | 0;
     $44 = $43 & 3;
     $45 = ($44 | 0) == 0;
     if ($45) {
      $46 = $4;
      $47 = $46 + 8 | 0;
      $48 = $47 + 4 | 0;
      $49 = HEAP32[$48 >> 2] | 0;
      $50 = $49;
      $5 = $50;
      $51 = $5;
      $52 = $51 + 4 | 0;
      $53 = HEAP32[$52 >> 2] | 0;
      $54 = $53 & 255;
      $55 = ($54 | 0) == 140;
      if ($55) {
       $56 = $5;
       $57 = $56 + 4 | 0;
       $58 = HEAP32[$57 >> 2] | 0;
       $59 = $58 >>> 8;
       $6 = $59;
       $7 = 0;
       while (1) {
        $60 = $7;
        $61 = $6;
        $62 = $61 - 1 | 0;
        $63 = ($60 | 0) < ($62 | 0);
        if (!$63) {
         break;
        }
        $64 = $2;
        $65 = $5;
        $66 = $65 + 8 | 0;
        $67 = $7;
        $68 = $66 + ($67 << 2) | 0;
        $69 = HEAP32[$68 >> 2] | 0;
        _compile_node($64, $69);
        $70 = $7;
        $71 = $70 + 1 | 0;
        $7 = $71;
       }
       $72 = $5;
       $73 = $72 + 8 | 0;
       $74 = $6;
       $75 = $74 - 1 | 0;
       $76 = $73 + ($75 << 2) | 0;
       $77 = HEAP32[$76 >> 2] | 0;
       $78 = $77;
       $5 = $78;
      }
      $79 = $5;
      $80 = $79 + 4 | 0;
      $81 = HEAP32[$80 >> 2] | 0;
      $82 = $81 & 255;
      $83 = ($82 | 0) == 48;
      if ($83) {
       $84 = $2;
       $85 = $5;
       $86 = $85 + 8 | 0;
       $87 = HEAP32[$86 >> 2] | 0;
       _compile_node($84, $87);
       $88 = $2;
       $89 = $88 + 40 | 0;
       $90 = HEAP32[$89 >> 2] | 0;
       _mp_emit_bc_subscr($90, 2);
       STACKTOP = sp;
       return;
      }
      $91 = $5;
      $92 = $91 + 4 | 0;
      $93 = HEAP32[$92 >> 2] | 0;
      $94 = $93 & 255;
      $95 = ($94 | 0) == 49;
      if ($95) {
       $96 = $2;
       $97 = $96 + 40 | 0;
       $98 = HEAP32[$97 >> 2] | 0;
       $99 = $5;
       $100 = $99 + 8 | 0;
       $101 = HEAP32[$100 >> 2] | 0;
       $102 = $101 >>> 4;
       _mp_emit_bc_attr($98, $102, 2);
       STACKTOP = sp;
       return;
      }
     }
    }
   } else {
    label = 17;
   }
  } else {
   label = 17;
  }
 } else {
  label = 17;
 }
 L24 : do {
  if ((label | 0) == 17) {
   $103 = $3;
   $104 = ($103 | 0) != 0;
   if ($104) {
    $105 = $3;
    $106 = $105 & 3;
    $107 = ($106 | 0) == 0;
    if ($107) {
     $108 = $3;
     $109 = $108;
     $110 = $109 + 4 | 0;
     $111 = HEAP32[$110 >> 2] | 0;
     $112 = $111 & 255;
     $113 = ($112 | 0) == 44;
     if ($113) {
      $114 = $3;
      $115 = $114;
      $116 = $115 + 8 | 0;
      $117 = HEAP32[$116 >> 2] | 0;
      $3 = $117;
      $118 = $3;
      $119 = ($118 | 0) == 0;
      if (!$119) {
       $120 = $3;
       $121 = $120;
       $8 = $121;
       $122 = $8;
       $123 = $122 + 8 | 0;
       $124 = $123 + 4 | 0;
       $125 = HEAP32[$124 >> 2] | 0;
       $126 = ($125 | 0) != 0;
       do {
        if ($126) {
         $127 = $8;
         $128 = $127 + 8 | 0;
         $129 = $128 + 4 | 0;
         $130 = HEAP32[$129 >> 2] | 0;
         $131 = $130 & 3;
         $132 = ($131 | 0) == 0;
         if ($132) {
          $133 = $8;
          $134 = $133 + 8 | 0;
          $135 = $134 + 4 | 0;
          $136 = HEAP32[$135 >> 2] | 0;
          $137 = $136;
          $9 = $137;
          $138 = $9;
          $139 = $138 + 4 | 0;
          $140 = HEAP32[$139 >> 2] | 0;
          $141 = $140 & 255;
          $142 = ($141 | 0) == 147;
          if ($142) {
           $143 = $2;
           $144 = $8;
           $145 = $144 + 8 | 0;
           $146 = HEAP32[$145 >> 2] | 0;
           _c_del_stmt($143, $146);
           STACKTOP = sp;
           return;
          }
          $147 = $9;
          $148 = $147 + 4 | 0;
          $149 = HEAP32[$148 >> 2] | 0;
          $150 = $149 & 255;
          $151 = ($150 | 0) == 148;
          $152 = $9;
          $153 = $152 + 4 | 0;
          $154 = HEAP32[$153 >> 2] | 0;
          if (!$151) {
           $171 = $154 & 255;
           $172 = ($171 | 0) == 171;
           if ($172) {
            break L24;
           } else {
            break;
           }
          }
          $155 = $154 >>> 8;
          $10 = $155;
          $156 = $2;
          $157 = $8;
          $158 = $157 + 8 | 0;
          $159 = HEAP32[$158 >> 2] | 0;
          _c_del_stmt($156, $159);
          $11 = 0;
          while (1) {
           $160 = $11;
           $161 = $10;
           $162 = ($160 | 0) < ($161 | 0);
           if (!$162) {
            break;
           }
           $163 = $2;
           $164 = $9;
           $165 = $164 + 8 | 0;
           $166 = $11;
           $167 = $165 + ($166 << 2) | 0;
           $168 = HEAP32[$167 >> 2] | 0;
           _c_del_stmt($163, $168);
           $169 = $11;
           $170 = $169 + 1 | 0;
           $11 = $170;
          }
          STACKTOP = sp;
          return;
         }
        }
       } while (0);
       $173 = $2;
       $174 = $8;
       $175 = $174 + 8 | 0;
       $176 = HEAP32[$175 >> 2] | 0;
       _c_del_stmt($173, $176);
       $177 = $2;
       $178 = $8;
       $179 = $178 + 8 | 0;
       $180 = $179 + 4 | 0;
       $181 = HEAP32[$180 >> 2] | 0;
       _c_del_stmt($177, $181);
       STACKTOP = sp;
       return;
      }
     }
    }
   }
  }
 } while (0);
 $182 = $2;
 $183 = $3;
 _compile_syntax_error($182, $183, 29405);
 STACKTOP = sp;
 return;
}
function _compile_async_with_stmt_helper($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $13 = $5;
 $14 = ($13 | 0) == 0;
 $15 = $4;
 if ($14) {
  $16 = $7;
  _compile_node($15, $16);
  STACKTOP = sp;
  return;
 }
 $17 = _comp_next_label($15) | 0;
 $8 = $17;
 $18 = $4;
 $19 = _comp_next_label($18) | 0;
 $9 = $19;
 $20 = $4;
 $21 = _comp_next_label($20) | 0;
 $10 = $21;
 $22 = $4;
 $23 = _comp_next_label($22) | 0;
 $11 = $23;
 $24 = $6;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = ($25 | 0) != 0;
 if ($26) {
  $27 = $6;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = $28 & 3;
  $30 = ($29 | 0) == 0;
  if ($30) {
   $31 = $6;
   $32 = HEAP32[$31 >> 2] | 0;
   $33 = $32;
   $34 = $33 + 4 | 0;
   $35 = HEAP32[$34 >> 2] | 0;
   $36 = $35 & 255;
   $37 = ($36 | 0) == 122;
   if ($37) {
    $38 = $6;
    $39 = HEAP32[$38 >> 2] | 0;
    $40 = $39;
    $12 = $40;
    $41 = $4;
    $42 = $12;
    $43 = $42 + 8 | 0;
    $44 = HEAP32[$43 >> 2] | 0;
    _compile_node($41, $44);
    $45 = $4;
    $46 = $45 + 40 | 0;
    $47 = HEAP32[$46 >> 2] | 0;
    _mp_emit_bc_dup_top($47);
    $48 = $4;
    _compile_await_object_method($48, 168);
    $49 = $4;
    $50 = $12;
    $51 = $50 + 8 | 0;
    $52 = $51 + 4 | 0;
    $53 = HEAP32[$52 >> 2] | 0;
    _c_assign($49, $53, 0);
   } else {
    label = 7;
   }
  } else {
   label = 7;
  }
 } else {
  label = 7;
 }
 if ((label | 0) == 7) {
  $54 = $4;
  $55 = $6;
  $56 = HEAP32[$55 >> 2] | 0;
  _compile_node($54, $56);
  $57 = $4;
  $58 = $57 + 40 | 0;
  $59 = HEAP32[$58 >> 2] | 0;
  _mp_emit_bc_dup_top($59);
  $60 = $4;
  _compile_await_object_method($60, 168);
  $61 = $4;
  $62 = $61 + 40 | 0;
  $63 = HEAP32[$62 >> 2] | 0;
  _mp_emit_bc_pop_top($63);
 }
 $64 = $4;
 $65 = $8;
 _compile_increase_except_level($64, $65, 3);
 $66 = $4;
 $67 = $66 + 40 | 0;
 $68 = HEAP32[$67 >> 2] | 0;
 _mp_emit_bc_adjust_stack_size($68, 3);
 $69 = $4;
 $70 = $5;
 $71 = $70 - 1 | 0;
 $72 = $6;
 $73 = $72 + 4 | 0;
 $74 = $7;
 _compile_async_with_stmt_helper($69, $71, $73, $74);
 $75 = $4;
 $76 = $75 + 40 | 0;
 $77 = HEAP32[$76 >> 2] | 0;
 _mp_emit_bc_adjust_stack_size($77, -3);
 $78 = $4;
 $79 = $78 + 40 | 0;
 $80 = HEAP32[$79 >> 2] | 0;
 _mp_emit_bc_load_const_tok($80, 14);
 $81 = $4;
 $82 = $81 + 40 | 0;
 $83 = HEAP32[$82 >> 2] | 0;
 _mp_emit_bc_rot_two($83);
 $84 = $4;
 $85 = $84 + 40 | 0;
 $86 = HEAP32[$85 >> 2] | 0;
 $87 = $9;
 _mp_emit_bc_jump($86, $87);
 $88 = $4;
 $89 = $88 + 40 | 0;
 $90 = HEAP32[$89 >> 2] | 0;
 $91 = $8;
 _mp_emit_bc_label_assign($90, $91);
 $92 = $4;
 $93 = $92 + 40 | 0;
 $94 = HEAP32[$93 >> 2] | 0;
 _mp_emit_bc_dup_top($94);
 $95 = $4;
 $96 = $95 + 40 | 0;
 $97 = HEAP32[$96 >> 2] | 0;
 _mp_emit_bc_load_global($97, 33, 1);
 $98 = $4;
 $99 = $98 + 40 | 0;
 $100 = HEAP32[$99 >> 2] | 0;
 _mp_emit_bc_binary_op($100, 8);
 $101 = $4;
 $102 = $101 + 40 | 0;
 $103 = HEAP32[$102 >> 2] | 0;
 $104 = $10;
 _mp_emit_bc_pop_jump_if($103, 0, $104);
 $105 = $4;
 $106 = $105 + 40 | 0;
 $107 = HEAP32[$106 >> 2] | 0;
 _mp_emit_bc_dup_top($107);
 $108 = $4;
 $109 = $108 + 40 | 0;
 $110 = HEAP32[$109 >> 2] | 0;
 _mp_emit_bc_rot_three($110);
 $111 = $4;
 $112 = $111 + 40 | 0;
 $113 = HEAP32[$112 >> 2] | 0;
 _mp_emit_bc_rot_two($113);
 $114 = $4;
 $115 = $114 + 40 | 0;
 $116 = HEAP32[$115 >> 2] | 0;
 _mp_emit_bc_load_method($116, 169, 0);
 $117 = $4;
 $118 = $117 + 40 | 0;
 $119 = HEAP32[$118 >> 2] | 0;
 _mp_emit_bc_rot_three($119);
 $120 = $4;
 $121 = $120 + 40 | 0;
 $122 = HEAP32[$121 >> 2] | 0;
 _mp_emit_bc_rot_three($122);
 $123 = $4;
 $124 = $123 + 40 | 0;
 $125 = HEAP32[$124 >> 2] | 0;
 _mp_emit_bc_dup_top($125);
 $126 = $4;
 $127 = $126 + 40 | 0;
 $128 = HEAP32[$127 >> 2] | 0;
 _mp_emit_bc_attr($128, 10, 0);
 $129 = $4;
 $130 = $129 + 40 | 0;
 $131 = HEAP32[$130 >> 2] | 0;
 _mp_emit_bc_rot_two($131);
 $132 = $4;
 $133 = $132 + 40 | 0;
 $134 = HEAP32[$133 >> 2] | 0;
 _mp_emit_bc_load_const_tok($134, 14);
 $135 = $4;
 $136 = $135 + 40 | 0;
 $137 = HEAP32[$136 >> 2] | 0;
 _mp_emit_bc_call_method($137, 3, 0, 0);
 $138 = $4;
 _compile_yield_from($138);
 $139 = $4;
 $140 = $139 + 40 | 0;
 $141 = HEAP32[$140 >> 2] | 0;
 $142 = $11;
 _mp_emit_bc_pop_jump_if($141, 0, $142);
 $143 = $4;
 $144 = $143 + 40 | 0;
 $145 = HEAP32[$144 >> 2] | 0;
 _mp_emit_bc_pop_top($145);
 $146 = $4;
 $147 = $146 + 40 | 0;
 $148 = HEAP32[$147 >> 2] | 0;
 _mp_emit_bc_load_const_tok($148, 14);
 $149 = $4;
 $150 = $149 + 40 | 0;
 $151 = HEAP32[$150 >> 2] | 0;
 $152 = $11;
 _mp_emit_bc_jump($151, $152);
 $153 = $4;
 $154 = $153 + 40 | 0;
 $155 = HEAP32[$154 >> 2] | 0;
 _mp_emit_bc_adjust_stack_size($155, 2);
 $156 = $4;
 $157 = $156 + 40 | 0;
 $158 = HEAP32[$157 >> 2] | 0;
 $159 = $10;
 _mp_emit_bc_label_assign($158, $159);
 $160 = $4;
 $161 = $160 + 40 | 0;
 $162 = HEAP32[$161 >> 2] | 0;
 _mp_emit_bc_rot_three($162);
 $163 = $4;
 $164 = $163 + 40 | 0;
 $165 = HEAP32[$164 >> 2] | 0;
 _mp_emit_bc_rot_three($165);
 $166 = $4;
 $167 = $166 + 40 | 0;
 $168 = HEAP32[$167 >> 2] | 0;
 $169 = $9;
 _mp_emit_bc_label_assign($168, $169);
 $170 = $4;
 $171 = $170 + 40 | 0;
 $172 = HEAP32[$171 >> 2] | 0;
 _mp_emit_bc_load_method($172, 169, 0);
 $173 = $4;
 $174 = $173 + 40 | 0;
 $175 = HEAP32[$174 >> 2] | 0;
 _mp_emit_bc_load_const_tok($175, 14);
 $176 = $4;
 $177 = $176 + 40 | 0;
 $178 = HEAP32[$177 >> 2] | 0;
 _mp_emit_bc_dup_top($178);
 $179 = $4;
 $180 = $179 + 40 | 0;
 $181 = HEAP32[$180 >> 2] | 0;
 _mp_emit_bc_dup_top($181);
 $182 = $4;
 $183 = $182 + 40 | 0;
 $184 = HEAP32[$183 >> 2] | 0;
 _mp_emit_bc_call_method($184, 3, 0, 0);
 $185 = $4;
 _compile_yield_from($185);
 $186 = $4;
 $187 = $186 + 40 | 0;
 $188 = HEAP32[$187 >> 2] | 0;
 _mp_emit_bc_pop_top($188);
 $189 = $4;
 $190 = $189 + 40 | 0;
 $191 = HEAP32[$190 >> 2] | 0;
 _mp_emit_bc_adjust_stack_size($191, -1);
 $192 = $4;
 $193 = $192 + 40 | 0;
 $194 = HEAP32[$193 >> 2] | 0;
 $195 = $11;
 _mp_emit_bc_label_assign($194, $195);
 $196 = $4;
 _compile_decrease_except_level($196);
 STACKTOP = sp;
 return;
}

function _mp_iternext($0) {
 $0 = $0 | 0;
 var $$0 = 0, $$reg2mem43$0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, $cond46 = 0, $cond47 = 0, $cond48 = 0, $cond49 = 0, $cond50 = 0, $cond51 = 0, $cond52 = 0, $cond53 = 0, $cond54 = 0, $vararg_buffer = 0, _setjmpTable = 0, _setjmpTableSize = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 192 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(192 | 0);
 $vararg_buffer = sp;
 _setjmpTableSize = 4;
 _setjmpTable = _malloc(40) | 0;
 HEAP32[_setjmpTable >> 2] = 0;
 $1 = sp + 176 | 0;
 $2 = sp + 8 | 0;
 __THREW__ = 0;
 $3 = invoke_ii(494, $0 | 0) | 0;
 $4 = __THREW__;
 __THREW__ = 0;
 if (($4 | 0) != 0 & (threwValue | 0) != 0) {
  $5 = _testSetjmp(HEAP32[$4 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  if (($5 | 0) == 0) {
   _longjmp($4 | 0, threwValue | 0);
  }
  setTempRet0(threwValue | 0);
 } else {
  $5 = -1;
 }
 $6 = getTempRet0() | 0;
 $cond = ($5 | 0) == 1;
 do {
  if ($cond) {
   $$reg2mem43$0 = $6;
  } else {
   $7 = $3 + 40 | 0;
   $8 = HEAP32[$7 >> 2] | 0;
   $9 = ($8 | 0) != (0 | 0);
   if ($9) {
    $10 = $3 + 40 | 0;
    $11 = HEAP32[$10 >> 2] | 0;
    __THREW__ = 0;
    $12 = invoke_ii($11 | 0, $0 | 0) | 0;
    $13 = __THREW__;
    __THREW__ = 0;
    if (($13 | 0) != 0 & (threwValue | 0) != 0) {
     $14 = _testSetjmp(HEAP32[$13 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     if (($14 | 0) == 0) {
      _longjmp($13 | 0, threwValue | 0);
     }
     setTempRet0(threwValue | 0);
    } else {
     $14 = -1;
    }
    $15 = getTempRet0() | 0;
    $cond51 = ($14 | 0) == 1;
    if ($cond51) {
     $$reg2mem43$0 = $15;
     break;
    }
    $$0 = $12;
    _free(_setjmpTable | 0);
    STACKTOP = sp;
    return $$0 | 0;
   }
   __THREW__ = 0;
   invoke_viii(495, $0 | 0, 25, $1 | 0);
   $16 = __THREW__;
   __THREW__ = 0;
   if (($16 | 0) != 0 & (threwValue | 0) != 0) {
    $17 = _testSetjmp(HEAP32[$16 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($17 | 0) == 0) {
     _longjmp($16 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $17 = -1;
   }
   $18 = getTempRet0() | 0;
   $cond46 = ($17 | 0) == 1;
   if ($cond46) {
    $$reg2mem43$0 = $18;
   } else {
    $19 = HEAP32[$1 >> 2] | 0;
    $20 = ($19 | 0) != (0 | 0);
    if ($20) {
     __THREW__ = 0;
     invoke_ii(496, $2 | 0) | 0;
     $21 = __THREW__;
     __THREW__ = 0;
     if (($21 | 0) != 0 & (threwValue | 0) != 0) {
      $22 = _testSetjmp(HEAP32[$21 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($22 | 0) == 0) {
       _longjmp($21 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $22 = -1;
     }
     $23 = getTempRet0() | 0;
     $cond49 = ($22 | 0) == 1;
     if ($cond49) {
      $$reg2mem43$0 = $23;
      break;
     }
     $24 = $2 + 8 | 0;
     _setjmpTable = _saveSetjmp($24, 1, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
     _setjmpTableSize = getTempRet0() | 0;
     __THREW__ = 0;
     $25 = __THREW__;
     __THREW__ = 0;
     if (($25 | 0) != 0 & (threwValue | 0) != 0) {
      $26 = _testSetjmp(HEAP32[$25 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($26 | 0) == 0) {
       _longjmp($25 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $26 = -1;
     }
     $27 = getTempRet0() | 0;
     $cond50 = ($26 | 0) == 1;
     if ($cond50) {
      $$reg2mem43$0 = $27;
      break;
     }
     $$reg2mem43$0 = 0;
     break;
    } else {
     __THREW__ = 0;
     $48 = invoke_ii(501, $0 | 0) | 0;
     $49 = __THREW__;
     __THREW__ = 0;
     if (($49 | 0) != 0 & (threwValue | 0) != 0) {
      $50 = _testSetjmp(HEAP32[$49 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($50 | 0) == 0) {
       _longjmp($49 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $50 = -1;
     }
     $51 = getTempRet0() | 0;
     $cond47 = ($50 | 0) == 1;
     if ($cond47) {
      $$reg2mem43$0 = $51;
      break;
     }
     __THREW__ = 0;
     HEAP32[$vararg_buffer >> 2] = $48;
     $52 = invoke_iiii(502, 16012 | 0, 29675 | 0, $vararg_buffer | 0) | 0;
     $53 = __THREW__;
     __THREW__ = 0;
     if (($53 | 0) != 0 & (threwValue | 0) != 0) {
      $54 = _testSetjmp(HEAP32[$53 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($54 | 0) == 0) {
       _longjmp($53 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $54 = -1;
     }
     $55 = getTempRet0() | 0;
     $cond48 = ($54 | 0) == 1;
     if ($cond48) {
      $$reg2mem43$0 = $55;
      break;
     }
     __THREW__ = 0;
     invoke_vi(500, $52 | 0);
     $56 = __THREW__;
     __THREW__ = 0;
     if (($56 | 0) != 0 & (threwValue | 0) != 0) {
      $57 = _testSetjmp(HEAP32[$56 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
      if (($57 | 0) == 0) {
       _longjmp($56 | 0, threwValue | 0);
      }
      setTempRet0(threwValue | 0);
     } else {
      $57 = -1;
     }
     $58 = getTempRet0() | 0;
     $$reg2mem43$0 = $58;
     break;
    }
   }
  }
 } while (0);
 while (1) {
  $28 = ($$reg2mem43$0 | 0) == 0;
  if ($28) {
   __THREW__ = 0;
   $29 = invoke_iiii(497, 0, 0, $1 | 0) | 0;
   $30 = __THREW__;
   __THREW__ = 0;
   if (($30 | 0) != 0 & (threwValue | 0) != 0) {
    $31 = _testSetjmp(HEAP32[$30 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($31 | 0) == 0) {
     _longjmp($30 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $31 = -1;
   }
   $32 = getTempRet0() | 0;
   $cond53 = ($31 | 0) == 1;
   if ($cond53) {
    $$reg2mem43$0 = $32;
    continue;
   }
   __THREW__ = 0;
   invoke_v(498);
   $33 = __THREW__;
   __THREW__ = 0;
   if (($33 | 0) != 0 & (threwValue | 0) != 0) {
    $34 = _testSetjmp(HEAP32[$33 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($34 | 0) == 0) {
     _longjmp($33 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $34 = -1;
   }
   $35 = getTempRet0() | 0;
   $cond54 = ($34 | 0) == 1;
   if ($cond54) {
    $$reg2mem43$0 = $35;
    continue;
   } else {
    label = 13;
    break;
   }
  }
  $36 = $2 + 4 | 0;
  $37 = HEAP32[$36 >> 2] | 0;
  $38 = HEAP32[$37 >> 2] | 0;
  __THREW__ = 0;
  $39 = invoke_iii(499, $38 | 0, 14676 | 0) | 0;
  $40 = __THREW__;
  __THREW__ = 0;
  if (($40 | 0) != 0 & (threwValue | 0) != 0) {
   $41 = _testSetjmp(HEAP32[$40 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($41 | 0) == 0) {
    _longjmp($40 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $41 = -1;
  }
  $42 = getTempRet0() | 0;
  $cond52 = ($41 | 0) == 1;
  if ($cond52) {
   $$reg2mem43$0 = $42;
   continue;
  }
  if ($39) {
   label = 16;
   break;
  }
  $43 = $2 + 4 | 0;
  $44 = HEAP32[$43 >> 2] | 0;
  __THREW__ = 0;
  invoke_vi(500, $44 | 0);
  $45 = __THREW__;
  __THREW__ = 0;
  if (($45 | 0) != 0 & (threwValue | 0) != 0) {
   $46 = _testSetjmp(HEAP32[$45 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($46 | 0) == 0) {
    _longjmp($45 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $46 = -1;
  }
  $47 = getTempRet0() | 0;
  $$reg2mem43$0 = $47;
 }
 if ((label | 0) == 13) {
  $$0 = $29;
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$0 | 0;
 } else if ((label | 0) == 16) {
  $$0 = 0;
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$0 | 0;
 }
 return 0 | 0;
}

function _str_replace($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(96 | 0);
 $8 = sp + 60 | 0;
 $10 = sp + 52 | 0;
 $12 = sp + 44 | 0;
 $14 = sp + 24 | 0;
 $3 = $0;
 $4 = $1;
 $5 = -1;
 $20 = $3;
 $21 = ($20 | 0) == 4;
 do {
  if ($21) {
   $22 = $4;
   $23 = $22 + 12 | 0;
   $24 = HEAP32[$23 >> 2] | 0;
   $25 = _mp_obj_get_int($24) | 0;
   $5 = $25;
   $26 = $5;
   $27 = ($26 | 0) == 0;
   if ($27) {
    $28 = $4;
    $29 = HEAP32[$28 >> 2] | 0;
    $2 = $29;
    $194 = $2;
    STACKTOP = sp;
    return $194 | 0;
   } else {
    $30 = $5;
    $31 = ($30 | 0) < 0;
    if (!$31) {
     break;
    }
    $5 = -1;
    break;
   }
  }
 } while (0);
 $32 = $4;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = _mp_obj_get_type($33) | 0;
 $6 = $34;
 $35 = $4;
 $36 = $35 + 4 | 0;
 $37 = HEAP32[$36 >> 2] | 0;
 $38 = _mp_obj_get_type($37) | 0;
 $39 = $6;
 $40 = ($38 | 0) != ($39 | 0);
 $41 = $4;
 if ($40) {
  $42 = $41 + 4 | 0;
  $43 = HEAP32[$42 >> 2] | 0;
  _bad_implicit_conversion($43);
 }
 $44 = $41 + 8 | 0;
 $45 = HEAP32[$44 >> 2] | 0;
 $46 = _mp_obj_get_type($45) | 0;
 $47 = $6;
 $48 = ($46 | 0) != ($47 | 0);
 $49 = $4;
 if ($48) {
  $50 = $49 + 8 | 0;
  $51 = HEAP32[$50 >> 2] | 0;
  _bad_implicit_conversion($51);
 }
 $52 = HEAP32[$49 >> 2] | 0;
 $53 = _mp_obj_is_qstr_1128($52) | 0;
 $54 = $4;
 $55 = HEAP32[$54 >> 2] | 0;
 if ($53) {
  $56 = $55;
  $57 = $56 >>> 2;
  $58 = _qstr_data($57, $8) | 0;
  $7 = $58;
 } else {
  $59 = $55 + 8 | 0;
  $60 = HEAP32[$59 >> 2] | 0;
  HEAP32[$8 >> 2] = $60;
  $61 = $4;
  $62 = HEAP32[$61 >> 2] | 0;
  $63 = $62 + 12 | 0;
  $64 = HEAP32[$63 >> 2] | 0;
  $7 = $64;
 }
 $65 = $4;
 $66 = $65 + 4 | 0;
 $67 = HEAP32[$66 >> 2] | 0;
 $68 = _mp_obj_is_qstr_1128($67) | 0;
 $69 = $4;
 $70 = $69 + 4 | 0;
 $71 = HEAP32[$70 >> 2] | 0;
 if ($68) {
  $72 = $71;
  $73 = $72 >>> 2;
  $74 = _qstr_data($73, $10) | 0;
  $9 = $74;
 } else {
  $75 = $71 + 8 | 0;
  $76 = HEAP32[$75 >> 2] | 0;
  HEAP32[$10 >> 2] = $76;
  $77 = $4;
  $78 = $77 + 4 | 0;
  $79 = HEAP32[$78 >> 2] | 0;
  $80 = $79 + 12 | 0;
  $81 = HEAP32[$80 >> 2] | 0;
  $9 = $81;
 }
 $82 = $4;
 $83 = $82 + 8 | 0;
 $84 = HEAP32[$83 >> 2] | 0;
 $85 = _mp_obj_is_qstr_1128($84) | 0;
 $86 = $4;
 $87 = $86 + 8 | 0;
 $88 = HEAP32[$87 >> 2] | 0;
 if ($85) {
  $89 = $88;
  $90 = $89 >>> 2;
  $91 = _qstr_data($90, $12) | 0;
  $11 = $91;
 } else {
  $92 = $88 + 8 | 0;
  $93 = HEAP32[$92 >> 2] | 0;
  HEAP32[$12 >> 2] = $93;
  $94 = $4;
  $95 = $94 + 8 | 0;
  $96 = HEAP32[$95 >> 2] | 0;
  $97 = $96 + 12 | 0;
  $98 = HEAP32[$97 >> 2] | 0;
  $11 = $98;
 }
 $99 = HEAP32[$10 >> 2] | 0;
 $100 = HEAP32[$8 >> 2] | 0;
 $101 = $99 >>> 0 > $100 >>> 0;
 if ($101) {
  $102 = $4;
  $103 = HEAP32[$102 >> 2] | 0;
  $2 = $103;
  $194 = $2;
  STACKTOP = sp;
  return $194 | 0;
 }
 $13 = 0;
 while (1) {
  $15 = 0;
  $16 = 0;
  $104 = $7;
  $18 = $104;
  $105 = HEAP32[$8 >> 2] | 0;
  $19 = $105;
  $106 = HEAP32[$10 >> 2] | 0;
  $107 = ($106 | 0) == 0;
  if ($107) {
   $108 = $13;
   $109 = ($108 | 0) != (0 | 0);
   if ($109) {
    $110 = $13;
    $111 = $11;
    $112 = HEAP32[$12 >> 2] | 0;
    _memcpy($110 | 0, $111 | 0, $112 | 0) | 0;
   }
   $113 = HEAP32[$12 >> 2] | 0;
   $114 = $15;
   $115 = $114 + $113 | 0;
   $15 = $115;
   $116 = $16;
   $117 = $116 + 1 | 0;
   $16 = $117;
  }
  while (1) {
   $118 = $16;
   $119 = $5;
   $120 = ($118 | 0) != ($119 | 0);
   $121 = $19;
   $122 = $121 >>> 0 > 0;
   $or$cond = $120 & $122;
   if (!$or$cond) {
    break;
   }
   $123 = $18;
   $124 = $19;
   $125 = $9;
   $126 = HEAP32[$10 >> 2] | 0;
   $127 = _find_subbytes($123, $124, $125, $126, 1) | 0;
   $17 = $127;
   $128 = ($127 | 0) != (0 | 0);
   if (!$128) {
    break;
   }
   $129 = HEAP32[$10 >> 2] | 0;
   $130 = ($129 | 0) == 0;
   if ($130) {
    $131 = $17;
    $132 = $131 + 1 | 0;
    $17 = $132;
   }
   $133 = $13;
   $134 = ($133 | 0) != (0 | 0);
   if ($134) {
    $135 = $13;
    $136 = $15;
    $137 = $135 + $136 | 0;
    $138 = $18;
    $139 = $17;
    $140 = $18;
    $141 = $139;
    $142 = $140;
    $143 = $141 - $142 | 0;
    _memcpy($137 | 0, $138 | 0, $143 | 0) | 0;
   }
   $144 = $17;
   $145 = $18;
   $146 = $144;
   $147 = $145;
   $148 = $146 - $147 | 0;
   $149 = $15;
   $150 = $149 + $148 | 0;
   $15 = $150;
   $151 = $13;
   $152 = ($151 | 0) != (0 | 0);
   if ($152) {
    $153 = $13;
    $154 = $15;
    $155 = $153 + $154 | 0;
    $156 = $11;
    $157 = HEAP32[$12 >> 2] | 0;
    _memcpy($155 | 0, $156 | 0, $157 | 0) | 0;
   }
   $158 = HEAP32[$12 >> 2] | 0;
   $159 = $15;
   $160 = $159 + $158 | 0;
   $15 = $160;
   $161 = $17;
   $162 = HEAP32[$10 >> 2] | 0;
   $163 = $161 + $162 | 0;
   $18 = $163;
   $164 = $7;
   $165 = HEAP32[$8 >> 2] | 0;
   $166 = $164 + $165 | 0;
   $167 = $18;
   $168 = $166;
   $169 = $167;
   $170 = $168 - $169 | 0;
   $19 = $170;
   $171 = $16;
   $172 = $171 + 1 | 0;
   $16 = $172;
  }
  $173 = $13;
  $174 = ($173 | 0) != (0 | 0);
  if ($174) {
   $175 = $13;
   $176 = $15;
   $177 = $175 + $176 | 0;
   $178 = $18;
   $179 = $19;
   _memcpy($177 | 0, $178 | 0, $179 | 0) | 0;
  }
  $180 = $19;
  $181 = $15;
  $182 = $181 + $180 | 0;
  $15 = $182;
  $183 = $13;
  $184 = ($183 | 0) == (0 | 0);
  if (!$184) {
   label = 42;
   break;
  }
  $185 = $16;
  $186 = ($185 | 0) == 0;
  if ($186) {
   label = 40;
   break;
  }
  $189 = $15;
  _vstr_init_len($14, $189);
  $190 = $14 + 8 | 0;
  $191 = HEAP32[$190 >> 2] | 0;
  $13 = $191;
 }
 if ((label | 0) == 40) {
  $187 = $4;
  $188 = HEAP32[$187 >> 2] | 0;
  $2 = $188;
  $194 = $2;
  STACKTOP = sp;
  return $194 | 0;
 } else if ((label | 0) == 42) {
  $192 = $6;
  $193 = _mp_obj_new_str_from_vstr($192, $14) | 0;
  $2 = $193;
  $194 = $2;
  STACKTOP = sp;
  return $194 | 0;
 }
 return 0 | 0;
}

function _compile_atom_brace_helper($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $8 = sp + 12 | 0;
 $3 = $0;
 $4 = $1;
 $14 = $2 & 1;
 $5 = $14;
 $15 = $4;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $6 = $17;
 $18 = $6;
 $19 = ($18 | 0) == 0;
 if ($19) {
  $20 = $5;
  $21 = $20 & 1;
  if (!$21) {
   STACKTOP = sp;
   return;
  }
  $22 = $3;
  $23 = $22 + 40 | 0;
  $24 = HEAP32[$23 >> 2] | 0;
  _mp_emit_bc_build($24, 0, 3);
  STACKTOP = sp;
  return;
 }
 $25 = $6;
 $26 = ($25 | 0) != 0;
 if ($26) {
  $27 = $6;
  $28 = $27 & 3;
  $29 = ($28 | 0) == 0;
  if ($29) {
   $30 = $6;
   $31 = $30;
   $4 = $31;
   $32 = $4;
   $33 = $32 + 4 | 0;
   $34 = HEAP32[$33 >> 2] | 0;
   $35 = $34 & 255;
   $36 = ($35 | 0) == 54;
   if ($36) {
    $37 = $5;
    $38 = $37 & 1;
    if ($38) {
     $39 = $3;
     $40 = $39 + 40 | 0;
     $41 = HEAP32[$40 >> 2] | 0;
     _mp_emit_bc_build($41, 1, 3);
    }
    $42 = $3;
    $43 = $6;
    _compile_node($42, $43);
    $44 = $3;
    $45 = $44 + 40 | 0;
    $46 = HEAP32[$45 >> 2] | 0;
    _mp_emit_bc_store_map($46);
    STACKTOP = sp;
    return;
   }
   $47 = $4;
   $48 = $47 + 4 | 0;
   $49 = HEAP32[$48 >> 2] | 0;
   $50 = $49 & 255;
   $51 = ($50 | 0) == 157;
   if ($51) {
    $52 = $4;
    $53 = $52 + 8 | 0;
    $54 = $53 + 4 | 0;
    $55 = HEAP32[$54 >> 2] | 0;
    $56 = $55;
    $7 = $56;
    $57 = $7;
    $58 = $57 + 4 | 0;
    $59 = HEAP32[$58 >> 2] | 0;
    $60 = $59 & 255;
    $61 = ($60 | 0) == 160;
    if (!$61) {
     $143 = $4;
     $144 = $143 + 8 | 0;
     $145 = HEAP32[$144 >> 2] | 0;
     $146 = ($145 | 0) != 0;
     if ($146) {
      $147 = $4;
      $148 = $147 + 8 | 0;
      $149 = HEAP32[$148 >> 2] | 0;
      $150 = $149 & 3;
      $151 = ($150 | 0) == 0;
      if ($151) {
       $152 = $4;
       $153 = $152 + 8 | 0;
       $154 = HEAP32[$153 >> 2] | 0;
       $155 = $154;
       $156 = $155 + 4 | 0;
       $157 = HEAP32[$156 >> 2] | 0;
       $158 = $157 & 255;
       $159 = ($158 | 0) == 54;
       if ($159) {
        $160 = $3;
        $161 = $4;
        _compile_comprehension($160, $161, 4);
        STACKTOP = sp;
        return;
       }
      }
     }
     $162 = $3;
     $163 = $4;
     _compile_comprehension($162, $163, 5);
     STACKTOP = sp;
     return;
    }
    $62 = $7;
    $63 = $62 + 8 | 0;
    $64 = _mp_parse_node_extract_list($63, 161, $8) | 0;
    $9 = $64;
    $65 = $4;
    $66 = $65 + 8 | 0;
    $67 = HEAP32[$66 >> 2] | 0;
    $68 = ($67 | 0) != 0;
    if ($68) {
     $69 = $4;
     $70 = $69 + 8 | 0;
     $71 = HEAP32[$70 >> 2] | 0;
     $72 = $71 & 3;
     $73 = ($72 | 0) == 0;
     if ($73) {
      $74 = $4;
      $75 = $74 + 8 | 0;
      $76 = HEAP32[$75 >> 2] | 0;
      $77 = $76;
      $78 = $77 + 4 | 0;
      $79 = HEAP32[$78 >> 2] | 0;
      $80 = $79 & 255;
      $81 = ($80 | 0) == 54;
      if ($81) {
       $82 = $5;
       $83 = $82 & 1;
       if ($83) {
        $84 = $3;
        $85 = $84 + 40 | 0;
        $86 = HEAP32[$85 >> 2] | 0;
        $87 = $9;
        $88 = 1 + $87 | 0;
        _mp_emit_bc_build($86, $88, 3);
       }
       $89 = $3;
       $90 = $4;
       $91 = $90 + 8 | 0;
       $92 = HEAP32[$91 >> 2] | 0;
       _compile_node($89, $92);
       $93 = $3;
       $94 = $93 + 40 | 0;
       $95 = HEAP32[$94 >> 2] | 0;
       _mp_emit_bc_store_map($95);
       $10 = 1;
      } else {
       label = 18;
      }
     } else {
      label = 18;
     }
    } else {
     label = 18;
    }
    if ((label | 0) == 18) {
     $96 = $3;
     $97 = $4;
     $98 = $97 + 8 | 0;
     $99 = HEAP32[$98 >> 2] | 0;
     _compile_node($96, $99);
     $10 = 0;
    }
    $11 = 0;
    while (1) {
     $100 = $11;
     $101 = $9;
     $102 = ($100 | 0) < ($101 | 0);
     if (!$102) {
      label = 31;
      break;
     }
     $103 = HEAP32[$8 >> 2] | 0;
     $104 = $11;
     $105 = $103 + ($104 << 2) | 0;
     $106 = HEAP32[$105 >> 2] | 0;
     $12 = $106;
     $107 = $12;
     $108 = ($107 | 0) != 0;
     if ($108) {
      $109 = $12;
      $110 = $109 & 3;
      $111 = ($110 | 0) == 0;
      if ($111) {
       $112 = $12;
       $113 = $112;
       $114 = $113 + 4 | 0;
       $115 = HEAP32[$114 >> 2] | 0;
       $116 = $115 & 255;
       $117 = ($116 | 0) == 54;
       $119 = $117;
      } else {
       $119 = 0;
      }
     } else {
      $119 = 0;
     }
     $118 = $119 & 1;
     $13 = $118;
     $120 = $3;
     $121 = $12;
     _compile_node($120, $121);
     $122 = $10;
     $123 = $122 & 1;
     $124 = $13;
     $125 = $124 & 1;
     if ($123) {
      $126 = $3;
      if (!$125) {
       label = 26;
       break;
      }
      $129 = $126 + 40 | 0;
      $130 = HEAP32[$129 >> 2] | 0;
      _mp_emit_bc_store_map($130);
     } else {
      if ($125) {
       label = 29;
       break;
      }
     }
     $134 = $11;
     $135 = $134 + 1 | 0;
     $11 = $135;
    }
    if ((label | 0) == 26) {
     $127 = $4;
     $128 = $127;
     _compile_syntax_error($126, $128, 28989);
     STACKTOP = sp;
     return;
    } else if ((label | 0) == 29) {
     $131 = $3;
     $132 = $4;
     $133 = $132;
     _compile_syntax_error($131, $133, 29018);
     STACKTOP = sp;
     return;
    } else if ((label | 0) == 31) {
     $136 = $10;
     $137 = $136 & 1;
     if ($137) {
      STACKTOP = sp;
      return;
     }
     $138 = $3;
     $139 = $138 + 40 | 0;
     $140 = HEAP32[$139 >> 2] | 0;
     $141 = $9;
     $142 = 1 + $141 | 0;
     _mp_emit_bc_build($140, $142, 6);
     STACKTOP = sp;
     return;
    }
   }
  }
 }
 $164 = $3;
 $165 = $6;
 _compile_node($164, $165);
 $166 = $3;
 $167 = $166 + 40 | 0;
 $168 = HEAP32[$167 >> 2] | 0;
 _mp_emit_bc_build($168, 1, 6);
 STACKTOP = sp;
 return;
}

function _compile_trailer_paren_helper($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $5 = sp + 40 | 0;
 $8 = sp + 32 | 0;
 $4 = $0;
 HEAP32[$5 >> 2] = $1;
 $17 = $2 & 1;
 $6 = $17;
 $7 = $3;
 $18 = _mp_parse_node_extract_list($5, 163, $8) | 0;
 $9 = $18;
 $19 = $7;
 $10 = $19;
 $11 = 0;
 $12 = 0;
 $13 = 0;
 $14 = 0;
 $15 = 0;
 L1 : while (1) {
  $20 = $15;
  $21 = $9;
  $22 = ($20 | 0) < ($21 | 0);
  if (!$22) {
   label = 27;
   break;
  }
  $23 = HEAP32[$8 >> 2] | 0;
  $24 = $15;
  $25 = $23 + ($24 << 2) | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = ($26 | 0) != 0;
  do {
   if ($27) {
    $28 = HEAP32[$8 >> 2] | 0;
    $29 = $15;
    $30 = $28 + ($29 << 2) | 0;
    $31 = HEAP32[$30 >> 2] | 0;
    $32 = $31 & 3;
    $33 = ($32 | 0) == 0;
    if ($33) {
     $34 = HEAP32[$8 >> 2] | 0;
     $35 = $15;
     $36 = $34 + ($35 << 2) | 0;
     $37 = HEAP32[$36 >> 2] | 0;
     $38 = $37;
     $16 = $38;
     $39 = $16;
     $40 = $39 + 4 | 0;
     $41 = HEAP32[$40 >> 2] | 0;
     $42 = $41 & 255;
     $43 = ($42 | 0) == 165;
     if ($43) {
      $44 = $12;
      $45 = $44 & 1;
      $46 = ($45 | 0) != 0;
      if ($46) {
       label = 7;
       break L1;
      }
      $50 = $12;
      $51 = $50 | 1;
      $12 = $51;
      $52 = $16;
      $13 = $52;
      break;
     }
     $53 = $16;
     $54 = $53 + 4 | 0;
     $55 = HEAP32[$54 >> 2] | 0;
     $56 = $55 & 255;
     $57 = ($56 | 0) == 166;
     if ($57) {
      $58 = $12;
      $59 = $58 & 2;
      $60 = ($59 | 0) != 0;
      if ($60) {
       label = 11;
       break L1;
      }
      $64 = $12;
      $65 = $64 | 2;
      $12 = $65;
      $66 = $16;
      $14 = $66;
      break;
     }
     $67 = $16;
     $68 = $67 + 4 | 0;
     $69 = HEAP32[$68 >> 2] | 0;
     $70 = $69 & 255;
     $71 = ($70 | 0) == 167;
     if ($71) {
      $72 = $16;
      $73 = $72 + 8 | 0;
      $74 = $73 + 4 | 0;
      $75 = HEAP32[$74 >> 2] | 0;
      $76 = ($75 | 0) != 0;
      if ($76) {
       $77 = $16;
       $78 = $77 + 8 | 0;
       $79 = $78 + 4 | 0;
       $80 = HEAP32[$79 >> 2] | 0;
       $81 = $80 & 3;
       $82 = ($81 | 0) == 0;
       if ($82) {
        $83 = $16;
        $84 = $83 + 8 | 0;
        $85 = $84 + 4 | 0;
        $86 = HEAP32[$85 >> 2] | 0;
        $87 = $86;
        $88 = $87 + 4 | 0;
        $89 = HEAP32[$88 >> 2] | 0;
        $90 = $89 & 255;
        $91 = ($90 | 0) == 171;
        if ($91) {
         $113 = $4;
         $114 = $16;
         _compile_comprehension($113, $114, 6);
         $115 = $10;
         $116 = $115 + 1 | 0;
         $10 = $116;
         break;
        }
       }
      }
      $92 = $16;
      $93 = $92 + 8 | 0;
      $94 = HEAP32[$93 >> 2] | 0;
      $95 = $94 & 15;
      $96 = ($95 | 0) == 2;
      $97 = $4;
      if (!$96) {
       label = 18;
       break L1;
      }
      $100 = $97 + 40 | 0;
      $101 = HEAP32[$100 >> 2] | 0;
      $102 = $16;
      $103 = $102 + 8 | 0;
      $104 = HEAP32[$103 >> 2] | 0;
      $105 = $104 >>> 4;
      _mp_emit_bc_load_const_str($101, $105);
      $106 = $4;
      $107 = $16;
      $108 = $107 + 8 | 0;
      $109 = $108 + 4 | 0;
      $110 = HEAP32[$109 >> 2] | 0;
      _compile_node($106, $110);
      $111 = $11;
      $112 = $111 + 1 | 0;
      $11 = $112;
     } else {
      label = 21;
     }
    } else {
     label = 21;
    }
   } else {
    label = 21;
   }
  } while (0);
  if ((label | 0) == 21) {
   label = 0;
   $117 = $12;
   $118 = ($117 | 0) != 0;
   if ($118) {
    label = 22;
    break;
   }
   $124 = $11;
   $125 = $124 >>> 0 > 0;
   $126 = $4;
   $127 = HEAP32[$8 >> 2] | 0;
   $128 = $15;
   $129 = $127 + ($128 << 2) | 0;
   $130 = HEAP32[$129 >> 2] | 0;
   if ($125) {
    label = 24;
    break;
   }
   _compile_node($126, $130);
   $131 = $10;
   $132 = $131 + 1 | 0;
   $10 = $132;
  }
  $133 = $15;
  $134 = $133 + 1 | 0;
  $15 = $134;
 }
 if ((label | 0) == 7) {
  $47 = $4;
  $48 = $16;
  $49 = $48;
  _compile_syntax_error($47, $49, 28848);
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 11) {
  $61 = $4;
  $62 = $16;
  $63 = $62;
  _compile_syntax_error($61, $63, 28871);
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 18) {
  $98 = $16;
  $99 = $98;
  _compile_syntax_error($97, $99, 28895);
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 22) {
  $119 = $4;
  $120 = HEAP32[$8 >> 2] | 0;
  $121 = $15;
  $122 = $120 + ($121 << 2) | 0;
  $123 = HEAP32[$122 >> 2] | 0;
  _compile_syntax_error($119, $123, 28928);
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 24) {
  _compile_syntax_error($126, $130, 28955);
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 27) {
  $135 = $12;
  $136 = ($135 | 0) != 0;
  do {
   if ($136) {
    $137 = $13;
    $138 = ($137 | 0) == (0 | 0);
    $139 = $4;
    if ($138) {
     $140 = $139 + 40 | 0;
     $141 = HEAP32[$140 >> 2] | 0;
     _mp_emit_bc_load_null($141);
    } else {
     $142 = $13;
     $143 = $142 + 8 | 0;
     $144 = HEAP32[$143 >> 2] | 0;
     _compile_node($139, $144);
    }
    $145 = $14;
    $146 = ($145 | 0) == (0 | 0);
    $147 = $4;
    if ($146) {
     $148 = $147 + 40 | 0;
     $149 = HEAP32[$148 >> 2] | 0;
     _mp_emit_bc_load_null($149);
     break;
    } else {
     $150 = $14;
     $151 = $150 + 8 | 0;
     $152 = HEAP32[$151 >> 2] | 0;
     _compile_node($147, $152);
     break;
    }
   }
  } while (0);
  $153 = $6;
  $154 = $153 & 1;
  $155 = $4;
  $156 = $155 + 40 | 0;
  $157 = HEAP32[$156 >> 2] | 0;
  $158 = $10;
  $159 = $11;
  $160 = $12;
  if ($154) {
   _mp_emit_bc_call_method($157, $158, $159, $160);
   STACKTOP = sp;
   return;
  } else {
   _mp_emit_bc_call_function($157, $158, $159, $160);
   STACKTOP = sp;
   return;
  }
 }
}

function _gc_realloc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$0$i = 0, $$0$i99 = 0, $$087107 = 0, $$088106 = 0, $$089105 = 0, $$090113 = 0, $$093 = 0, $$093111 = 0, $$093114 = 0, $$094$lcssa = 0, $$094112 = 0, $$191102 = 0, $$195101 = 0, $$292 = 0, $$4 = 0, $$pre$i = 0, $$pre$i98 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $exitcond = 0, $trunc = 0, $trunc$clear = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $3 = ($0 | 0) == (0 | 0);
 if ($3) {
  $4 = _gc_alloc($1, 0) | 0;
  $$4 = $4;
  return $$4 | 0;
 }
 $5 = ($1 | 0) == 0;
 $6 = HEAP16[41020 >> 1] | 0;
 $7 = $6 << 16 >> 16 == 0;
 if ($5) {
  if (!$7) {
   $$4 = 0;
   return $$4 | 0;
  }
  $8 = HEAP32[40752 >> 2] | 0;
  $9 = $0;
  $10 = $9 - $8 | 0;
  $11 = $10 >>> 4;
  $12 = $10 >>> 6;
  $13 = HEAP32[41032 >> 2] | 0;
  $14 = $12 >>> 0 < $13 >>> 0;
  if ($14) {
   HEAP32[41032 >> 2] = $12;
  }
  $$pre$i = HEAP32[40744 >> 2] | 0;
  $$0$i = $11;
  $21 = $$pre$i;
  while (1) {
   $15 = $$0$i << 1;
   $16 = $15 & 6;
   $17 = 3 << $16;
   $18 = $17 ^ 255;
   $19 = $$0$i >>> 2;
   $20 = $21 + $19 | 0;
   $22 = HEAP8[$20 >> 0] | 0;
   $23 = $22 & 255;
   $24 = $18 & $23;
   $25 = $24 & 255;
   HEAP8[$20 >> 0] = $25;
   $26 = $$0$i + 1 | 0;
   $27 = HEAP32[40744 >> 2] | 0;
   $28 = $26 >>> 2;
   $29 = $27 + $28 | 0;
   $30 = HEAP8[$29 >> 0] | 0;
   $31 = $30 & 255;
   $32 = $26 << 1;
   $33 = $32 & 6;
   $34 = $31 >>> $33;
   $35 = $34 & 3;
   $36 = ($35 | 0) == 2;
   if ($36) {
    $$0$i = $26;
    $21 = $27;
   } else {
    $$4 = 0;
    break;
   }
  }
  return $$4 | 0;
 }
 if (!$7) {
  $$4 = 0;
  return $$4 | 0;
 }
 $37 = HEAP32[40752 >> 2] | 0;
 $38 = $0;
 $39 = $38 - $37 | 0;
 $40 = $39 >>> 4;
 $41 = $1 + 15 | 0;
 $42 = $41 >>> 4;
 $43 = HEAP32[40748 >> 2] | 0;
 $44 = $43 << 2;
 $$093111 = $40 + 1 | 0;
 $45 = $$093111 >>> 0 < $44 >>> 0;
 L20 : do {
  if ($45) {
   $46 = HEAP32[40744 >> 2] | 0;
   $$090113 = 0;
   $$093114 = $$093111;
   $$094112 = 1;
   while (1) {
    $47 = $$093114 >>> 2;
    $48 = $46 + $47 | 0;
    $49 = HEAP8[$48 >> 0] | 0;
    $50 = $49 & 255;
    $51 = $$093114 << 1;
    $52 = $51 & 6;
    $53 = $50 >>> $52;
    $trunc = $53 & 255;
    $trunc$clear = $trunc & 3;
    switch ($trunc$clear << 24 >> 24) {
    case 2:
     {
      $54 = $$094112 + 1 | 0;
      $$191102 = $$090113;
      $$195101 = $54;
      break;
     }
    case 0:
     {
      $55 = $$090113 + 1 | 0;
      $56 = $55 + $$094112 | 0;
      $57 = $56 >>> 0 < $42 >>> 0;
      if ($57) {
       $$191102 = $55;
       $$195101 = $$094112;
      } else {
       $$094$lcssa = $$094112;
       $$292 = $55;
       break L20;
      }
      break;
     }
    default:
     {
      $$094$lcssa = $$094112;
      $$292 = $$090113;
      break L20;
     }
    }
    $$093 = $$093114 + 1 | 0;
    $58 = $$093 >>> 0 < $44 >>> 0;
    if ($58) {
     $$090113 = $$191102;
     $$093114 = $$093;
     $$094112 = $$195101;
    } else {
     $$094$lcssa = $$195101;
     $$292 = $$191102;
     break L20;
    }
   }
  } else {
   $$094$lcssa = 1;
   $$292 = 0;
  }
 } while (0);
 $59 = ($42 | 0) == ($$094$lcssa | 0);
 if ($59) {
  $$4 = $0;
  return $$4 | 0;
 }
 $60 = $42 >>> 0 < $$094$lcssa >>> 0;
 if ($60) {
  $61 = $40 + $42 | 0;
  $62 = $$094$lcssa - $42 | 0;
  $63 = ($62 | 0) == 0;
  if (!$63) {
   $$088106 = $62;
   $$089105 = $61;
   while (1) {
    $67 = $$089105 << 1;
    $68 = $67 & 6;
    $69 = 3 << $68;
    $70 = $69 ^ 255;
    $71 = HEAP32[40744 >> 2] | 0;
    $72 = $$089105 >>> 2;
    $73 = $71 + $72 | 0;
    $74 = HEAP8[$73 >> 0] | 0;
    $75 = $74 & 255;
    $76 = $70 & $75;
    $77 = $76 & 255;
    HEAP8[$73 >> 0] = $77;
    $78 = $$089105 + 1 | 0;
    $79 = $$088106 + -1 | 0;
    $80 = ($79 | 0) == 0;
    if ($80) {
     break;
    } else {
     $$088106 = $79;
     $$089105 = $78;
    }
   }
  }
  $64 = $61 >>> 2;
  $65 = HEAP32[41032 >> 2] | 0;
  $66 = $64 >>> 0 < $65 >>> 0;
  if (!$66) {
   $$4 = $0;
   return $$4 | 0;
  }
  HEAP32[41032 >> 2] = $64;
  $$4 = $0;
  return $$4 | 0;
 }
 $81 = $$292 + $$094$lcssa | 0;
 $82 = $42 >>> 0 > $81 >>> 0;
 if (!$82) {
  $83 = $$094$lcssa + $40 | 0;
  $84 = $40 + $42 | 0;
  $85 = $83 >>> 0 < $84 >>> 0;
  if ($85) {
   $$087107 = $83;
   while (1) {
    $90 = $$087107 << 1;
    $91 = $90 & 6;
    $92 = 2 << $91;
    $93 = HEAP32[40744 >> 2] | 0;
    $94 = $$087107 >>> 2;
    $95 = $93 + $94 | 0;
    $96 = HEAP8[$95 >> 0] | 0;
    $97 = $96 & 255;
    $98 = $92 | $97;
    $99 = $98 & 255;
    HEAP8[$95 >> 0] = $99;
    $100 = $$087107 + 1 | 0;
    $exitcond = ($100 | 0) == ($84 | 0);
    if ($exitcond) {
     break;
    } else {
     $$087107 = $100;
    }
   }
  }
  $86 = $$094$lcssa << 4;
  $87 = $0 + $86 | 0;
  $88 = $42 - $$094$lcssa | 0;
  $89 = $88 << 4;
  _memset($87 | 0, 0, $89 | 0) | 0;
  $$4 = $0;
  return $$4 | 0;
 }
 if (!$2) {
  $$4 = 0;
  return $$4 | 0;
 }
 $101 = _gc_alloc($1, 0) | 0;
 $102 = ($101 | 0) == (0 | 0);
 if ($102) {
  $$4 = 0;
  return $$4 | 0;
 }
 $103 = $$094$lcssa << 4;
 _memcpy($101 | 0, $0 | 0, $103 | 0) | 0;
 $104 = HEAP16[41020 >> 1] | 0;
 $105 = $104 << 16 >> 16 == 0;
 if (!$105) {
  $$4 = $101;
  return $$4 | 0;
 }
 $106 = HEAP32[40752 >> 2] | 0;
 $107 = $38 - $106 | 0;
 $108 = $107 >>> 4;
 $109 = $107 >>> 6;
 $110 = HEAP32[41032 >> 2] | 0;
 $111 = $109 >>> 0 < $110 >>> 0;
 if ($111) {
  HEAP32[41032 >> 2] = $109;
 }
 $$pre$i98 = HEAP32[40744 >> 2] | 0;
 $$0$i99 = $108;
 $118 = $$pre$i98;
 while (1) {
  $112 = $$0$i99 << 1;
  $113 = $112 & 6;
  $114 = 3 << $113;
  $115 = $114 ^ 255;
  $116 = $$0$i99 >>> 2;
  $117 = $118 + $116 | 0;
  $119 = HEAP8[$117 >> 0] | 0;
  $120 = $119 & 255;
  $121 = $115 & $120;
  $122 = $121 & 255;
  HEAP8[$117 >> 0] = $122;
  $123 = $$0$i99 + 1 | 0;
  $124 = HEAP32[40744 >> 2] | 0;
  $125 = $123 >>> 2;
  $126 = $124 + $125 | 0;
  $127 = HEAP8[$126 >> 0] | 0;
  $128 = $127 & 255;
  $129 = $123 << 1;
  $130 = $129 & 6;
  $131 = $128 >>> $130;
  $132 = $131 & 3;
  $133 = ($132 | 0) == 2;
  if ($133) {
   $$0$i99 = $123;
   $118 = $124;
  } else {
   $$4 = $101;
   break;
  }
 }
 return $$4 | 0;
}

function _uctypes_struct_subscr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $15 = sp + 28 | 0;
 $20 = sp + 8 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $23 = $4;
 $7 = $23;
 $24 = $6;
 $25 = ($24 | 0) == (0 | 0);
 if ($25) {
  $3 = 0;
  $188 = $3;
  STACKTOP = sp;
  return $188 | 0;
 }
 $26 = $7;
 $27 = $26 + 4 | 0;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = _mp_obj_is_obj_1471($28) | 0;
 if (!$29) {
  _mp_raise_TypeError(34531);
 }
 $30 = $7;
 $31 = $30 + 4 | 0;
 $32 = HEAP32[$31 >> 2] | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = ($33 | 0) == (18952 | 0);
 if (!$34) {
  _mp_raise_TypeError(34531);
 }
 $35 = $7;
 $36 = $35 + 4 | 0;
 $37 = HEAP32[$36 >> 2] | 0;
 $8 = $37;
 $38 = $8;
 $39 = $38 + 8 | 0;
 $40 = HEAP32[$39 >> 2] | 0;
 $41 = $40;
 $42 = $41 >> 1;
 $9 = $42;
 $43 = $9;
 $44 = $43 >> 29;
 $45 = $44 & 3;
 $10 = $45;
 $46 = $5;
 $47 = $46;
 $48 = $47 >> 1;
 $11 = $48;
 $49 = $10;
 $50 = ($49 | 0) == 2;
 if (!$50) {
  $136 = $10;
  $137 = ($136 | 0) == 1;
  if (!$137) {
   $3 = 0;
   $188 = $3;
   STACKTOP = sp;
   return $188 | 0;
  }
  $138 = $7;
  $139 = $138 + 8 | 0;
  $140 = HEAP32[$139 >> 2] | 0;
  $141 = HEAP32[$140 >> 2] | 0;
  $18 = $141;
  $142 = $8;
  $143 = $142 + 8 | 0;
  $144 = $143 + 4 | 0;
  $145 = HEAP32[$144 >> 2] | 0;
  $146 = _mp_obj_is_small_int_1472($145) | 0;
  if ($146) {
   $147 = $8;
   $148 = $147 + 8 | 0;
   $149 = $148 + 4 | 0;
   $150 = HEAP32[$149 >> 2] | 0;
   $151 = $150;
   $152 = $151 >> 1;
   $153 = $152 >> 27;
   $154 = $153 & 15;
   $19 = $154;
   $155 = $19;
   $156 = $18;
   $157 = $11;
   $158 = _get_aligned($155, $156, $157) | 0;
   $3 = $158;
   $188 = $3;
   STACKTOP = sp;
   return $188 | 0;
  } else {
   HEAP32[$20 >> 2] = 0;
   $159 = $8;
   $160 = $159 + 8 | 0;
   $161 = $160 + 4 | 0;
   $162 = HEAP32[$161 >> 2] | 0;
   $163 = $7;
   $164 = $163 + 12 | 0;
   $165 = HEAP32[$164 >> 2] | 0;
   $166 = _uctypes_struct_size($162, $165, $20) | 0;
   $21 = $166;
   $167 = _m_malloc(16) | 0;
   $22 = $167;
   $168 = $22;
   HEAP32[$168 >> 2] = 20948;
   $169 = $8;
   $170 = $169 + 8 | 0;
   $171 = $170 + 4 | 0;
   $172 = HEAP32[$171 >> 2] | 0;
   $173 = $22;
   $174 = $173 + 4 | 0;
   HEAP32[$174 >> 2] = $172;
   $175 = $18;
   $176 = $21;
   $177 = $11;
   $178 = Math_imul($176, $177) | 0;
   $179 = $175 + $178 | 0;
   $180 = $22;
   $181 = $180 + 8 | 0;
   HEAP32[$181 >> 2] = $179;
   $182 = $7;
   $183 = $182 + 12 | 0;
   $184 = HEAP32[$183 >> 2] | 0;
   $185 = $22;
   $186 = $185 + 12 | 0;
   HEAP32[$186 >> 2] = $184;
   $187 = $22;
   $3 = $187;
   $188 = $3;
   STACKTOP = sp;
   return $188 | 0;
  }
 }
 $51 = $8;
 $52 = $51 + 8 | 0;
 $53 = $52 + 4 | 0;
 $54 = HEAP32[$53 >> 2] | 0;
 $55 = $54;
 $56 = $55 >> 1;
 $12 = $56;
 $57 = $12;
 $58 = $57 >> 27;
 $59 = $58 & 15;
 $13 = $59;
 $60 = $12;
 $61 = $60 & 134217727;
 $12 = $61;
 $62 = $11;
 $63 = $12;
 $64 = ($62 | 0) >= ($63 | 0);
 if ($64) {
  $65 = _mp_obj_new_exception_msg(15532, 34552) | 0;
  _nlr_jump($65);
 }
 $66 = $8;
 $67 = $66 + 4 | 0;
 $68 = HEAP32[$67 >> 2] | 0;
 $69 = ($68 | 0) == 2;
 if (!$69) {
  $103 = $6;
  $104 = ($103 | 0) == (4 | 0);
  if ($104) {
   HEAP32[$15 >> 2] = 0;
   $105 = $8;
   $106 = $105 + 8 | 0;
   $107 = $106 + 8 | 0;
   $108 = HEAP32[$107 >> 2] | 0;
   $109 = $7;
   $110 = $109 + 12 | 0;
   $111 = HEAP32[$110 >> 2] | 0;
   $112 = _uctypes_struct_size($108, $111, $15) | 0;
   $16 = $112;
   $113 = _m_malloc(16) | 0;
   $17 = $113;
   $114 = $17;
   HEAP32[$114 >> 2] = 20948;
   $115 = $8;
   $116 = $115 + 8 | 0;
   $117 = $116 + 8 | 0;
   $118 = HEAP32[$117 >> 2] | 0;
   $119 = $17;
   $120 = $119 + 4 | 0;
   HEAP32[$120 >> 2] = $118;
   $121 = $7;
   $122 = $121 + 8 | 0;
   $123 = HEAP32[$122 >> 2] | 0;
   $124 = $16;
   $125 = $11;
   $126 = Math_imul($124, $125) | 0;
   $127 = $123 + $126 | 0;
   $128 = $17;
   $129 = $128 + 8 | 0;
   HEAP32[$129 >> 2] = $127;
   $130 = $7;
   $131 = $130 + 12 | 0;
   $132 = HEAP32[$131 >> 2] | 0;
   $133 = $17;
   $134 = $133 + 12 | 0;
   HEAP32[$134 >> 2] = $132;
   $135 = $17;
   $3 = $135;
   $188 = $3;
   STACKTOP = sp;
   return $188 | 0;
  } else {
   $3 = 0;
   $188 = $3;
   STACKTOP = sp;
   return $188 | 0;
  }
 }
 $70 = $7;
 $71 = $70 + 12 | 0;
 $72 = HEAP32[$71 >> 2] | 0;
 $73 = ($72 | 0) == 2;
 if ($73) {
  $74 = $6;
  $75 = ($74 | 0) == (4 | 0);
  $76 = $13;
  $77 = $7;
  $78 = $77 + 8 | 0;
  $79 = HEAP32[$78 >> 2] | 0;
  $80 = $11;
  if ($75) {
   $81 = _get_aligned($76, $79, $80) | 0;
   $3 = $81;
   $188 = $3;
   STACKTOP = sp;
   return $188 | 0;
  } else {
   $82 = $6;
   _set_aligned($76, $79, $80, $82);
   $83 = $6;
   $3 = $83;
   $188 = $3;
   STACKTOP = sp;
   return $188 | 0;
  }
 } else {
  $84 = $7;
  $85 = $84 + 8 | 0;
  $86 = HEAP32[$85 >> 2] | 0;
  $87 = $13;
  $88 = $87 >>> 1;
  $89 = 1 << $88;
  $90 = $11;
  $91 = Math_imul($89, $90) | 0;
  $92 = $86 + $91 | 0;
  $14 = $92;
  $93 = $6;
  $94 = ($93 | 0) == (4 | 0);
  $95 = $13;
  $96 = $14;
  $97 = $7;
  $98 = $97 + 12 | 0;
  $99 = HEAP32[$98 >> 2] | 0;
  if ($94) {
   $100 = _get_unaligned($95, $96, $99) | 0;
   $3 = $100;
   $188 = $3;
   STACKTOP = sp;
   return $188 | 0;
  } else {
   $101 = $6;
   _set_unaligned($95, $96, $99, $101);
   $102 = $6;
   $3 = $102;
   $188 = $3;
   STACKTOP = sp;
   return $188 | 0;
  }
 }
 return 0 | 0;
}

function _re1_5_dumpcode($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer13 = 0, $vararg_buffer16 = 0, $vararg_buffer18 = 0, $vararg_buffer22 = 0, $vararg_buffer26 = 0, $vararg_buffer28 = 0, $vararg_buffer31 = 0, $vararg_buffer33 = 0, $vararg_buffer36 = 0, $vararg_buffer38 = 0, $vararg_buffer40 = 0, $vararg_buffer5 = 0, $vararg_buffer9 = 0, $vararg_ptr12 = 0, $vararg_ptr21 = 0, $vararg_ptr25 = 0, $vararg_ptr4 = 0, $vararg_ptr43 = 0, $vararg_ptr8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 144 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(144 | 0);
 $vararg_buffer40 = sp + 112 | 0;
 $vararg_buffer38 = sp + 104 | 0;
 $vararg_buffer36 = sp + 96 | 0;
 $vararg_buffer33 = sp + 88 | 0;
 $vararg_buffer31 = sp + 80 | 0;
 $vararg_buffer28 = sp + 72 | 0;
 $vararg_buffer26 = sp + 64 | 0;
 $vararg_buffer22 = sp + 56 | 0;
 $vararg_buffer18 = sp + 48 | 0;
 $vararg_buffer16 = sp + 40 | 0;
 $vararg_buffer13 = sp + 32 | 0;
 $vararg_buffer9 = sp + 24 | 0;
 $vararg_buffer5 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $1 = $0;
 $2 = 0;
 $5 = $1;
 $6 = $5 + 12 | 0;
 $3 = $6;
 while (1) {
  $7 = $2;
  $8 = $1;
  $9 = HEAP32[$8 >> 2] | 0;
  $10 = ($7 | 0) < ($9 | 0);
  if (!$10) {
   break;
  }
  $11 = $2;
  HEAP32[$vararg_buffer >> 2] = $11;
  _printf(34718, $vararg_buffer) | 0;
  $12 = $3;
  $13 = $2;
  $14 = $13 + 1 | 0;
  $2 = $14;
  $15 = $12 + $13 | 0;
  $16 = HEAP8[$15 >> 0] | 0;
  $17 = $16 << 24 >> 24;
  do {
   switch ($17 | 0) {
   case 81:
    {
     _printf(34857, $vararg_buffer38) | 0;
     break;
    }
   case 98:
    {
     $33 = $2;
     $34 = $3;
     $35 = $2;
     $36 = $34 + $35 | 0;
     $37 = HEAP8[$36 >> 0] | 0;
     $38 = $37 << 24 >> 24;
     $39 = $33 + $38 | 0;
     $40 = $39 + 1 | 0;
     $41 = $3;
     $42 = $2;
     $43 = $41 + $42 | 0;
     $44 = HEAP8[$43 >> 0] | 0;
     $45 = $44 << 24 >> 24;
     HEAP32[$vararg_buffer5 >> 2] = $40;
     $vararg_ptr8 = $vararg_buffer5 + 4 | 0;
     HEAP32[$vararg_ptr8 >> 2] = $45;
     _printf(34739, $vararg_buffer5) | 0;
     $46 = $2;
     $47 = $46 + 1 | 0;
     $2 = $47;
     break;
    }
   case 96:
    {
     $48 = $2;
     $49 = $3;
     $50 = $2;
     $51 = $49 + $50 | 0;
     $52 = HEAP8[$51 >> 0] | 0;
     $53 = $52 << 24 >> 24;
     $54 = $48 + $53 | 0;
     $55 = $54 + 1 | 0;
     $56 = $3;
     $57 = $2;
     $58 = $56 + $57 | 0;
     $59 = HEAP8[$58 >> 0] | 0;
     $60 = $59 << 24 >> 24;
     HEAP32[$vararg_buffer9 >> 2] = $55;
     $vararg_ptr12 = $vararg_buffer9 + 4 | 0;
     HEAP32[$vararg_ptr12 >> 2] = $60;
     _printf(34755, $vararg_buffer9) | 0;
     $61 = $2;
     $62 = $61 + 1 | 0;
     $2 = $62;
     break;
    }
   case 1:
    {
     $63 = $3;
     $64 = $2;
     $65 = $64 + 1 | 0;
     $2 = $65;
     $66 = $63 + $64 | 0;
     $67 = HEAP8[$66 >> 0] | 0;
     $68 = $67 << 24 >> 24;
     HEAP32[$vararg_buffer13 >> 2] = $68;
     _printf(34768, $vararg_buffer13) | 0;
     break;
    }
   case 2:
    {
     _printf(34777, $vararg_buffer16) | 0;
     break;
    }
   case 4:
   case 3:
    {
     $69 = $3;
     $70 = $2;
     $71 = $69 + $70 | 0;
     $72 = HEAP8[$71 >> 0] | 0;
     $73 = $72 << 24 >> 24;
     $4 = $73;
     $74 = $3;
     $75 = $2;
     $76 = $75 - 1 | 0;
     $77 = $74 + $76 | 0;
     $78 = HEAP8[$77 >> 0] | 0;
     $79 = $78 << 24 >> 24;
     $80 = ($79 | 0) == 4;
     $81 = $80 ? 34782 : 41653;
     $82 = $4;
     HEAP32[$vararg_buffer18 >> 2] = $81;
     $vararg_ptr21 = $vararg_buffer18 + 4 | 0;
     HEAP32[$vararg_ptr21 >> 2] = $82;
     _printf(34786, $vararg_buffer18) | 0;
     $83 = $2;
     $84 = $83 + 1 | 0;
     $2 = $84;
     while (1) {
      $85 = $4;
      $86 = $85 + -1 | 0;
      $4 = $86;
      $87 = ($85 | 0) != 0;
      if (!$87) {
       break;
      }
      $88 = $3;
      $89 = $2;
      $90 = $88 + $89 | 0;
      $91 = HEAP8[$90 >> 0] | 0;
      $92 = $91 << 24 >> 24;
      $93 = $3;
      $94 = $2;
      $95 = $94 + 1 | 0;
      $96 = $93 + $95 | 0;
      $97 = HEAP8[$96 >> 0] | 0;
      $98 = $97 << 24 >> 24;
      HEAP32[$vararg_buffer22 >> 2] = $92;
      $vararg_ptr25 = $vararg_buffer22 + 4 | 0;
      HEAP32[$vararg_ptr25 >> 2] = $98;
      _printf(34797, $vararg_buffer22) | 0;
      $99 = $2;
      $100 = $99 + 2 | 0;
      $2 = $100;
     }
     _printf(34812, $vararg_buffer26) | 0;
     break;
    }
   case 5:
    {
     $101 = $3;
     $102 = $2;
     $103 = $102 + 1 | 0;
     $2 = $103;
     $104 = $101 + $102 | 0;
     $105 = HEAP8[$104 >> 0] | 0;
     $106 = $105 << 24 >> 24;
     HEAP32[$vararg_buffer28 >> 2] = $106;
     _printf(34814, $vararg_buffer28) | 0;
     break;
    }
   case 127:
    {
     _printf(34829, $vararg_buffer31) | 0;
     break;
    }
   case 126:
    {
     $107 = $3;
     $108 = $2;
     $109 = $108 + 1 | 0;
     $2 = $109;
     $110 = $107 + $108 | 0;
     $111 = HEAP8[$110 >> 0] | 0;
     $112 = $111 & 255;
     HEAP32[$vararg_buffer33 >> 2] = $112;
     _printf(34836, $vararg_buffer33) | 0;
     break;
    }
   case 80:
    {
     _printf(34845, $vararg_buffer36) | 0;
     break;
    }
   default:
    {
     $18 = $2;
     $19 = $3;
     $20 = $2;
     $21 = $19 + $20 | 0;
     $22 = HEAP8[$21 >> 0] | 0;
     $23 = $22 << 24 >> 24;
     $24 = $18 + $23 | 0;
     $25 = $24 + 1 | 0;
     $26 = $3;
     $27 = $2;
     $28 = $26 + $27 | 0;
     $29 = HEAP8[$28 >> 0] | 0;
     $30 = $29 << 24 >> 24;
     HEAP32[$vararg_buffer1 >> 2] = $25;
     $vararg_ptr4 = $vararg_buffer1 + 4 | 0;
     HEAP32[$vararg_ptr4 >> 2] = $30;
     _printf(34724, $vararg_buffer1) | 0;
     $31 = $2;
     $32 = $31 + 1 | 0;
     $2 = $32;
    }
   }
  } while (0);
 }
 $113 = $1;
 $114 = HEAP32[$113 >> 2] | 0;
 $115 = $1;
 $116 = $115 + 4 | 0;
 $117 = HEAP32[$116 >> 2] | 0;
 HEAP32[$vararg_buffer40 >> 2] = $114;
 $vararg_ptr43 = $vararg_buffer40 + 4 | 0;
 HEAP32[$vararg_ptr43 >> 2] = $117;
 _printf(34869, $vararg_buffer40) | 0;
 STACKTOP = sp;
 return;
}

function _parse_string_literal($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $8 = sp + 8 | 0;
 $2 = $0;
 $11 = $1 & 1;
 $3 = $11;
 $4 = 39;
 $12 = $2;
 $13 = _is_char($12, 34) | 0;
 if ($13) {
  $4 = 34;
 }
 $14 = $2;
 _next_char($14);
 $15 = $2;
 $16 = $4;
 $17 = $4;
 $18 = _is_char_and($15, $16, $17) | 0;
 if ($18) {
  $19 = $2;
  _next_char($19);
  $20 = $2;
  _next_char($20);
  $5 = 3;
 } else {
  $5 = 1;
 }
 $6 = 0;
 L8 : while (1) {
  $21 = $2;
  $22 = _is_end($21) | 0;
  if ($22) {
   break;
  }
  $23 = $5;
  $24 = $23 >>> 0 > 1;
  if (!$24) {
   $25 = $2;
   $26 = _is_char($25, 10) | 0;
   if ($26) {
    break;
   }
  }
  $27 = $6;
  $28 = $5;
  $29 = $27 >>> 0 < $28 >>> 0;
  if (!$29) {
   break;
  }
  $30 = $2;
  $31 = $4;
  $32 = _is_char($30, $31) | 0;
  do {
   if ($32) {
    $33 = $6;
    $34 = $33 + 1 | 0;
    $6 = $34;
    $35 = $2;
    $36 = $35 + 68 | 0;
    $37 = $2;
    $38 = $37 + 16 | 0;
    $39 = HEAP32[$38 >> 2] | 0;
    _vstr_add_char($36, $39);
   } else {
    $6 = 0;
    $40 = $2;
    $41 = _is_char($40, 92) | 0;
    $42 = $2;
    if (!$41) {
     $113 = $42 + 68 | 0;
     $114 = $2;
     $115 = $114 + 16 | 0;
     $116 = HEAP32[$115 >> 2] | 0;
     $117 = $116 & 255;
     _vstr_add_byte($113, $117);
     break;
    }
    _next_char($42);
    $43 = $2;
    $44 = $43 + 16 | 0;
    $45 = HEAP32[$44 >> 2] | 0;
    $7 = $45;
    $46 = $3;
    $47 = $46 & 1;
    L21 : do {
     if ($47) {
      $48 = $2;
      $49 = $48 + 68 | 0;
      _vstr_add_char($49, 92);
     } else {
      $50 = $7;
      do {
       switch ($50 | 0) {
       case 78:
        {
         label = 32;
         break L8;
         break;
        }
       case 34:
       case 39:
       case 92:
        {
         break L21;
         break;
        }
       case 10:
        {
         $7 = -1;
         break L21;
         break;
        }
       case 97:
        {
         $7 = 7;
         break L21;
         break;
        }
       case 98:
        {
         $7 = 8;
         break L21;
         break;
        }
       case 116:
        {
         $7 = 9;
         break L21;
         break;
        }
       case 110:
        {
         $7 = 10;
         break L21;
         break;
        }
       case 118:
        {
         $7 = 11;
         break L21;
         break;
        }
       case 102:
        {
         $7 = 12;
         break L21;
         break;
        }
       case 114:
        {
         $7 = 13;
         break L21;
         break;
        }
       case 85:
       case 117:
        {
         $51 = $2;
         $52 = $51 + 64 | 0;
         $53 = HEAP32[$52 >> 2] | 0;
         $54 = ($53 | 0) == 11;
         if ($54) {
          $55 = $2;
          $56 = $55 + 68 | 0;
          _vstr_add_char($56, 92);
          break L21;
         }
         break;
        }
       case 120:
        {
         break;
        }
       default:
        {
         $68 = $7;
         $69 = $68 >>> 0 >= 48;
         $70 = $7;
         $71 = $70 >>> 0 <= 55;
         $or$cond = $69 & $71;
         if (!$or$cond) {
          $88 = $2;
          $89 = $88 + 68 | 0;
          _vstr_add_char($89, 92);
          break L21;
         }
         $9 = 3;
         $72 = $7;
         $73 = $72 - 48 | 0;
         $10 = $73;
         while (1) {
          $74 = $2;
          $75 = _is_following_odigit($74) | 0;
          if (!$75) {
           break;
          }
          $76 = $9;
          $77 = $76 + -1 | 0;
          $9 = $77;
          $78 = ($77 | 0) != 0;
          if (!$78) {
           break;
          }
          $79 = $2;
          _next_char($79);
          $80 = $10;
          $81 = $80 << 3;
          $82 = $2;
          $83 = $82 + 16 | 0;
          $84 = HEAP32[$83 >> 2] | 0;
          $85 = $84 - 48 | 0;
          $86 = $81 + $85 | 0;
          $10 = $86;
         }
         $87 = $10;
         $7 = $87;
         break L21;
        }
       }
      } while (0);
      HEAP32[$8 >> 2] = 0;
      $57 = $2;
      $58 = $7;
      $59 = ($58 | 0) == 120;
      if ($59) {
       $63 = 2;
      } else {
       $60 = $7;
       $61 = ($60 | 0) == 117;
       $62 = $61 ? 4 : 8;
       $63 = $62;
      }
      $64 = _get_hex($57, $63, $8) | 0;
      if (!$64) {
       $65 = $2;
       $66 = $65 + 64 | 0;
       HEAP32[$66 >> 2] = 1;
      }
      $67 = HEAP32[$8 >> 2] | 0;
      $7 = $67;
     }
    } while (0);
    $90 = $7;
    $91 = ($90 | 0) != -1;
    if ($91) {
     $92 = $7;
     $93 = $92 >>> 0 < 1114112;
     if ($93) {
      $94 = $2;
      $95 = $94 + 64 | 0;
      $96 = HEAP32[$95 >> 2] | 0;
      $97 = ($96 | 0) == 10;
      if ($97) {
       $98 = $2;
       $99 = $98 + 68 | 0;
       $100 = $7;
       _vstr_add_char($99, $100);
       break;
      }
     }
     $101 = $7;
     $102 = $101 >>> 0 < 256;
     if ($102) {
      $103 = $2;
      $104 = $103 + 64 | 0;
      $105 = HEAP32[$104 >> 2] | 0;
      $106 = ($105 | 0) == 11;
      if ($106) {
       $107 = $2;
       $108 = $107 + 68 | 0;
       $109 = $7;
       $110 = $109 & 255;
       _vstr_add_byte($108, $110);
       break;
      }
     }
     $111 = $2;
     $112 = $111 + 64 | 0;
     HEAP32[$112 >> 2] = 1;
    }
   }
  } while (0);
  $118 = $2;
  _next_char($118);
 }
 if ((label | 0) == 32) {
  _mp_raise_NotImplementedError(28603);
 }
 $119 = $6;
 $120 = $5;
 $121 = $119 >>> 0 < $120 >>> 0;
 if (!$121) {
  $124 = $2;
  $125 = $124 + 68 | 0;
  $126 = $6;
  _vstr_cut_tail_bytes($125, $126);
  STACKTOP = sp;
  return;
 }
 $122 = $2;
 $123 = $122 + 64 | 0;
 HEAP32[$123 >> 2] = 3;
 $124 = $2;
 $125 = $124 + 68 | 0;
 $126 = $6;
 _vstr_cut_tail_bytes($125, $126);
 STACKTOP = sp;
 return;
}

function _mp_obj_str_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112 | 0);
 $6 = sp + 92 | 0;
 $7 = sp + 88 | 0;
 $8 = sp + 84 | 0;
 $12 = sp + 68 | 0;
 $13 = sp + 64 | 0;
 $14 = sp + 48 | 0;
 $18 = sp + 28 | 0;
 $19 = sp + 16 | 0;
 $20 = sp;
 $4 = $0;
 $5 = $1;
 HEAP32[$6 >> 2] = $2;
 $21 = $4;
 $22 = ($21 | 0) == 31;
 if ($22) {
  HEAP32[$7 >> 2] = $6;
  HEAP32[$8 >> 2] = 1;
  $9 = 0;
  $23 = HEAP32[$6 >> 2] | 0;
  $24 = _mp_obj_is_obj_1154($23) | 0;
  if ($24) {
   $25 = HEAP32[$6 >> 2] | 0;
   $26 = HEAP32[$25 >> 2] | 0;
   $27 = ($26 | 0) == (18952 | 0);
   if ($27) {
    $28 = HEAP32[$6 >> 2] | 0;
    _mp_obj_tuple_get($28, $8, $7);
   } else {
    label = 5;
   }
  } else {
   label = 5;
  }
  if ((label | 0) == 5) {
   $29 = HEAP32[$6 >> 2] | 0;
   $30 = _mp_obj_is_obj_1154($29) | 0;
   if ($30) {
    $31 = HEAP32[$6 >> 2] | 0;
    $32 = HEAP32[$31 >> 2] | 0;
    $33 = ($32 | 0) == (14112 | 0);
    if ($33) {
     $34 = HEAP32[$6 >> 2] | 0;
     $9 = $34;
    }
   }
  }
  $35 = $5;
  $36 = HEAP32[$8 >> 2] | 0;
  $37 = HEAP32[$7 >> 2] | 0;
  $38 = $9;
  $39 = _str_modulo_format($35, $36, $37, $38) | 0;
  $3 = $39;
  $137 = $3;
  STACKTOP = sp;
  return $137 | 0;
 }
 $40 = $5;
 $41 = _mp_obj_get_type($40) | 0;
 $10 = $41;
 $42 = $5;
 $43 = _mp_obj_is_qstr_1128($42) | 0;
 $44 = $5;
 if ($43) {
  $45 = $44;
  $46 = $45 >>> 2;
  $47 = _qstr_data($46, $12) | 0;
  $11 = $47;
 } else {
  $48 = $44 + 8 | 0;
  $49 = HEAP32[$48 >> 2] | 0;
  HEAP32[$12 >> 2] = $49;
  $50 = $5;
  $51 = $50 + 12 | 0;
  $52 = HEAP32[$51 >> 2] | 0;
  $11 = $52;
 }
 $53 = $4;
 $54 = ($53 | 0) == 28;
 if ($54) {
  $55 = HEAP32[$6 >> 2] | 0;
  $56 = _mp_obj_get_int_maybe($55, $13) | 0;
  if (!$56) {
   $3 = 0;
   $137 = $3;
   STACKTOP = sp;
   return $137 | 0;
  }
  $57 = HEAP32[$13 >> 2] | 0;
  $58 = ($57 | 0) <= 0;
  if (!$58) {
   $61 = HEAP32[$12 >> 2] | 0;
   $62 = HEAP32[$13 >> 2] | 0;
   $63 = Math_imul($61, $62) | 0;
   _vstr_init_len($14, $63);
   $64 = $11;
   $65 = HEAP32[$12 >> 2] | 0;
   $66 = HEAP32[$13 >> 2] | 0;
   $67 = $14 + 8 | 0;
   $68 = HEAP32[$67 >> 2] | 0;
   _mp_seq_multiply($64, 1, $65, $66, $68);
   $69 = $10;
   $70 = _mp_obj_new_str_from_vstr($69, $14) | 0;
   $3 = $70;
   $137 = $3;
   STACKTOP = sp;
   return $137 | 0;
  }
  $59 = $10;
  $60 = ($59 | 0) == (18680 | 0);
  if ($60) {
   $3 = 6;
   $137 = $3;
   STACKTOP = sp;
   return $137 | 0;
  } else {
   $3 = 18288;
   $137 = $3;
   STACKTOP = sp;
   return $137 | 0;
  }
 }
 $71 = $10;
 $72 = HEAP32[$6 >> 2] | 0;
 $73 = _mp_obj_get_type($72) | 0;
 $74 = ($71 | 0) == ($73 | 0);
 do {
  if ($74) {
   $75 = HEAP32[$6 >> 2] | 0;
   $76 = _mp_obj_is_qstr_1128($75) | 0;
   $77 = HEAP32[$6 >> 2] | 0;
   if ($76) {
    $78 = $77;
    $79 = $78 >>> 2;
    $80 = _qstr_data($79, $18) | 0;
    $17 = $80;
   } else {
    $81 = $77 + 8 | 0;
    $82 = HEAP32[$81 >> 2] | 0;
    HEAP32[$18 >> 2] = $82;
    $83 = HEAP32[$6 >> 2] | 0;
    $84 = $83 + 12 | 0;
    $85 = HEAP32[$84 >> 2] | 0;
    $17 = $85;
   }
   $86 = $17;
   $15 = $86;
   $87 = HEAP32[$18 >> 2] | 0;
   $16 = $87;
  } else {
   $88 = $10;
   $89 = ($88 | 0) == (18304 | 0);
   $90 = HEAP32[$6 >> 2] | 0;
   if (!$89) {
    _bad_implicit_conversion($90);
   }
   $91 = _mp_get_buffer($90, $19, 1) | 0;
   if ($91) {
    $92 = HEAP32[$19 >> 2] | 0;
    $15 = $92;
    $93 = $19 + 4 | 0;
    $94 = HEAP32[$93 >> 2] | 0;
    $16 = $94;
    break;
   }
   $3 = 0;
   $137 = $3;
   STACKTOP = sp;
   return $137 | 0;
  }
 } while (0);
 $95 = $4;
 switch ($95 | 0) {
 case 14:
 case 26:
  {
   $96 = HEAP32[$12 >> 2] | 0;
   $97 = ($96 | 0) == 0;
   if ($97) {
    $98 = HEAP32[$6 >> 2] | 0;
    $99 = _mp_obj_get_type($98) | 0;
    $100 = $10;
    $101 = ($99 | 0) == ($100 | 0);
    if ($101) {
     $102 = HEAP32[$6 >> 2] | 0;
     $3 = $102;
     $137 = $3;
     STACKTOP = sp;
     return $137 | 0;
    }
   }
   $103 = $16;
   $104 = ($103 | 0) == 0;
   if ($104) {
    $105 = $5;
    $3 = $105;
    $137 = $3;
    STACKTOP = sp;
    return $137 | 0;
   } else {
    $106 = HEAP32[$12 >> 2] | 0;
    $107 = $16;
    $108 = $106 + $107 | 0;
    _vstr_init_len($20, $108);
    $109 = $20 + 8 | 0;
    $110 = HEAP32[$109 >> 2] | 0;
    $111 = $11;
    $112 = HEAP32[$12 >> 2] | 0;
    _memcpy($110 | 0, $111 | 0, $112 | 0) | 0;
    $113 = $20 + 8 | 0;
    $114 = HEAP32[$113 >> 2] | 0;
    $115 = HEAP32[$12 >> 2] | 0;
    $116 = $114 + $115 | 0;
    $117 = $15;
    $118 = $16;
    _memcpy($116 | 0, $117 | 0, $118 | 0) | 0;
    $119 = $10;
    $120 = _mp_obj_new_str_from_vstr($119, $20) | 0;
    $3 = $120;
    $137 = $3;
    STACKTOP = sp;
    return $137 | 0;
   }
   break;
  }
 case 34:
  {
   $121 = $11;
   $122 = HEAP32[$12 >> 2] | 0;
   $123 = $15;
   $124 = $16;
   $125 = _find_subbytes($121, $122, $123, $124, 1) | 0;
   $126 = ($125 | 0) != (0 | 0);
   $127 = $126 & 1;
   $128 = _mp_obj_new_bool_1159($127) | 0;
   $3 = $128;
   $137 = $3;
   STACKTOP = sp;
   return $137 | 0;
   break;
  }
 case 4:
 case 1:
 case 3:
 case 0:
 case 2:
  {
   $129 = $4;
   $130 = $11;
   $131 = HEAP32[$12 >> 2] | 0;
   $132 = $15;
   $133 = $16;
   $134 = _mp_seq_cmp_bytes($129, $130, $131, $132, $133) | 0;
   $135 = $134 & 1;
   $136 = _mp_obj_new_bool_1159($135) | 0;
   $3 = $136;
   $137 = $3;
   STACKTOP = sp;
   return $137 | 0;
   break;
  }
 default:
  {
   $3 = 0;
   $137 = $3;
   STACKTOP = sp;
   return $137 | 0;
  }
 }
 return 0 | 0;
}

function _mp_emit_bc_start_pass($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $spec$store$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $13 = $4;
 $14 = $3;
 $15 = $14 + 5 | 0;
 $16 = $13 & 65535;
 $17 = HEAPU8[$15 >> 0] | HEAPU8[$15 + 1 >> 0] << 8;
 $18 = $16 & 255;
 $19 = $17 & -256;
 $20 = $19 | $18;
 HEAP8[$15 >> 0] = $20 & 255;
 HEAP8[$15 + 1 >> 0] = $20 >> 8;
 $21 = $3;
 $22 = $21 + 8 | 0;
 HEAP32[$22 >> 2] = 0;
 $23 = $3;
 $24 = $23 + 5 | 0;
 $25 = HEAPU8[$24 >> 0] | HEAPU8[$24 + 1 >> 0] << 8;
 $26 = $25 & 255;
 HEAP8[$24 >> 0] = $26 & 255;
 HEAP8[$24 + 1 >> 0] = $26 >> 8;
 $27 = $5;
 $28 = $3;
 $29 = $28 + 12 | 0;
 HEAP32[$29 >> 2] = $27;
 $30 = $3;
 $31 = $30 + 16 | 0;
 HEAP32[$31 >> 2] = 0;
 $32 = $3;
 $33 = $32 + 20 | 0;
 HEAP32[$33 >> 2] = 1;
 $34 = $3;
 $35 = $34 + 40 | 0;
 HEAP32[$35 >> 2] = 0;
 $36 = $3;
 $37 = $36 + 32 | 0;
 HEAP32[$37 >> 2] = 0;
 $38 = $5;
 $39 = $38 + 34 | 0;
 $40 = HEAP16[$39 >> 1] | 0;
 $41 = $40 & 65535;
 $42 = $5;
 $43 = $42 + 36 | 0;
 $44 = HEAP16[$43 >> 1] | 0;
 $45 = $44 & 65535;
 $46 = $41 + $45 | 0;
 $6 = $46;
 $47 = $6;
 $48 = ($47 | 0) == 0;
 $spec$store$select = $48 ? 1 : $46;
 $6 = $spec$store$select;
 $49 = $3;
 $50 = $6;
 _emit_write_code_info_uint($49, $50);
 $51 = $3;
 $52 = $5;
 $53 = $52 + 38 | 0;
 $54 = HEAP16[$53 >> 1] | 0;
 $55 = $54 & 65535;
 _emit_write_code_info_uint($51, $55);
 $56 = $3;
 $57 = $3;
 $58 = $57 + 12 | 0;
 $59 = HEAP32[$58 >> 2] | 0;
 $60 = $59 + 24 | 0;
 $61 = HEAP16[$60 >> 1] | 0;
 $62 = $61 & 255;
 _emit_write_code_info_byte($56, $62);
 $63 = $3;
 $64 = $3;
 $65 = $64 + 12 | 0;
 $66 = HEAP32[$65 >> 2] | 0;
 $67 = $66 + 28 | 0;
 $68 = HEAP16[$67 >> 1] | 0;
 $69 = $68 & 255;
 _emit_write_code_info_byte($63, $69);
 $70 = $3;
 $71 = $3;
 $72 = $71 + 12 | 0;
 $73 = HEAP32[$72 >> 2] | 0;
 $74 = $73 + 30 | 0;
 $75 = HEAP16[$74 >> 1] | 0;
 $76 = $75 & 255;
 _emit_write_code_info_byte($70, $76);
 $77 = $3;
 $78 = $3;
 $79 = $78 + 12 | 0;
 $80 = HEAP32[$79 >> 2] | 0;
 $81 = $80 + 32 | 0;
 $82 = HEAP16[$81 >> 1] | 0;
 $83 = $82 & 255;
 _emit_write_code_info_byte($77, $83);
 $84 = $4;
 $85 = ($84 | 0) == 4;
 $86 = $3;
 if ($85) {
  $87 = $3;
  $88 = $87 + 36 | 0;
  $89 = HEAP32[$88 >> 2] | 0;
  $90 = $3;
  $91 = $90 + 32 | 0;
  $92 = HEAP32[$91 >> 2] | 0;
  $93 = $89 - $92 | 0;
  _emit_write_code_info_uint($86, $93);
 } else {
  _emit_get_cur_to_write_code_info($86, 2) | 0;
 }
 $94 = $3;
 $95 = $5;
 $96 = $95 + 22 | 0;
 $97 = HEAP16[$96 >> 1] | 0;
 $98 = $97 & 65535;
 _emit_write_code_info_qstr($94, $98);
 $99 = $3;
 $100 = $5;
 $101 = $100 + 20 | 0;
 $102 = HEAP16[$101 >> 1] | 0;
 $103 = $102 & 65535;
 _emit_write_code_info_qstr($99, $103);
 $7 = 0;
 while (1) {
  $104 = $7;
  $105 = $5;
  $106 = $105 + 42 | 0;
  $107 = HEAP16[$106 >> 1] | 0;
  $108 = $107 & 65535;
  $109 = ($104 | 0) < ($108 | 0);
  if (!$109) {
   break;
  }
  $110 = $5;
  $111 = $110 + 44 | 0;
  $112 = HEAP32[$111 >> 2] | 0;
  $113 = $7;
  $114 = $112 + ($113 << 3) | 0;
  $8 = $114;
  $115 = $8;
  $116 = HEAP8[$115 >> 0] | 0;
  $117 = $116 & 255;
  $118 = ($117 | 0) == 4;
  if ($118) {
   $119 = $3;
   $120 = $8;
   $121 = $120 + 2 | 0;
   $122 = HEAP16[$121 >> 1] | 0;
   $123 = $122 & 255;
   _emit_write_bytecode_byte($119, $123);
  }
  $124 = $7;
  $125 = $124 + 1 | 0;
  $7 = $125;
 }
 $126 = $3;
 _emit_write_bytecode_byte($126, -1);
 $127 = $4;
 $128 = ($127 | 0) == 4;
 if (!$128) {
  STACKTOP = sp;
  return;
 }
 $9 = 0;
 while (1) {
  $129 = $9;
  $130 = $5;
  $131 = $130 + 28 | 0;
  $132 = HEAP16[$131 >> 1] | 0;
  $133 = $132 & 65535;
  $134 = $5;
  $135 = $134 + 30 | 0;
  $136 = HEAP16[$135 >> 1] | 0;
  $137 = $136 & 65535;
  $138 = $133 + $137 | 0;
  $139 = ($129 | 0) < ($138 | 0);
  if (!$139) {
   break;
  }
  $10 = 5;
  $11 = 0;
  while (1) {
   $140 = $11;
   $141 = $5;
   $142 = $141 + 42 | 0;
   $143 = HEAP16[$142 >> 1] | 0;
   $144 = $143 & 65535;
   $145 = ($140 | 0) < ($144 | 0);
   if (!$145) {
    break;
   }
   $146 = $5;
   $147 = $146 + 44 | 0;
   $148 = HEAP32[$147 >> 2] | 0;
   $149 = $11;
   $150 = $148 + ($149 << 3) | 0;
   $12 = $150;
   $151 = $12;
   $152 = $151 + 1 | 0;
   $153 = HEAP8[$152 >> 0] | 0;
   $154 = $153 & 255;
   $155 = $154 & 1;
   $156 = ($155 | 0) != 0;
   if ($156) {
    $157 = $12;
    $158 = $157 + 2 | 0;
    $159 = HEAP16[$158 >> 1] | 0;
    $160 = $159 & 65535;
    $161 = $9;
    $162 = ($160 | 0) == ($161 | 0);
    if ($162) {
     label = 16;
     break;
    }
   }
   $166 = $11;
   $167 = $166 + 1 | 0;
   $11 = $167;
  }
  if ((label | 0) == 16) {
   label = 0;
   $163 = $12;
   $164 = $163 + 4 | 0;
   $165 = HEAP32[$164 >> 2] | 0;
   $10 = $165;
  }
  $168 = $10;
  $169 = $168 << 2;
  $170 = $169 | 2;
  $171 = $170;
  $172 = $171;
  $173 = $3;
  $174 = $173 + 52 | 0;
  $175 = HEAP32[$174 >> 2] | 0;
  $176 = $9;
  $177 = $175 + ($176 << 2) | 0;
  HEAP32[$177 >> 2] = $172;
  $178 = $9;
  $179 = $178 + 1 | 0;
  $9 = $179;
 }
 STACKTOP = sp;
 return;
}

function _uzlib_adler32($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $177 = 0, $178 = 0, $179 = 0, $18 = 0, $180 = 0, $181 = 0, $182 = 0, $183 = 0, $184 = 0, $185 = 0, $186 = 0, $187 = 0, $188 = 0, $189 = 0, $19 = 0, $190 = 0, $191 = 0, $192 = 0, $193 = 0, $194 = 0, $195 = 0, $196 = 0, $197 = 0, $198 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $11 = $3;
 $6 = $11;
 $12 = $5;
 $13 = $12 & 65535;
 $7 = $13;
 $14 = $5;
 $15 = $14 >>> 16;
 $8 = $15;
 while (1) {
  $16 = $4;
  $17 = $16 >>> 0 > 0;
  if (!$17) {
   break;
  }
  $18 = $4;
  $19 = $18 >>> 0 < 5552;
  $20 = $4;
  $21 = $19 ? $20 : 5552;
  $9 = $21;
  $22 = $9;
  $23 = ($22 | 0) / 16 & -1;
  $10 = $23;
  while (1) {
   $24 = $10;
   $25 = ($24 | 0) != 0;
   if (!$25) {
    break;
   }
   $26 = $6;
   $27 = HEAP8[$26 >> 0] | 0;
   $28 = $27 & 255;
   $29 = $7;
   $30 = $29 + $28 | 0;
   $7 = $30;
   $31 = $7;
   $32 = $8;
   $33 = $32 + $31 | 0;
   $8 = $33;
   $34 = $6;
   $35 = $34 + 1 | 0;
   $36 = HEAP8[$35 >> 0] | 0;
   $37 = $36 & 255;
   $38 = $7;
   $39 = $38 + $37 | 0;
   $7 = $39;
   $40 = $7;
   $41 = $8;
   $42 = $41 + $40 | 0;
   $8 = $42;
   $43 = $6;
   $44 = $43 + 2 | 0;
   $45 = HEAP8[$44 >> 0] | 0;
   $46 = $45 & 255;
   $47 = $7;
   $48 = $47 + $46 | 0;
   $7 = $48;
   $49 = $7;
   $50 = $8;
   $51 = $50 + $49 | 0;
   $8 = $51;
   $52 = $6;
   $53 = $52 + 3 | 0;
   $54 = HEAP8[$53 >> 0] | 0;
   $55 = $54 & 255;
   $56 = $7;
   $57 = $56 + $55 | 0;
   $7 = $57;
   $58 = $7;
   $59 = $8;
   $60 = $59 + $58 | 0;
   $8 = $60;
   $61 = $6;
   $62 = $61 + 4 | 0;
   $63 = HEAP8[$62 >> 0] | 0;
   $64 = $63 & 255;
   $65 = $7;
   $66 = $65 + $64 | 0;
   $7 = $66;
   $67 = $7;
   $68 = $8;
   $69 = $68 + $67 | 0;
   $8 = $69;
   $70 = $6;
   $71 = $70 + 5 | 0;
   $72 = HEAP8[$71 >> 0] | 0;
   $73 = $72 & 255;
   $74 = $7;
   $75 = $74 + $73 | 0;
   $7 = $75;
   $76 = $7;
   $77 = $8;
   $78 = $77 + $76 | 0;
   $8 = $78;
   $79 = $6;
   $80 = $79 + 6 | 0;
   $81 = HEAP8[$80 >> 0] | 0;
   $82 = $81 & 255;
   $83 = $7;
   $84 = $83 + $82 | 0;
   $7 = $84;
   $85 = $7;
   $86 = $8;
   $87 = $86 + $85 | 0;
   $8 = $87;
   $88 = $6;
   $89 = $88 + 7 | 0;
   $90 = HEAP8[$89 >> 0] | 0;
   $91 = $90 & 255;
   $92 = $7;
   $93 = $92 + $91 | 0;
   $7 = $93;
   $94 = $7;
   $95 = $8;
   $96 = $95 + $94 | 0;
   $8 = $96;
   $97 = $6;
   $98 = $97 + 8 | 0;
   $99 = HEAP8[$98 >> 0] | 0;
   $100 = $99 & 255;
   $101 = $7;
   $102 = $101 + $100 | 0;
   $7 = $102;
   $103 = $7;
   $104 = $8;
   $105 = $104 + $103 | 0;
   $8 = $105;
   $106 = $6;
   $107 = $106 + 9 | 0;
   $108 = HEAP8[$107 >> 0] | 0;
   $109 = $108 & 255;
   $110 = $7;
   $111 = $110 + $109 | 0;
   $7 = $111;
   $112 = $7;
   $113 = $8;
   $114 = $113 + $112 | 0;
   $8 = $114;
   $115 = $6;
   $116 = $115 + 10 | 0;
   $117 = HEAP8[$116 >> 0] | 0;
   $118 = $117 & 255;
   $119 = $7;
   $120 = $119 + $118 | 0;
   $7 = $120;
   $121 = $7;
   $122 = $8;
   $123 = $122 + $121 | 0;
   $8 = $123;
   $124 = $6;
   $125 = $124 + 11 | 0;
   $126 = HEAP8[$125 >> 0] | 0;
   $127 = $126 & 255;
   $128 = $7;
   $129 = $128 + $127 | 0;
   $7 = $129;
   $130 = $7;
   $131 = $8;
   $132 = $131 + $130 | 0;
   $8 = $132;
   $133 = $6;
   $134 = $133 + 12 | 0;
   $135 = HEAP8[$134 >> 0] | 0;
   $136 = $135 & 255;
   $137 = $7;
   $138 = $137 + $136 | 0;
   $7 = $138;
   $139 = $7;
   $140 = $8;
   $141 = $140 + $139 | 0;
   $8 = $141;
   $142 = $6;
   $143 = $142 + 13 | 0;
   $144 = HEAP8[$143 >> 0] | 0;
   $145 = $144 & 255;
   $146 = $7;
   $147 = $146 + $145 | 0;
   $7 = $147;
   $148 = $7;
   $149 = $8;
   $150 = $149 + $148 | 0;
   $8 = $150;
   $151 = $6;
   $152 = $151 + 14 | 0;
   $153 = HEAP8[$152 >> 0] | 0;
   $154 = $153 & 255;
   $155 = $7;
   $156 = $155 + $154 | 0;
   $7 = $156;
   $157 = $7;
   $158 = $8;
   $159 = $158 + $157 | 0;
   $8 = $159;
   $160 = $6;
   $161 = $160 + 15 | 0;
   $162 = HEAP8[$161 >> 0] | 0;
   $163 = $162 & 255;
   $164 = $7;
   $165 = $164 + $163 | 0;
   $7 = $165;
   $166 = $7;
   $167 = $8;
   $168 = $167 + $166 | 0;
   $8 = $168;
   $169 = $10;
   $170 = $169 + -1 | 0;
   $10 = $170;
   $171 = $6;
   $172 = $171 + 16 | 0;
   $6 = $172;
  }
  $173 = $9;
  $174 = ($173 | 0) % 16 & -1;
  $10 = $174;
  while (1) {
   $175 = $10;
   $176 = ($175 | 0) != 0;
   if (!$176) {
    break;
   }
   $177 = $6;
   $178 = $177 + 1 | 0;
   $6 = $178;
   $179 = HEAP8[$177 >> 0] | 0;
   $180 = $179 & 255;
   $181 = $7;
   $182 = $181 + $180 | 0;
   $7 = $182;
   $183 = $7;
   $184 = $8;
   $185 = $184 + $183 | 0;
   $8 = $185;
   $186 = $10;
   $187 = $186 + -1 | 0;
   $10 = $187;
  }
  $188 = $7;
  $189 = ($188 >>> 0) % 65521 & -1;
  $7 = $189;
  $190 = $8;
  $191 = ($190 >>> 0) % 65521 & -1;
  $8 = $191;
  $192 = $9;
  $193 = $4;
  $194 = $193 - $192 | 0;
  $4 = $194;
 }
 $195 = $8;
 $196 = $195 << 16;
 $197 = $7;
 $198 = $196 | $197;
 STACKTOP = sp;
 return $198 | 0;
}

function _recursiveloop($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 L1 : while (1) {
  $13 = $6;
  $14 = HEAP8[$13 >> 0] | 0;
  $15 = $14 << 24 >> 24;
  $16 = ($15 | 0) < 80;
  if ($16) {
   $17 = $7;
   $18 = $8;
   $19 = $18 + 4 | 0;
   $20 = HEAP32[$19 >> 2] | 0;
   $21 = $17 >>> 0 >= $20 >>> 0;
   if ($21) {
    label = 4;
    break;
   }
  }
  $22 = $6;
  $23 = $22 + 1 | 0;
  $6 = $23;
  $24 = HEAP8[$22 >> 0] | 0;
  $25 = $24 << 24 >> 24;
  do {
   switch ($25 | 0) {
   case 127:
    {
     label = 15;
     break L1;
     break;
    }
   case 1:
    {
     $26 = $7;
     $27 = HEAP8[$26 >> 0] | 0;
     $28 = $27 << 24 >> 24;
     $29 = $6;
     $30 = $29 + 1 | 0;
     $6 = $30;
     $31 = HEAP8[$29 >> 0] | 0;
     $32 = $31 << 24 >> 24;
     $33 = ($28 | 0) != ($32 | 0);
     if ($33) {
      label = 7;
      break L1;
     }
     break;
    }
   case 2:
    {
     break;
    }
   case 4:
   case 3:
    {
     $36 = $6;
     $37 = $7;
     $38 = __re1_5_classmatch($36, $37) | 0;
     $39 = ($38 | 0) != 0;
     if (!$39) {
      label = 10;
      break L1;
     }
     $40 = $6;
     $41 = HEAP8[$40 >> 0] | 0;
     $42 = $41 & 255;
     $43 = $42 << 1;
     $44 = $43 + 1 | 0;
     $45 = $6;
     $46 = $45 + $44 | 0;
     $6 = $46;
     $47 = $7;
     $48 = $47 + 1 | 0;
     $7 = $48;
     continue L1;
     break;
    }
   case 5:
    {
     $49 = $6;
     $50 = $7;
     $51 = __re1_5_namedclassmatch($49, $50) | 0;
     $52 = ($51 | 0) != 0;
     if (!$52) {
      label = 13;
      break L1;
     }
     $53 = $6;
     $54 = $53 + 1 | 0;
     $6 = $54;
     $55 = $7;
     $56 = $55 + 1 | 0;
     $7 = $56;
     continue L1;
     break;
    }
   case 96:
    {
     $57 = $6;
     $58 = $57 + 1 | 0;
     $6 = $58;
     $59 = HEAP8[$57 >> 0] | 0;
     $60 = $59 << 24 >> 24;
     $12 = $60;
     $61 = $6;
     $62 = $12;
     $63 = $61 + $62 | 0;
     $6 = $63;
     continue L1;
     break;
    }
   case 97:
    {
     $64 = $6;
     $65 = $64 + 1 | 0;
     $6 = $65;
     $66 = HEAP8[$64 >> 0] | 0;
     $67 = $66 << 24 >> 24;
     $12 = $67;
     $68 = $6;
     $69 = $7;
     $70 = $8;
     $71 = $9;
     $72 = $10;
     $73 = _recursiveloop($68, $69, $70, $71, $72) | 0;
     $74 = ($73 | 0) != 0;
     if ($74) {
      label = 18;
      break L1;
     }
     $75 = $6;
     $76 = $12;
     $77 = $75 + $76 | 0;
     $6 = $77;
     continue L1;
     break;
    }
   case 98:
    {
     $78 = $6;
     $79 = $78 + 1 | 0;
     $6 = $79;
     $80 = HEAP8[$78 >> 0] | 0;
     $81 = $80 << 24 >> 24;
     $12 = $81;
     $82 = $6;
     $83 = $12;
     $84 = $82 + $83 | 0;
     $85 = $7;
     $86 = $8;
     $87 = $9;
     $88 = $10;
     $89 = _recursiveloop($84, $85, $86, $87, $88) | 0;
     $90 = ($89 | 0) != 0;
     if ($90) {
      label = 21;
      break L1;
     }
     continue L1;
     break;
    }
   case 126:
    {
     $91 = $6;
     $92 = $91 + 1 | 0;
     $6 = $92;
     $93 = HEAP8[$91 >> 0] | 0;
     $94 = $93 & 255;
     $12 = $94;
     $95 = $12;
     $96 = $10;
     $97 = ($95 | 0) >= ($96 | 0);
     if (!$97) {
      label = 25;
      break L1;
     }
     continue L1;
     break;
    }
   case 80:
    {
     $117 = $7;
     $118 = $8;
     $119 = HEAP32[$118 >> 2] | 0;
     $120 = ($117 | 0) != ($119 | 0);
     if ($120) {
      label = 29;
      break L1;
     }
     continue L1;
     break;
    }
   case 81:
    {
     $121 = $7;
     $122 = $8;
     $123 = $122 + 4 | 0;
     $124 = HEAP32[$123 >> 2] | 0;
     $125 = ($121 | 0) != ($124 | 0);
     if ($125) {
      label = 32;
      break L1;
     }
     continue L1;
     break;
    }
   default:
    {
     continue L1;
    }
   }
  } while (0);
  $34 = $7;
  $35 = $34 + 1 | 0;
  $7 = $35;
 }
 switch (label | 0) {
 case 4:
  {
   $5 = 0;
   $126 = $5;
   STACKTOP = sp;
   return $126 | 0;
   break;
  }
 case 7:
  {
   $5 = 0;
   $126 = $5;
   STACKTOP = sp;
   return $126 | 0;
   break;
  }
 case 10:
  {
   $5 = 0;
   $126 = $5;
   STACKTOP = sp;
   return $126 | 0;
   break;
  }
 case 13:
  {
   $5 = 0;
   $126 = $5;
   STACKTOP = sp;
   return $126 | 0;
   break;
  }
 case 15:
  {
   $5 = 1;
   $126 = $5;
   STACKTOP = sp;
   return $126 | 0;
   break;
  }
 case 18:
  {
   $5 = 1;
   $126 = $5;
   STACKTOP = sp;
   return $126 | 0;
   break;
  }
 case 21:
  {
   $5 = 1;
   $126 = $5;
   STACKTOP = sp;
   return $126 | 0;
   break;
  }
 case 25:
  {
   $98 = $9;
   $99 = $12;
   $100 = $98 + ($99 << 2) | 0;
   $101 = HEAP32[$100 >> 2] | 0;
   $11 = $101;
   $102 = $7;
   $103 = $9;
   $104 = $12;
   $105 = $103 + ($104 << 2) | 0;
   HEAP32[$105 >> 2] = $102;
   $106 = $6;
   $107 = $7;
   $108 = $8;
   $109 = $9;
   $110 = $10;
   $111 = _recursiveloop($106, $107, $108, $109, $110) | 0;
   $112 = ($111 | 0) != 0;
   if ($112) {
    $5 = 1;
    $126 = $5;
    STACKTOP = sp;
    return $126 | 0;
   } else {
    $113 = $11;
    $114 = $9;
    $115 = $12;
    $116 = $114 + ($115 << 2) | 0;
    HEAP32[$116 >> 2] = $113;
    $5 = 0;
    $126 = $5;
    STACKTOP = sp;
    return $126 | 0;
   }
   break;
  }
 case 29:
  {
   $5 = 0;
   $126 = $5;
   STACKTOP = sp;
   return $126 | 0;
   break;
  }
 case 32:
  {
   $5 = 0;
   $126 = $5;
   STACKTOP = sp;
   return $126 | 0;
   break;
  }
 }
 return 0 | 0;
}

function _stream_read_generic($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(96 | 0);
 $9 = sp + 56 | 0;
 $13 = sp + 36 | 0;
 $18 = sp + 8 | 0;
 $19 = sp + 4 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $21 = $4;
 $22 = ($21 | 0) == 1;
 if (!$22) {
  $23 = $5;
  $24 = $23 + 4 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = _mp_obj_get_int($25) | 0;
  $7 = $26;
  $27 = ($26 | 0) == -1;
  if (!$27) {
   $31 = $5;
   $32 = HEAP32[$31 >> 2] | 0;
   $33 = _mp_get_stream($32) | 0;
   $8 = $33;
   $34 = $8;
   $35 = $34 + 12 | 0;
   $36 = HEAP8[$35 >> 0] | 0;
   $37 = $36 & 1;
   $38 = $37 & 255;
   $39 = ($38 | 0) != 0;
   $40 = $7;
   if (!$39) {
    _vstr_init_len($18, $40);
    $119 = $5;
    $120 = HEAP32[$119 >> 2] | 0;
    $121 = $18 + 8 | 0;
    $122 = HEAP32[$121 >> 2] | 0;
    $123 = $7;
    $124 = $6;
    $125 = _mp_stream_rw($120, $122, $123, $19, $124) | 0;
    $20 = $125;
    $126 = HEAP32[$19 >> 2] | 0;
    $127 = ($126 | 0) != 0;
    if (!$127) {
     $133 = $20;
     $134 = $18 + 4 | 0;
     HEAP32[$134 >> 2] = $133;
     $135 = $8;
     $136 = $135 + 12 | 0;
     $137 = HEAP8[$136 >> 0] | 0;
     $138 = $137 & 1;
     $139 = $138 & 255;
     $140 = ($139 | 0) != 0;
     $141 = $140 ? 18680 : 18304;
     $142 = _mp_obj_new_str_from_vstr($141, $18) | 0;
     $3 = $142;
     $143 = $3;
     STACKTOP = sp;
     return $143 | 0;
    }
    _vstr_clear($18);
    $128 = HEAP32[$19 >> 2] | 0;
    $129 = ($128 | 0) == 11;
    $130 = HEAP32[$19 >> 2] | 0;
    $131 = ($130 | 0) == 11;
    $or$cond3 = $129 | $131;
    if (!$or$cond3) {
     $132 = HEAP32[$19 >> 2] | 0;
     _mp_raise_OSError($132);
    }
    $3 = 17668;
    $143 = $3;
    STACKTOP = sp;
    return $143 | 0;
   }
   _vstr_init($9, $40);
   $41 = $7;
   $10 = $41;
   $11 = 0;
   while (1) {
    $42 = $10;
    $43 = $42 >>> 0 > 0;
    if (!$43) {
     break;
    }
    $44 = $10;
    $45 = _vstr_add_len($9, $44) | 0;
    $12 = $45;
    $46 = $5;
    $47 = HEAP32[$46 >> 2] | 0;
    $48 = $12;
    $49 = $10;
    $50 = _mp_stream_rw($47, $48, $49, $13, 0) | 0;
    $14 = $50;
    $51 = HEAP32[$13 >> 2] | 0;
    $52 = ($51 | 0) != 0;
    if ($52) {
     label = 8;
     break;
    }
    $62 = $14;
    $63 = $10;
    $64 = $62 >>> 0 < $63 >>> 0;
    if ($64) {
     $65 = $10;
     $66 = $14;
     $67 = $65 - $66 | 0;
     _vstr_cut_tail_bytes($9, $67);
     $68 = $14;
     $69 = ($68 | 0) == 0;
     if ($69) {
      break;
     }
    }
    $70 = $11;
    $15 = $70;
    while (1) {
     $71 = $9 + 8 | 0;
     $72 = HEAP32[$71 >> 2] | 0;
     $73 = $15;
     $74 = $72 + $73 | 0;
     $75 = HEAP8[$74 >> 0] | 0;
     $16 = $75;
     $76 = $16;
     $77 = $76 & 255;
     $78 = $77 & 128;
     $79 = ($78 | 0) != 0;
     do {
      if ($79) {
       $80 = $16;
       $81 = $80 & 255;
       $82 = $81 & 224;
       $83 = ($82 | 0) == 192;
       if ($83) {
        $17 = 2;
        break;
       }
       $84 = $16;
       $85 = $84 & 255;
       $86 = $85 & 240;
       $87 = ($86 | 0) == 224;
       if ($87) {
        $17 = 3;
        break;
       }
       $88 = $16;
       $89 = $88 & 255;
       $90 = $89 & 248;
       $91 = ($90 | 0) == 240;
       if ($91) {
        $17 = 4;
        break;
       } else {
        $17 = 5;
        break;
       }
      } else {
       $17 = 1;
      }
     } while (0);
     $92 = $15;
     $93 = $17;
     $94 = $92 + $93 | 0;
     $95 = $9 + 4 | 0;
     $96 = HEAP32[$95 >> 2] | 0;
     $97 = $94 >>> 0 <= $96 >>> 0;
     if (!$97) {
      label = 27;
      break;
     }
     $98 = $17;
     $99 = $15;
     $100 = $99 + $98 | 0;
     $15 = $100;
     $101 = $7;
     $102 = $101 - 1 | 0;
     $7 = $102;
     $103 = $15;
     $11 = $103;
     $104 = $15;
     $105 = $9 + 4 | 0;
     $106 = HEAP32[$105 >> 2] | 0;
     $107 = $104 >>> 0 >= $106 >>> 0;
     if ($107) {
      label = 26;
      break;
     }
    }
    if ((label | 0) == 26) {
     label = 0;
     $108 = $7;
     $10 = $108;
    } else if ((label | 0) == 27) {
     label = 0;
     $109 = $15;
     $110 = $17;
     $111 = $109 + $110 | 0;
     $112 = $9 + 4 | 0;
     $113 = HEAP32[$112 >> 2] | 0;
     $114 = $111 - $113 | 0;
     $115 = $7;
     $116 = $115 - 1 | 0;
     $117 = $114 + $116 | 0;
     $10 = $117;
    }
   }
   if ((label | 0) == 8) {
    $53 = $10;
    _vstr_cut_tail_bytes($9, $53);
    $54 = HEAP32[$13 >> 2] | 0;
    $55 = ($54 | 0) == 11;
    $56 = HEAP32[$13 >> 2] | 0;
    $57 = ($56 | 0) == 11;
    $or$cond = $55 | $57;
    if (!$or$cond) {
     $61 = HEAP32[$13 >> 2] | 0;
     _mp_raise_OSError($61);
    }
    $58 = $9 + 4 | 0;
    $59 = HEAP32[$58 >> 2] | 0;
    $60 = ($59 | 0) == 0;
    if ($60) {
     _vstr_clear($9);
     $3 = 17668;
     $143 = $3;
     STACKTOP = sp;
     return $143 | 0;
    }
   }
   $118 = _mp_obj_new_str_from_vstr(18680, $9) | 0;
   $3 = $118;
   $143 = $3;
   STACKTOP = sp;
   return $143 | 0;
  }
 }
 $28 = $5;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = _stream_readall($29) | 0;
 $3 = $30;
 $143 = $3;
 STACKTOP = sp;
 return $143 | 0;
}

function _mp_compile_to_raw_code($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, dest = 0, label = 0, sp = 0, stop = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112 | 0);
 $8 = sp + 48 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $21 = $3 & 1;
 $7 = $21;
 dest = $8;
 stop = dest + 44 | 0;
 do {
  HEAP32[dest >> 2] = 0 | 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 $9 = $8;
 $22 = $5;
 $23 = $9;
 HEAP32[$23 >> 2] = $22;
 $24 = $7;
 $25 = $24 & 1;
 $26 = $25 & 1;
 $27 = $9;
 $28 = $27 + 4 | 0;
 HEAP8[$28 >> 0] = $26;
 $29 = $9;
 $30 = $29 + 24 | 0;
 HEAP16[$30 >> 1] = -1;
 $31 = $9;
 $32 = $31 + 26 | 0;
 HEAP16[$32 >> 1] = -1;
 $33 = $9;
 $34 = $4;
 $35 = HEAP32[$34 >> 2] | 0;
 $36 = $6;
 $37 = _scope_new_and_link($33, 0, $35, $36) | 0;
 $10 = $37;
 $38 = _emit_bc_new() | 0;
 $11 = $38;
 $39 = $11;
 $40 = $9;
 $41 = $40 + 40 | 0;
 HEAP32[$41 >> 2] = $39;
 $12 = 0;
 $42 = $9;
 $43 = $42 + 32 | 0;
 $44 = HEAP32[$43 >> 2] | 0;
 $13 = $44;
 while (1) {
  $45 = $13;
  $46 = ($45 | 0) != (0 | 0);
  if ($46) {
   $47 = $9;
   $48 = $47 + 8 | 0;
   $49 = HEAP32[$48 >> 2] | 0;
   $50 = ($49 | 0) == (0 | 0);
   $171 = $50;
  } else {
   $171 = 0;
  }
  $51 = $9;
  if (!$171) {
   break;
  }
  $52 = $13;
  _compile_scope($51, $52, 1);
  $14 = 0;
  while (1) {
   $53 = $14;
   $54 = $13;
   $55 = $54 + 42 | 0;
   $56 = HEAP16[$55 >> 1] | 0;
   $57 = $56 & 65535;
   $58 = $53 >>> 0 < $57 >>> 0;
   if (!$58) {
    break;
   }
   $59 = $13;
   $60 = $59 + 44 | 0;
   $61 = HEAP32[$60 >> 2] | 0;
   $62 = $14;
   $63 = $61 + ($62 << 3) | 0;
   $15 = $63;
   $64 = $15;
   $65 = HEAP8[$64 >> 0] | 0;
   $66 = $65 & 255;
   $67 = ($66 | 0) == 1;
   if ($67) {
    $68 = $13;
    $69 = $15;
    _scope_check_to_close_over($68, $69);
   }
   $70 = $14;
   $71 = $70 + 1 | 0;
   $14 = $71;
  }
  $72 = $9;
  $73 = $72 + 16 | 0;
  $74 = HEAP32[$73 >> 2] | 0;
  $75 = $12;
  $76 = $74 >>> 0 > $75 >>> 0;
  if ($76) {
   $77 = $9;
   $78 = $77 + 16 | 0;
   $79 = HEAP32[$78 >> 2] | 0;
   $12 = $79;
  }
  $80 = $13;
  $81 = $80 + 8 | 0;
  $82 = HEAP32[$81 >> 2] | 0;
  $13 = $82;
 }
 $83 = $51 + 32 | 0;
 $84 = HEAP32[$83 >> 2] | 0;
 $16 = $84;
 while (1) {
  $85 = $16;
  $86 = ($85 | 0) != (0 | 0);
  if (!$86) {
   break;
  }
  $87 = $9;
  $88 = $87 + 8 | 0;
  $89 = HEAP32[$88 >> 2] | 0;
  $90 = ($89 | 0) == (0 | 0);
  if (!$90) {
   break;
  }
  $91 = $16;
  _scope_compute_things($91);
  $92 = $16;
  $93 = $92 + 8 | 0;
  $94 = HEAP32[$93 >> 2] | 0;
  $16 = $94;
 }
 $95 = $11;
 $96 = $12;
 _emit_bc_set_max_num_labels($95, $96);
 $97 = $9;
 $98 = $97 + 32 | 0;
 $99 = HEAP32[$98 >> 2] | 0;
 $17 = $99;
 while (1) {
  $100 = $17;
  $101 = ($100 | 0) != (0 | 0);
  if (!$101) {
   break;
  }
  $102 = $9;
  $103 = $102 + 8 | 0;
  $104 = HEAP32[$103 >> 2] | 0;
  $105 = ($104 | 0) == (0 | 0);
  if (!$105) {
   break;
  }
  $106 = $11;
  $107 = $9;
  $108 = $107 + 40 | 0;
  HEAP32[$108 >> 2] = $106;
  $109 = $9;
  $110 = $17;
  _compile_scope($109, $110, 2);
  $111 = $9;
  $112 = $111 + 8 | 0;
  $113 = HEAP32[$112 >> 2] | 0;
  $114 = ($113 | 0) == (0 | 0);
  if ($114) {
   $115 = $9;
   $116 = $17;
   _compile_scope($115, $116, 3);
  }
  $117 = $9;
  $118 = $117 + 8 | 0;
  $119 = HEAP32[$118 >> 2] | 0;
  $120 = ($119 | 0) == (0 | 0);
  if ($120) {
   $121 = $9;
   $122 = $17;
   _compile_scope($121, $122, 4);
  }
  $123 = $17;
  $124 = $123 + 8 | 0;
  $125 = HEAP32[$124 >> 2] | 0;
  $17 = $125;
 }
 $126 = $9;
 $127 = $126 + 8 | 0;
 $128 = HEAP32[$127 >> 2] | 0;
 $129 = ($128 | 0) != (0 | 0);
 if ($129) {
  $130 = $9;
  $131 = $9;
  $132 = $131 + 36 | 0;
  $133 = HEAP32[$132 >> 2] | 0;
  $134 = $133 + 12 | 0;
  $135 = HEAP32[$134 >> 2] | 0;
  _compile_error_set_line($130, $135);
  $136 = $9;
  $137 = $136 + 8 | 0;
  $138 = HEAP32[$137 >> 2] | 0;
  $139 = $9;
  $140 = HEAP32[$139 >> 2] | 0;
  $141 = $9;
  $142 = $141 + 12 | 0;
  $143 = HEAP32[$142 >> 2] | 0;
  $144 = $9;
  $145 = $144 + 36 | 0;
  $146 = HEAP32[$145 >> 2] | 0;
  $147 = $146 + 22 | 0;
  $148 = HEAP16[$147 >> 1] | 0;
  $149 = $148 & 65535;
  _mp_obj_exception_add_traceback($138, $140, $143, $149);
 }
 $150 = $11;
 _emit_bc_free($150);
 $151 = $4;
 _mp_parse_tree_clear($151);
 $152 = $10;
 $153 = $152 + 16 | 0;
 $154 = HEAP32[$153 >> 2] | 0;
 $18 = $154;
 $155 = $10;
 $19 = $155;
 while (1) {
  $156 = $19;
  $157 = ($156 | 0) != (0 | 0);
  if (!$157) {
   break;
  }
  $158 = $19;
  $159 = $158 + 8 | 0;
  $160 = HEAP32[$159 >> 2] | 0;
  $20 = $160;
  $161 = $19;
  _scope_free($161);
  $162 = $20;
  $19 = $162;
 }
 $163 = $9;
 $164 = $163 + 8 | 0;
 $165 = HEAP32[$164 >> 2] | 0;
 $166 = ($165 | 0) != (0 | 0);
 if ($166) {
  $167 = $9;
  $168 = $167 + 8 | 0;
  $169 = HEAP32[$168 >> 2] | 0;
  _nlr_jump($169);
 } else {
  $170 = $18;
  STACKTOP = sp;
  return $170 | 0;
 }
 return 0 | 0;
}

function _mpz_set_from_float($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0.0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $165 = 0, $166 = 0, $167 = 0, $168 = 0, $169 = 0, $17 = 0, $170 = 0, $171 = 0, $172 = 0, $173 = 0, $174 = 0, $175 = 0, $176 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0.0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = sp + 8 | 0;
 $10 = sp;
 $2 = $0;
 $3 = $1;
 $11 = $3;
 HEAPF64[$4 >> 3] = $11;
 $12 = $4;
 $13 = $12;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $12 + 4 | 0;
 $16 = $15;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = _bitshift64Lshr($14 | 0, $17 | 0, 63) | 0;
 $19 = getTempRet0() | 0;
 $20 = $2;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $18 & 1;
 $23 = $21 & -2;
 $24 = $23 | $22;
 HEAP32[$20 >> 2] = $24;
 $25 = $4;
 $26 = $25;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = $25 + 4 | 0;
 $29 = $28;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = _bitshift64Lshr($27 | 0, $30 | 0, 52) | 0;
 $32 = getTempRet0() | 0;
 $33 = $31 & 2047;
 $34 = ($33 | 0) == 0;
 if ($34) {
  $35 = $2;
  _mpz_set_from_int($35, 0);
  STACKTOP = sp;
  return;
 }
 $36 = $4;
 $37 = $36;
 $38 = HEAP32[$37 >> 2] | 0;
 $39 = $36 + 4 | 0;
 $40 = $39;
 $41 = HEAP32[$40 >> 2] | 0;
 $42 = _bitshift64Lshr($38 | 0, $41 | 0, 52) | 0;
 $43 = getTempRet0() | 0;
 $44 = $42 & 2047;
 $45 = ($44 | 0) == 2047;
 if ($45) {
  $46 = $2;
  _mpz_set_from_int($46, 0);
  STACKTOP = sp;
  return;
 }
 $47 = $4;
 $48 = $47;
 $49 = HEAP32[$48 >> 2] | 0;
 $50 = $47 + 4 | 0;
 $51 = $50;
 $52 = HEAP32[$51 >> 2] | 0;
 $53 = _bitshift64Lshr($49 | 0, $52 | 0, 52) | 0;
 $54 = getTempRet0() | 0;
 $55 = $53 & 2047;
 $56 = $55 - 1023 | 0;
 $5 = $56;
 $57 = $5;
 $58 = ($57 | 0) < 0;
 if ($58) {
  $59 = $2;
  _mpz_set_from_int($59, 0);
  STACKTOP = sp;
  return;
 }
 $60 = $5;
 $61 = ($60 | 0) == 0;
 if ($61) {
  $62 = $2;
  _mpz_set_from_int($62, 1);
  STACKTOP = sp;
  return;
 }
 $63 = $5;
 $64 = $63 + 1 | 0;
 $65 = $64 + 15 | 0;
 $66 = ($65 | 0) / 16 & -1;
 $6 = $66;
 $67 = $5;
 $68 = ($67 | 0) % 16 & -1;
 $7 = $68;
 $69 = $4;
 $70 = $69;
 $71 = HEAP32[$70 >> 2] | 0;
 $72 = $69 + 4 | 0;
 $73 = $72;
 $74 = HEAP32[$73 >> 2] | 0;
 $75 = $74 & 1048575;
 $76 = $75 | 1048576;
 $77 = $10;
 $78 = $77;
 HEAP32[$78 >> 2] = $71;
 $79 = $77 + 4 | 0;
 $80 = $79;
 HEAP32[$80 >> 2] = $76;
 $81 = $5;
 $82 = ($81 | 0) < 52;
 if ($82) {
  $9 = 0;
  $8 = 0;
  $83 = $5;
  $84 = 52 - $83 | 0;
  $85 = $10;
  $86 = $85;
  $87 = HEAP32[$86 >> 2] | 0;
  $88 = $85 + 4 | 0;
  $89 = $88;
  $90 = HEAP32[$89 >> 2] | 0;
  $91 = _bitshift64Lshr($87 | 0, $90 | 0, $84 | 0) | 0;
  $92 = getTempRet0() | 0;
  $93 = $10;
  $94 = $93;
  HEAP32[$94 >> 2] = $91;
  $95 = $93 + 4 | 0;
  $96 = $95;
  HEAP32[$96 >> 2] = $92;
 } else {
  $97 = $7;
  $98 = $97 - 52 | 0;
  $99 = ($98 >>> 0) % 16 & -1;
  $9 = $99;
  $100 = $5;
  $101 = $100 - 52 | 0;
  $102 = ($101 | 0) / 16 & -1;
  $8 = $102;
 }
 $103 = $2;
 $104 = $6;
 _mpz_need_dig($103, $104);
 $105 = $6;
 $106 = $2;
 $107 = $106 + 4 | 0;
 HEAP32[$107 >> 2] = $105;
 $108 = $8;
 $109 = ($108 | 0) != 0;
 if ($109) {
  $110 = $2;
  $111 = $110 + 8 | 0;
  $112 = HEAP32[$111 >> 2] | 0;
  $113 = $8;
  $114 = $113 << 1;
  _memset($112 | 0, 0, $114 | 0) | 0;
 }
 $115 = $9;
 $116 = ($115 | 0) != 0;
 if ($116) {
  $117 = $10;
  $118 = $117;
  $119 = HEAP32[$118 >> 2] | 0;
  $120 = $117 + 4 | 0;
  $121 = $120;
  $122 = HEAP32[$121 >> 2] | 0;
  $123 = $9;
  $124 = _bitshift64Shl($119 | 0, $122 | 0, $123 | 0) | 0;
  $125 = getTempRet0() | 0;
  $126 = $124 & 65535;
  $127 = $126 & 65535;
  $128 = $2;
  $129 = $128 + 8 | 0;
  $130 = HEAP32[$129 >> 2] | 0;
  $131 = $8;
  $132 = $131 + 1 | 0;
  $8 = $132;
  $133 = $130 + ($131 << 1) | 0;
  HEAP16[$133 >> 1] = $127;
  $134 = $9;
  $135 = 16 - $134 | 0;
  $136 = $10;
  $137 = $136;
  $138 = HEAP32[$137 >> 2] | 0;
  $139 = $136 + 4 | 0;
  $140 = $139;
  $141 = HEAP32[$140 >> 2] | 0;
  $142 = _bitshift64Lshr($138 | 0, $141 | 0, $135 | 0) | 0;
  $143 = getTempRet0() | 0;
  $144 = $10;
  $145 = $144;
  HEAP32[$145 >> 2] = $142;
  $146 = $144 + 4 | 0;
  $147 = $146;
  HEAP32[$147 >> 2] = $143;
 }
 while (1) {
  $148 = $8;
  $149 = $6;
  $150 = ($148 | 0) != ($149 | 0);
  if (!$150) {
   break;
  }
  $151 = $10;
  $152 = $151;
  $153 = HEAP32[$152 >> 2] | 0;
  $154 = $151 + 4 | 0;
  $155 = $154;
  $156 = HEAP32[$155 >> 2] | 0;
  $157 = $153 & 65535;
  $158 = $157 & 65535;
  $159 = $2;
  $160 = $159 + 8 | 0;
  $161 = HEAP32[$160 >> 2] | 0;
  $162 = $8;
  $163 = $162 + 1 | 0;
  $8 = $163;
  $164 = $161 + ($162 << 1) | 0;
  HEAP16[$164 >> 1] = $158;
  $165 = $10;
  $166 = $165;
  $167 = HEAP32[$166 >> 2] | 0;
  $168 = $165 + 4 | 0;
  $169 = $168;
  $170 = HEAP32[$169 >> 2] | 0;
  $171 = _bitshift64Lshr($167 | 0, $170 | 0, 16) | 0;
  $172 = getTempRet0() | 0;
  $173 = $10;
  $174 = $173;
  HEAP32[$174 >> 2] = $171;
  $175 = $173 + 4 | 0;
  $176 = $175;
  HEAP32[$176 >> 2] = $172;
 }
 STACKTOP = sp;
 return;
}

function _push_result_token($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $2 = $0;
 $3 = $1;
 $12 = $2;
 $13 = $12 + 24 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $5 = $14;
 $15 = $5;
 $16 = $15 + 64 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = ($17 | 0) == 7;
 $19 = $5;
 if ($18) {
  $20 = $19 + 68 | 0;
  $21 = $20 + 8 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $5;
  $24 = $23 + 68 | 0;
  $25 = $24 + 4 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = _qstr_from_strn($22, $26) | 0;
  $6 = $27;
  $28 = $3;
  $29 = $28 & 255;
  $30 = ($29 | 0) == 142;
  if ($30) {
   $31 = $2;
   $32 = $31 + 40 | 0;
   $33 = $6;
   $34 = $33 << 2;
   $35 = $34 | 2;
   $36 = $35;
   $37 = _mp_map_lookup($32, $36, 0) | 0;
   $7 = $37;
   $38 = ($37 | 0) != (0 | 0);
   if ($38) {
    $39 = $7;
    $40 = $39 + 4 | 0;
    $41 = HEAP32[$40 >> 2] | 0;
    $42 = _mp_obj_is_small_int_558($41) | 0;
    $43 = $2;
    if ($42) {
     $44 = $7;
     $45 = $44 + 4 | 0;
     $46 = HEAP32[$45 >> 2] | 0;
     $47 = _mp_parse_node_new_small_int_checked($43, $46) | 0;
     $4 = $47;
     $150 = $2;
     $151 = $4;
     _push_result_node($150, $151);
     STACKTOP = sp;
     return;
    } else {
     $48 = $5;
     $49 = $48 + 56 | 0;
     $50 = HEAP32[$49 >> 2] | 0;
     $51 = $7;
     $52 = $51 + 4 | 0;
     $53 = HEAP32[$52 >> 2] | 0;
     $54 = _make_node_const_object($43, $50, $53) | 0;
     $4 = $54;
     $150 = $2;
     $151 = $4;
     _push_result_node($150, $151);
     STACKTOP = sp;
     return;
    }
   }
  }
  $55 = $6;
  $56 = _mp_parse_node_new_leaf(2, $55) | 0;
  $4 = $56;
  $150 = $2;
  $151 = $4;
  _push_result_node($150, $151);
  STACKTOP = sp;
  return;
 }
 $57 = $19 + 64 | 0;
 $58 = HEAP32[$57 >> 2] | 0;
 $59 = ($58 | 0) == 8;
 $60 = $5;
 if ($59) {
  $61 = $60 + 68 | 0;
  $62 = $61 + 8 | 0;
  $63 = HEAP32[$62 >> 2] | 0;
  $64 = $5;
  $65 = $64 + 68 | 0;
  $66 = $65 + 4 | 0;
  $67 = HEAP32[$66 >> 2] | 0;
  $68 = $5;
  $69 = _mp_parse_num_integer($63, $67, 0, $68) | 0;
  $8 = $69;
  $70 = $8;
  $71 = _mp_obj_is_small_int_558($70) | 0;
  $72 = $2;
  if ($71) {
   $73 = $8;
   $74 = _mp_parse_node_new_small_int_checked($72, $73) | 0;
   $4 = $74;
   $150 = $2;
   $151 = $4;
   _push_result_node($150, $151);
   STACKTOP = sp;
   return;
  } else {
   $75 = $5;
   $76 = $75 + 56 | 0;
   $77 = HEAP32[$76 >> 2] | 0;
   $78 = $8;
   $79 = _make_node_const_object($72, $77, $78) | 0;
   $4 = $79;
   $150 = $2;
   $151 = $4;
   _push_result_node($150, $151);
   STACKTOP = sp;
   return;
  }
 }
 $80 = $60 + 64 | 0;
 $81 = HEAP32[$80 >> 2] | 0;
 $82 = ($81 | 0) == 9;
 $83 = $5;
 if ($82) {
  $84 = $83 + 68 | 0;
  $85 = $84 + 8 | 0;
  $86 = HEAP32[$85 >> 2] | 0;
  $87 = $5;
  $88 = $87 + 68 | 0;
  $89 = $88 + 4 | 0;
  $90 = HEAP32[$89 >> 2] | 0;
  $91 = $5;
  $92 = _mp_parse_num_decimal($86, $90, 1, 0, $91) | 0;
  $9 = $92;
  $93 = $2;
  $94 = $5;
  $95 = $94 + 56 | 0;
  $96 = HEAP32[$95 >> 2] | 0;
  $97 = $9;
  $98 = _make_node_const_object($93, $96, $97) | 0;
  $4 = $98;
  $150 = $2;
  $151 = $4;
  _push_result_node($150, $151);
  STACKTOP = sp;
  return;
 }
 $99 = $83 + 64 | 0;
 $100 = HEAP32[$99 >> 2] | 0;
 $101 = ($100 | 0) == 10;
 if (!$101) {
  $102 = $5;
  $103 = $102 + 64 | 0;
  $104 = HEAP32[$103 >> 2] | 0;
  $105 = ($104 | 0) == 11;
  if (!$105) {
   $146 = $5;
   $147 = $146 + 64 | 0;
   $148 = HEAP32[$147 >> 2] | 0;
   $149 = _mp_parse_node_new_leaf(14, $148) | 0;
   $4 = $149;
   $150 = $2;
   $151 = $4;
   _push_result_node($150, $151);
   STACKTOP = sp;
   return;
  }
 }
 $10 = 0;
 $106 = $5;
 $107 = $106 + 68 | 0;
 $108 = $107 + 4 | 0;
 $109 = HEAP32[$108 >> 2] | 0;
 $110 = $109 >>> 0 <= 10;
 $111 = $5;
 $112 = $111 + 68 | 0;
 $113 = $112 + 8 | 0;
 $114 = HEAP32[$113 >> 2] | 0;
 $115 = $5;
 $116 = $115 + 68 | 0;
 $117 = $116 + 4 | 0;
 $118 = HEAP32[$117 >> 2] | 0;
 if ($110) {
  $119 = _qstr_from_strn($114, $118) | 0;
  $10 = $119;
 } else {
  $120 = _qstr_find_strn($114, $118) | 0;
  $10 = $120;
 }
 $121 = $10;
 $122 = ($121 | 0) != 0;
 $123 = $5;
 $124 = $123 + 64 | 0;
 $125 = HEAP32[$124 >> 2] | 0;
 $126 = ($125 | 0) == 10;
 if ($122) {
  $127 = $126 ? 6 : 10;
  $128 = $10;
  $129 = _mp_parse_node_new_leaf($127, $128) | 0;
  $4 = $129;
  $150 = $2;
  $151 = $4;
  _push_result_node($150, $151);
  STACKTOP = sp;
  return;
 } else {
  $130 = $126 ? 18680 : 18304;
  $131 = $5;
  $132 = $131 + 68 | 0;
  $133 = $132 + 8 | 0;
  $134 = HEAP32[$133 >> 2] | 0;
  $135 = $5;
  $136 = $135 + 68 | 0;
  $137 = $136 + 4 | 0;
  $138 = HEAP32[$137 >> 2] | 0;
  $139 = _mp_obj_new_str_copy($130, $134, $138) | 0;
  $11 = $139;
  $140 = $2;
  $141 = $5;
  $142 = $141 + 56 | 0;
  $143 = HEAP32[$142 >> 2] | 0;
  $144 = $11;
  $145 = _make_node_const_object($140, $143, $144) | 0;
  $4 = $145;
  $150 = $2;
  $151 = $4;
  _push_result_node($150, $151);
  STACKTOP = sp;
  return;
 }
}

function _compile_try_except($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $9 = $4;
 $20 = $5;
 $21 = _comp_next_label($20) | 0;
 $10 = $21;
 $22 = $5;
 $23 = _comp_next_label($22) | 0;
 $11 = $23;
 $24 = $5;
 $25 = $10;
 _compile_increase_except_level($24, $25, 2);
 $26 = $5;
 $27 = $6;
 _compile_node($26, $27);
 $28 = $5;
 $29 = $28 + 40 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = $11;
 _mp_emit_bc_pop_except_jump($30, $31, 0);
 $32 = $5;
 $33 = $32 + 40 | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = $10;
 _mp_emit_bc_label_assign($34, $35);
 $36 = $5;
 $37 = $36 + 40 | 0;
 $38 = HEAP32[$37 >> 2] | 0;
 _mp_emit_bc_start_except_handler($38);
 $39 = $5;
 $40 = _comp_next_label($39) | 0;
 $12 = $40;
 $13 = 0;
 while (1) {
  $41 = $13;
  $42 = $7;
  $43 = ($41 | 0) < ($42 | 0);
  if (!$43) {
   label = 19;
   break;
  }
  $44 = $8;
  $45 = $13;
  $46 = $44 + ($45 << 2) | 0;
  $47 = HEAP32[$46 >> 2] | 0;
  $48 = $47;
  $14 = $48;
  $15 = 0;
  $49 = $5;
  $50 = _comp_next_label($49) | 0;
  $16 = $50;
  $51 = $14;
  $52 = $51 + 8 | 0;
  $53 = HEAP32[$52 >> 2] | 0;
  $54 = ($53 | 0) == 0;
  if ($54) {
   $55 = $13;
   $56 = $55 + 1 | 0;
   $57 = $7;
   $58 = ($56 | 0) != ($57 | 0);
   if ($58) {
    label = 5;
    break;
   }
  } else {
   $65 = $14;
   $66 = $65 + 8 | 0;
   $67 = HEAP32[$66 >> 2] | 0;
   $17 = $67;
   $68 = $17;
   $69 = ($68 | 0) != 0;
   if ($69) {
    $70 = $17;
    $71 = $70 & 3;
    $72 = ($71 | 0) == 0;
    if ($72) {
     $73 = $17;
     $74 = $73;
     $18 = $74;
     $75 = $18;
     $76 = $75 + 4 | 0;
     $77 = HEAP32[$76 >> 2] | 0;
     $78 = $77 & 255;
     $79 = ($78 | 0) == 117;
     if ($79) {
      $80 = $18;
      $81 = $80 + 8 | 0;
      $82 = HEAP32[$81 >> 2] | 0;
      $17 = $82;
      $83 = $18;
      $84 = $83 + 8 | 0;
      $85 = $84 + 4 | 0;
      $86 = HEAP32[$85 >> 2] | 0;
      $87 = $86 >>> 4;
      $15 = $87;
     }
    }
   }
   $88 = $5;
   $89 = $88 + 40 | 0;
   $90 = HEAP32[$89 >> 2] | 0;
   _mp_emit_bc_dup_top($90);
   $91 = $5;
   $92 = $17;
   _compile_node($91, $92);
   $93 = $5;
   $94 = $93 + 40 | 0;
   $95 = HEAP32[$94 >> 2] | 0;
   _mp_emit_bc_binary_op($95, 8);
   $96 = $5;
   $97 = $96 + 40 | 0;
   $98 = HEAP32[$97 >> 2] | 0;
   $99 = $16;
   _mp_emit_bc_pop_jump_if($98, 0, $99);
  }
  $100 = $15;
  $101 = ($100 | 0) == 0;
  $102 = $5;
  if ($101) {
   $103 = $102 + 40 | 0;
   $104 = HEAP32[$103 >> 2] | 0;
   _mp_emit_bc_pop_top($104);
  } else {
   $105 = $15;
   _compile_store_id($102, $105);
  }
  $19 = 0;
  $106 = $15;
  $107 = ($106 | 0) != 0;
  if ($107) {
   $108 = $5;
   $109 = _comp_next_label($108) | 0;
   $19 = $109;
   $110 = $5;
   $111 = $19;
   _compile_increase_except_level($110, $111, 3);
  }
  $112 = $5;
  $113 = $14;
  $114 = $113 + 8 | 0;
  $115 = $114 + 4 | 0;
  $116 = HEAP32[$115 >> 2] | 0;
  _compile_node($112, $116);
  $117 = $15;
  $118 = ($117 | 0) != 0;
  if ($118) {
   $119 = $5;
   $120 = $119 + 40 | 0;
   $121 = HEAP32[$120 >> 2] | 0;
   _mp_emit_bc_load_const_tok($121, 14);
   $122 = $5;
   $123 = $122 + 40 | 0;
   $124 = HEAP32[$123 >> 2] | 0;
   $125 = $19;
   _mp_emit_bc_label_assign($124, $125);
   $126 = $5;
   $127 = $126 + 40 | 0;
   $128 = HEAP32[$127 >> 2] | 0;
   _mp_emit_bc_load_const_tok($128, 14);
   $129 = $5;
   $130 = $15;
   _compile_store_id($129, $130);
   $131 = $5;
   $132 = $15;
   _compile_delete_id($131, $132);
   $133 = $5;
   _compile_decrease_except_level($133);
  }
  $134 = $5;
  $135 = $134 + 40 | 0;
  $136 = HEAP32[$135 >> 2] | 0;
  $137 = $12;
  _mp_emit_bc_pop_except_jump($136, $137, 1);
  $138 = $5;
  $139 = $138 + 40 | 0;
  $140 = HEAP32[$139 >> 2] | 0;
  $141 = $16;
  _mp_emit_bc_label_assign($140, $141);
  $142 = $5;
  $143 = $142 + 40 | 0;
  $144 = HEAP32[$143 >> 2] | 0;
  _mp_emit_bc_adjust_stack_size($144, 1);
  $145 = $13;
  $146 = $145 + 1 | 0;
  $13 = $146;
 }
 if ((label | 0) == 5) {
  $59 = $5;
  $60 = $8;
  $61 = $13;
  $62 = $60 + ($61 << 2) | 0;
  $63 = HEAP32[$62 >> 2] | 0;
  _compile_syntax_error($59, $63, 29173);
  $64 = $5;
  _compile_decrease_except_level($64);
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 19) {
  $147 = $5;
  _compile_decrease_except_level($147);
  $148 = $5;
  $149 = $148 + 40 | 0;
  $150 = HEAP32[$149 >> 2] | 0;
  _mp_emit_bc_end_except_handler($150);
  $151 = $5;
  $152 = $151 + 40 | 0;
  $153 = HEAP32[$152 >> 2] | 0;
  $154 = $11;
  _mp_emit_bc_label_assign($153, $154);
  $155 = $5;
  $156 = $9;
  _compile_node($155, $156);
  $157 = $5;
  $158 = $157 + 40 | 0;
  $159 = HEAP32[$158 >> 2] | 0;
  $160 = $12;
  _mp_emit_bc_label_assign($159, $160);
  STACKTOP = sp;
  return;
 }
}

function _c_if_cond($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = $0;
 $5 = $1;
 $13 = $2 & 1;
 $6 = $13;
 $7 = $3;
 $14 = $5;
 $15 = _mp_parse_node_is_const_false($14) | 0;
 if ($15) {
  $16 = $6;
  $17 = $16 & 1;
  $18 = $17 & 1;
  $19 = ($18 | 0) == 0;
  if (!$19) {
   STACKTOP = sp;
   return;
  }
  $20 = $4;
  $21 = $20 + 40 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $7;
  _mp_emit_bc_jump($22, $23);
  STACKTOP = sp;
  return;
 }
 $24 = $5;
 $25 = _mp_parse_node_is_const_true($24) | 0;
 if ($25) {
  $26 = $6;
  $27 = $26 & 1;
  $28 = $27 & 1;
  $29 = ($28 | 0) == 1;
  if (!$29) {
   STACKTOP = sp;
   return;
  }
  $30 = $4;
  $31 = $30 + 40 | 0;
  $32 = HEAP32[$31 >> 2] | 0;
  $33 = $7;
  _mp_emit_bc_jump($32, $33);
  STACKTOP = sp;
  return;
 }
 $34 = $5;
 $35 = ($34 | 0) != 0;
 L15 : do {
  if ($35) {
   $36 = $5;
   $37 = $36 & 3;
   $38 = ($37 | 0) == 0;
   if ($38) {
    $39 = $5;
    $40 = $39;
    $8 = $40;
    $41 = $8;
    $42 = $41 + 4 | 0;
    $43 = HEAP32[$42 >> 2] | 0;
    $44 = $43 >>> 8;
    $9 = $44;
    $45 = $8;
    $46 = $45 + 4 | 0;
    $47 = HEAP32[$46 >> 2] | 0;
    $48 = $47 & 255;
    $49 = ($48 | 0) == 29;
    do {
     if ($49) {
      $50 = $6;
      $51 = $50 & 1;
      $52 = $51 & 1;
      $53 = ($52 | 0) == 0;
      if (!$53) {
       label = 15;
      }
     } else {
      $97 = $8;
      $98 = $97 + 4 | 0;
      $99 = HEAP32[$98 >> 2] | 0;
      $100 = $99 & 255;
      $101 = ($100 | 0) == 30;
      if ($101) {
       $102 = $6;
       $103 = $102 & 1;
       $104 = $103 & 1;
       $105 = ($104 | 0) == 0;
       if ($105) {
        label = 15;
        break;
       } else {
        break;
       }
      }
      $106 = $8;
      $107 = $106 + 4 | 0;
      $108 = HEAP32[$107 >> 2] | 0;
      $109 = $108 & 255;
      $110 = ($109 | 0) == 31;
      if ($110) {
       $111 = $4;
       $112 = $8;
       $113 = $112 + 8 | 0;
       $114 = HEAP32[$113 >> 2] | 0;
       $115 = $6;
       $116 = $115 & 1;
       $117 = $116 ^ 1;
       $118 = $7;
       _c_if_cond($111, $114, $117, $118);
       STACKTOP = sp;
       return;
      }
      $119 = $8;
      $120 = $119 + 4 | 0;
      $121 = HEAP32[$120 >> 2] | 0;
      $122 = $121 & 255;
      $123 = ($122 | 0) == 44;
      if (!$123) {
       break L15;
      }
      $124 = $8;
      $125 = $124 + 8 | 0;
      $126 = HEAP32[$125 >> 2] | 0;
      $127 = ($126 | 0) == 0;
      $128 = $6;
      $129 = $128 & 1;
      $130 = $129 & 1;
      if ($127) {
       $131 = ($130 | 0) == 0;
       if (!$131) {
        STACKTOP = sp;
        return;
       }
       $132 = $4;
       $133 = $132 + 40 | 0;
       $134 = HEAP32[$133 >> 2] | 0;
       $135 = $7;
       _mp_emit_bc_jump($134, $135);
       STACKTOP = sp;
       return;
      } else {
       $136 = ($130 | 0) == 1;
       if (!$136) {
        STACKTOP = sp;
        return;
       }
       $137 = $4;
       $138 = $137 + 40 | 0;
       $139 = HEAP32[$138 >> 2] | 0;
       $140 = $7;
       _mp_emit_bc_jump($139, $140);
       STACKTOP = sp;
       return;
      }
     }
    } while (0);
    if ((label | 0) == 15) {
     $12 = 0;
     while (1) {
      $83 = $12;
      $84 = $9;
      $85 = ($83 | 0) < ($84 | 0);
      if (!$85) {
       break;
      }
      $86 = $4;
      $87 = $8;
      $88 = $87 + 8 | 0;
      $89 = $12;
      $90 = $88 + ($89 << 2) | 0;
      $91 = HEAP32[$90 >> 2] | 0;
      $92 = $6;
      $93 = $92 & 1;
      $94 = $7;
      _c_if_cond($86, $91, $93, $94);
      $95 = $12;
      $96 = $95 + 1 | 0;
      $12 = $96;
     }
     STACKTOP = sp;
     return;
    }
    $54 = $4;
    $55 = _comp_next_label($54) | 0;
    $10 = $55;
    $11 = 0;
    while (1) {
     $56 = $11;
     $57 = $9;
     $58 = $57 - 1 | 0;
     $59 = ($56 | 0) < ($58 | 0);
     $60 = $4;
     $61 = $8;
     $62 = $61 + 8 | 0;
     if (!$59) {
      break;
     }
     $63 = $11;
     $64 = $62 + ($63 << 2) | 0;
     $65 = HEAP32[$64 >> 2] | 0;
     $66 = $6;
     $67 = $66 & 1;
     $68 = $67 ^ 1;
     $69 = $10;
     _c_if_cond($60, $65, $68, $69);
     $70 = $11;
     $71 = $70 + 1 | 0;
     $11 = $71;
    }
    $72 = $9;
    $73 = $72 - 1 | 0;
    $74 = $62 + ($73 << 2) | 0;
    $75 = HEAP32[$74 >> 2] | 0;
    $76 = $6;
    $77 = $76 & 1;
    $78 = $7;
    _c_if_cond($60, $75, $77, $78);
    $79 = $4;
    $80 = $79 + 40 | 0;
    $81 = HEAP32[$80 >> 2] | 0;
    $82 = $10;
    _mp_emit_bc_label_assign($81, $82);
    STACKTOP = sp;
    return;
   }
  }
 } while (0);
 $141 = $4;
 $142 = $5;
 _compile_node($141, $142);
 $143 = $4;
 $144 = $143 + 40 | 0;
 $145 = HEAP32[$144 >> 2] | 0;
 $146 = $6;
 $147 = $146 & 1;
 $148 = $7;
 _mp_emit_bc_pop_jump_if($145, $147, $148);
 STACKTOP = sp;
 return;
}

function _mp_unpack_ex($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $vararg_buffer = sp;
 $8 = sp + 36 | 0;
 $10 = sp + 28 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $17 = $4;
 $18 = $17 & 255;
 $6 = $18;
 $19 = $4;
 $20 = $19 >>> 8;
 $21 = $20 & 255;
 $7 = $21;
 $22 = $3;
 $23 = _mp_obj_is_obj_729($22) | 0;
 if ($23) {
  $24 = $3;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = ($25 | 0) == (18952 | 0);
  if (!$26) {
   label = 3;
  }
 } else {
  label = 3;
 }
 do {
  if ((label | 0) == 3) {
   $27 = $3;
   $28 = _mp_obj_is_obj_729($27) | 0;
   if ($28) {
    $29 = $3;
    $30 = HEAP32[$29 >> 2] | 0;
    $31 = ($30 | 0) == (17028 | 0);
    if ($31) {
     break;
    }
   }
   $84 = $3;
   $85 = _mp_getiter($84, 0) | 0;
   $13 = $85;
   HEAP32[$8 >> 2] = 0;
   while (1) {
    $86 = HEAP32[$8 >> 2] | 0;
    $87 = $6;
    $88 = $86 >>> 0 < $87 >>> 0;
    if (!$88) {
     break;
    }
    $89 = $13;
    $90 = _mp_iternext($89) | 0;
    $14 = $90;
    $91 = $14;
    $92 = ($91 | 0) == (0 | 0);
    if ($92) {
     label = 26;
     break;
    }
    $93 = $14;
    $94 = $5;
    $95 = $6;
    $96 = $7;
    $97 = $95 + $96 | 0;
    $98 = $97 + 1 | 0;
    $99 = $98 - 1 | 0;
    $100 = HEAP32[$8 >> 2] | 0;
    $101 = $99 - $100 | 0;
    $102 = $94 + ($101 << 2) | 0;
    HEAP32[$102 >> 2] = $93;
    $103 = HEAP32[$8 >> 2] | 0;
    $104 = $103 + 1 | 0;
    HEAP32[$8 >> 2] = $104;
   }
   if ((label | 0) == 26) {
    $147 = HEAP32[$8 >> 2] | 0;
    HEAP32[$vararg_buffer >> 2] = $147;
    $148 = _mp_obj_new_exception_msg_varg(16072, 29829, $vararg_buffer) | 0;
    _nlr_jump($148);
   }
   $105 = _mp_obj_new_list(0, 0) | 0;
   $15 = $105;
   while (1) {
    $106 = $13;
    $107 = _mp_iternext($106) | 0;
    $14 = $107;
    $108 = ($107 | 0) != (0 | 0);
    $109 = $15;
    if (!$108) {
     break;
    }
    $110 = $14;
    _mp_obj_list_append($109, $110) | 0;
   }
   $111 = $109 + 8 | 0;
   $112 = HEAP32[$111 >> 2] | 0;
   $113 = $7;
   $114 = $112 >>> 0 < $113 >>> 0;
   if ($114) {
    $147 = HEAP32[$8 >> 2] | 0;
    HEAP32[$vararg_buffer >> 2] = $147;
    $148 = _mp_obj_new_exception_msg_varg(16072, 29829, $vararg_buffer) | 0;
    _nlr_jump($148);
   }
   $115 = $15;
   $116 = $5;
   $117 = $7;
   $118 = $116 + ($117 << 2) | 0;
   HEAP32[$118 >> 2] = $115;
   $16 = 0;
   while (1) {
    $119 = $16;
    $120 = $7;
    $121 = $119 >>> 0 < $120 >>> 0;
    $122 = $15;
    if (!$121) {
     break;
    }
    $123 = $122 + 12 | 0;
    $124 = HEAP32[$123 >> 2] | 0;
    $125 = $15;
    $126 = $125 + 8 | 0;
    $127 = HEAP32[$126 >> 2] | 0;
    $128 = $7;
    $129 = $127 - $128 | 0;
    $130 = $16;
    $131 = $129 + $130 | 0;
    $132 = $124 + ($131 << 2) | 0;
    $133 = HEAP32[$132 >> 2] | 0;
    $134 = $5;
    $135 = $7;
    $136 = $135 - 1 | 0;
    $137 = $16;
    $138 = $136 - $137 | 0;
    $139 = $134 + ($138 << 2) | 0;
    HEAP32[$139 >> 2] = $133;
    $140 = $16;
    $141 = $140 + 1 | 0;
    $16 = $141;
   }
   $142 = $15;
   $143 = $142 + 8 | 0;
   $144 = HEAP32[$143 >> 2] | 0;
   $145 = $7;
   $146 = $144 - $145 | 0;
   _mp_obj_list_set_len($122, $146);
   STACKTOP = sp;
   return;
  }
 } while (0);
 $32 = $3;
 $9 = $32;
 $33 = $9;
 _mp_obj_get_array($33, $8, $10);
 $34 = HEAP32[$8 >> 2] | 0;
 $35 = $6;
 $36 = $7;
 $37 = $35 + $36 | 0;
 $38 = $34 >>> 0 < $37 >>> 0;
 if ($38) {
  $147 = HEAP32[$8 >> 2] | 0;
  HEAP32[$vararg_buffer >> 2] = $147;
  $148 = _mp_obj_new_exception_msg_varg(16072, 29829, $vararg_buffer) | 0;
  _nlr_jump($148);
 }
 $11 = 0;
 while (1) {
  $39 = $11;
  $40 = $7;
  $41 = $39 >>> 0 < $40 >>> 0;
  if (!$41) {
   break;
  }
  $42 = HEAP32[$10 >> 2] | 0;
  $43 = HEAP32[$8 >> 2] | 0;
  $44 = $43 - 1 | 0;
  $45 = $11;
  $46 = $44 - $45 | 0;
  $47 = $42 + ($46 << 2) | 0;
  $48 = HEAP32[$47 >> 2] | 0;
  $49 = $5;
  $50 = $11;
  $51 = $49 + ($50 << 2) | 0;
  HEAP32[$51 >> 2] = $48;
  $52 = $11;
  $53 = $52 + 1 | 0;
  $11 = $53;
 }
 $54 = HEAP32[$8 >> 2] | 0;
 $55 = $6;
 $56 = $54 - $55 | 0;
 $57 = $7;
 $58 = $56 - $57 | 0;
 $59 = HEAP32[$10 >> 2] | 0;
 $60 = $6;
 $61 = $59 + ($60 << 2) | 0;
 $62 = _mp_obj_new_list($58, $61) | 0;
 $63 = $5;
 $64 = $7;
 $65 = $63 + ($64 << 2) | 0;
 HEAP32[$65 >> 2] = $62;
 $12 = 0;
 while (1) {
  $66 = $12;
  $67 = $6;
  $68 = $66 >>> 0 < $67 >>> 0;
  if (!$68) {
   break;
  }
  $69 = HEAP32[$10 >> 2] | 0;
  $70 = $6;
  $71 = $70 - 1 | 0;
  $72 = $12;
  $73 = $71 - $72 | 0;
  $74 = $69 + ($73 << 2) | 0;
  $75 = HEAP32[$74 >> 2] | 0;
  $76 = $5;
  $77 = $7;
  $78 = $77 + 1 | 0;
  $79 = $12;
  $80 = $78 + $79 | 0;
  $81 = $76 + ($80 << 2) | 0;
  HEAP32[$81 >> 2] = $75;
  $82 = $12;
  $83 = $82 + 1 | 0;
  $12 = $83;
 }
 $9 = 0;
 STACKTOP = sp;
 return;
}

function _mp_obj_float_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0.0, $104 = 0, $105 = 0, $11 = 0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $20 = 0.0, $21 = 0.0, $22 = 0, $23 = 0.0, $24 = 0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $29 = 0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0, $39 = 0, $4 = 0, $40 = 0.0, $41 = 0, $42 = 0, $43 = 0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0, $49 = 0.0, $5 = 0, $50 = 0, $51 = 0.0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0.0, $59 = 0, $6 = 0, $60 = 0.0, $61 = 0.0, $62 = 0.0, $63 = 0, $64 = 0.0, $65 = 0, $66 = 0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0.0, $71 = 0, $72 = 0.0, $73 = 0, $74 = 0, $75 = 0.0, $76 = 0, $77 = 0, $78 = 0.0, $79 = 0.0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0.0, $84 = 0.0, $85 = 0, $86 = 0, $87 = 0, $88 = 0.0, $89 = 0.0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0.0, $94 = 0.0, $95 = 0, $96 = 0, $97 = 0, $98 = 0.0, $99 = 0.0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = sp + 8 | 0;
 $7 = sp;
 $8 = sp + 16 | 0;
 $4 = $0;
 HEAPF64[$5 >> 3] = $1;
 $6 = $2;
 $9 = $6;
 $10 = _mp_obj_get_float_maybe($9, $7) | 0;
 if (!$10) {
  $3 = 0;
  $105 = $3;
  STACKTOP = sp;
  return $105 | 0;
 }
 $11 = $4;
 L5 : do {
  switch ($11 | 0) {
  case 14:
  case 26:
   {
    $12 = +HEAPF64[$7 >> 3];
    $13 = +HEAPF64[$5 >> 3];
    $14 = $13 + $12;
    HEAPF64[$5 >> 3] = $14;
    break;
   }
  case 15:
  case 27:
   {
    $15 = +HEAPF64[$7 >> 3];
    $16 = +HEAPF64[$5 >> 3];
    $17 = $16 - $15;
    HEAPF64[$5 >> 3] = $17;
    break;
   }
  case 16:
  case 28:
   {
    $18 = +HEAPF64[$7 >> 3];
    $19 = +HEAPF64[$5 >> 3];
    $20 = $19 * $18;
    HEAPF64[$5 >> 3] = $20;
    break;
   }
  case 17:
  case 29:
   {
    $21 = +HEAPF64[$7 >> 3];
    $22 = $21 == 0.0;
    if ($22) {
     _mp_raise_msg(15172, 33845);
    } else {
     _mp_obj_float_divmod($5, $7);
     break L5;
    }
    break;
   }
  case 18:
  case 30:
   {
    $23 = +HEAPF64[$7 >> 3];
    $24 = $23 == 0.0;
    if ($24) {
     _mp_raise_msg(15172, 33845);
    } else {
     $25 = +HEAPF64[$7 >> 3];
     $26 = +HEAPF64[$5 >> 3];
     $27 = $26 / $25;
     HEAPF64[$5 >> 3] = $27;
     break L5;
    }
    break;
   }
  case 19:
  case 31:
   {
    $28 = +HEAPF64[$7 >> 3];
    $29 = $28 == 0.0;
    if ($29) {
     _mp_raise_msg(15172, 33845);
    }
    $30 = +HEAPF64[$5 >> 3];
    $31 = +HEAPF64[$7 >> 3];
    $32 = $30 % $31;
    HEAPF64[$5 >> 3] = $32;
    $33 = +HEAPF64[$5 >> 3];
    $34 = $33 == 0.0;
    if ($34) {
     $35 = +HEAPF64[$7 >> 3];
     $36 = +_llvm_copysign_f64(0.0, +$35);
     HEAPF64[$5 >> 3] = $36;
     break L5;
    }
    $37 = +HEAPF64[$5 >> 3];
    $38 = $37 < 0.0;
    $39 = $38 & 1;
    $40 = +HEAPF64[$7 >> 3];
    $41 = $40 < 0.0;
    $42 = $41 & 1;
    $43 = ($39 | 0) != ($42 | 0);
    if ($43) {
     $44 = +HEAPF64[$7 >> 3];
     $45 = +HEAPF64[$5 >> 3];
     $46 = $45 + $44;
     HEAPF64[$5 >> 3] = $46;
    }
    break;
   }
  case 20:
  case 32:
   {
    $47 = +HEAPF64[$5 >> 3];
    $48 = $47 == 0.0;
    $49 = +HEAPF64[$7 >> 3];
    $50 = $49 < 0.0;
    $or$cond = $48 & $50;
    if ($or$cond) {
     $51 = +HEAPF64[$7 >> 3];
     $52 = ___DOUBLE_BITS_968($51) | 0;
     $53 = getTempRet0() | 0;
     $54 = $53 & 2147483647;
     $55 = ($52 | 0) == 0;
     $56 = ($54 | 0) == 2146435072;
     $57 = $55 & $56;
     if (!$57) {
      _mp_raise_msg(15172, 33845);
     }
    }
    $58 = +HEAPF64[$5 >> 3];
    $59 = $58 < 0.0;
    if ($59) {
     $60 = +HEAPF64[$7 >> 3];
     $61 = +HEAPF64[$7 >> 3];
     $62 = +Math_floor(+$61);
     $63 = $60 != $62;
     if ($63) {
      $64 = +HEAPF64[$5 >> 3];
      $65 = $6;
      $66 = _mp_obj_complex_binary_op(32, $64, 0.0, $65) | 0;
      $3 = $66;
      $105 = $3;
      STACKTOP = sp;
      return $105 | 0;
     }
    }
    $67 = +HEAPF64[$5 >> 3];
    $68 = +HEAPF64[$7 >> 3];
    $69 = +Math_pow(+$67, +$68);
    HEAPF64[$5 >> 3] = $69;
    break;
   }
  case 33:
   {
    $70 = +HEAPF64[$7 >> 3];
    $71 = $70 == 0.0;
    if ($71) {
     _mp_raise_msg(15172, 33845);
    }
    _mp_obj_float_divmod($5, $7);
    $72 = +HEAPF64[$5 >> 3];
    $73 = _mp_obj_new_float($72) | 0;
    HEAP32[$8 >> 2] = $73;
    $74 = $8 + 4 | 0;
    $75 = +HEAPF64[$7 >> 3];
    $76 = _mp_obj_new_float($75) | 0;
    HEAP32[$74 >> 2] = $76;
    $77 = _mp_obj_new_tuple(2, $8) | 0;
    $3 = $77;
    $105 = $3;
    STACKTOP = sp;
    return $105 | 0;
    break;
   }
  case 0:
   {
    $78 = +HEAPF64[$5 >> 3];
    $79 = +HEAPF64[$7 >> 3];
    $80 = $78 < $79;
    $81 = $80 & 1;
    $82 = _mp_obj_new_bool_971($81) | 0;
    $3 = $82;
    $105 = $3;
    STACKTOP = sp;
    return $105 | 0;
    break;
   }
  case 1:
   {
    $83 = +HEAPF64[$5 >> 3];
    $84 = +HEAPF64[$7 >> 3];
    $85 = $83 > $84;
    $86 = $85 & 1;
    $87 = _mp_obj_new_bool_971($86) | 0;
    $3 = $87;
    $105 = $3;
    STACKTOP = sp;
    return $105 | 0;
    break;
   }
  case 2:
   {
    $88 = +HEAPF64[$5 >> 3];
    $89 = +HEAPF64[$7 >> 3];
    $90 = $88 == $89;
    $91 = $90 & 1;
    $92 = _mp_obj_new_bool_971($91) | 0;
    $3 = $92;
    $105 = $3;
    STACKTOP = sp;
    return $105 | 0;
    break;
   }
  case 3:
   {
    $93 = +HEAPF64[$5 >> 3];
    $94 = +HEAPF64[$7 >> 3];
    $95 = $93 <= $94;
    $96 = $95 & 1;
    $97 = _mp_obj_new_bool_971($96) | 0;
    $3 = $97;
    $105 = $3;
    STACKTOP = sp;
    return $105 | 0;
    break;
   }
  case 4:
   {
    $98 = +HEAPF64[$5 >> 3];
    $99 = +HEAPF64[$7 >> 3];
    $100 = $98 >= $99;
    $101 = $100 & 1;
    $102 = _mp_obj_new_bool_971($101) | 0;
    $3 = $102;
    $105 = $3;
    STACKTOP = sp;
    return $105 | 0;
    break;
   }
  default:
   {
    $3 = 0;
    $105 = $3;
    STACKTOP = sp;
    return $105 | 0;
   }
  }
 } while (0);
 $103 = +HEAPF64[$5 >> 3];
 $104 = _mp_obj_new_float($103) | 0;
 $3 = $104;
 $105 = $3;
 STACKTOP = sp;
 return $105 | 0;
}

function _mp_obj_class_lookup($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $2 = $0;
 $3 = $1;
 L1 : while (1) {
  $13 = $2;
  $14 = $13 + 8 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = ($15 | 0) != 0;
  if ($16) {
   $17 = $3;
   $18 = $17 + 12 | 0;
   $19 = HEAP32[$18 >> 2] | 0;
   $20 = ($19 | 0) != (515 | 0);
   if ($20) {
    $21 = $3;
    $22 = $2;
    $23 = $22 + 8 | 0;
    $24 = HEAP32[$23 >> 2] | 0;
    $25 = $21 + $24 | 0;
    $26 = HEAP32[$25 >> 2] | 0;
    $27 = ($26 | 0) != (0 | 0);
    if ($27) {
     label = 5;
     break;
    }
   }
  }
  $31 = $3;
  $32 = $31 + 56 | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = ($33 | 0) != (0 | 0);
  if ($34) {
   $35 = $3;
   $36 = $35 + 56 | 0;
   $37 = HEAP32[$36 >> 2] | 0;
   $38 = $37 + 4 | 0;
   $4 = $38;
   $39 = $4;
   $40 = $2;
   $41 = $40 + 4 | 0;
   $42 = HEAP32[$41 >> 2] | 0;
   $43 = $42 << 2;
   $44 = $43 | 2;
   $45 = $44;
   $46 = _mp_map_lookup($39, $45, 0) | 0;
   $5 = $46;
   $47 = $5;
   $48 = ($47 | 0) != (0 | 0);
   if ($48) {
    label = 8;
    break;
   }
  }
  $82 = $2;
  $83 = HEAP32[$82 >> 2] | 0;
  $84 = ($83 | 0) != (0 | 0);
  if ($84) {
   $85 = $2;
   $86 = $85 + 16 | 0;
   $87 = HEAP8[$86 >> 0] | 0;
   $88 = $87 & 1;
   if (!$88) {
    $89 = $3;
    $90 = $89 + 12 | 0;
    $91 = HEAP32[$90 >> 2] | 0;
    $92 = ($91 | 0) != (515 | 0);
    $93 = $3;
    $94 = ($93 | 0) != (17348 | 0);
    $or$cond3 = $92 & $94;
    if ($or$cond3) {
     $95 = $2;
     $96 = HEAP32[$95 >> 2] | 0;
     $97 = $96 + 16 | 0;
     $98 = HEAP32[$97 >> 2] | 0;
     $99 = $2;
     $100 = $99 + 4 | 0;
     $101 = HEAP32[$100 >> 2] | 0;
     $102 = $2;
     $103 = $102 + 12 | 0;
     $104 = HEAP32[$103 >> 2] | 0;
     _mp_load_method_maybe($98, $101, $104);
     $105 = $2;
     $106 = $105 + 12 | 0;
     $107 = HEAP32[$106 >> 2] | 0;
     $108 = HEAP32[$107 >> 2] | 0;
     $109 = ($108 | 0) != (0 | 0);
     if ($109) {
      label = 30;
      break;
     }
    }
   }
  }
  $110 = $3;
  $111 = $110 + 52 | 0;
  $112 = HEAP32[$111 >> 2] | 0;
  $113 = ($112 | 0) == (0 | 0);
  if ($113) {
   label = 30;
   break;
  }
  $114 = $3;
  $115 = $114 + 52 | 0;
  $116 = HEAP32[$115 >> 2] | 0;
  $117 = HEAP32[$116 >> 2] | 0;
  $118 = ($117 | 0) == (18952 | 0);
  $119 = $3;
  $120 = $119 + 52 | 0;
  $121 = HEAP32[$120 >> 2] | 0;
  if ($118) {
   $9 = $121;
   $122 = $9;
   $123 = $122 + 8 | 0;
   $10 = $123;
   $124 = $10;
   $125 = $9;
   $126 = $125 + 4 | 0;
   $127 = HEAP32[$126 >> 2] | 0;
   $128 = $124 + ($127 << 2) | 0;
   $129 = $128 + -4 | 0;
   $11 = $129;
   while (1) {
    $130 = $10;
    $131 = $11;
    $132 = $130 >>> 0 < $131 >>> 0;
    $133 = $10;
    $134 = HEAP32[$133 >> 2] | 0;
    if (!$132) {
     break;
    }
    $12 = $134;
    $135 = $12;
    $136 = ($135 | 0) == (17348 | 0);
    if (!$136) {
     $137 = $2;
     $138 = $12;
     _mp_obj_class_lookup($137, $138);
     $139 = $2;
     $140 = $139 + 12 | 0;
     $141 = HEAP32[$140 >> 2] | 0;
     $142 = HEAP32[$141 >> 2] | 0;
     $143 = ($142 | 0) != (0 | 0);
     if ($143) {
      label = 30;
      break L1;
     }
    }
    $144 = $10;
    $145 = $144 + 4 | 0;
    $10 = $145;
   }
   $3 = $134;
  } else {
   $3 = $121;
  }
  $146 = $3;
  $147 = ($146 | 0) == (17348 | 0);
  if ($147) {
   label = 30;
   break;
  }
 }
 if ((label | 0) == 5) {
  $28 = $2;
  $29 = $28 + 12 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  HEAP32[$30 >> 2] = 4;
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 8) {
  $49 = $2;
  $50 = $49 + 16 | 0;
  $51 = HEAP8[$50 >> 0] | 0;
  $52 = $51 & 1;
  $53 = $2;
  $54 = HEAP32[$53 >> 2] | 0;
  if ($52) {
   $6 = $54;
   $55 = $6;
   $56 = $5;
   $57 = $56 + 4 | 0;
   $58 = HEAP32[$57 >> 2] | 0;
   $59 = $2;
   $60 = $59 + 12 | 0;
   $61 = HEAP32[$60 >> 2] | 0;
   _mp_convert_member_lookup(0, $55, $58, $61);
   STACKTOP = sp;
   return;
  }
  $7 = $54;
  $62 = $7;
  $63 = ($62 | 0) != (0 | 0);
  if ($63) {
   $64 = $3;
   $65 = $64 + 12 | 0;
   $66 = HEAP32[$65 >> 2] | 0;
   $67 = ($66 | 0) != (515 | 0);
   $68 = $3;
   $69 = ($68 | 0) != (17348 | 0);
   $or$cond = $67 & $69;
   if ($or$cond) {
    $70 = $7;
    $71 = $70 + 16 | 0;
    $72 = HEAP32[$71 >> 2] | 0;
    $8 = $72;
   } else {
    label = 13;
   }
  } else {
   label = 13;
  }
  if ((label | 0) == 13) {
   $73 = $7;
   $8 = $73;
  }
  $74 = $8;
  $75 = $3;
  $76 = $5;
  $77 = $76 + 4 | 0;
  $78 = HEAP32[$77 >> 2] | 0;
  $79 = $2;
  $80 = $79 + 12 | 0;
  $81 = HEAP32[$80 >> 2] | 0;
  _mp_convert_member_lookup($74, $75, $78, $81);
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 30) {
  STACKTOP = sp;
  return;
 }
}

function _mp_obj_str_split($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $9 = sp + 20 | 0;
 $12 = sp + 8 | 0;
 $2 = $0;
 $3 = $1;
 $15 = $3;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = _mp_obj_get_type($16) | 0;
 $4 = $17;
 $5 = -1;
 $6 = 17668;
 $18 = $2;
 $19 = $18 >>> 0 > 1;
 if ($19) {
  $20 = $3;
  $21 = $20 + 4 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $6 = $22;
  $23 = $2;
  $24 = $23 >>> 0 > 2;
  if ($24) {
   $25 = $3;
   $26 = $25 + 8 | 0;
   $27 = HEAP32[$26 >> 2] | 0;
   $28 = _mp_obj_get_int($27) | 0;
   $5 = $28;
  }
 }
 $29 = _mp_obj_new_list(0, 0) | 0;
 $7 = $29;
 $30 = $3;
 $31 = HEAP32[$30 >> 2] | 0;
 $32 = _mp_obj_is_qstr_1128($31) | 0;
 $33 = $3;
 $34 = HEAP32[$33 >> 2] | 0;
 if ($32) {
  $35 = $34;
  $36 = $35 >>> 2;
  $37 = _qstr_data($36, $9) | 0;
  $8 = $37;
 } else {
  $38 = $34 + 8 | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  HEAP32[$9 >> 2] = $39;
  $40 = $3;
  $41 = HEAP32[$40 >> 2] | 0;
  $42 = $41 + 12 | 0;
  $43 = HEAP32[$42 >> 2] | 0;
  $8 = $43;
 }
 $44 = $8;
 $45 = HEAP32[$9 >> 2] | 0;
 $46 = $44 + $45 | 0;
 $10 = $46;
 $47 = $6;
 $48 = ($47 | 0) == (17668 | 0);
 if (!$48) {
  $112 = $6;
  $113 = _mp_obj_get_type($112) | 0;
  $114 = $4;
  $115 = ($113 | 0) != ($114 | 0);
  $116 = $6;
  if ($115) {
   _bad_implicit_conversion($116);
  }
  $117 = _mp_obj_str_get_data($116, $12) | 0;
  $13 = $117;
  $118 = HEAP32[$12 >> 2] | 0;
  $119 = ($118 | 0) == 0;
  if ($119) {
   _mp_raise_ValueError(31716);
  }
  while (1) {
   $120 = $8;
   $14 = $120;
   while (1) {
    $121 = $5;
    $122 = ($121 | 0) == 0;
    if ($122) {
     label = 36;
     break;
    }
    $123 = $8;
    $124 = HEAP32[$12 >> 2] | 0;
    $125 = $123 + $124 | 0;
    $126 = $10;
    $127 = $125 >>> 0 > $126 >>> 0;
    if ($127) {
     label = 36;
     break;
    }
    $129 = $8;
    $130 = $13;
    $131 = HEAP32[$12 >> 2] | 0;
    $132 = _memcmp($129, $130, $131) | 0;
    $133 = ($132 | 0) == 0;
    if ($133) {
     break;
    }
    $134 = $8;
    $135 = $134 + 1 | 0;
    $8 = $135;
   }
   if ((label | 0) == 36) {
    label = 0;
    $128 = $10;
    $8 = $128;
   }
   $136 = $7;
   $137 = $4;
   $138 = $14;
   $139 = $8;
   $140 = $14;
   $141 = $139;
   $142 = $140;
   $143 = $141 - $142 | 0;
   $144 = _mp_obj_new_str_of_type($137, $138, $143) | 0;
   _mp_obj_list_append($136, $144) | 0;
   $145 = $8;
   $146 = $10;
   $147 = $145 >>> 0 >= $146 >>> 0;
   if ($147) {
    break;
   }
   $148 = HEAP32[$12 >> 2] | 0;
   $149 = $8;
   $150 = $149 + $148 | 0;
   $8 = $150;
   $151 = $5;
   $152 = ($151 | 0) > 0;
   if ($152) {
    $153 = $5;
    $154 = $153 + -1 | 0;
    $5 = $154;
   }
  }
  $155 = $7;
  STACKTOP = sp;
  return $155 | 0;
 }
 while (1) {
  $49 = $8;
  $50 = $10;
  $51 = $49 >>> 0 < $50 >>> 0;
  if (!$51) {
   break;
  }
  $52 = $8;
  $53 = HEAP8[$52 >> 0] | 0;
  $54 = $53 & 255;
  $55 = _unichar_isspace($54) | 0;
  if (!$55) {
   break;
  }
  $56 = $8;
  $57 = $56 + 1 | 0;
  $8 = $57;
 }
 while (1) {
  $58 = $8;
  $59 = $10;
  $60 = $58 >>> 0 < $59 >>> 0;
  $61 = $5;
  $62 = ($61 | 0) != 0;
  $63 = $60 ? $62 : 0;
  if (!$63) {
   break;
  }
  $64 = $8;
  $11 = $64;
  while (1) {
   $65 = $8;
   $66 = $10;
   $67 = $65 >>> 0 < $66 >>> 0;
   if (!$67) {
    break;
   }
   $68 = $8;
   $69 = HEAP8[$68 >> 0] | 0;
   $70 = $69 & 255;
   $71 = _unichar_isspace($70) | 0;
   $72 = $71 ^ 1;
   if (!$72) {
    break;
   }
   $73 = $8;
   $74 = $73 + 1 | 0;
   $8 = $74;
  }
  $75 = $7;
  $76 = $4;
  $77 = $11;
  $78 = $8;
  $79 = $11;
  $80 = $78;
  $81 = $79;
  $82 = $80 - $81 | 0;
  $83 = _mp_obj_new_str_of_type($76, $77, $82) | 0;
  _mp_obj_list_append($75, $83) | 0;
  $84 = $8;
  $85 = $10;
  $86 = $84 >>> 0 >= $85 >>> 0;
  if ($86) {
   break;
  }
  while (1) {
   $87 = $8;
   $88 = $10;
   $89 = $87 >>> 0 < $88 >>> 0;
   if (!$89) {
    break;
   }
   $90 = $8;
   $91 = HEAP8[$90 >> 0] | 0;
   $92 = $91 & 255;
   $93 = _unichar_isspace($92) | 0;
   if (!$93) {
    break;
   }
   $94 = $8;
   $95 = $94 + 1 | 0;
   $8 = $95;
  }
  $96 = $5;
  $97 = ($96 | 0) > 0;
  if ($97) {
   $98 = $5;
   $99 = $98 + -1 | 0;
   $5 = $99;
  }
 }
 $100 = $8;
 $101 = $10;
 $102 = $100 >>> 0 < $101 >>> 0;
 if (!$102) {
  $155 = $7;
  STACKTOP = sp;
  return $155 | 0;
 }
 $103 = $7;
 $104 = $4;
 $105 = $8;
 $106 = $10;
 $107 = $8;
 $108 = $106;
 $109 = $107;
 $110 = $108 - $109 | 0;
 $111 = _mp_obj_new_str_of_type($104, $105, $110) | 0;
 _mp_obj_list_append($103, $111) | 0;
 $155 = $7;
 STACKTOP = sp;
 return $155 | 0;
}

function _mp_obj_complex_binary_op($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = +$2;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0.0, $101 = 0.0, $102 = 0.0, $103 = 0.0, $104 = 0.0, $105 = 0.0, $106 = 0.0, $107 = 0.0, $108 = 0.0, $109 = 0.0, $11 = 0.0, $110 = 0.0, $111 = 0.0, $112 = 0.0, $113 = 0.0, $114 = 0.0, $115 = 0.0, $116 = 0.0, $117 = 0.0, $118 = 0.0, $119 = 0.0, $12 = 0.0, $120 = 0.0, $121 = 0.0, $122 = 0.0, $123 = 0.0, $124 = 0.0, $125 = 0.0, $126 = 0.0, $127 = 0.0, $128 = 0.0, $129 = 0.0, $13 = 0.0, $130 = 0, $131 = 0.0, $132 = 0.0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0.0, $138 = 0.0, $139 = 0, $14 = 0.0, $140 = 0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $20 = 0, $21 = 0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $29 = 0.0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0, $51 = 0.0, $52 = 0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0.0, $60 = 0.0, $61 = 0.0, $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0.0, $70 = 0.0, $71 = 0.0, $72 = 0.0, $73 = 0.0, $74 = 0.0, $75 = 0.0, $76 = 0.0, $77 = 0.0, $78 = 0.0, $79 = 0.0, $8 = 0, $80 = 0.0, $81 = 0.0, $82 = 0.0, $83 = 0.0, $84 = 0.0, $85 = 0.0, $86 = 0.0, $87 = 0.0, $88 = 0.0, $89 = 0.0, $9 = 0, $90 = 0, $91 = 0.0, $92 = 0, $93 = 0.0, $94 = 0, $95 = 0.0, $96 = 0, $97 = 0, $98 = 0.0, $99 = 0.0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(128 | 0);
 $9 = sp + 80 | 0;
 $10 = sp + 72 | 0;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $20 = $8;
 _mp_obj_get_complex($20, $9, $10);
 $21 = $5;
 L1 : do {
  switch ($21 | 0) {
  case 14:
  case 26:
   {
    $22 = +HEAPF64[$9 >> 3];
    $23 = $6;
    $24 = $23 + $22;
    $6 = $24;
    $25 = +HEAPF64[$10 >> 3];
    $26 = $7;
    $27 = $26 + $25;
    $7 = $27;
    break;
   }
  case 15:
  case 27:
   {
    $28 = +HEAPF64[$9 >> 3];
    $29 = $6;
    $30 = $29 - $28;
    $6 = $30;
    $31 = +HEAPF64[$10 >> 3];
    $32 = $7;
    $33 = $32 - $31;
    $7 = $33;
    break;
   }
  case 16:
  case 28:
   {
    label = 4;
    break;
   }
  case 17:
  case 29:
   {
    _mp_raise_TypeError(30878);
    break;
   }
  case 18:
  case 30:
   {
    $49 = +HEAPF64[$10 >> 3];
    $50 = $49 == 0.0;
    $51 = +HEAPF64[$9 >> 3];
    $52 = $51 == 0.0;
    if ($50) {
     if ($52) {
      _mp_raise_msg(15172, 30917);
     } else {
      $53 = +HEAPF64[$9 >> 3];
      $54 = $6;
      $55 = $54 / $53;
      $6 = $55;
      $56 = +HEAPF64[$9 >> 3];
      $57 = $7;
      $58 = $57 / $56;
      $7 = $58;
      break L1;
     }
    } else {
     if ($52) {
      $59 = $7;
      $60 = +HEAPF64[$10 >> 3];
      $61 = $59 / $60;
      $12 = $61;
      $62 = $6;
      $63 = -$62;
      $64 = +HEAPF64[$10 >> 3];
      $65 = $63 / $64;
      $7 = $65;
      $66 = $12;
      $6 = $66;
      break L1;
     } else {
      $67 = +HEAPF64[$9 >> 3];
      $68 = +HEAPF64[$9 >> 3];
      $69 = $67 * $68;
      $70 = +HEAPF64[$10 >> 3];
      $71 = +HEAPF64[$10 >> 3];
      $72 = $70 * $71;
      $73 = $69 + $72;
      $13 = $73;
      $74 = $13;
      $75 = +HEAPF64[$9 >> 3];
      $76 = $75 / $74;
      HEAPF64[$9 >> 3] = $76;
      $77 = $13;
      $78 = -$77;
      $79 = +HEAPF64[$10 >> 3];
      $80 = $79 / $78;
      HEAPF64[$10 >> 3] = $80;
      label = 4;
      break L1;
     }
    }
    break;
   }
  case 20:
  case 32:
   {
    $81 = $6;
    $82 = $6;
    $83 = $81 * $82;
    $84 = $7;
    $85 = $7;
    $86 = $84 * $85;
    $87 = $83 + $86;
    $88 = +Math_sqrt(+$87);
    $14 = $88;
    $89 = $14;
    $90 = $89 == 0.0;
    if (!$90) {
     $99 = $14;
     $100 = +Math_log(+$99);
     $15 = $100;
     $101 = $7;
     $102 = $6;
     $103 = +_atan2($101, $102);
     $16 = $103;
     $104 = +HEAPF64[$9 >> 3];
     $105 = $15;
     $106 = $104 * $105;
     $107 = +HEAPF64[$10 >> 3];
     $108 = $16;
     $109 = $107 * $108;
     $110 = $106 - $109;
     $17 = $110;
     $111 = +HEAPF64[$10 >> 3];
     $112 = $15;
     $113 = $111 * $112;
     $114 = +HEAPF64[$9 >> 3];
     $115 = $16;
     $116 = $114 * $115;
     $117 = $113 + $116;
     $18 = $117;
     $118 = $17;
     $119 = +Math_exp(+$118);
     $19 = $119;
     $120 = $19;
     $121 = $18;
     $122 = +_llvm_cos_f64(+$121);
     $123 = $120 * $122;
     $6 = $123;
     $124 = $19;
     $125 = $18;
     $126 = +_llvm_sin_f64(+$125);
     $127 = $124 * $126;
     $7 = $127;
     break L1;
    }
    $91 = +HEAPF64[$10 >> 3];
    $92 = $91 == 0.0;
    $93 = +HEAPF64[$9 >> 3];
    $94 = $93 >= 0.0;
    $or$cond = $92 & $94;
    if ($or$cond) {
     $95 = +HEAPF64[$9 >> 3];
     $96 = $95 == 0.0;
     $97 = $96 & 1;
     $98 = +($97 | 0);
     $6 = $98;
     break L1;
    } else {
     _mp_raise_msg(15172, 30940);
    }
    break;
   }
  case 2:
   {
    $128 = $6;
    $129 = +HEAPF64[$9 >> 3];
    $130 = $128 == $129;
    if ($130) {
     $131 = $7;
     $132 = +HEAPF64[$10 >> 3];
     $133 = $131 == $132;
     $135 = $133;
    } else {
     $135 = 0;
    }
    $134 = $135 & 1;
    $136 = _mp_obj_new_bool_859($134) | 0;
    $4 = $136;
    $140 = $4;
    STACKTOP = sp;
    return $140 | 0;
    break;
   }
  default:
   {
    $4 = 0;
    $140 = $4;
    STACKTOP = sp;
    return $140 | 0;
   }
  }
 } while (0);
 if ((label | 0) == 4) {
  $34 = $6;
  $35 = +HEAPF64[$9 >> 3];
  $36 = $34 * $35;
  $37 = $7;
  $38 = +HEAPF64[$10 >> 3];
  $39 = $37 * $38;
  $40 = $36 - $39;
  $11 = $40;
  $41 = $6;
  $42 = +HEAPF64[$10 >> 3];
  $43 = $41 * $42;
  $44 = $7;
  $45 = +HEAPF64[$9 >> 3];
  $46 = $44 * $45;
  $47 = $43 + $46;
  $7 = $47;
  $48 = $11;
  $6 = $48;
 }
 $137 = $6;
 $138 = $7;
 $139 = _mp_obj_new_complex($137, $138) | 0;
 $4 = $139;
 $140 = $4;
 STACKTOP = sp;
 return $140 | 0;
}

function _mpz_as_str_inpl($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $164 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $7 = $0;
 $8 = $1;
 $9 = $2;
 $10 = $3;
 $11 = $4;
 $12 = $5;
 $24 = $7;
 $25 = $24 + 4 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $13 = $26;
 $27 = $12;
 $14 = $27;
 $28 = $13;
 $29 = ($28 | 0) == 0;
 if ($29) {
  $30 = $9;
  $31 = ($30 | 0) != (0 | 0);
  L3 : do {
   if ($31) {
    while (1) {
     $32 = $9;
     $33 = HEAP8[$32 >> 0] | 0;
     $34 = $33 << 24 >> 24 != 0;
     if (!$34) {
      break L3;
     }
     $35 = $9;
     $36 = $35 + 1 | 0;
     $9 = $36;
     $37 = HEAP8[$35 >> 0] | 0;
     $38 = $14;
     $39 = $38 + 1 | 0;
     $14 = $39;
     HEAP8[$38 >> 0] = $37;
    }
   }
  } while (0);
  $40 = $14;
  $41 = $40 + 1 | 0;
  $14 = $41;
  HEAP8[$40 >> 0] = 48;
  $42 = $14;
  HEAP8[$42 >> 0] = 0;
  $43 = $14;
  $44 = $12;
  $45 = $43;
  $46 = $44;
  $47 = $45 - $46 | 0;
  $6 = $47;
  $164 = $6;
  STACKTOP = sp;
  return $164 | 0;
 }
 $48 = $13;
 $49 = $48 << 1;
 $50 = _m_malloc($49) | 0;
 $15 = $50;
 $51 = $15;
 $52 = $7;
 $53 = $52 + 8 | 0;
 $54 = HEAP32[$53 >> 2] | 0;
 $55 = $13;
 $56 = $55 << 1;
 _memcpy($51 | 0, $54 | 0, $56 | 0) | 0;
 $57 = $12;
 $16 = $57;
 while (1) {
  $58 = $15;
  $59 = $13;
  $60 = $58 + ($59 << 1) | 0;
  $18 = $60;
  $19 = 0;
  while (1) {
   $61 = $18;
   $62 = $61 + -2 | 0;
   $18 = $62;
   $63 = $15;
   $64 = $62 >>> 0 >= $63 >>> 0;
   $65 = $19;
   if (!$64) {
    break;
   }
   $66 = $65 << 16;
   $67 = $18;
   $68 = HEAP16[$67 >> 1] | 0;
   $69 = $68 & 65535;
   $70 = $66 | $69;
   $19 = $70;
   $71 = $19;
   $72 = $8;
   $73 = ($71 >>> 0) / ($72 >>> 0) & -1;
   $74 = $73 & 65535;
   $75 = $18;
   HEAP16[$75 >> 1] = $74;
   $76 = $8;
   $77 = $19;
   $78 = ($77 >>> 0) % ($76 >>> 0) & -1;
   $19 = $78;
  }
  $79 = $65 + 48 | 0;
  $19 = $79;
  $80 = $19;
  $81 = $80 >>> 0 > 57;
  if ($81) {
   $82 = $10;
   $83 = $82 << 24 >> 24;
   $84 = $83 - 57 | 0;
   $85 = $84 - 1 | 0;
   $86 = $19;
   $87 = $86 + $85 | 0;
   $19 = $87;
  }
  $88 = $19;
  $89 = $88 & 255;
  $90 = $14;
  $91 = $90 + 1 | 0;
  $14 = $91;
  HEAP8[$90 >> 0] = $89;
  $17 = 1;
  $92 = $15;
  $18 = $92;
  while (1) {
   $93 = $18;
   $94 = $15;
   $95 = $13;
   $96 = $94 + ($95 << 1) | 0;
   $97 = $93 >>> 0 < $96 >>> 0;
   if (!$97) {
    break;
   }
   $98 = $18;
   $99 = HEAP16[$98 >> 1] | 0;
   $100 = $99 & 65535;
   $101 = ($100 | 0) != 0;
   if ($101) {
    label = 16;
    break;
   }
   $102 = $18;
   $103 = $102 + 2 | 0;
   $18 = $103;
  }
  if ((label | 0) == 16) {
   label = 0;
   $17 = 0;
  }
  $104 = $11;
  $105 = $104 << 24 >> 24;
  $106 = ($105 | 0) != 0;
  if ($106) {
   $107 = $14;
   $108 = $16;
   $109 = $107;
   $110 = $108;
   $111 = $109 - $110 | 0;
   $112 = ($111 | 0) == 3;
   if ($112) {
    $113 = $11;
    $114 = $14;
    $115 = $114 + 1 | 0;
    $14 = $115;
    HEAP8[$114 >> 0] = $113;
    $116 = $14;
    $16 = $116;
   }
  }
  $117 = $17;
  $118 = $117 & 1;
  $119 = $118 ^ 1;
  if (!$119) {
   break;
  }
 }
 $120 = $15;
 _m_free($120);
 $121 = $9;
 $122 = ($121 | 0) != (0 | 0);
 L32 : do {
  if ($122) {
   $123 = $9;
   $124 = $9;
   $125 = _strlen($124) | 0;
   $126 = $123 + $125 | 0;
   $20 = $126;
   while (1) {
    $127 = $20;
    $128 = $9;
    $129 = $127 >>> 0 > $128 >>> 0;
    if (!$129) {
     break L32;
    }
    $130 = $20;
    $131 = $130 + -1 | 0;
    $20 = $131;
    $132 = HEAP8[$131 >> 0] | 0;
    $133 = $14;
    $134 = $133 + 1 | 0;
    $14 = $134;
    HEAP8[$133 >> 0] = $132;
   }
  }
 } while (0);
 $135 = $7;
 $136 = HEAP32[$135 >> 2] | 0;
 $137 = $136 & 1;
 $138 = ($137 | 0) != 0;
 if ($138) {
  $139 = $14;
  $140 = $139 + 1 | 0;
  $14 = $140;
  HEAP8[$139 >> 0] = 45;
 }
 $141 = $12;
 $21 = $141;
 $142 = $14;
 $143 = $142 + -1 | 0;
 $22 = $143;
 while (1) {
  $144 = $21;
  $145 = $22;
  $146 = $144 >>> 0 < $145 >>> 0;
  if (!$146) {
   break;
  }
  $147 = $21;
  $148 = HEAP8[$147 >> 0] | 0;
  $23 = $148;
  $149 = $22;
  $150 = HEAP8[$149 >> 0] | 0;
  $151 = $21;
  HEAP8[$151 >> 0] = $150;
  $152 = $23;
  $153 = $22;
  HEAP8[$153 >> 0] = $152;
  $154 = $21;
  $155 = $154 + 1 | 0;
  $21 = $155;
  $156 = $22;
  $157 = $156 + -1 | 0;
  $22 = $157;
 }
 $158 = $14;
 HEAP8[$158 >> 0] = 0;
 $159 = $14;
 $160 = $12;
 $161 = $159;
 $162 = $160;
 $163 = $161 - $162 | 0;
 $6 = $163;
 $164 = $6;
 STACKTOP = sp;
 return $164 | 0;
}

function _mod_binascii_b2a_base64($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $2 = sp + 32 | 0;
 $3 = sp + 16 | 0;
 $1 = $0;
 $8 = $1;
 _mp_get_buffer_raise($8, $2, 1);
 $9 = $2 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = ($10 | 0) != 0;
 if ($11) {
  $12 = $2 + 4 | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = $13 - 1 | 0;
  $15 = ($14 >>> 0) / 3 & -1;
  $16 = $15 + 1 | 0;
  $17 = $16 << 2;
  $19 = $17;
 } else {
  $19 = 0;
 }
 $18 = $19 + 1 | 0;
 _vstr_init_len($3, $18);
 $20 = HEAP32[$2 >> 2] | 0;
 $4 = $20;
 $21 = $3 + 8 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $5 = $22;
 $23 = $2 + 4 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $6 = $24;
 while (1) {
  $25 = $6;
  $26 = $25 >>> 0 >= 3;
  if (!$26) {
   break;
  }
  $27 = $4;
  $28 = HEAP8[$27 >> 0] | 0;
  $29 = $28 & 255;
  $30 = $29 & 252;
  $31 = $30 >> 2;
  $32 = $31 & 255;
  $33 = $5;
  $34 = $33 + 1 | 0;
  $5 = $34;
  HEAP8[$33 >> 0] = $32;
  $35 = $4;
  $36 = HEAP8[$35 >> 0] | 0;
  $37 = $36 & 255;
  $38 = $37 & 3;
  $39 = $38 << 4;
  $40 = $4;
  $41 = $40 + 1 | 0;
  $42 = HEAP8[$41 >> 0] | 0;
  $43 = $42 & 255;
  $44 = $43 & 240;
  $45 = $44 >> 4;
  $46 = $39 | $45;
  $47 = $46 & 255;
  $48 = $5;
  $49 = $48 + 1 | 0;
  $5 = $49;
  HEAP8[$48 >> 0] = $47;
  $50 = $4;
  $51 = $50 + 1 | 0;
  $52 = HEAP8[$51 >> 0] | 0;
  $53 = $52 & 255;
  $54 = $53 & 15;
  $55 = $54 << 2;
  $56 = $4;
  $57 = $56 + 2 | 0;
  $58 = HEAP8[$57 >> 0] | 0;
  $59 = $58 & 255;
  $60 = $59 & 192;
  $61 = $60 >> 6;
  $62 = $55 | $61;
  $63 = $62 & 255;
  $64 = $5;
  $65 = $64 + 1 | 0;
  $5 = $65;
  HEAP8[$64 >> 0] = $63;
  $66 = $4;
  $67 = $66 + 2 | 0;
  $68 = HEAP8[$67 >> 0] | 0;
  $69 = $68 & 255;
  $70 = $69 & 63;
  $71 = $70 & 255;
  $72 = $5;
  $73 = $72 + 1 | 0;
  $5 = $73;
  HEAP8[$72 >> 0] = $71;
  $74 = $4;
  $75 = $74 + 3 | 0;
  $4 = $75;
  $76 = $6;
  $77 = $76 - 3 | 0;
  $6 = $77;
 }
 $78 = $6;
 $79 = ($78 | 0) != 0;
 if ($79) {
  $80 = $4;
  $81 = HEAP8[$80 >> 0] | 0;
  $82 = $81 & 255;
  $83 = $82 & 252;
  $84 = $83 >> 2;
  $85 = $84 & 255;
  $86 = $5;
  $87 = $86 + 1 | 0;
  $5 = $87;
  HEAP8[$86 >> 0] = $85;
  $88 = $6;
  $89 = ($88 | 0) == 2;
  $90 = $4;
  $91 = HEAP8[$90 >> 0] | 0;
  $92 = $91 & 255;
  $93 = $92 & 3;
  $94 = $93 << 4;
  if ($89) {
   $95 = $4;
   $96 = $95 + 1 | 0;
   $97 = HEAP8[$96 >> 0] | 0;
   $98 = $97 & 255;
   $99 = $98 & 240;
   $100 = $99 >> 4;
   $101 = $94 | $100;
   $102 = $101 & 255;
   $103 = $5;
   $104 = $103 + 1 | 0;
   $5 = $104;
   HEAP8[$103 >> 0] = $102;
   $105 = $4;
   $106 = $105 + 1 | 0;
   $107 = HEAP8[$106 >> 0] | 0;
   $108 = $107 & 255;
   $109 = $108 & 15;
   $110 = $109 << 2;
   $111 = $110 & 255;
   $112 = $5;
   $113 = $112 + 1 | 0;
   $5 = $113;
   HEAP8[$112 >> 0] = $111;
  } else {
   $114 = $94 & 255;
   $115 = $5;
   $116 = $115 + 1 | 0;
   $5 = $116;
   HEAP8[$115 >> 0] = $114;
   $117 = $5;
   $118 = $117 + 1 | 0;
   $5 = $118;
   HEAP8[$117 >> 0] = 64;
  }
  $119 = $5;
  HEAP8[$119 >> 0] = 64;
 }
 $120 = $3 + 8 | 0;
 $121 = HEAP32[$120 >> 2] | 0;
 $5 = $121;
 $122 = $3 + 4 | 0;
 $123 = HEAP32[$122 >> 2] | 0;
 $124 = $123 - 1 | 0;
 $7 = $124;
 while (1) {
  $125 = $7;
  $126 = $125 + -1 | 0;
  $7 = $126;
  $127 = ($125 | 0) != 0;
  $128 = $5;
  if (!$127) {
   break;
  }
  $129 = HEAP8[$128 >> 0] | 0;
  $130 = $129 & 255;
  $131 = ($130 | 0) < 26;
  $132 = $5;
  $133 = HEAP8[$132 >> 0] | 0;
  $134 = $133 & 255;
  do {
   if ($131) {
    $135 = $134 + 65 | 0;
    $136 = $135 & 255;
    HEAP8[$132 >> 0] = $136;
   } else {
    $137 = ($134 | 0) < 52;
    $138 = $5;
    $139 = HEAP8[$138 >> 0] | 0;
    $140 = $139 & 255;
    if ($137) {
     $141 = $140 + 71 | 0;
     $142 = $141 & 255;
     HEAP8[$138 >> 0] = $142;
     break;
    }
    $143 = ($140 | 0) < 62;
    $144 = $5;
    $145 = HEAP8[$144 >> 0] | 0;
    $146 = $145 & 255;
    if ($143) {
     $147 = $146 + -4 | 0;
     $148 = $147 & 255;
     HEAP8[$144 >> 0] = $148;
     break;
    }
    $149 = ($146 | 0) == 62;
    $150 = $5;
    if ($149) {
     HEAP8[$150 >> 0] = 43;
     break;
    }
    $151 = HEAP8[$150 >> 0] | 0;
    $152 = $151 & 255;
    $153 = ($152 | 0) == 63;
    $154 = $5;
    if ($153) {
     HEAP8[$154 >> 0] = 47;
     break;
    } else {
     HEAP8[$154 >> 0] = 61;
     break;
    }
   }
  } while (0);
  $155 = $5;
  $156 = $155 + 1 | 0;
  $5 = $156;
 }
 HEAP8[$128 >> 0] = 10;
 $157 = _mp_obj_new_str_from_vstr(18304, $3) | 0;
 STACKTOP = sp;
 return $157 | 0;
}

function _compile_import_from($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $6 = sp + 56 | 0;
 $8 = sp + 48 | 0;
 $11 = sp + 36 | 0;
 $12 = sp + 32 | 0;
 $17 = sp + 12 | 0;
 $2 = $0;
 $3 = $1;
 $21 = $3;
 $22 = $21 + 8 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $4 = $23;
 $5 = 0;
 $24 = $4;
 $25 = $24 & 15;
 $26 = ($25 | 0) == 14;
 do {
  if ($26) {
   label = 5;
  } else {
   $27 = $4;
   $28 = ($27 | 0) != 0;
   if ($28) {
    $29 = $4;
    $30 = $29 & 3;
    $31 = ($30 | 0) == 0;
    if ($31) {
     $32 = $4;
     $33 = $32;
     $34 = $33 + 4 | 0;
     $35 = HEAP32[$34 >> 2] | 0;
     $36 = $35 & 255;
     $37 = ($36 | 0) == 100;
     if ($37) {
      label = 5;
      break;
     }
    }
   }
   $39 = $4;
   $40 = ($39 | 0) != 0;
   if ($40) {
    $41 = $4;
    $42 = $41 & 3;
    $43 = ($42 | 0) == 0;
    if ($43) {
     $44 = $4;
     $45 = $44;
     $46 = $45 + 4 | 0;
     $47 = HEAP32[$46 >> 2] | 0;
     $48 = $47 & 255;
     $49 = ($48 | 0) == 97;
     if ($49) {
      $50 = $4;
      $51 = $50;
      $7 = $51;
      $52 = $7;
      $53 = $52 + 8 | 0;
      $54 = HEAP32[$53 >> 2] | 0;
      HEAP32[$6 >> 2] = $54;
      $55 = $7;
      $56 = $55 + 8 | 0;
      $57 = $56 + 4 | 0;
      $58 = HEAP32[$57 >> 2] | 0;
      $4 = $58;
      label = 10;
     }
    }
   }
  }
 } while (0);
 if ((label | 0) == 5) {
  $38 = $4;
  HEAP32[$6 >> 2] = $38;
  $4 = 0;
  label = 10;
 }
 L12 : do {
  if ((label | 0) == 10) {
   $59 = _mp_parse_node_extract_list($6, 100, $8) | 0;
   $9 = $59;
   $10 = 0;
   while (1) {
    $60 = $10;
    $61 = $9;
    $62 = ($60 | 0) < ($61 | 0);
    if (!$62) {
     break L12;
    }
    $63 = HEAP32[$8 >> 2] | 0;
    $64 = $10;
    $65 = $63 + ($64 << 2) | 0;
    $66 = HEAP32[$65 >> 2] | 0;
    $67 = ($66 | 0) == 1230;
    $68 = $5;
    if ($67) {
     $69 = $68 + 1 | 0;
     $5 = $69;
    } else {
     $70 = $68 + 3 | 0;
     $5 = $70;
    }
    $71 = $10;
    $72 = $71 + 1 | 0;
    $10 = $72;
   }
  }
 } while (0);
 $73 = $3;
 $74 = $73 + 8 | 0;
 $75 = $74 + 4 | 0;
 $76 = HEAP32[$75 >> 2] | 0;
 $77 = ($76 | 0) == 830;
 $78 = $2;
 $79 = $78 + 40 | 0;
 $80 = HEAP32[$79 >> 2] | 0;
 $81 = $5;
 _mp_emit_bc_load_const_small_int($80, $81);
 if ($77) {
  $82 = $2;
  $83 = $82 + 40 | 0;
  $84 = HEAP32[$83 >> 2] | 0;
  _mp_emit_bc_load_const_str($84, 5);
  $85 = $2;
  $86 = $85 + 40 | 0;
  $87 = HEAP32[$86 >> 2] | 0;
  _mp_emit_bc_build($87, 1, 0);
  $88 = $2;
  $89 = $4;
  _do_import_name($88, $89, $11);
  $90 = $2;
  $91 = $90 + 40 | 0;
  $92 = HEAP32[$91 >> 2] | 0;
  _mp_emit_bc_import($92, 0, 2);
  STACKTOP = sp;
  return;
 }
 $93 = $3;
 $94 = $93 + 8 | 0;
 $95 = $94 + 4 | 0;
 $96 = _mp_parse_node_extract_list($95, 105, $12) | 0;
 $13 = $96;
 $14 = 0;
 while (1) {
  $97 = $14;
  $98 = $13;
  $99 = ($97 | 0) < ($98 | 0);
  if (!$99) {
   break;
  }
  $100 = HEAP32[$12 >> 2] | 0;
  $101 = $14;
  $102 = $100 + ($101 << 2) | 0;
  $103 = HEAP32[$102 >> 2] | 0;
  $104 = $103;
  $15 = $104;
  $105 = $15;
  $106 = $105 + 8 | 0;
  $107 = HEAP32[$106 >> 2] | 0;
  $108 = $107 >>> 4;
  $16 = $108;
  $109 = $2;
  $110 = $109 + 40 | 0;
  $111 = HEAP32[$110 >> 2] | 0;
  $112 = $16;
  _mp_emit_bc_load_const_str($111, $112);
  $113 = $14;
  $114 = $113 + 1 | 0;
  $14 = $114;
 }
 $115 = $2;
 $116 = $115 + 40 | 0;
 $117 = HEAP32[$116 >> 2] | 0;
 $118 = $13;
 _mp_emit_bc_build($117, $118, 0);
 $119 = $2;
 $120 = $4;
 _do_import_name($119, $120, $17);
 $18 = 0;
 while (1) {
  $121 = $18;
  $122 = $13;
  $123 = ($121 | 0) < ($122 | 0);
  if (!$123) {
   break;
  }
  $124 = HEAP32[$12 >> 2] | 0;
  $125 = $18;
  $126 = $124 + ($125 << 2) | 0;
  $127 = HEAP32[$126 >> 2] | 0;
  $128 = $127;
  $19 = $128;
  $129 = $19;
  $130 = $129 + 8 | 0;
  $131 = HEAP32[$130 >> 2] | 0;
  $132 = $131 >>> 4;
  $20 = $132;
  $133 = $2;
  $134 = $133 + 40 | 0;
  $135 = HEAP32[$134 >> 2] | 0;
  $136 = $20;
  _mp_emit_bc_import($135, $136, 1);
  $137 = $19;
  $138 = $137 + 8 | 0;
  $139 = $138 + 4 | 0;
  $140 = HEAP32[$139 >> 2] | 0;
  $141 = ($140 | 0) == 0;
  $142 = $2;
  if ($141) {
   $143 = $20;
   _compile_store_id($142, $143);
  } else {
   $144 = $19;
   $145 = $144 + 8 | 0;
   $146 = $145 + 4 | 0;
   $147 = HEAP32[$146 >> 2] | 0;
   $148 = $147 >>> 4;
   _compile_store_id($142, $148);
  }
  $149 = $18;
  $150 = $149 + 1 | 0;
  $18 = $150;
 }
 $151 = $2;
 $152 = $151 + 40 | 0;
 $153 = HEAP32[$152 >> 2] | 0;
 _mp_emit_bc_pop_top($153);
 STACKTOP = sp;
 return;
}

function _c_assign($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $10 = $4;
 $11 = $10 & 3;
 $12 = ($11 | 0) != 0;
 $13 = $4;
 L1 : do {
  if ($12) {
   $14 = $13 & 15;
   $15 = ($14 | 0) == 2;
   if ($15) {
    $16 = $4;
    $17 = $16 >>> 4;
    $6 = $17;
    $18 = $5;
    switch ($18 | 0) {
    case 2:
    case 0:
     {
      $19 = $3;
      $20 = $6;
      _compile_store_id($19, $20);
      STACKTOP = sp;
      return;
      break;
     }
    default:
     {
      $21 = $3;
      $22 = $6;
      _compile_load_id($21, $22);
      STACKTOP = sp;
      return;
     }
    }
   }
  } else {
   $23 = $13;
   $7 = $23;
   $24 = $7;
   $25 = $24 + 4 | 0;
   $26 = HEAP32[$25 >> 2] | 0;
   $27 = $26 & 255;
   L10 : do {
    switch ($27 | 0) {
    case 43:
     {
      $28 = $3;
      $29 = $7;
      $30 = $5;
      _c_assign_atom_expr($28, $29, $30);
      STACKTOP = sp;
      return;
      break;
     }
    case 155:
    case 6:
     {
      $31 = $5;
      $32 = ($31 | 0) != 0;
      if ($32) {
       break L1;
      }
      $33 = $3;
      $34 = $7;
      $35 = $34 + 4 | 0;
      $36 = HEAP32[$35 >> 2] | 0;
      $37 = $36 >>> 8;
      $38 = $7;
      $39 = $38 + 8 | 0;
      _c_assign_tuple($33, 0, $37, $39);
      STACKTOP = sp;
      return;
      break;
     }
    case 44:
     {
      $40 = $7;
      $41 = $40 + 8 | 0;
      $42 = HEAP32[$41 >> 2] | 0;
      $43 = ($42 | 0) == 0;
      $44 = $5;
      $45 = ($44 | 0) != 0;
      $or$cond = $43 | $45;
      if ($or$cond) {
       break L1;
      }
      $46 = $7;
      $47 = $46 + 8 | 0;
      $48 = HEAP32[$47 >> 2] | 0;
      $49 = $48;
      $7 = $49;
      break;
     }
    case 45:
     {
      $50 = $5;
      $51 = ($50 | 0) != 0;
      if ($51) {
       break L1;
      }
      $52 = $7;
      $53 = $52 + 8 | 0;
      $54 = HEAP32[$53 >> 2] | 0;
      $55 = ($54 | 0) == 0;
      if ($55) {
       $56 = $3;
       _c_assign_tuple($56, 0, 0, 0);
       STACKTOP = sp;
       return;
      }
      $57 = $7;
      $58 = $57 + 8 | 0;
      $59 = HEAP32[$58 >> 2] | 0;
      $60 = ($59 | 0) != 0;
      if ($60) {
       $61 = $7;
       $62 = $61 + 8 | 0;
       $63 = HEAP32[$62 >> 2] | 0;
       $64 = $63 & 3;
       $65 = ($64 | 0) == 0;
       if ($65) {
        $66 = $7;
        $67 = $66 + 8 | 0;
        $68 = HEAP32[$67 >> 2] | 0;
        $69 = $68;
        $70 = $69 + 4 | 0;
        $71 = HEAP32[$70 >> 2] | 0;
        $72 = $71 & 255;
        $73 = ($72 | 0) == 144;
        if ($73) {
         $74 = $7;
         $75 = $74 + 8 | 0;
         $76 = HEAP32[$75 >> 2] | 0;
         $77 = $76;
         $7 = $77;
         break L10;
        }
       }
      }
      $78 = $3;
      $79 = $7;
      $80 = $79 + 8 | 0;
      $81 = HEAP32[$80 >> 2] | 0;
      _c_assign_tuple($78, $81, 0, 0);
      STACKTOP = sp;
      return;
      break;
     }
    default:
     {
      break L1;
     }
    }
   } while (0);
   $82 = $7;
   $83 = $82 + 8 | 0;
   $84 = $83 + 4 | 0;
   $85 = HEAP32[$84 >> 2] | 0;
   $86 = ($85 | 0) != 0;
   do {
    if ($86) {
     $87 = $7;
     $88 = $87 + 8 | 0;
     $89 = $88 + 4 | 0;
     $90 = HEAP32[$89 >> 2] | 0;
     $91 = $90 & 3;
     $92 = ($91 | 0) == 0;
     if ($92) {
      $93 = $7;
      $94 = $93 + 8 | 0;
      $95 = $94 + 4 | 0;
      $96 = HEAP32[$95 >> 2] | 0;
      $97 = $96;
      $8 = $97;
      $98 = $8;
      $99 = $98 + 4 | 0;
      $100 = HEAP32[$99 >> 2] | 0;
      $101 = $100 & 255;
      $102 = ($101 | 0) == 147;
      if ($102) {
       $103 = $3;
       $104 = $7;
       $105 = $104 + 8 | 0;
       $106 = HEAP32[$105 >> 2] | 0;
       _c_assign_tuple($103, $106, 0, 0);
       STACKTOP = sp;
       return;
      }
      $107 = $8;
      $108 = $107 + 4 | 0;
      $109 = HEAP32[$108 >> 2] | 0;
      $110 = $109 & 255;
      $111 = ($110 | 0) == 148;
      $112 = $8;
      $113 = $112 + 4 | 0;
      $114 = HEAP32[$113 >> 2] | 0;
      if (!$111) {
       $123 = $114 & 255;
       $124 = ($123 | 0) == 171;
       if ($124) {
        break L1;
       } else {
        break;
       }
      }
      $115 = $114 >>> 8;
      $9 = $115;
      $116 = $3;
      $117 = $7;
      $118 = $117 + 8 | 0;
      $119 = HEAP32[$118 >> 2] | 0;
      $120 = $9;
      $121 = $8;
      $122 = $121 + 8 | 0;
      _c_assign_tuple($116, $119, $120, $122);
      STACKTOP = sp;
      return;
     }
    }
   } while (0);
   $125 = $3;
   $126 = $7;
   $127 = $126 + 8 | 0;
   _c_assign_tuple($125, 0, 2, $127);
   STACKTOP = sp;
   return;
  }
 } while (0);
 $128 = $3;
 $129 = $4;
 _compile_syntax_error($128, $129, 28734);
 STACKTOP = sp;
 return;
}

function _select_select($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0.0, $36 = Math_fround(0), $37 = Math_fround(0), $38 = 0, $39 = Math_fround(0), $4 = 0, $40 = Math_fround(0), $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = Math_fround(0), $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $4 = sp + 60 | 0;
 $5 = sp + 56 | 0;
 $6 = sp + 52 | 0;
 $7 = sp + 48 | 0;
 $10 = sp + 28 | 0;
 $13 = sp + 8 | 0;
 $2 = $0;
 $3 = $1;
 $16 = $3;
 $17 = HEAP32[$16 >> 2] | 0;
 _mp_obj_get_array($17, $4, $5);
 $18 = $3;
 $19 = $18 + 4 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = $4 + 4 | 0;
 _mp_obj_get_array($20, $21, $6);
 $22 = $3;
 $23 = $22 + 8 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $4 + 8 | 0;
 _mp_obj_get_array($24, $25, $7);
 $8 = -1;
 $26 = $2;
 $27 = ($26 | 0) == 4;
 if ($27) {
  $28 = $3;
  $29 = $28 + 12 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = ($30 | 0) != (17668 | 0);
  if ($31) {
   $32 = $3;
   $33 = $32 + 12 | 0;
   $34 = HEAP32[$33 >> 2] | 0;
   $35 = +_mp_obj_get_float($34);
   $36 = Math_fround($35);
   $9 = $36;
   $37 = $9;
   $38 = $37 >= Math_fround(0.0);
   if ($38) {
    $39 = $9;
    $40 = Math_fround($39 * Math_fround(1.0e3));
    $41 = ~~$40 >>> 0;
    $8 = $41;
   }
  }
 }
 $42 = HEAP32[$4 >> 2] | 0;
 $43 = $4 + 4 | 0;
 $44 = HEAP32[$43 >> 2] | 0;
 $45 = $42 + $44 | 0;
 $46 = $4 + 8 | 0;
 $47 = HEAP32[$46 >> 2] | 0;
 $48 = $45 + $47 | 0;
 _mp_map_init($10, $48);
 $49 = HEAP32[$5 >> 2] | 0;
 $50 = HEAP32[$4 >> 2] | 0;
 _poll_map_add($10, $49, $50, 1, 1);
 $51 = HEAP32[$6 >> 2] | 0;
 $52 = $4 + 4 | 0;
 $53 = HEAP32[$52 >> 2] | 0;
 _poll_map_add($10, $51, $53, 4, 1);
 $54 = HEAP32[$7 >> 2] | 0;
 $55 = $4 + 8 | 0;
 $56 = HEAP32[$55 >> 2] | 0;
 _poll_map_add($10, $54, $56, 24, 1);
 $57 = _mp_hal_ticks_ms() | 0;
 $11 = $57;
 $58 = $4 + 8 | 0;
 HEAP32[$58 >> 2] = 0;
 $59 = $4 + 4 | 0;
 HEAP32[$59 >> 2] = 0;
 HEAP32[$4 >> 2] = 0;
 while (1) {
  $60 = _poll_map_poll($10, $4) | 0;
  $12 = $60;
  $61 = $12;
  $62 = $61 >>> 0 > 0;
  if ($62) {
   break;
  }
  $63 = $8;
  $64 = ($63 | 0) != -1;
  if ($64) {
   $65 = _mp_hal_ticks_ms() | 0;
   $66 = $11;
   $67 = $65 - $66 | 0;
   $68 = $8;
   $69 = $67 >>> 0 >= $68 >>> 0;
   if ($69) {
    break;
   }
  }
  _mp_handle_pending();
 }
 $70 = HEAP32[$4 >> 2] | 0;
 $71 = _mp_obj_new_list($70, 0) | 0;
 HEAP32[$13 >> 2] = $71;
 $72 = $4 + 4 | 0;
 $73 = HEAP32[$72 >> 2] | 0;
 $74 = _mp_obj_new_list($73, 0) | 0;
 $75 = $13 + 4 | 0;
 HEAP32[$75 >> 2] = $74;
 $76 = $4 + 8 | 0;
 $77 = HEAP32[$76 >> 2] | 0;
 $78 = _mp_obj_new_list($77, 0) | 0;
 $79 = $13 + 8 | 0;
 HEAP32[$79 >> 2] = $78;
 $80 = $4 + 8 | 0;
 HEAP32[$80 >> 2] = 0;
 $81 = $4 + 4 | 0;
 HEAP32[$81 >> 2] = 0;
 HEAP32[$4 >> 2] = 0;
 $14 = 0;
 while (1) {
  $82 = $14;
  $83 = $10 + 4 | 0;
  $84 = HEAP32[$83 >> 2] | 0;
  $85 = $82 >>> 0 < $84 >>> 0;
  if (!$85) {
   break;
  }
  $86 = $14;
  $87 = _mp_map_slot_is_filled_1536($10, $86) | 0;
  if ($87) {
   $88 = $10 + 8 | 0;
   $89 = HEAP32[$88 >> 2] | 0;
   $90 = $14;
   $91 = $89 + ($90 << 3) | 0;
   $92 = $91 + 4 | 0;
   $93 = HEAP32[$92 >> 2] | 0;
   $15 = $93;
   $94 = $15;
   $95 = $94 + 12 | 0;
   $96 = HEAP32[$95 >> 2] | 0;
   $97 = $96 & 1;
   $98 = ($97 | 0) != 0;
   if ($98) {
    $99 = $15;
    $100 = HEAP32[$99 >> 2] | 0;
    $101 = HEAP32[$13 >> 2] | 0;
    $102 = $101 + 12 | 0;
    $103 = HEAP32[$102 >> 2] | 0;
    $104 = HEAP32[$4 >> 2] | 0;
    $105 = $104 + 1 | 0;
    HEAP32[$4 >> 2] = $105;
    $106 = $103 + ($104 << 2) | 0;
    HEAP32[$106 >> 2] = $100;
   }
   $107 = $15;
   $108 = $107 + 12 | 0;
   $109 = HEAP32[$108 >> 2] | 0;
   $110 = $109 & 4;
   $111 = ($110 | 0) != 0;
   if ($111) {
    $112 = $15;
    $113 = HEAP32[$112 >> 2] | 0;
    $114 = $13 + 4 | 0;
    $115 = HEAP32[$114 >> 2] | 0;
    $116 = $115 + 12 | 0;
    $117 = HEAP32[$116 >> 2] | 0;
    $118 = $4 + 4 | 0;
    $119 = HEAP32[$118 >> 2] | 0;
    $120 = $119 + 1 | 0;
    HEAP32[$118 >> 2] = $120;
    $121 = $117 + ($119 << 2) | 0;
    HEAP32[$121 >> 2] = $113;
   }
   $122 = $15;
   $123 = $122 + 12 | 0;
   $124 = HEAP32[$123 >> 2] | 0;
   $125 = $124 & -6;
   $126 = ($125 | 0) != 0;
   if ($126) {
    $127 = $15;
    $128 = HEAP32[$127 >> 2] | 0;
    $129 = $13 + 8 | 0;
    $130 = HEAP32[$129 >> 2] | 0;
    $131 = $130 + 12 | 0;
    $132 = HEAP32[$131 >> 2] | 0;
    $133 = $4 + 8 | 0;
    $134 = HEAP32[$133 >> 2] | 0;
    $135 = $134 + 1 | 0;
    HEAP32[$133 >> 2] = $135;
    $136 = $132 + ($134 << 2) | 0;
    HEAP32[$136 >> 2] = $128;
   }
  }
  $137 = $14;
  $138 = $137 + 1 | 0;
  $14 = $138;
 }
 _mp_map_deinit($10);
 $139 = _mp_obj_new_tuple(3, $13) | 0;
 STACKTOP = sp;
 return $139 | 0;
}

function _compile_for_stmt_optimised_range($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $156 = 0, $157 = 0, $158 = 0, $159 = 0, $16 = 0, $160 = 0, $161 = 0, $162 = 0, $163 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $7 = $0;
 $8 = $1;
 $9 = $2;
 $10 = $3;
 $11 = $4;
 $12 = $5;
 $13 = $6;
 $23 = $7;
 $24 = $23 + 24 | 0;
 $25 = HEAP16[$24 >> 1] | 0;
 $14 = $25;
 $26 = $7;
 $27 = $26 + 26 | 0;
 $28 = HEAP16[$27 >> 1] | 0;
 $15 = $28;
 $29 = $7;
 $30 = $29 + 30 | 0;
 $31 = HEAP16[$30 >> 1] | 0;
 $16 = $31;
 $32 = $7;
 $33 = _comp_next_label($32) | 0;
 $17 = $33;
 $34 = $7;
 $35 = _comp_next_label($34) | 0;
 $18 = $35;
 $36 = $17;
 $37 = $36 & 65535;
 $38 = $7;
 $39 = $38 + 24 | 0;
 HEAP16[$39 >> 1] = $37;
 $40 = $18;
 $41 = $40 & 65535;
 $42 = $7;
 $43 = $42 + 26 | 0;
 HEAP16[$43 >> 1] = $41;
 $44 = $7;
 $45 = $44 + 28 | 0;
 $46 = HEAP16[$45 >> 1] | 0;
 $47 = $7;
 $48 = $47 + 30 | 0;
 HEAP16[$48 >> 1] = $46;
 $49 = $7;
 $50 = _comp_next_label($49) | 0;
 $19 = $50;
 $51 = $7;
 $52 = _comp_next_label($51) | 0;
 $20 = $52;
 $53 = $10;
 $54 = $53 & 1;
 $55 = ($54 | 0) == 1;
 $56 = $55 ^ 1;
 $57 = $56 & 1;
 $21 = $57;
 $58 = $21;
 $59 = $58 & 1;
 if ($59) {
  $60 = $7;
  $61 = $10;
  _compile_node($60, $61);
 }
 $62 = $7;
 $63 = $9;
 _compile_node($62, $63);
 $64 = $7;
 $65 = $64 + 40 | 0;
 $66 = HEAP32[$65 >> 2] | 0;
 $67 = $20;
 _mp_emit_bc_jump($66, $67);
 $68 = $7;
 $69 = $68 + 40 | 0;
 $70 = HEAP32[$69 >> 2] | 0;
 $71 = $19;
 _mp_emit_bc_label_assign($70, $71);
 $72 = $7;
 $73 = $72 + 40 | 0;
 $74 = HEAP32[$73 >> 2] | 0;
 _mp_emit_bc_dup_top($74);
 $75 = $7;
 $76 = $8;
 _c_assign($75, $76, 0);
 $77 = $7;
 $78 = $12;
 _compile_node($77, $78);
 $79 = $7;
 $80 = $79 + 40 | 0;
 $81 = HEAP32[$80 >> 2] | 0;
 $82 = $18;
 _mp_emit_bc_label_assign($81, $82);
 $83 = $7;
 $84 = $11;
 _compile_node($83, $84);
 $85 = $7;
 $86 = $85 + 40 | 0;
 $87 = HEAP32[$86 >> 2] | 0;
 _mp_emit_bc_binary_op($87, 14);
 $88 = $7;
 $89 = $88 + 40 | 0;
 $90 = HEAP32[$89 >> 2] | 0;
 $91 = $20;
 _mp_emit_bc_label_assign($90, $91);
 $92 = $21;
 $93 = $92 & 1;
 $94 = $7;
 $95 = $94 + 40 | 0;
 $96 = HEAP32[$95 >> 2] | 0;
 if ($93) {
  _mp_emit_bc_dup_top_two($96);
  $97 = $7;
  $98 = $97 + 40 | 0;
  $99 = HEAP32[$98 >> 2] | 0;
  _mp_emit_bc_rot_two($99);
 } else {
  _mp_emit_bc_dup_top($96);
  $100 = $7;
  $101 = $10;
  _compile_node($100, $101);
 }
 $102 = $11;
 $103 = $102 >> 1;
 $104 = ($103 | 0) >= 0;
 $105 = $7;
 $106 = $105 + 40 | 0;
 $107 = HEAP32[$106 >> 2] | 0;
 if ($104) {
  _mp_emit_bc_binary_op($107, 0);
 } else {
  _mp_emit_bc_binary_op($107, 1);
 }
 $108 = $7;
 $109 = $108 + 40 | 0;
 $110 = HEAP32[$109 >> 2] | 0;
 $111 = $19;
 _mp_emit_bc_pop_jump_if($110, 1, $111);
 $112 = $14;
 $113 = $7;
 $114 = $113 + 24 | 0;
 HEAP16[$114 >> 1] = $112;
 $115 = $15;
 $116 = $7;
 $117 = $116 + 26 | 0;
 HEAP16[$117 >> 1] = $115;
 $118 = $16;
 $119 = $7;
 $120 = $119 + 30 | 0;
 HEAP16[$120 >> 1] = $118;
 $22 = 0;
 $121 = $13;
 $122 = ($121 | 0) == 0;
 if (!$122) {
  $123 = $7;
  $124 = $123 + 40 | 0;
  $125 = HEAP32[$124 >> 2] | 0;
  _mp_emit_bc_pop_top($125);
  $126 = $21;
  $127 = $126 & 1;
  if ($127) {
   $128 = $7;
   $129 = $128 + 40 | 0;
   $130 = HEAP32[$129 >> 2] | 0;
   _mp_emit_bc_pop_top($130);
  }
  $131 = $7;
  $132 = $13;
  _compile_node($131, $132);
  $133 = $7;
  $134 = _comp_next_label($133) | 0;
  $22 = $134;
  $135 = $7;
  $136 = $135 + 40 | 0;
  $137 = HEAP32[$136 >> 2] | 0;
  $138 = $22;
  _mp_emit_bc_jump($137, $138);
  $139 = $7;
  $140 = $139 + 40 | 0;
  $141 = HEAP32[$140 >> 2] | 0;
  $142 = $21;
  $143 = $142 & 1;
  $144 = $143 & 1;
  $145 = 1 + $144 | 0;
  _mp_emit_bc_adjust_stack_size($141, $145);
 }
 $146 = $7;
 $147 = $146 + 40 | 0;
 $148 = HEAP32[$147 >> 2] | 0;
 $149 = $17;
 _mp_emit_bc_label_assign($148, $149);
 $150 = $7;
 $151 = $150 + 40 | 0;
 $152 = HEAP32[$151 >> 2] | 0;
 _mp_emit_bc_pop_top($152);
 $153 = $21;
 $154 = $153 & 1;
 if ($154) {
  $155 = $7;
  $156 = $155 + 40 | 0;
  $157 = HEAP32[$156 >> 2] | 0;
  _mp_emit_bc_pop_top($157);
 }
 $158 = $13;
 $159 = ($158 | 0) == 0;
 if ($159) {
  STACKTOP = sp;
  return;
 }
 $160 = $7;
 $161 = $160 + 40 | 0;
 $162 = HEAP32[$161 >> 2] | 0;
 $163 = $22;
 _mp_emit_bc_label_assign($162, $163);
 STACKTOP = sp;
 return;
}

function _mp_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_ptr4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $8 = sp + 24 | 0;
 $3 = $0;
 $4 = $1;
 $11 = $3;
 $12 = ($11 | 0) == 3;
 $13 = $4;
 if ($12) {
  $14 = _mp_obj_is_true($13) | 0;
  $15 = $14 & 1;
  $16 = ($15 | 0) == 0;
  $17 = $16 & 1;
  $18 = _mp_obj_new_bool($17) | 0;
  $2 = $18;
  $120 = $2;
  STACKTOP = sp;
  return $120 | 0;
 }
 $19 = _mp_obj_is_small_int_727($13) | 0;
 if (!$19) {
  $54 = $3;
  $55 = ($54 | 0) == 6;
  do {
   if ($55) {
    $56 = $4;
    $57 = _mp_obj_is_qstr_728($56) | 0;
    if (!$57) {
     $58 = $4;
     $59 = _mp_obj_is_obj_729($58) | 0;
     if (!$59) {
      break;
     }
     $60 = $4;
     $61 = HEAP32[$60 >> 2] | 0;
     $62 = $61 + 24 | 0;
     $63 = HEAP32[$62 >> 2] | 0;
     $64 = ($63 | 0) == (206 | 0);
     if (!$64) {
      break;
     }
    }
    $65 = $4;
    $66 = _mp_obj_is_qstr_728($65) | 0;
    $67 = $4;
    if ($66) {
     $68 = $67;
     $69 = $68 >>> 2;
     $70 = _qstr_hash($69) | 0;
     $6 = $70;
    } else {
     $71 = $67 + 4 | 0;
     $72 = HEAP32[$71 >> 2] | 0;
     $6 = $72;
    }
    $73 = $6;
    $74 = ($73 | 0) == 0;
    if ($74) {
     $75 = $4;
     $76 = _mp_obj_is_qstr_728($75) | 0;
     $77 = $4;
     if ($76) {
      $78 = $77;
      $79 = $78 >>> 2;
      $80 = _qstr_data($79, $8) | 0;
      $7 = $80;
     } else {
      $81 = $77 + 8 | 0;
      $82 = HEAP32[$81 >> 2] | 0;
      HEAP32[$8 >> 2] = $82;
      $83 = $4;
      $84 = $83 + 12 | 0;
      $85 = HEAP32[$84 >> 2] | 0;
      $7 = $85;
     }
     $86 = $7;
     $87 = HEAP32[$8 >> 2] | 0;
     $88 = _qstr_compute_hash($86, $87) | 0;
     $6 = $88;
    }
    $89 = $6;
    $90 = $89 << 1;
    $91 = $90 | 1;
    $92 = $91;
    $2 = $92;
    $120 = $2;
    STACKTOP = sp;
    return $120 | 0;
   }
  } while (0);
  $93 = $4;
  $94 = _mp_obj_get_type($93) | 0;
  $9 = $94;
  $95 = $9;
  $96 = $95 + 20 | 0;
  $97 = HEAP32[$96 >> 2] | 0;
  $98 = ($97 | 0) != (0 | 0);
  if ($98) {
   $99 = $9;
   $100 = $99 + 20 | 0;
   $101 = HEAP32[$100 >> 2] | 0;
   $102 = $3;
   $103 = $4;
   $104 = FUNCTION_TABLE_iii[$101 & 1023]($102, $103) | 0;
   $10 = $104;
   $105 = $10;
   $106 = ($105 | 0) != (0 | 0);
   if ($106) {
    $107 = $10;
    $2 = $107;
    $120 = $2;
    STACKTOP = sp;
    return $120 | 0;
   }
  }
  $108 = $3;
  $109 = ($108 | 0) == 8;
  if ($109) {
   $110 = $4;
   $111 = _mp_obj_get_type_str($110) | 0;
   HEAP32[$vararg_buffer >> 2] = $111;
   $112 = _mp_obj_new_exception_msg_varg(16012, 29584, $vararg_buffer) | 0;
   _nlr_jump($112);
  } else {
   $113 = $3;
   $114 = 32993 + $113 | 0;
   $115 = HEAP8[$114 >> 0] | 0;
   $116 = $115 & 255;
   $117 = $4;
   $118 = _mp_obj_get_type_str($117) | 0;
   HEAP32[$vararg_buffer1 >> 2] = $116;
   $vararg_ptr4 = $vararg_buffer1 + 4 | 0;
   HEAP32[$vararg_ptr4 >> 2] = $118;
   $119 = _mp_obj_new_exception_msg_varg(16012, 29608, $vararg_buffer1) | 0;
   _nlr_jump($119);
  }
 }
 $20 = $4;
 $21 = $20;
 $22 = $21 >> 1;
 $5 = $22;
 $23 = $3;
 switch ($23 | 0) {
 case 4:
  {
   $24 = $5;
   $25 = ($24 | 0) != 0;
   $26 = $25 & 1;
   $27 = _mp_obj_new_bool($26) | 0;
   $2 = $27;
   $120 = $2;
   STACKTOP = sp;
   return $120 | 0;
   break;
  }
 case 6:
  {
   $28 = $4;
   $2 = $28;
   $120 = $2;
   STACKTOP = sp;
   return $120 | 0;
   break;
  }
 case 8:
 case 0:
  {
   $29 = $4;
   $2 = $29;
   $120 = $2;
   STACKTOP = sp;
   return $120 | 0;
   break;
  }
 case 1:
  {
   $30 = $5;
   $31 = ($30 | 0) == -1073741824;
   $32 = $5;
   $33 = 0 - $32 | 0;
   if ($31) {
    $34 = _mp_obj_new_int($33) | 0;
    $2 = $34;
    $120 = $2;
    STACKTOP = sp;
    return $120 | 0;
   } else {
    $35 = $33 << 1;
    $36 = $35 | 1;
    $37 = $36;
    $2 = $37;
    $120 = $2;
    STACKTOP = sp;
    return $120 | 0;
   }
   break;
  }
 case 7:
  {
   $38 = $5;
   $39 = ($38 | 0) >= 0;
   if ($39) {
    $40 = $4;
    $2 = $40;
    $120 = $2;
    STACKTOP = sp;
    return $120 | 0;
   }
   $41 = $5;
   $42 = ($41 | 0) == -1073741824;
   $43 = $5;
   $44 = 0 - $43 | 0;
   if ($42) {
    $45 = _mp_obj_new_int($44) | 0;
    $2 = $45;
    $120 = $2;
    STACKTOP = sp;
    return $120 | 0;
   } else {
    $46 = $44 << 1;
    $47 = $46 | 1;
    $48 = $47;
    $2 = $48;
    $120 = $2;
    STACKTOP = sp;
    return $120 | 0;
   }
   break;
  }
 default:
  {
   $49 = $5;
   $50 = $49 ^ -1;
   $51 = $50 << 1;
   $52 = $51 | 1;
   $53 = $52;
   $2 = $53;
   $120 = $2;
   STACKTOP = sp;
   return $120 | 0;
  }
 }
 return 0 | 0;
}

function _mp_parse_num_integer($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, $or$cond5 = 0, $or$cond7 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $vararg_buffer = sp;
 $6 = sp + 40 | 0;
 $15 = sp + 8 | 0;
 $4 = $0;
 $5 = $1;
 HEAP32[$6 >> 2] = $2;
 $7 = $3;
 $17 = $4;
 $8 = $17;
 $18 = $8;
 $19 = $5;
 $20 = $18 + $19 | 0;
 $9 = $20;
 $10 = 0;
 $21 = HEAP32[$6 >> 2] | 0;
 $22 = ($21 | 0) != 0;
 $23 = HEAP32[$6 >> 2] | 0;
 $24 = ($23 | 0) < 2;
 $or$cond = $22 & $24;
 $25 = HEAP32[$6 >> 2] | 0;
 $26 = ($25 | 0) > 36;
 $or$cond3 = $or$cond | $26;
 if ($or$cond3) {
  _mp_raise_ValueError(29459);
 }
 while (1) {
  $27 = $8;
  $28 = $9;
  $29 = $27 >>> 0 < $28 >>> 0;
  if (!$29) {
   break;
  }
  $30 = $8;
  $31 = HEAP8[$30 >> 0] | 0;
  $32 = $31 & 255;
  $33 = _unichar_isspace($32) | 0;
  if (!$33) {
   break;
  }
  $34 = $8;
  $35 = $34 + 1 | 0;
  $8 = $35;
 }
 $36 = $8;
 $37 = $9;
 $38 = $36 >>> 0 < $37 >>> 0;
 do {
  if ($38) {
   $39 = $8;
   $40 = HEAP8[$39 >> 0] | 0;
   $41 = $40 & 255;
   $42 = ($41 | 0) == 43;
   $43 = $8;
   if ($42) {
    $44 = $43 + 1 | 0;
    $8 = $44;
    break;
   }
   $45 = HEAP8[$43 >> 0] | 0;
   $46 = $45 & 255;
   $47 = ($46 | 0) == 45;
   if ($47) {
    $48 = $8;
    $49 = $48 + 1 | 0;
    $8 = $49;
    $10 = 1;
   }
  }
 } while (0);
 $50 = $8;
 $51 = $9;
 $52 = $8;
 $53 = $51;
 $54 = $52;
 $55 = $53 - $54 | 0;
 $56 = _mp_parse_num_base($50, $55, $6) | 0;
 $57 = $8;
 $58 = $57 + $56 | 0;
 $8 = $58;
 $12 = 0;
 $59 = $8;
 $13 = $59;
 while (1) {
  $60 = $8;
  $61 = $9;
  $62 = $60 >>> 0 < $61 >>> 0;
  if (!$62) {
   label = 23;
   break;
  }
  $63 = $8;
  $64 = HEAP8[$63 >> 0] | 0;
  $65 = $64 & 255;
  $14 = $65;
  $66 = $14;
  $67 = 48 <= $66 >>> 0;
  $68 = $14;
  $69 = $68 >>> 0 <= 57;
  $or$cond5 = $67 & $69;
  $70 = $14;
  if ($or$cond5) {
   $71 = $70 - 48 | 0;
   $14 = $71;
   label = 19;
  } else {
   $72 = ($70 | 0) == 95;
   if (!$72) {
    $73 = $14;
    $74 = $73 | 32;
    $14 = $74;
    $75 = $14;
    $76 = 97 <= $75 >>> 0;
    $77 = $14;
    $78 = $77 >>> 0 <= 122;
    $or$cond7 = $76 & $78;
    if (!$or$cond7) {
     label = 23;
     break;
    }
    $79 = $14;
    $80 = $79 - 87 | 0;
    $14 = $80;
    label = 19;
   }
  }
  if ((label | 0) == 19) {
   label = 0;
   $81 = $14;
   $82 = HEAP32[$6 >> 2] | 0;
   $83 = $81 >>> 0 >= $82 >>> 0;
   if ($83) {
    label = 23;
    break;
   }
   $84 = $12;
   $85 = HEAP32[$6 >> 2] | 0;
   $86 = _mp_small_int_mul_overflow($84, $85) | 0;
   if ($86) {
    label = 33;
    break;
   }
   $87 = $12;
   $88 = HEAP32[$6 >> 2] | 0;
   $89 = Math_imul($87, $88) | 0;
   $90 = $14;
   $91 = $89 + $90 | 0;
   $12 = $91;
   $92 = $12;
   $93 = $12;
   $94 = $93 << 1;
   $95 = $92 ^ $94;
   $96 = $95 & -2147483648;
   $97 = ($96 | 0) == 0;
   if (!$97) {
    label = 33;
    break;
   }
  }
  $98 = $8;
  $99 = $98 + 1 | 0;
  $8 = $99;
 }
 if ((label | 0) == 23) {
  $100 = $10;
  $101 = $100 & 1;
  if ($101) {
   $102 = $12;
   $103 = 0 - $102 | 0;
   $12 = $103;
  }
  $104 = $12;
  $105 = $104 << 1;
  $106 = $105 | 1;
  $107 = $106;
  $11 = $107;
 } else if ((label | 0) == 33) {
  $124 = $13;
  HEAP32[$15 >> 2] = $124;
  $125 = $9;
  $126 = $13;
  $127 = $125;
  $128 = $126;
  $129 = $127 - $128 | 0;
  $130 = $10;
  $131 = $130 & 1;
  $132 = HEAP32[$6 >> 2] | 0;
  $133 = _mp_obj_new_int_from_str_len($15, $129, $131, $132) | 0;
  $11 = $133;
  $134 = HEAP32[$15 >> 2] | 0;
  $8 = $134;
 }
 $108 = $8;
 $109 = $13;
 $110 = ($108 | 0) == ($109 | 0);
 if ($110) {
  $135 = HEAP32[$6 >> 2] | 0;
  HEAP32[$vararg_buffer >> 2] = $135;
  $136 = _mp_obj_new_exception_msg_varg(16072, 29494, $vararg_buffer) | 0;
  $16 = $136;
  $137 = $16;
  $138 = $7;
  _raise_exc($137, $138);
 }
 while (1) {
  $111 = $8;
  $112 = $9;
  $113 = $111 >>> 0 < $112 >>> 0;
  if (!$113) {
   break;
  }
  $114 = $8;
  $115 = HEAP8[$114 >> 0] | 0;
  $116 = $115 & 255;
  $117 = _unichar_isspace($116) | 0;
  if (!$117) {
   break;
  }
  $118 = $8;
  $119 = $118 + 1 | 0;
  $8 = $119;
 }
 $120 = $8;
 $121 = $9;
 $122 = ($120 | 0) != ($121 | 0);
 if ($122) {
  $135 = HEAP32[$6 >> 2] | 0;
  HEAP32[$vararg_buffer >> 2] = $135;
  $136 = _mp_obj_new_exception_msg_varg(16072, 29494, $vararg_buffer) | 0;
  $16 = $136;
  $137 = $16;
  $138 = $7;
  _raise_exc($137, $138);
 } else {
  $123 = $11;
  STACKTOP = sp;
  return $123 | 0;
 }
 return 0 | 0;
}

function _framebuf_blit($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $154 = 0, $155 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $3 = $0;
 $4 = $1;
 $19 = $4;
 $20 = HEAP32[$19 >> 2] | 0;
 $5 = $20;
 $21 = $4;
 $22 = $21 + 4 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $6 = $23;
 $24 = $4;
 $25 = $24 + 8 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = _mp_obj_get_int($26) | 0;
 $7 = $27;
 $28 = $4;
 $29 = $28 + 12 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = _mp_obj_get_int($30) | 0;
 $8 = $31;
 $9 = -1;
 $32 = $3;
 $33 = $32 >>> 0 > 4;
 if ($33) {
  $34 = $4;
  $35 = $34 + 16 | 0;
  $36 = HEAP32[$35 >> 2] | 0;
  $37 = _mp_obj_get_int($36) | 0;
  $9 = $37;
 }
 $38 = $7;
 $39 = $5;
 $40 = $39 + 12 | 0;
 $41 = HEAP16[$40 >> 1] | 0;
 $42 = $41 & 65535;
 $43 = ($38 | 0) >= ($42 | 0);
 if (!$43) {
  $44 = $8;
  $45 = $5;
  $46 = $45 + 14 | 0;
  $47 = HEAP16[$46 >> 1] | 0;
  $48 = $47 & 65535;
  $49 = ($44 | 0) >= ($48 | 0);
  if (!$49) {
   $50 = $7;
   $51 = 0 - $50 | 0;
   $52 = $6;
   $53 = $52 + 12 | 0;
   $54 = HEAP16[$53 >> 1] | 0;
   $55 = $54 & 65535;
   $56 = ($51 | 0) >= ($55 | 0);
   if (!$56) {
    $57 = $8;
    $58 = 0 - $57 | 0;
    $59 = $6;
    $60 = $59 + 14 | 0;
    $61 = HEAP16[$60 >> 1] | 0;
    $62 = $61 & 65535;
    $63 = ($58 | 0) >= ($62 | 0);
    if (!$63) {
     $64 = $7;
     $65 = 0 > ($64 | 0);
     $66 = $7;
     $67 = $65 ? 0 : $66;
     $10 = $67;
     $68 = $8;
     $69 = 0 > ($68 | 0);
     $70 = $8;
     $71 = $69 ? 0 : $70;
     $11 = $71;
     $72 = $7;
     $73 = 0 - $72 | 0;
     $74 = 0 > ($73 | 0);
     $75 = $7;
     $76 = 0 - $75 | 0;
     $77 = $74 ? 0 : $76;
     $12 = $77;
     $78 = $8;
     $79 = 0 - $78 | 0;
     $80 = 0 > ($79 | 0);
     $81 = $8;
     $82 = 0 - $81 | 0;
     $83 = $80 ? 0 : $82;
     $13 = $83;
     $84 = $5;
     $85 = $84 + 12 | 0;
     $86 = HEAP16[$85 >> 1] | 0;
     $87 = $86 & 65535;
     $88 = $7;
     $89 = $6;
     $90 = $89 + 12 | 0;
     $91 = HEAP16[$90 >> 1] | 0;
     $92 = $91 & 65535;
     $93 = $88 + $92 | 0;
     $94 = ($87 | 0) < ($93 | 0);
     if ($94) {
      $95 = $5;
      $96 = $95 + 12 | 0;
      $97 = HEAP16[$96 >> 1] | 0;
      $98 = $97 & 65535;
      $105 = $98;
     } else {
      $99 = $7;
      $100 = $6;
      $101 = $100 + 12 | 0;
      $102 = HEAP16[$101 >> 1] | 0;
      $103 = $102 & 65535;
      $104 = $99 + $103 | 0;
      $105 = $104;
     }
     $14 = $105;
     $106 = $5;
     $107 = $106 + 14 | 0;
     $108 = HEAP16[$107 >> 1] | 0;
     $109 = $108 & 65535;
     $110 = $8;
     $111 = $6;
     $112 = $111 + 14 | 0;
     $113 = HEAP16[$112 >> 1] | 0;
     $114 = $113 & 65535;
     $115 = $110 + $114 | 0;
     $116 = ($109 | 0) < ($115 | 0);
     if ($116) {
      $117 = $5;
      $118 = $117 + 14 | 0;
      $119 = HEAP16[$118 >> 1] | 0;
      $120 = $119 & 65535;
      $127 = $120;
     } else {
      $121 = $8;
      $122 = $6;
      $123 = $122 + 14 | 0;
      $124 = HEAP16[$123 >> 1] | 0;
      $125 = $124 & 65535;
      $126 = $121 + $125 | 0;
      $127 = $126;
     }
     $15 = $127;
     while (1) {
      $128 = $11;
      $129 = $15;
      $130 = ($128 | 0) < ($129 | 0);
      if (!$130) {
       break;
      }
      $131 = $12;
      $16 = $131;
      $132 = $10;
      $17 = $132;
      while (1) {
       $133 = $17;
       $134 = $14;
       $135 = ($133 | 0) < ($134 | 0);
       if (!$135) {
        break;
       }
       $136 = $6;
       $137 = $16;
       $138 = $13;
       $139 = _getpixel($136, $137, $138) | 0;
       $18 = $139;
       $140 = $18;
       $141 = $9;
       $142 = ($140 | 0) != ($141 | 0);
       if ($142) {
        $143 = $5;
        $144 = $17;
        $145 = $11;
        $146 = $18;
        _setpixel($143, $144, $145, $146);
       }
       $147 = $16;
       $148 = $147 + 1 | 0;
       $16 = $148;
       $149 = $17;
       $150 = $149 + 1 | 0;
       $17 = $150;
      }
      $151 = $13;
      $152 = $151 + 1 | 0;
      $13 = $152;
      $153 = $11;
      $154 = $153 + 1 | 0;
      $11 = $154;
     }
     $2 = 17668;
     $155 = $2;
     STACKTOP = sp;
     return $155 | 0;
    }
   }
  }
 }
 $2 = 17668;
 $155 = $2;
 STACKTOP = sp;
 return $155 | 0;
}

function _expm1($0) {
 $0 = +$0;
 var $$0 = 0.0, $$0105 = 0, $$0106 = 0.0, $$0107 = 0.0, $$0109 = 0.0, $$0110 = 0.0, $$0111 = 0.0, $$1 = 0, $$1108 = 0.0, $$sink = 0.0, $$sink113 = 0.0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0.0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0, $25 = 0.0, $26 = 0.0, $27 = 0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $55 = 0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0, $60 = 0.0, $61 = 0.0, $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0.0, $71 = 0.0, $72 = 0.0, $73 = 0, $74 = 0, $75 = 0, $76 = 0.0, $77 = 0, $78 = 0.0, $79 = 0.0, $8 = 0, $80 = 0, $81 = 0.0, $82 = 0.0, $83 = 0.0, $84 = 0.0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0.0, $9 = 0, $90 = 0.0, $91 = 0.0, $92 = 0.0, $93 = 0.0, $94 = 0.0, $95 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = $2 & 2147483647;
 $4 = _bitshift64Lshr($1 | 0, $2 | 0, 63) | 0;
 $5 = getTempRet0() | 0;
 $6 = $3 >>> 0 > 1078159481;
 do {
  if ($6) {
   $7 = ___DOUBLE_BITS_149($0) | 0;
   $8 = getTempRet0() | 0;
   $9 = $8 & 2147483647;
   $10 = $9 >>> 0 > 2146435072;
   $11 = $7 >>> 0 > 0;
   $12 = ($9 | 0) == 2146435072;
   $13 = $12 & $11;
   $14 = $10 | $13;
   if ($14) {
    $$0 = $0;
   } else {
    $15 = ($4 | 0) == 0;
    if ($15) {
     $16 = $0 > 709.782712893384;
     if ($16) {
      $17 = $0 * 8988465674311579538646525.0e283;
      $$0 = $17;
     } else {
      label = 11;
     }
    } else {
     $$0 = -1.0;
    }
   }
  } else {
   $18 = $3 >>> 0 > 1071001154;
   if (!$18) {
    $35 = $3 >>> 0 < 1016070144;
    if ($35) {
     $$0 = $0;
     break;
    } else {
     $$0106 = $0;
     $$0111 = 0.0;
     $$1 = 0;
     label = 14;
     break;
    }
   }
   $19 = $3 >>> 0 < 1072734898;
   if ($19) {
    $20 = ($4 | 0) == 0;
    if ($20) {
     $21 = $0 + -.6931471803691238;
     $$0105 = 1;
     $$0109 = $21;
     $$0110 = 1.9082149292705877e-10;
     label = 12;
     break;
    } else {
     $22 = $0 + .6931471803691238;
     $$0105 = -1;
     $$0109 = $22;
     $$0110 = -1.9082149292705877e-10;
     label = 12;
     break;
    }
   } else {
    label = 11;
   }
  }
 } while (0);
 if ((label | 0) == 11) {
  $23 = $0 * 1.4426950408889634;
  $24 = ($4 | 0) == 0;
  $25 = $24 ? .5 : -.5;
  $26 = $23 + $25;
  $27 = ~~$26;
  $28 = +($27 | 0);
  $29 = $28 * .6931471803691238;
  $30 = $0 - $29;
  $31 = $28 * 1.9082149292705877e-10;
  $$0105 = $27;
  $$0109 = $30;
  $$0110 = $31;
  label = 12;
 }
 if ((label | 0) == 12) {
  $32 = $$0109 - $$0110;
  $33 = $$0109 - $32;
  $34 = $33 - $$0110;
  $$0106 = $32;
  $$0111 = $34;
  $$1 = $$0105;
  label = 14;
 }
 L18 : do {
  if ((label | 0) == 14) {
   $36 = $$0106 * .5;
   $37 = $$0106 * $36;
   $38 = $37 * 2.0109921818362437e-07;
   $39 = 4.008217827329362e-06 - $38;
   $40 = $37 * $39;
   $41 = $40 + -7.93650757867488e-05;
   $42 = $37 * $41;
   $43 = $42 + 1.5873015872548146e-03;
   $44 = $37 * $43;
   $45 = $44 + -.03333333333333313;
   $46 = $37 * $45;
   $47 = $46 + 1.0;
   $48 = $36 * $47;
   $49 = 3.0 - $48;
   $50 = $47 - $49;
   $51 = $$0106 * $49;
   $52 = 6.0 - $51;
   $53 = $50 / $52;
   $54 = $37 * $53;
   $55 = ($$1 | 0) == 0;
   if ($55) {
    $56 = $$0106 * $54;
    $57 = $56 - $37;
    $58 = $$0106 - $57;
    $$0 = $58;
    break;
   }
   $59 = $54 - $$0111;
   $60 = $$0106 * $59;
   $61 = $60 - $$0111;
   $62 = $61 - $37;
   switch ($$1 | 0) {
   case -1:
    {
     $63 = $$0106 - $62;
     $64 = $63 * .5;
     $65 = $64 + -.5;
     $$0 = $65;
     break L18;
     break;
    }
   case 1:
    {
     $66 = $$0106 < -.25;
     if ($66) {
      $67 = $$0106 + .5;
      $68 = $62 - $67;
      $69 = $68 * -2.0;
      $$0 = $69;
      break L18;
     } else {
      $70 = $$0106 - $62;
      $71 = $70 * 2.0;
      $72 = $71 + 1.0;
      $$0 = $72;
      break L18;
     }
     break;
    }
   default:
    {
     $73 = $$1 + 1023 | 0;
     $74 = _bitshift64Shl($73 | 0, 0, 52) | 0;
     $75 = getTempRet0() | 0;
     HEAP32[tempDoublePtr >> 2] = $74;
     HEAP32[tempDoublePtr + 4 >> 2] = $75;
     $76 = +HEAPF64[tempDoublePtr >> 3];
     $77 = $$1 >>> 0 > 56;
     if ($77) {
      $78 = $$0106 - $62;
      $79 = $78 + 1.0;
      $80 = ($$1 | 0) == 1024;
      $81 = $79 * 2.0;
      $82 = $81 * 8988465674311579538646525.0e283;
      $83 = $79 * $76;
      $$0107 = $80 ? $82 : $83;
      $84 = $$0107 + -1.0;
      $$0 = $84;
      break L18;
     }
     $85 = 1023 - $$1 | 0;
     $86 = _bitshift64Shl($85 | 0, 0, 52) | 0;
     $87 = getTempRet0() | 0;
     $88 = ($$1 | 0) < 20;
     if ($88) {
      $89 = $$0106 - $62;
      HEAP32[tempDoublePtr >> 2] = $86;
      HEAP32[tempDoublePtr + 4 >> 2] = $87;
      $90 = +HEAPF64[tempDoublePtr >> 3];
      $91 = 1.0 - $90;
      $$sink = $91;
      $$sink113 = $89;
     } else {
      HEAP32[tempDoublePtr >> 2] = $86;
      HEAP32[tempDoublePtr + 4 >> 2] = $87;
      $92 = +HEAPF64[tempDoublePtr >> 3];
      $93 = $62 + $92;
      $94 = $$0106 - $93;
      $$sink = $94;
      $$sink113 = 1.0;
     }
     $95 = $$sink + $$sink113;
     $$1108 = $95 * $76;
     $$0 = $$1108;
     break L18;
    }
   }
  }
 } while (0);
 return +$$0;
}

function _compile_scope_func_lambda_param($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $9 = $4;
 $14 = $5;
 $15 = $14 + 36 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $16 + 24 | 0;
 $18 = HEAP16[$17 >> 1] | 0;
 $19 = $18 & 65535;
 $20 = $19 & 2;
 $21 = ($20 | 0) != 0;
 if ($21) {
  $22 = $5;
  $23 = $6;
  _compile_syntax_error($22, $23, 28787);
  STACKTOP = sp;
  return;
 }
 $10 = 0;
 $11 = 1;
 $12 = 0;
 $24 = $6;
 $25 = $24 & 15;
 $26 = ($25 | 0) == 2;
 $27 = $6;
 do {
  if ($26) {
   $28 = $27 >>> 4;
   $10 = $28;
   $29 = $5;
   $30 = $29 + 6 | 0;
   $31 = HEAP8[$30 >> 0] | 0;
   $32 = $31 << 24 >> 24 != 0;
   $33 = $5;
   $34 = $33 + 36 | 0;
   $35 = HEAP32[$34 >> 2] | 0;
   if ($32) {
    $36 = $35 + 30 | 0;
    $37 = HEAP16[$36 >> 1] | 0;
    $38 = $37 & 65535;
    $39 = $38 + 1 | 0;
    $40 = $39 & 65535;
    HEAP16[$36 >> 1] = $40;
    break;
   } else {
    $41 = $35 + 28 | 0;
    $42 = HEAP16[$41 >> 1] | 0;
    $43 = $42 & 65535;
    $44 = $43 + 1 | 0;
    $45 = $44 & 65535;
    HEAP16[$41 >> 1] = $45;
    break;
   }
  } else {
   $46 = $27;
   $12 = $46;
   $47 = $12;
   $48 = $47 + 4 | 0;
   $49 = HEAP32[$48 >> 2] | 0;
   $50 = $49 & 255;
   $51 = $7;
   $52 = ($50 | 0) == ($51 | 0);
   $53 = $12;
   if ($52) {
    $54 = $53 + 8 | 0;
    $55 = HEAP32[$54 >> 2] | 0;
    $56 = $55 >>> 4;
    $10 = $56;
    $57 = $5;
    $58 = $57 + 6 | 0;
    $59 = HEAP8[$58 >> 0] | 0;
    $60 = $59 << 24 >> 24 != 0;
    $61 = $5;
    $62 = $61 + 36 | 0;
    $63 = HEAP32[$62 >> 2] | 0;
    if ($60) {
     $64 = $63 + 30 | 0;
     $65 = HEAP16[$64 >> 1] | 0;
     $66 = $65 & 65535;
     $67 = $66 + 1 | 0;
     $68 = $67 & 65535;
     HEAP16[$64 >> 1] = $68;
     break;
    } else {
     $69 = $63 + 28 | 0;
     $70 = HEAP16[$69 >> 1] | 0;
     $71 = $70 & 65535;
     $72 = $71 + 1 | 0;
     $73 = $72 & 65535;
     HEAP16[$69 >> 1] = $73;
     break;
    }
   }
   $74 = $53 + 4 | 0;
   $75 = HEAP32[$74 >> 2] | 0;
   $76 = $75 & 255;
   $77 = $8;
   $78 = ($76 | 0) == ($77 | 0);
   if (!$78) {
    $112 = $12;
    $113 = $112 + 8 | 0;
    $114 = HEAP32[$113 >> 2] | 0;
    $115 = $114 >>> 4;
    $10 = $115;
    $11 = 5;
    $116 = $5;
    $117 = $116 + 36 | 0;
    $118 = HEAP32[$117 >> 2] | 0;
    $119 = $118 + 24 | 0;
    $120 = HEAP16[$119 >> 1] | 0;
    $121 = $120 & 65535;
    $122 = $121 | 2;
    $123 = $122 & 65535;
    HEAP16[$119 >> 1] = $123;
    break;
   }
   $79 = $5;
   $80 = $79 + 6 | 0;
   $81 = HEAP8[$80 >> 0] | 0;
   $82 = $81 << 24 >> 24 != 0;
   $83 = $5;
   if ($82) {
    $84 = $6;
    _compile_syntax_error($83, $84, 28787);
    STACKTOP = sp;
    return;
   }
   $85 = $83 + 6 | 0;
   HEAP8[$85 >> 0] = 1;
   $11 = 3;
   $86 = $12;
   $87 = $86 + 8 | 0;
   $88 = HEAP32[$87 >> 2] | 0;
   $89 = ($88 | 0) == 0;
   if ($89) {
    $12 = 0;
    break;
   }
   $90 = $12;
   $91 = $90 + 8 | 0;
   $92 = HEAP32[$91 >> 2] | 0;
   $93 = $92 & 15;
   $94 = ($93 | 0) == 2;
   $95 = $5;
   $96 = $95 + 36 | 0;
   $97 = HEAP32[$96 >> 2] | 0;
   $98 = $97 + 24 | 0;
   $99 = HEAP16[$98 >> 1] | 0;
   $100 = $99 & 65535;
   $101 = $100 | 1;
   $102 = $101 & 65535;
   HEAP16[$98 >> 1] = $102;
   $103 = $12;
   $104 = $103 + 8 | 0;
   $105 = HEAP32[$104 >> 2] | 0;
   if ($94) {
    $106 = $105 >>> 4;
    $10 = $106;
    $12 = 0;
    break;
   } else {
    $107 = $105;
    $12 = $107;
    $108 = $12;
    $109 = $108 + 8 | 0;
    $110 = HEAP32[$109 >> 2] | 0;
    $111 = $110 >>> 4;
    $10 = $111;
    break;
   }
  }
 } while (0);
 $124 = $10;
 $125 = ($124 | 0) != 0;
 if (!$125) {
  STACKTOP = sp;
  return;
 }
 $126 = $5;
 $127 = $126 + 36 | 0;
 $128 = HEAP32[$127 >> 2] | 0;
 $129 = $10;
 $130 = _scope_find_or_add_id($128, $129, 0) | 0;
 $13 = $130;
 $131 = $13;
 $132 = HEAP8[$131 >> 0] | 0;
 $133 = $132 & 255;
 $134 = ($133 | 0) != 0;
 if ($134) {
  $135 = $5;
  $136 = $6;
  _compile_syntax_error($135, $136, 28802);
  STACKTOP = sp;
  return;
 } else {
  $137 = $13;
  HEAP8[$137 >> 0] = 3;
  $138 = $11;
  $139 = $138 & 255;
  $140 = $13;
  $141 = $140 + 1 | 0;
  HEAP8[$141 >> 0] = $139;
  STACKTOP = sp;
  return;
 }
}

function _mp_binary_get_val($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = Math_fround(0), $84 = 0.0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0.0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $8 = sp + 28 | 0;
 $10 = sp + 8 | 0;
 $12 = sp + 16 | 0;
 $13 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $14 = $6;
 $15 = HEAP32[$14 >> 2] | 0;
 $7 = $15;
 $16 = $4;
 $17 = $5;
 $18 = _mp_binary_get_size($16, $17, $8) | 0;
 $9 = $18;
 $19 = $4;
 $20 = $19 << 24 >> 24;
 $21 = ($20 | 0) == 64;
 if ($21) {
  $22 = $7;
  $23 = $22;
  $24 = HEAP32[$8 >> 2] | 0;
  $25 = $24 - 1 | 0;
  $26 = $23 + $25 | 0;
  $27 = HEAP32[$8 >> 2] | 0;
  $28 = $27 - 1 | 0;
  $29 = $28 ^ -1;
  $30 = $26 & $29;
  $31 = $30;
  $7 = $31;
  $4 = 60;
 }
 $32 = $7;
 $33 = $9;
 $34 = $32 + $33 | 0;
 $35 = $6;
 HEAP32[$35 >> 2] = $34;
 $36 = $9;
 $37 = $5;
 $38 = $37 << 24 >> 24;
 $39 = ($38 | 0) > 90;
 $40 = $4;
 $41 = $40 << 24 >> 24;
 $42 = ($41 | 0) == 62;
 $43 = $7;
 $44 = _mp_binary_get_int($36, $39, $42, $43) | 0;
 $45 = getTempRet0() | 0;
 $46 = $10;
 $47 = $46;
 HEAP32[$47 >> 2] = $44;
 $48 = $46 + 4 | 0;
 $49 = $48;
 HEAP32[$49 >> 2] = $45;
 $50 = $5;
 $51 = $50 << 24 >> 24;
 $52 = ($51 | 0) == 79;
 if ($52) {
  $53 = $10;
  $54 = $53;
  $55 = HEAP32[$54 >> 2] | 0;
  $56 = $53 + 4 | 0;
  $57 = $56;
  $58 = HEAP32[$57 >> 2] | 0;
  $59 = $55;
  $3 = $59;
  $147 = $3;
  STACKTOP = sp;
  return $147 | 0;
 }
 $60 = $5;
 $61 = $60 << 24 >> 24;
 $62 = ($61 | 0) == 83;
 if ($62) {
  $63 = $10;
  $64 = $63;
  $65 = HEAP32[$64 >> 2] | 0;
  $66 = $63 + 4 | 0;
  $67 = $66;
  $68 = HEAP32[$67 >> 2] | 0;
  $69 = $65;
  $11 = $69;
  $70 = $11;
  $71 = $11;
  $72 = _strlen($71) | 0;
  $73 = _mp_obj_new_str($70, $72) | 0;
  $3 = $73;
  $147 = $3;
  STACKTOP = sp;
  return $147 | 0;
 }
 $74 = $5;
 $75 = $74 << 24 >> 24;
 $76 = ($75 | 0) == 102;
 if ($76) {
  $77 = $10;
  $78 = $77;
  $79 = HEAP32[$78 >> 2] | 0;
  $80 = $77 + 4 | 0;
  $81 = $80;
  $82 = HEAP32[$81 >> 2] | 0;
  HEAP32[$12 >> 2] = $79;
  $83 = Math_fround(HEAPF32[$12 >> 2]);
  $84 = +$83;
  $85 = _mp_obj_new_float($84) | 0;
  $3 = $85;
  $147 = $3;
  STACKTOP = sp;
  return $147 | 0;
 }
 $86 = $5;
 $87 = $86 << 24 >> 24;
 $88 = ($87 | 0) == 100;
 if ($88) {
  $89 = $10;
  $90 = $89;
  $91 = HEAP32[$90 >> 2] | 0;
  $92 = $89 + 4 | 0;
  $93 = $92;
  $94 = HEAP32[$93 >> 2] | 0;
  $95 = $13;
  $96 = $95;
  HEAP32[$96 >> 2] = $91;
  $97 = $95 + 4 | 0;
  $98 = $97;
  HEAP32[$98 >> 2] = $94;
  $99 = +HEAPF64[$13 >> 3];
  $100 = _mp_obj_new_float($99) | 0;
  $3 = $100;
  $147 = $3;
  STACKTOP = sp;
  return $147 | 0;
 }
 $101 = $5;
 $102 = $101 << 24 >> 24;
 $103 = ($102 | 0) > 90;
 $104 = $10;
 $105 = $104;
 $106 = HEAP32[$105 >> 2] | 0;
 $107 = $104 + 4 | 0;
 $108 = $107;
 $109 = HEAP32[$108 >> 2] | 0;
 if ($103) {
  $110 = -1 < ($109 | 0);
  $111 = 3221225472 <= $106 >>> 0;
  $112 = -1 == ($109 | 0);
  $113 = $112 & $111;
  $114 = $110 | $113;
  $115 = $10;
  $116 = $115;
  $117 = HEAP32[$116 >> 2] | 0;
  $118 = $115 + 4 | 0;
  $119 = $118;
  $120 = HEAP32[$119 >> 2] | 0;
  $121 = ($120 | 0) < 0;
  $122 = $117 >>> 0 <= 1073741823;
  $123 = ($120 | 0) == 0;
  $124 = $123 & $122;
  $125 = $121 | $124;
  $or$cond = $114 & $125;
  $126 = $10;
  $127 = $126;
  $128 = HEAP32[$127 >> 2] | 0;
  $129 = $126 + 4 | 0;
  $130 = $129;
  $131 = HEAP32[$130 >> 2] | 0;
  if ($or$cond) {
   $132 = _mp_obj_new_int($128) | 0;
   $3 = $132;
   $147 = $3;
   STACKTOP = sp;
   return $147 | 0;
  } else {
   $133 = _mp_obj_new_int_from_ll($128, $131) | 0;
   $3 = $133;
   $147 = $3;
   STACKTOP = sp;
   return $147 | 0;
  }
 } else {
  $134 = $109 >>> 0 < 0;
  $135 = $106 >>> 0 <= 1073741823;
  $136 = ($109 | 0) == 0;
  $137 = $136 & $135;
  $138 = $134 | $137;
  $139 = $10;
  $140 = $139;
  $141 = HEAP32[$140 >> 2] | 0;
  $142 = $139 + 4 | 0;
  $143 = $142;
  $144 = HEAP32[$143 >> 2] | 0;
  if ($138) {
   $145 = _mp_obj_new_int_from_uint($141) | 0;
   $3 = $145;
   $147 = $3;
   STACKTOP = sp;
   return $147 | 0;
  } else {
   $146 = _mp_obj_new_int_from_ull($141, $144) | 0;
   $3 = $146;
   $147 = $3;
   STACKTOP = sp;
   return $147 | 0;
  }
 }
 return 0 | 0;
}

function _check_for_doc_string($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $8 = $3;
 $9 = ($8 | 0) != 0;
 if ($9) {
  $10 = $3;
  $11 = $10 & 3;
  $12 = ($11 | 0) == 0;
  if ($12) {
   $13 = $3;
   $14 = $13;
   $15 = $14 + 4 | 0;
   $16 = HEAP32[$15 >> 2] | 0;
   $17 = $16 & 255;
   $18 = ($17 | 0) == 5;
   if (!$18) {
    label = 4;
   }
  } else {
   label = 4;
  }
 } else {
  label = 4;
 }
 L4 : do {
  if ((label | 0) == 4) {
   $19 = $3;
   $20 = ($19 | 0) != 0;
   if ($20) {
    $21 = $3;
    $22 = $21 & 3;
    $23 = ($22 | 0) == 0;
    if ($23) {
     $24 = $3;
     $25 = $24;
     $26 = $25 + 4 | 0;
     $27 = HEAP32[$26 >> 2] | 0;
     $28 = $27 & 255;
     $29 = ($28 | 0) == 1;
     if ($29) {
      $30 = $3;
      $31 = $30;
      $4 = $31;
      $32 = $4;
      $33 = $32 + 4 | 0;
      $34 = HEAP32[$33 >> 2] | 0;
      $35 = $34 >>> 8;
      $5 = $35;
      $6 = 0;
      while (1) {
       $36 = $6;
       $37 = $5;
       $38 = ($36 | 0) < ($37 | 0);
       if (!$38) {
        break L4;
       }
       $39 = $4;
       $40 = $39 + 8 | 0;
       $41 = $6;
       $42 = $40 + ($41 << 2) | 0;
       $43 = HEAP32[$42 >> 2] | 0;
       $3 = $43;
       $44 = $3;
       $45 = $44 & 3;
       $46 = ($45 | 0) != 0;
       if (!$46) {
        break L4;
       }
       $47 = $3;
       $48 = $47 & 15;
       $49 = ($48 | 0) == 14;
       if (!$49) {
        break L4;
       }
       $50 = $3;
       $51 = $50 >>> 4;
       $52 = ($51 | 0) == 4;
       if (!$52) {
        break L4;
       }
       $53 = $6;
       $54 = $53 + 1 | 0;
       $6 = $54;
      }
     }
    }
   }
   $55 = $3;
   $56 = ($55 | 0) != 0;
   if (!$56) {
    STACKTOP = sp;
    return;
   }
   $57 = $3;
   $58 = $57 & 3;
   $59 = ($58 | 0) == 0;
   if (!$59) {
    STACKTOP = sp;
    return;
   }
   $60 = $3;
   $61 = $60;
   $62 = $61 + 4 | 0;
   $63 = HEAP32[$62 >> 2] | 0;
   $64 = $63 & 255;
   $65 = ($64 | 0) == 25;
   if ($65) {
    $66 = $3;
    $67 = $66;
    $68 = $67 + 8 | 0;
    $69 = HEAP32[$68 >> 2] | 0;
    $3 = $69;
    break;
   } else {
    STACKTOP = sp;
    return;
   }
  }
 } while (0);
 $70 = $3;
 $71 = ($70 | 0) != 0;
 if (!$71) {
  STACKTOP = sp;
  return;
 }
 $72 = $3;
 $73 = $72 & 3;
 $74 = ($73 | 0) == 0;
 if (!$74) {
  STACKTOP = sp;
  return;
 }
 $75 = $3;
 $76 = $75;
 $77 = $76 + 4 | 0;
 $78 = HEAP32[$77 >> 2] | 0;
 $79 = $78 & 255;
 $80 = ($79 | 0) == 5;
 if (!$80) {
  STACKTOP = sp;
  return;
 }
 $81 = $3;
 $82 = $81;
 $7 = $82;
 $83 = $7;
 $84 = $83 + 8 | 0;
 $85 = HEAP32[$84 >> 2] | 0;
 $86 = $85 & 3;
 $87 = ($86 | 0) != 0;
 if ($87) {
  $88 = $7;
  $89 = $88 + 8 | 0;
  $90 = HEAP32[$89 >> 2] | 0;
  $91 = $90 & 15;
  $92 = ($91 | 0) == 6;
  if (!$92) {
   label = 22;
  }
 } else {
  label = 22;
 }
 if ((label | 0) == 22) {
  $93 = $7;
  $94 = $93 + 8 | 0;
  $95 = HEAP32[$94 >> 2] | 0;
  $96 = ($95 | 0) != 0;
  if (!$96) {
   STACKTOP = sp;
   return;
  }
  $97 = $7;
  $98 = $97 + 8 | 0;
  $99 = HEAP32[$98 >> 2] | 0;
  $100 = $99 & 3;
  $101 = ($100 | 0) == 0;
  if (!$101) {
   STACKTOP = sp;
   return;
  }
  $102 = $7;
  $103 = $102 + 8 | 0;
  $104 = HEAP32[$103 >> 2] | 0;
  $105 = $104;
  $106 = $105 + 4 | 0;
  $107 = HEAP32[$106 >> 2] | 0;
  $108 = $107 & 255;
  $109 = ($108 | 0) == 57;
  if (!$109) {
   STACKTOP = sp;
   return;
  }
  $110 = $7;
  $111 = $110 + 8 | 0;
  $112 = HEAP32[$111 >> 2] | 0;
  $113 = $112;
  $114 = _get_const_object($113) | 0;
  $115 = _mp_obj_is_qstr($114) | 0;
  if (!$115) {
   $116 = $7;
   $117 = $116 + 8 | 0;
   $118 = HEAP32[$117 >> 2] | 0;
   $119 = $118;
   $120 = _get_const_object($119) | 0;
   $121 = _mp_obj_is_obj_568($120) | 0;
   if (!$121) {
    STACKTOP = sp;
    return;
   }
   $122 = $7;
   $123 = $122 + 8 | 0;
   $124 = HEAP32[$123 >> 2] | 0;
   $125 = $124;
   $126 = _get_const_object($125) | 0;
   $127 = HEAP32[$126 >> 2] | 0;
   $128 = ($127 | 0) == (18680 | 0);
   if (!$128) {
    STACKTOP = sp;
    return;
   }
  }
 }
 $129 = $2;
 $130 = $7;
 $131 = $130 + 8 | 0;
 $132 = HEAP32[$131 >> 2] | 0;
 _compile_node($129, $132);
 $133 = $2;
 _compile_store_id($133, 178);
 STACKTOP = sp;
 return;
}

function _str_rsplit($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $8 = sp + 36 | 0;
 $13 = sp + 16 | 0;
 $3 = $0;
 $4 = $1;
 $18 = $3;
 $19 = $18 >>> 0 < 3;
 if ($19) {
  $20 = $3;
  $21 = $4;
  $22 = _mp_obj_str_split($20, $21) | 0;
  $2 = $22;
  $153 = $2;
  STACKTOP = sp;
  return $153 | 0;
 }
 $23 = $4;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = _mp_obj_get_type($24) | 0;
 $5 = $25;
 $26 = $4;
 $27 = $26 + 4 | 0;
 $28 = HEAP32[$27 >> 2] | 0;
 $6 = $28;
 $29 = $4;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = _mp_obj_is_qstr_1128($30) | 0;
 $32 = $4;
 $33 = HEAP32[$32 >> 2] | 0;
 if ($31) {
  $34 = $33;
  $35 = $34 >>> 2;
  $36 = _qstr_data($35, $8) | 0;
  $7 = $36;
 } else {
  $37 = $33 + 8 | 0;
  $38 = HEAP32[$37 >> 2] | 0;
  HEAP32[$8 >> 2] = $38;
  $39 = $4;
  $40 = HEAP32[$39 >> 2] | 0;
  $41 = $40 + 12 | 0;
  $42 = HEAP32[$41 >> 2] | 0;
  $7 = $42;
 }
 $43 = $4;
 $44 = $43 + 8 | 0;
 $45 = HEAP32[$44 >> 2] | 0;
 $46 = _mp_obj_get_int($45) | 0;
 $9 = $46;
 $47 = $9;
 $48 = ($47 | 0) < 0;
 if ($48) {
  $49 = $3;
  $50 = $4;
  $51 = _mp_obj_str_split($49, $50) | 0;
  $2 = $51;
  $153 = $2;
  STACKTOP = sp;
  return $153 | 0;
 }
 $52 = $9;
 $10 = $52;
 $53 = $9;
 $54 = $53 + 1 | 0;
 $55 = _mp_obj_new_list($54, 0) | 0;
 $11 = $55;
 $56 = $9;
 $12 = $56;
 $57 = $6;
 $58 = ($57 | 0) == (17668 | 0);
 if ($58) {
  _mp_raise_NotImplementedError(32370);
 }
 $59 = $6;
 $60 = _mp_obj_str_get_data($59, $13) | 0;
 $14 = $60;
 $61 = HEAP32[$13 >> 2] | 0;
 $62 = ($61 | 0) == 0;
 if ($62) {
  _mp_raise_ValueError(31716);
 }
 $63 = $7;
 $15 = $63;
 $64 = $7;
 $65 = HEAP32[$8 >> 2] | 0;
 $66 = $64 + $65 | 0;
 $16 = $66;
 while (1) {
  $67 = $16;
  $68 = HEAP32[$13 >> 2] | 0;
  $69 = 0 - $68 | 0;
  $70 = $67 + $69 | 0;
  $7 = $70;
  while (1) {
   $71 = $9;
   $72 = ($71 | 0) == 0;
   if ($72) {
    break;
   }
   $73 = $7;
   $74 = $15;
   $75 = $73 >>> 0 < $74 >>> 0;
   if ($75) {
    break;
   }
   $76 = $7;
   $77 = $14;
   $78 = HEAP32[$13 >> 2] | 0;
   $79 = _memcmp($76, $77, $78) | 0;
   $80 = ($79 | 0) == 0;
   if ($80) {
    break;
   }
   $81 = $7;
   $82 = $81 + -1 | 0;
   $7 = $82;
  }
  $83 = $7;
  $84 = $15;
  $85 = $83 >>> 0 < $84 >>> 0;
  $86 = $9;
  $87 = ($86 | 0) == 0;
  $or$cond = $85 | $87;
  $88 = $5;
  if ($or$cond) {
   break;
  }
  $103 = $7;
  $104 = HEAP32[$13 >> 2] | 0;
  $105 = $103 + $104 | 0;
  $106 = $16;
  $107 = $7;
  $108 = $106;
  $109 = $107;
  $110 = $108 - $109 | 0;
  $111 = HEAP32[$13 >> 2] | 0;
  $112 = $110 - $111 | 0;
  $113 = _mp_obj_new_str_of_type($88, $105, $112) | 0;
  $114 = $11;
  $115 = $114 + 12 | 0;
  $116 = HEAP32[$115 >> 2] | 0;
  $117 = $12;
  $118 = $117 + -1 | 0;
  $12 = $118;
  $119 = $116 + ($117 << 2) | 0;
  HEAP32[$119 >> 2] = $113;
  $120 = $7;
  $16 = $120;
  $121 = $9;
  $122 = $121 + -1 | 0;
  $9 = $122;
 }
 $89 = $15;
 $90 = $16;
 $91 = $15;
 $92 = $90;
 $93 = $91;
 $94 = $92 - $93 | 0;
 $95 = _mp_obj_new_str_of_type($88, $89, $94) | 0;
 $96 = $11;
 $97 = $96 + 12 | 0;
 $98 = HEAP32[$97 >> 2] | 0;
 $99 = $12;
 $100 = $98 + ($99 << 2) | 0;
 HEAP32[$100 >> 2] = $95;
 $101 = $12;
 $102 = ($101 | 0) != 0;
 if ($102) {
  $123 = $10;
  $124 = $123 + 1 | 0;
  $125 = $12;
  $126 = $124 - $125 | 0;
  $17 = $126;
  $127 = $11;
  $128 = $127 + 12 | 0;
  $129 = HEAP32[$128 >> 2] | 0;
  $130 = $11;
  $131 = $130 + 12 | 0;
  $132 = HEAP32[$131 >> 2] | 0;
  $133 = $12;
  $134 = $132 + ($133 << 2) | 0;
  $135 = $17;
  $136 = $135 << 2;
  _memmove($129 | 0, $134 | 0, $136 | 0) | 0;
  $137 = $11;
  $138 = $137 + 12 | 0;
  $139 = HEAP32[$138 >> 2] | 0;
  $140 = $17;
  $141 = $140 << 2;
  $142 = $139 + $141 | 0;
  $143 = $11;
  $144 = $143 + 4 | 0;
  $145 = HEAP32[$144 >> 2] | 0;
  $146 = $17;
  $147 = $145 - $146 | 0;
  $148 = $147 << 2;
  _memset($142 | 0, 0, $148 | 0) | 0;
  $149 = $17;
  $150 = $11;
  $151 = $150 + 8 | 0;
  HEAP32[$151 >> 2] = $149;
 }
 $152 = $11;
 $2 = $152;
 $153 = $2;
 STACKTOP = sp;
 return $153 | 0;
}

function _framebuf_line($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, $or$cond5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $2 = $0;
 $3 = $1;
 $18 = $3;
 $19 = HEAP32[$18 >> 2] | 0;
 $4 = $19;
 $20 = $3;
 $21 = $20 + 4 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = _mp_obj_get_int($22) | 0;
 $5 = $23;
 $24 = $3;
 $25 = $24 + 8 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = _mp_obj_get_int($26) | 0;
 $6 = $27;
 $28 = $3;
 $29 = $28 + 12 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = _mp_obj_get_int($30) | 0;
 $7 = $31;
 $32 = $3;
 $33 = $32 + 16 | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = _mp_obj_get_int($34) | 0;
 $8 = $35;
 $36 = $3;
 $37 = $36 + 20 | 0;
 $38 = HEAP32[$37 >> 2] | 0;
 $39 = _mp_obj_get_int($38) | 0;
 $9 = $39;
 $40 = $7;
 $41 = $5;
 $42 = $40 - $41 | 0;
 $10 = $42;
 $43 = $10;
 $44 = ($43 | 0) > 0;
 if ($44) {
  $11 = 1;
 } else {
  $45 = $10;
  $46 = 0 - $45 | 0;
  $10 = $46;
  $11 = -1;
 }
 $47 = $8;
 $48 = $6;
 $49 = $47 - $48 | 0;
 $12 = $49;
 $50 = $12;
 $51 = ($50 | 0) > 0;
 if ($51) {
  $13 = 1;
 } else {
  $52 = $12;
  $53 = 0 - $52 | 0;
  $12 = $53;
  $13 = -1;
 }
 $54 = $12;
 $55 = $10;
 $56 = ($54 | 0) > ($55 | 0);
 if ($56) {
  $57 = $5;
  $15 = $57;
  $58 = $6;
  $5 = $58;
  $59 = $15;
  $6 = $59;
  $60 = $10;
  $15 = $60;
  $61 = $12;
  $10 = $61;
  $62 = $15;
  $12 = $62;
  $63 = $11;
  $15 = $63;
  $64 = $13;
  $11 = $64;
  $65 = $15;
  $13 = $65;
  $14 = 1;
 } else {
  $14 = 0;
 }
 $66 = $12;
 $67 = $66 << 1;
 $68 = $10;
 $69 = $67 - $68 | 0;
 $16 = $69;
 $17 = 0;
 while (1) {
  $70 = $17;
  $71 = $10;
  $72 = ($70 | 0) < ($71 | 0);
  if (!$72) {
   break;
  }
  $73 = $14;
  $74 = $73 & 1;
  if ($74) {
   $75 = $6;
   $76 = 0 <= ($75 | 0);
   if ($76) {
    $77 = $6;
    $78 = $4;
    $79 = $78 + 12 | 0;
    $80 = HEAP16[$79 >> 1] | 0;
    $81 = $80 & 65535;
    $82 = ($77 | 0) < ($81 | 0);
    $83 = $5;
    $84 = 0 <= ($83 | 0);
    $or$cond = $82 & $84;
    if ($or$cond) {
     $85 = $5;
     $86 = $4;
     $87 = $86 + 14 | 0;
     $88 = HEAP16[$87 >> 1] | 0;
     $89 = $88 & 65535;
     $90 = ($85 | 0) < ($89 | 0);
     if ($90) {
      $91 = $4;
      $92 = $6;
      $93 = $5;
      $94 = $9;
      _setpixel($91, $92, $93, $94);
     }
    }
   }
  } else {
   $95 = $5;
   $96 = 0 <= ($95 | 0);
   if ($96) {
    $97 = $5;
    $98 = $4;
    $99 = $98 + 12 | 0;
    $100 = HEAP16[$99 >> 1] | 0;
    $101 = $100 & 65535;
    $102 = ($97 | 0) < ($101 | 0);
    $103 = $6;
    $104 = 0 <= ($103 | 0);
    $or$cond3 = $102 & $104;
    if ($or$cond3) {
     $105 = $6;
     $106 = $4;
     $107 = $106 + 14 | 0;
     $108 = HEAP16[$107 >> 1] | 0;
     $109 = $108 & 65535;
     $110 = ($105 | 0) < ($109 | 0);
     if ($110) {
      $111 = $4;
      $112 = $5;
      $113 = $6;
      $114 = $9;
      _setpixel($111, $112, $113, $114);
     }
    }
   }
  }
  while (1) {
   $115 = $16;
   $116 = ($115 | 0) >= 0;
   if (!$116) {
    break;
   }
   $117 = $13;
   $118 = $6;
   $119 = $118 + $117 | 0;
   $6 = $119;
   $120 = $10;
   $121 = $120 << 1;
   $122 = $16;
   $123 = $122 - $121 | 0;
   $16 = $123;
  }
  $124 = $11;
  $125 = $5;
  $126 = $125 + $124 | 0;
  $5 = $126;
  $127 = $12;
  $128 = $127 << 1;
  $129 = $16;
  $130 = $129 + $128 | 0;
  $16 = $130;
  $131 = $17;
  $132 = $131 + 1 | 0;
  $17 = $132;
 }
 $133 = $7;
 $134 = 0 <= ($133 | 0);
 if (!$134) {
  STACKTOP = sp;
  return 17668 | 0;
 }
 $135 = $7;
 $136 = $4;
 $137 = $136 + 12 | 0;
 $138 = HEAP16[$137 >> 1] | 0;
 $139 = $138 & 65535;
 $140 = ($135 | 0) < ($139 | 0);
 $141 = $8;
 $142 = 0 <= ($141 | 0);
 $or$cond5 = $140 & $142;
 if (!$or$cond5) {
  STACKTOP = sp;
  return 17668 | 0;
 }
 $143 = $8;
 $144 = $4;
 $145 = $144 + 14 | 0;
 $146 = HEAP16[$145 >> 1] | 0;
 $147 = $146 & 65535;
 $148 = ($143 | 0) < ($147 | 0);
 if (!$148) {
  STACKTOP = sp;
  return 17668 | 0;
 }
 $149 = $4;
 $150 = $7;
 $151 = $8;
 $152 = $9;
 _setpixel($149, $150, $151, $152);
 STACKTOP = sp;
 return 17668 | 0;
}

function _compile_async_for_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $2 = $0;
 $3 = $1;
 $14 = $3;
 $15 = $14 + 8 | 0;
 $16 = $15 + 4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $17 >>> 4;
 $4 = $18;
 $19 = $2;
 $20 = _comp_next_label($19) | 0;
 $5 = $20;
 $21 = $2;
 $22 = _comp_next_label($21) | 0;
 $6 = $22;
 $23 = $2;
 $24 = _comp_next_label($23) | 0;
 $7 = $24;
 $25 = $2;
 $26 = _comp_next_label($25) | 0;
 $8 = $26;
 $27 = $2;
 $28 = $3;
 $29 = $28 + 8 | 0;
 $30 = $29 + 4 | 0;
 $31 = HEAP32[$30 >> 2] | 0;
 _compile_node($27, $31);
 $32 = $2;
 _compile_await_object_method($32, 170);
 $33 = $2;
 $34 = $4;
 _compile_store_id($33, $34);
 $35 = $2;
 $36 = $35 + 24 | 0;
 $37 = HEAP16[$36 >> 1] | 0;
 $9 = $37;
 $38 = $2;
 $39 = $38 + 26 | 0;
 $40 = HEAP16[$39 >> 1] | 0;
 $10 = $40;
 $41 = $2;
 $42 = $41 + 30 | 0;
 $43 = HEAP16[$42 >> 1] | 0;
 $11 = $43;
 $44 = $2;
 $45 = _comp_next_label($44) | 0;
 $12 = $45;
 $46 = $2;
 $47 = _comp_next_label($46) | 0;
 $13 = $47;
 $48 = $12;
 $49 = $48 & 65535;
 $50 = $2;
 $51 = $50 + 24 | 0;
 HEAP16[$51 >> 1] = $49;
 $52 = $13;
 $53 = $52 & 65535;
 $54 = $2;
 $55 = $54 + 26 | 0;
 HEAP16[$55 >> 1] = $53;
 $56 = $2;
 $57 = $56 + 28 | 0;
 $58 = HEAP16[$57 >> 1] | 0;
 $59 = $2;
 $60 = $59 + 30 | 0;
 HEAP16[$60 >> 1] = $58;
 $61 = $2;
 $62 = $61 + 40 | 0;
 $63 = HEAP32[$62 >> 2] | 0;
 $64 = $13;
 _mp_emit_bc_label_assign($63, $64);
 $65 = $2;
 $66 = $6;
 _compile_increase_except_level($65, $66, 2);
 $67 = $2;
 $68 = $4;
 _compile_load_id($67, $68);
 $69 = $2;
 _compile_await_object_method($69, 172);
 $70 = $2;
 $71 = $3;
 $72 = $71 + 8 | 0;
 $73 = HEAP32[$72 >> 2] | 0;
 _c_assign($70, $73, 0);
 $74 = $2;
 $75 = $74 + 40 | 0;
 $76 = HEAP32[$75 >> 2] | 0;
 $77 = $7;
 _mp_emit_bc_pop_except_jump($76, $77, 0);
 $78 = $2;
 $79 = $78 + 40 | 0;
 $80 = HEAP32[$79 >> 2] | 0;
 $81 = $6;
 _mp_emit_bc_label_assign($80, $81);
 $82 = $2;
 $83 = $82 + 40 | 0;
 $84 = HEAP32[$83 >> 2] | 0;
 _mp_emit_bc_start_except_handler($84);
 $85 = $2;
 $86 = $85 + 40 | 0;
 $87 = HEAP32[$86 >> 2] | 0;
 _mp_emit_bc_dup_top($87);
 $88 = $2;
 $89 = $88 + 40 | 0;
 $90 = HEAP32[$89 >> 2] | 0;
 _mp_emit_bc_load_global($90, 280, 1);
 $91 = $2;
 $92 = $91 + 40 | 0;
 $93 = HEAP32[$92 >> 2] | 0;
 _mp_emit_bc_binary_op($93, 8);
 $94 = $2;
 $95 = $94 + 40 | 0;
 $96 = HEAP32[$95 >> 2] | 0;
 $97 = $8;
 _mp_emit_bc_pop_jump_if($96, 0, $97);
 $98 = $2;
 $99 = $98 + 40 | 0;
 $100 = HEAP32[$99 >> 2] | 0;
 _mp_emit_bc_pop_top($100);
 $101 = $2;
 $102 = $101 + 40 | 0;
 $103 = HEAP32[$102 >> 2] | 0;
 $104 = $5;
 _mp_emit_bc_pop_except_jump($103, $104, 1);
 $105 = $2;
 $106 = $105 + 40 | 0;
 $107 = HEAP32[$106 >> 2] | 0;
 $108 = $8;
 _mp_emit_bc_label_assign($107, $108);
 $109 = $2;
 $110 = $109 + 40 | 0;
 $111 = HEAP32[$110 >> 2] | 0;
 _mp_emit_bc_adjust_stack_size($111, 1);
 $112 = $2;
 _compile_decrease_except_level($112);
 $113 = $2;
 $114 = $113 + 40 | 0;
 $115 = HEAP32[$114 >> 2] | 0;
 _mp_emit_bc_end_except_handler($115);
 $116 = $2;
 $117 = $116 + 40 | 0;
 $118 = HEAP32[$117 >> 2] | 0;
 $119 = $7;
 _mp_emit_bc_label_assign($118, $119);
 $120 = $2;
 $121 = $3;
 $122 = $121 + 8 | 0;
 $123 = $122 + 8 | 0;
 $124 = HEAP32[$123 >> 2] | 0;
 _compile_node($120, $124);
 $125 = $2;
 $126 = $125 + 40 | 0;
 $127 = HEAP32[$126 >> 2] | 0;
 $128 = $13;
 _mp_emit_bc_jump($127, $128);
 $129 = $9;
 $130 = $2;
 $131 = $130 + 24 | 0;
 HEAP16[$131 >> 1] = $129;
 $132 = $10;
 $133 = $2;
 $134 = $133 + 26 | 0;
 HEAP16[$134 >> 1] = $132;
 $135 = $11;
 $136 = $2;
 $137 = $136 + 30 | 0;
 HEAP16[$137 >> 1] = $135;
 $138 = $2;
 $139 = $138 + 40 | 0;
 $140 = HEAP32[$139 >> 2] | 0;
 $141 = $5;
 _mp_emit_bc_label_assign($140, $141);
 $142 = $2;
 $143 = $3;
 $144 = $143 + 8 | 0;
 $145 = $144 + 12 | 0;
 $146 = HEAP32[$145 >> 2] | 0;
 _compile_node($142, $146);
 $147 = $2;
 $148 = $147 + 40 | 0;
 $149 = HEAP32[$148 >> 2] | 0;
 $150 = $12;
 _mp_emit_bc_label_assign($149, $150);
 STACKTOP = sp;
 return;
}

function _mp_obj_int_formatted($0, $1, $2, $3, $4, $5, $6, $7) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 $7 = $7 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $138 = 0, $139 = 0, $14 = 0, $140 = 0, $141 = 0, $142 = 0, $143 = 0, $144 = 0, $145 = 0, $146 = 0, $147 = 0, $148 = 0, $149 = 0, $15 = 0, $150 = 0, $151 = 0, $152 = 0, $153 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $9 = $0;
 $10 = $1;
 $11 = $2;
 $12 = $3;
 $13 = $4;
 $14 = $5;
 $15 = $6;
 $16 = $7;
 $26 = $12;
 $27 = _mp_obj_is_small_int_1012($26) | 0;
 if (!$27) {
  $33 = $9;
  $34 = $10;
  $35 = $11;
  $36 = $12;
  $37 = $13;
  $38 = $14;
  $39 = $15;
  $40 = $16;
  $41 = _mp_obj_int_formatted_impl($33, $34, $35, $36, $37, $38, $39, $40) | 0;
  $8 = $41;
  $153 = $8;
  STACKTOP = sp;
  return $153 | 0;
 }
 $28 = $12;
 $29 = $28;
 $30 = $29 >> 1;
 $17 = $30;
 $18 = 0;
 $31 = $17;
 $32 = ($31 | 0) < 0;
 if ($32) {
  $42 = $17;
  $43 = 0 - $42 | 0;
  $17 = $43;
  $18 = 45;
 }
 $44 = $13;
 $45 = $14;
 $46 = $16;
 $47 = _mp_int_format_size(32, $44, $45, $46) | 0;
 $19 = $47;
 $48 = $19;
 $49 = $10;
 $50 = HEAP32[$49 >> 2] | 0;
 $51 = $48 >>> 0 > $50 >>> 0;
 if ($51) {
  $52 = $19;
  $53 = $52;
  $54 = _m_malloc($53) | 0;
  $55 = $9;
  HEAP32[$55 >> 2] = $54;
  $56 = $19;
  $57 = $10;
  HEAP32[$57 >> 2] = $56;
 }
 $58 = $9;
 $59 = HEAP32[$58 >> 2] | 0;
 $20 = $59;
 $60 = $20;
 $61 = $19;
 $62 = $60 + $61 | 0;
 $21 = $62;
 $63 = $21;
 $64 = $63 + -1 | 0;
 $21 = $64;
 HEAP8[$64 >> 0] = 0;
 $65 = $21;
 $22 = $65;
 $66 = $17;
 $67 = ($66 | 0) == 0;
 if ($67) {
  $68 = $21;
  $69 = $68 + -1 | 0;
  $21 = $69;
  HEAP8[$69 >> 0] = 48;
 } else {
  while (1) {
   $70 = $17;
   $71 = $13;
   $72 = ($70 >>> 0) % ($71 >>> 0) & -1;
   $23 = $72;
   $73 = $17;
   $74 = $13;
   $75 = ($73 >>> 0) / ($74 >>> 0) & -1;
   $17 = $75;
   $76 = $23;
   $77 = ($76 | 0) >= 10;
   if ($77) {
    $78 = $15;
    $79 = $78 << 24 >> 24;
    $80 = $79 - 10 | 0;
    $81 = $23;
    $82 = $81 + $80 | 0;
    $23 = $82;
   } else {
    $83 = $23;
    $84 = $83 + 48 | 0;
    $23 = $84;
   }
   $85 = $23;
   $86 = $85 & 255;
   $87 = $21;
   $88 = $87 + -1 | 0;
   $21 = $88;
   HEAP8[$88 >> 0] = $86;
   $89 = $16;
   $90 = $89 << 24 >> 24;
   $91 = ($90 | 0) != 0;
   $92 = $17;
   $93 = ($92 | 0) != 0;
   $or$cond = $91 & $93;
   if ($or$cond) {
    $94 = $21;
    $95 = $20;
    $96 = $94 >>> 0 > $95 >>> 0;
    if ($96) {
     $97 = $22;
     $98 = $21;
     $99 = $97;
     $100 = $98;
     $101 = $99 - $100 | 0;
     $102 = ($101 | 0) == 3;
     if ($102) {
      $103 = $16;
      $104 = $21;
      $105 = $104 + -1 | 0;
      $21 = $105;
      HEAP8[$105 >> 0] = $103;
      $106 = $21;
      $22 = $106;
     }
    }
   }
   $107 = $21;
   $108 = $20;
   $109 = $107 >>> 0 > $108 >>> 0;
   $110 = $17;
   $111 = ($110 | 0) != 0;
   $112 = $109 ? $111 : 0;
   if (!$112) {
    break;
   }
  }
 }
 $113 = $14;
 $114 = ($113 | 0) != (0 | 0);
 L26 : do {
  if ($114) {
   $115 = $14;
   $116 = _strlen($115) | 0;
   $24 = $116;
   $117 = $21;
   $118 = $24;
   $119 = 0 - $118 | 0;
   $120 = $117 + $119 | 0;
   $25 = $120;
   $121 = $25;
   $122 = $20;
   $123 = $121 >>> 0 > $122 >>> 0;
   if ($123) {
    $124 = $25;
    $21 = $124;
    while (1) {
     $125 = $14;
     $126 = HEAP8[$125 >> 0] | 0;
     $127 = $126 << 24 >> 24 != 0;
     if (!$127) {
      break L26;
     }
     $128 = $14;
     $129 = $128 + 1 | 0;
     $14 = $129;
     $130 = HEAP8[$128 >> 0] | 0;
     $131 = $25;
     $132 = $131 + 1 | 0;
     $25 = $132;
     HEAP8[$131 >> 0] = $130;
    }
   }
  }
 } while (0);
 $133 = $18;
 $134 = $133 << 24 >> 24;
 $135 = ($134 | 0) != 0;
 if ($135) {
  $136 = $21;
  $137 = $20;
  $138 = $136 >>> 0 > $137 >>> 0;
  if ($138) {
   $139 = $18;
   $140 = $21;
   $141 = $140 + -1 | 0;
   $21 = $141;
   HEAP8[$141 >> 0] = $139;
  }
 }
 $142 = $9;
 $143 = HEAP32[$142 >> 2] | 0;
 $144 = $19;
 $145 = $143 + $144 | 0;
 $146 = $21;
 $147 = $145;
 $148 = $146;
 $149 = $147 - $148 | 0;
 $150 = $149 - 1 | 0;
 $151 = $11;
 HEAP32[$151 >> 2] = $150;
 $152 = $21;
 $8 = $152;
 $153 = $8;
 STACKTOP = sp;
 return $153 | 0;
}

function _mp_obj_instance_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(96 | 0);
 $vararg_buffer = sp;
 $9 = sp + 56 | 0;
 $10 = sp + 32 | 0;
 $11 = sp + 28 | 0;
 $14 = sp + 16 | 0;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 HEAP32[$9 >> 2] = 0 | 0;
 HEAP32[$9 + 4 >> 2] = 0 | 0;
 HEAP32[$10 >> 2] = 0;
 $18 = $10 + 4 | 0;
 HEAP32[$18 >> 2] = 24;
 $19 = $10 + 8 | 0;
 HEAP32[$19 >> 2] = 12;
 $20 = $10 + 12 | 0;
 HEAP32[$20 >> 2] = $9;
 $21 = $10 + 16 | 0;
 HEAP8[$21 >> 0] = 0;
 $22 = $5;
 _mp_obj_class_lookup($10, $22);
 HEAP32[$11 >> 2] = 0;
 $23 = HEAP32[$9 >> 2] | 0;
 $24 = ($23 | 0) == (0 | 0);
 do {
  if ($24) {
   label = 3;
  } else {
   $25 = HEAP32[$9 >> 2] | 0;
   $26 = ($25 | 0) == (4 | 0);
   if ($26) {
    label = 3;
   } else {
    $29 = $6;
    $30 = ($29 | 0) == 0;
    $31 = $7;
    $32 = ($31 | 0) == 0;
    $or$cond = $30 & $32;
    if ($or$cond) {
     $33 = $5;
     HEAP32[$14 >> 2] = $33;
     $34 = HEAP32[$9 >> 2] | 0;
     $35 = _mp_call_function_n_kw($34, 1, 0, $14) | 0;
     $13 = $35;
    } else {
     $36 = $6;
     $37 = 1 + $36 | 0;
     $38 = $7;
     $39 = $38 << 1;
     $40 = $37 + $39 | 0;
     $41 = $40 << 2;
     $42 = _m_malloc($41) | 0;
     $15 = $42;
     $43 = $5;
     $44 = $15;
     HEAP32[$44 >> 2] = $43;
     $45 = $15;
     $46 = $45 + 4 | 0;
     $47 = $8;
     $48 = $6;
     $49 = $7;
     $50 = $49 << 1;
     $51 = $48 + $50 | 0;
     $52 = $51 << 2;
     _memcpy($46 | 0, $47 | 0, $52 | 0) | 0;
     $53 = HEAP32[$9 >> 2] | 0;
     $54 = $6;
     $55 = $54 + 1 | 0;
     $56 = $7;
     $57 = $15;
     $58 = _mp_call_function_n_kw($53, $55, $56, $57) | 0;
     $13 = $58;
     $59 = $15;
     _m_free($59);
    }
    $60 = $13;
    $61 = _mp_obj_get_type($60) | 0;
    $62 = $5;
    $63 = ($61 | 0) != ($62 | 0);
    $64 = $13;
    if (!$63) {
     $12 = $64;
     break;
    }
    $4 = $64;
    $125 = $4;
    STACKTOP = sp;
    return $125 | 0;
   }
  }
 } while (0);
 if ((label | 0) == 3) {
  $27 = $5;
  $28 = _mp_obj_new_instance($27, $11) | 0;
  $12 = $28;
 }
 $65 = $9 + 4 | 0;
 HEAP32[$65 >> 2] = 0;
 HEAP32[$9 >> 2] = 0;
 $66 = $12;
 HEAP32[$10 >> 2] = $66;
 $67 = $10 + 4 | 0;
 HEAP32[$67 >> 2] = 17;
 $68 = $10 + 8 | 0;
 HEAP32[$68 >> 2] = 0;
 $69 = $5;
 _mp_obj_class_lookup($10, $69);
 $70 = HEAP32[$9 >> 2] | 0;
 $71 = ($70 | 0) != (0 | 0);
 if ($71) {
  $72 = $6;
  $73 = ($72 | 0) == 0;
  $74 = $7;
  $75 = ($74 | 0) == 0;
  $or$cond3 = $73 & $75;
  if ($or$cond3) {
   $76 = _mp_call_method_n_kw(0, 0, $9) | 0;
   $16 = $76;
  } else {
   $77 = $6;
   $78 = 2 + $77 | 0;
   $79 = $7;
   $80 = $79 << 1;
   $81 = $78 + $80 | 0;
   $82 = $81 << 2;
   $83 = _m_malloc($82) | 0;
   $17 = $83;
   $84 = HEAP32[$9 >> 2] | 0;
   $85 = $17;
   HEAP32[$85 >> 2] = $84;
   $86 = $9 + 4 | 0;
   $87 = HEAP32[$86 >> 2] | 0;
   $88 = $17;
   $89 = $88 + 4 | 0;
   HEAP32[$89 >> 2] = $87;
   $90 = $17;
   $91 = $90 + 8 | 0;
   $92 = $8;
   $93 = $6;
   $94 = $7;
   $95 = $94 << 1;
   $96 = $93 + $95 | 0;
   $97 = $96 << 2;
   _memcpy($91 | 0, $92 | 0, $97 | 0) | 0;
   $98 = $6;
   $99 = $7;
   $100 = $17;
   $101 = _mp_call_method_n_kw($98, $99, $100) | 0;
   $16 = $101;
   $102 = $17;
   _m_free($102);
  }
  $103 = $16;
  $104 = ($103 | 0) != (17668 | 0);
  if ($104) {
   $105 = $16;
   $106 = _mp_obj_get_type_str($105) | 0;
   HEAP32[$vararg_buffer >> 2] = $106;
   $107 = _mp_obj_new_exception_msg_varg(16012, 33056, $vararg_buffer) | 0;
   _nlr_jump($107);
  }
 }
 $108 = HEAP32[$11 >> 2] | 0;
 $109 = ($108 | 0) != (0 | 0);
 if ($109) {
  $110 = $12;
  $111 = $110 + 16 | 0;
  $112 = HEAP32[$111 >> 2] | 0;
  $113 = ($112 | 0) == (19108 | 0);
  if ($113) {
   $114 = HEAP32[$11 >> 2] | 0;
   $115 = $114 + 12 | 0;
   $116 = HEAP32[$115 >> 2] | 0;
   $117 = HEAP32[$11 >> 2] | 0;
   $118 = $6;
   $119 = $7;
   $120 = $8;
   $121 = FUNCTION_TABLE_iiiii[$116 & 1023]($117, $118, $119, $120) | 0;
   $122 = $12;
   $123 = $122 + 16 | 0;
   HEAP32[$123 >> 2] = $121;
  }
 }
 $124 = $12;
 $4 = $124;
 $125 = $4;
 STACKTOP = sp;
 return $125 | 0;
}

function _bytes_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 128 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(128 | 0);
 $10 = sp + 100 | 0;
 $14 = sp + 72 | 0;
 $15 = sp + 56 | 0;
 $16 = sp + 40 | 0;
 $19 = sp + 16 | 0;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $23 = $7;
 $24 = ($23 | 0) != 0;
 if ($24) {
  _mp_arg_error_unimpl_kw();
 }
 $25 = $6;
 $26 = ($25 | 0) == 0;
 if ($26) {
  $4 = 18288;
  $124 = $4;
  STACKTOP = sp;
  return $124 | 0;
 }
 $27 = $8;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = _mp_obj_is_qstr_1128($28) | 0;
 do {
  if (!$29) {
   $30 = $8;
   $31 = HEAP32[$30 >> 2] | 0;
   $32 = _mp_obj_is_obj_1154($31) | 0;
   if ($32) {
    $33 = $8;
    $34 = HEAP32[$33 >> 2] | 0;
    $35 = HEAP32[$34 >> 2] | 0;
    $36 = ($35 | 0) == (18680 | 0);
    if ($36) {
     break;
    }
   }
   $79 = $6;
   $80 = $79 >>> 0 > 1;
   if ($80) {
    _mp_raise_TypeError(32727);
   }
   $81 = $8;
   $82 = HEAP32[$81 >> 2] | 0;
   $83 = _mp_obj_is_small_int_1155($82) | 0;
   $84 = $8;
   $85 = HEAP32[$84 >> 2] | 0;
   if ($83) {
    $86 = $85;
    $87 = $86 >> 1;
    $13 = $87;
    $88 = $13;
    $89 = ($88 | 0) < 0;
    if ($89) {
     _mp_raise_ValueError(0);
    }
    $90 = $13;
    _vstr_init_len($14, $90);
    $91 = $14 + 8 | 0;
    $92 = HEAP32[$91 >> 2] | 0;
    $93 = $13;
    _memset($92 | 0, 0, $93 | 0) | 0;
    $94 = _mp_obj_new_str_from_vstr(18304, $14) | 0;
    $4 = $94;
    $124 = $4;
    STACKTOP = sp;
    return $124 | 0;
   }
   $95 = _mp_get_buffer($85, $15, 1) | 0;
   if ($95) {
    $96 = HEAP32[$15 >> 2] | 0;
    $97 = $15 + 4 | 0;
    $98 = HEAP32[$97 >> 2] | 0;
    $99 = _mp_obj_new_bytes($96, $98) | 0;
    $4 = $99;
    $124 = $4;
    STACKTOP = sp;
    return $124 | 0;
   }
   $100 = $8;
   $101 = HEAP32[$100 >> 2] | 0;
   $102 = _mp_obj_len_maybe($101) | 0;
   $17 = $102;
   $103 = $17;
   $104 = ($103 | 0) == (0 | 0);
   if ($104) {
    _vstr_init($16, 16);
   } else {
    $105 = $17;
    $106 = $105;
    $107 = $106 >> 1;
    $18 = $107;
    $108 = $18;
    _vstr_init($16, $108);
   }
   $109 = $8;
   $110 = HEAP32[$109 >> 2] | 0;
   $111 = _mp_getiter($110, $19) | 0;
   $20 = $111;
   while (1) {
    $112 = $20;
    $113 = _mp_iternext($112) | 0;
    $21 = $113;
    $114 = ($113 | 0) != (0 | 0);
    if (!$114) {
     break;
    }
    $115 = $21;
    $116 = _mp_obj_get_int($115) | 0;
    $22 = $116;
    $117 = $22;
    $118 = ($117 | 0) < 0;
    $119 = $22;
    $120 = ($119 | 0) > 255;
    $or$cond3 = $118 | $120;
    if ($or$cond3) {
     label = 31;
     break;
    }
    $121 = $22;
    $122 = $121 & 255;
    _vstr_add_byte($16, $122);
   }
   if ((label | 0) == 31) {
    _mp_raise_ValueError(32702);
   }
   $123 = _mp_obj_new_str_from_vstr(18304, $16) | 0;
   $4 = $123;
   $124 = $4;
   STACKTOP = sp;
   return $124 | 0;
  }
 } while (0);
 $37 = $6;
 $38 = $37 >>> 0 < 2;
 $39 = $6;
 $40 = $39 >>> 0 > 3;
 $or$cond = $38 | $40;
 if ($or$cond) {
  _mp_raise_TypeError(32727);
 }
 $41 = $8;
 $42 = HEAP32[$41 >> 2] | 0;
 $43 = _mp_obj_is_qstr_1128($42) | 0;
 $44 = $8;
 $45 = HEAP32[$44 >> 2] | 0;
 if ($43) {
  $46 = $45;
  $47 = $46 >>> 2;
  $48 = _qstr_data($47, $10) | 0;
  $9 = $48;
 } else {
  $49 = $45 + 8 | 0;
  $50 = HEAP32[$49 >> 2] | 0;
  HEAP32[$10 >> 2] = $50;
  $51 = $8;
  $52 = HEAP32[$51 >> 2] | 0;
  $53 = $52 + 12 | 0;
  $54 = HEAP32[$53 >> 2] | 0;
  $9 = $54;
 }
 $55 = $8;
 $56 = HEAP32[$55 >> 2] | 0;
 $57 = _mp_obj_is_qstr_1128($56) | 0;
 $58 = $8;
 $59 = HEAP32[$58 >> 2] | 0;
 if ($57) {
  $60 = $59;
  $61 = $60 >>> 2;
  $62 = _qstr_hash($61) | 0;
  $11 = $62;
 } else {
  $63 = $59 + 4 | 0;
  $64 = HEAP32[$63 >> 2] | 0;
  $11 = $64;
 }
 $65 = $11;
 $66 = ($65 | 0) == 0;
 if ($66) {
  $67 = $9;
  $68 = HEAP32[$10 >> 2] | 0;
  $69 = _qstr_compute_hash($67, $68) | 0;
  $11 = $69;
 }
 $70 = HEAP32[$10 >> 2] | 0;
 $71 = _mp_obj_new_str_copy(18304, 0, $70) | 0;
 $12 = $71;
 $72 = $9;
 $73 = $12;
 $74 = $73 + 12 | 0;
 HEAP32[$74 >> 2] = $72;
 $75 = $11;
 $76 = $12;
 $77 = $76 + 4 | 0;
 HEAP32[$77 >> 2] = $75;
 $78 = $12;
 $4 = $78;
 $124 = $4;
 STACKTOP = sp;
 return $124 | 0;
}

function _uctypes_struct_size($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $17 = $4;
 $18 = _mp_obj_is_obj_1471($17) | 0;
 if ($18) {
  $19 = $4;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = ($20 | 0) == (14112 | 0);
  if (!$21) {
   label = 3;
  }
 } else {
  label = 3;
 }
 do {
  if ((label | 0) == 3) {
   $22 = $4;
   $23 = _mp_obj_is_obj_1471($22) | 0;
   if ($23) {
    $24 = $4;
    $25 = HEAP32[$24 >> 2] | 0;
    $26 = ($25 | 0) == (14436 | 0);
    if ($26) {
     break;
    }
   }
   $27 = $4;
   $28 = _mp_obj_is_obj_1471($27) | 0;
   if ($28) {
    $29 = $4;
    $30 = HEAP32[$29 >> 2] | 0;
    $31 = ($30 | 0) == (18952 | 0);
    if ($31) {
     $32 = $4;
     $33 = $5;
     $34 = $6;
     $35 = _uctypes_struct_agg_size($32, $33, $34) | 0;
     $3 = $35;
     $128 = $3;
     STACKTOP = sp;
     return $128 | 0;
    }
   }
   $36 = $4;
   $37 = _mp_obj_is_small_int_1472($36) | 0;
   if ($37) {
    _mp_raise_TypeError(34457);
   } else {
    _syntax_error();
   }
  }
 } while (0);
 $38 = $4;
 $7 = $38;
 $8 = 0;
 $9 = 0;
 L17 : while (1) {
  $39 = $9;
  $40 = $7;
  $41 = $40 + 4 | 0;
  $42 = $41 + 4 | 0;
  $43 = HEAP32[$42 >> 2] | 0;
  $44 = $39 >>> 0 < $43 >>> 0;
  if (!$44) {
   label = 27;
   break;
  }
  $45 = $7;
  $46 = $45 + 4 | 0;
  $47 = $9;
  $48 = _mp_map_slot_is_filled_1474($46, $47) | 0;
  do {
   if ($48) {
    $49 = $7;
    $50 = $49 + 4 | 0;
    $51 = $50 + 8 | 0;
    $52 = HEAP32[$51 >> 2] | 0;
    $53 = $9;
    $54 = $52 + ($53 << 3) | 0;
    $55 = $54 + 4 | 0;
    $56 = HEAP32[$55 >> 2] | 0;
    $10 = $56;
    $57 = $10;
    $58 = _mp_obj_is_small_int_1472($57) | 0;
    $59 = $10;
    if (!$58) {
     $89 = _mp_obj_is_obj_1471($59) | 0;
     if (!$89) {
      label = 23;
      break L17;
     }
     $90 = $10;
     $91 = HEAP32[$90 >> 2] | 0;
     $92 = ($91 | 0) == (18952 | 0);
     if (!$92) {
      label = 23;
      break L17;
     }
     $93 = $10;
     $14 = $93;
     $94 = $14;
     $95 = $94 + 8 | 0;
     $96 = HEAP32[$95 >> 2] | 0;
     $97 = $96;
     $98 = $97 >> 1;
     $15 = $98;
     $99 = $15;
     $100 = $99 & 536870911;
     $15 = $100;
     $101 = $14;
     $102 = $5;
     $103 = $6;
     $104 = _uctypes_struct_agg_size($101, $102, $103) | 0;
     $16 = $104;
     $105 = $15;
     $106 = $16;
     $107 = $105 + $106 | 0;
     $108 = $8;
     $109 = $107 >>> 0 > $108 >>> 0;
     if (!$109) {
      break;
     }
     $110 = $15;
     $111 = $16;
     $112 = $110 + $111 | 0;
     $8 = $112;
     break;
    }
    $60 = $59;
    $61 = $60 >> 1;
    $11 = $61;
    $62 = $11;
    $63 = $62 >>> 27;
    $64 = $63 & 15;
    $12 = $64;
    $65 = $11;
    $66 = $65 & 134217727;
    $11 = $66;
    $67 = $12;
    $68 = $67 >>> 0 >= 8;
    $69 = $12;
    $70 = $69 >>> 0 <= 13;
    $or$cond = $68 & $70;
    if ($or$cond) {
     $71 = $11;
     $72 = $71 & 131071;
     $11 = $72;
    }
    $73 = $12;
    $74 = _uctypes_struct_scalar_size($73) | 0;
    $13 = $74;
    $75 = $13;
    $76 = $6;
    $77 = HEAP32[$76 >> 2] | 0;
    $78 = $75 >>> 0 > $77 >>> 0;
    if ($78) {
     $79 = $13;
     $80 = $6;
     HEAP32[$80 >> 2] = $79;
    }
    $81 = $11;
    $82 = $13;
    $83 = $81 + $82 | 0;
    $84 = $8;
    $85 = $83 >>> 0 > $84 >>> 0;
    if ($85) {
     $86 = $11;
     $87 = $13;
     $88 = $86 + $87 | 0;
     $8 = $88;
    }
   }
  } while (0);
  $113 = $9;
  $114 = $113 + 1 | 0;
  $9 = $114;
 }
 if ((label | 0) == 23) {
  _syntax_error();
 } else if ((label | 0) == 27) {
  $115 = $5;
  $116 = ($115 | 0) == 2;
  if ($116) {
   $117 = $8;
   $118 = $6;
   $119 = HEAP32[$118 >> 2] | 0;
   $120 = $117 + $119 | 0;
   $121 = $120 - 1 | 0;
   $122 = $6;
   $123 = HEAP32[$122 >> 2] | 0;
   $124 = $123 - 1 | 0;
   $125 = $124 ^ -1;
   $126 = $121 & $125;
   $8 = $126;
  }
  $127 = $8;
  $3 = $127;
  $128 = $3;
  STACKTOP = sp;
  return $128 | 0;
 }
 return 0 | 0;
}

function _array_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 112 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(112 | 0);
 $8 = sp + 72 | 0;
 $9 = sp + 60 | 0;
 $13 = sp + 36 | 0;
 $14 = sp + 24 | 0;
 $15 = sp + 12 | 0;
 $16 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $17 = $5;
 $7 = $17;
 $18 = $4;
 $19 = $18 - 2 | 0;
 $20 = $19 >>> 2;
 $21 = $19 << 30;
 $22 = $20 | $21;
 switch ($22 | 0) {
 case 6:
  {
   $23 = $5;
   _array_get_buffer($23, $8, 1) | 0;
   $24 = $6;
   _mp_get_buffer_raise($24, $9, 1);
   $25 = $8 + 8 | 0;
   $26 = HEAP32[$25 >> 2] | 0;
   $27 = $26 & 255;
   $28 = _mp_binary_get_size(64, $27, 0) | 0;
   $10 = $28;
   $29 = $9 + 4 | 0;
   $30 = HEAP32[$29 >> 2] | 0;
   $31 = $10;
   $32 = ($30 >>> 0) / ($31 >>> 0) & -1;
   $11 = $32;
   $33 = $8 + 8 | 0;
   $34 = HEAP32[$33 >> 2] | 0;
   $35 = $34 & 255;
   $36 = $7;
   $37 = $36 + 8 | 0;
   $38 = HEAP32[$37 >> 2] | 0;
   $39 = $11;
   $40 = $38 + $39 | 0;
   $41 = _array_new($35, $40) | 0;
   $12 = $41;
   $42 = $12;
   $43 = $42 + 12 | 0;
   $44 = HEAP32[$43 >> 2] | 0;
   $45 = HEAP32[$8 >> 2] | 0;
   $46 = $8 + 4 | 0;
   $47 = HEAP32[$46 >> 2] | 0;
   $48 = $47;
   _memcpy($44 | 0, $45 | 0, $48 | 0) | 0;
   $49 = $12;
   $50 = $49 + 12 | 0;
   $51 = HEAP32[$50 >> 2] | 0;
   $52 = $8 + 4 | 0;
   $53 = HEAP32[$52 >> 2] | 0;
   $54 = $51 + $53 | 0;
   $55 = HEAP32[$9 >> 2] | 0;
   $56 = $11;
   $57 = $10;
   $58 = Math_imul($56, $57) | 0;
   $59 = $58;
   _memcpy($54 | 0, $55 | 0, $59 | 0) | 0;
   $60 = $12;
   $3 = $60;
   $110 = $3;
   STACKTOP = sp;
   return $110 | 0;
   break;
  }
 case 3:
  {
   $61 = $7;
   $62 = HEAP32[$61 >> 2] | 0;
   $63 = ($62 | 0) == (13464 | 0);
   if ($63) {
    $3 = 0;
    $110 = $3;
    STACKTOP = sp;
    return $110 | 0;
   } else {
    $64 = $5;
    $65 = $6;
    _array_extend($64, $65) | 0;
    $66 = $5;
    $3 = $66;
    $110 = $3;
    STACKTOP = sp;
    return $110 | 0;
   }
   break;
  }
 case 8:
  {
   $67 = $6;
   $68 = _mp_get_buffer($67, $14, 1) | 0;
   if ($68) {
    $69 = $5;
    $70 = _mp_obj_is_obj_817($69) | 0;
    if ($70) {
     $71 = $5;
     $72 = HEAP32[$71 >> 2] | 0;
     $73 = ($72 | 0) == (13584 | 0);
     if ($73) {
      $74 = $5;
      _array_get_buffer($74, $13, 1) | 0;
      $75 = HEAP32[$13 >> 2] | 0;
      $76 = $13 + 4 | 0;
      $77 = HEAP32[$76 >> 2] | 0;
      $78 = HEAP32[$14 >> 2] | 0;
      $79 = $14 + 4 | 0;
      $80 = HEAP32[$79 >> 2] | 0;
      $81 = _find_subbytes($75, $77, $78, $80, 1) | 0;
      $82 = ($81 | 0) != (0 | 0);
      $83 = $82 & 1;
      $84 = _mp_obj_new_bool_832($83) | 0;
      $3 = $84;
      $110 = $3;
      STACKTOP = sp;
      return $110 | 0;
     }
    }
    $3 = 13856;
    $110 = $3;
    STACKTOP = sp;
    return $110 | 0;
   }
   $85 = $6;
   $86 = _mp_obj_is_small_int_831($85) | 0;
   if ($86) {
    _mp_raise_NotImplementedError(0);
   }
   $87 = $6;
   $88 = _mp_obj_is_obj_817($87) | 0;
   if ($88) {
    $89 = $6;
    $90 = HEAP32[$89 >> 2] | 0;
    $91 = ($90 | 0) == (16904 | 0);
    if ($91) {
     _mp_raise_NotImplementedError(0);
    }
   }
   $92 = $6;
   $93 = _mp_obj_is_obj_817($92) | 0;
   if ($93) {
    $94 = $6;
    $95 = HEAP32[$94 >> 2] | 0;
    $96 = ($95 | 0) == (16252 | 0);
    if ($96) {
     _mp_raise_NotImplementedError(0);
    }
   }
   $3 = 13856;
   $110 = $3;
   STACKTOP = sp;
   return $110 | 0;
   break;
  }
 case 0:
  {
   $97 = $5;
   _array_get_buffer($97, $15, 1) | 0;
   $98 = $6;
   $99 = _mp_get_buffer($98, $16, 1) | 0;
   if ($99) {
    $100 = $4;
    $101 = HEAP32[$15 >> 2] | 0;
    $102 = $15 + 4 | 0;
    $103 = HEAP32[$102 >> 2] | 0;
    $104 = HEAP32[$16 >> 2] | 0;
    $105 = $16 + 4 | 0;
    $106 = HEAP32[$105 >> 2] | 0;
    $107 = _mp_seq_cmp_bytes($100, $101, $103, $104, $106) | 0;
    $108 = $107 & 1;
    $109 = _mp_obj_new_bool_832($108) | 0;
    $3 = $109;
    $110 = $3;
    STACKTOP = sp;
    return $110 | 0;
   } else {
    $3 = 13856;
    $110 = $3;
    STACKTOP = sp;
    return $110 | 0;
   }
   break;
  }
 default:
  {
   $3 = 0;
   $110 = $3;
   STACKTOP = sp;
   return $110 | 0;
  }
 }
 return 0 | 0;
}

function _gc_dump_info() {
 var $$0$i = 0, $$05159$i = 0, $$05258$i = 0, $$05457$i = 0, $$056$i = 0, $$1$i = 0, $$153$i = 0, $$2$i = 0, $$in$i = 0, $$pre$i = 0, $$sroa$12$0 = 0, $$sroa$12$1 = 0, $$sroa$14$0 = 0, $$sroa$14$1 = 0, $$sroa$14$2 = 0, $$sroa$16$0 = 0, $$sroa$16$1 = 0, $$sroa$16$2 = 0, $$sroa$18$0 = 0, $$sroa$18$2 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond5$i = 0, $spec$select = 0, $spec$select10 = 0, $spec$select8 = 0, $spec$select9 = 0, $trunc$i = 0, $trunc$i$clear = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, $vararg_ptr1 = 0, $vararg_ptr2 = 0, $vararg_ptr6 = 0, $vararg_ptr7 = 0, $vararg_ptr8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer3 = sp + 16 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[40756 >> 2] | 0;
 $1 = HEAP32[40752 >> 2] | 0;
 $$pre$i = HEAP32[40744 >> 2] | 0;
 $2 = HEAP32[40748 >> 2] | 0;
 $3 = $2 << 2;
 $$05159$i = 0;
 $$05258$i = 0;
 $$05457$i = 0;
 $$sroa$12$0 = 0;
 $$sroa$14$0 = 0;
 $$sroa$16$0 = 0;
 $$sroa$18$0 = 0;
 $12 = 0;
 $15 = 0;
 $30 = 0;
 $32 = 0;
 $34 = 0;
 $36 = 0;
 while (1) {
  $4 = $$05457$i >>> 2;
  $5 = $$pre$i + $4 | 0;
  $6 = HEAP8[$5 >> 0] | 0;
  $7 = $6 & 255;
  $8 = $$05457$i << 1;
  $9 = $8 & 6;
  $10 = $7 >>> $9;
  $trunc$i = $10 & 255;
  $trunc$i$clear = $trunc$i & 3;
  switch ($trunc$i$clear << 24 >> 24) {
  case 0:
   {
    $11 = $12 + 1 | 0;
    $13 = $$05159$i + 1 | 0;
    $$1$i = $13;
    $$153$i = 0;
    $39 = $15;
    $41 = $11;
    break;
   }
  case 1:
   {
    $14 = $15 + 1 | 0;
    $$1$i = $$05159$i;
    $$153$i = 1;
    $39 = $14;
    $41 = $12;
    break;
   }
  case 2:
   {
    $16 = $15 + 1 | 0;
    $17 = $$05258$i + 1 | 0;
    $$1$i = $$05159$i;
    $$153$i = $17;
    $39 = $16;
    $41 = $12;
    break;
   }
  default:
   {
    $$1$i = $$05159$i;
    $$153$i = $$05258$i;
    $39 = $15;
    $41 = $12;
   }
  }
  $18 = $$05457$i + 1 | 0;
  $19 = ($18 | 0) == ($3 | 0);
  if ($19) {
   $$056$i = $10 & 3;
   $$in$i = $$056$i;
   label = 9;
  } else {
   $20 = $18 << 1;
   $21 = $20 & 6;
   $22 = $18 >>> 2;
   $23 = $$pre$i + $22 | 0;
   $24 = HEAP8[$23 >> 0] | 0;
   $25 = $24 & 255;
   $26 = $25 >>> $21;
   $$0$i = $26 & 3;
   $27 = $$0$i >>> 0 < 2;
   if ($27) {
    $$in$i = $$0$i;
    label = 9;
   } else {
    $$2$i = $$1$i;
    $$sroa$12$1 = $$sroa$12$0;
    $$sroa$14$2 = $$sroa$14$0;
    $$sroa$16$2 = $$sroa$16$0;
    $$sroa$18$2 = $$sroa$18$0;
    $42 = $36;
    $43 = $34;
    $44 = $30;
    $45 = $32;
   }
  }
  if ((label | 0) == 9) {
   label = 0;
   $28 = ($$in$i | 0) == 1;
   switch ($$153$i | 0) {
   case 1:
    {
     $29 = $30 + 1 | 0;
     $$sroa$14$1 = $29;
     $$sroa$16$1 = $$sroa$16$0;
     $46 = $29;
     $47 = $32;
     break;
    }
   case 2:
    {
     $31 = $32 + 1 | 0;
     $$sroa$14$1 = $$sroa$14$0;
     $$sroa$16$1 = $31;
     $46 = $30;
     $47 = $31;
     break;
    }
   default:
    {
     $$sroa$14$1 = $$sroa$14$0;
     $$sroa$16$1 = $$sroa$16$0;
     $46 = $30;
     $47 = $32;
    }
   }
   $33 = $$153$i >>> 0 > $34 >>> 0;
   $spec$select = $33 ? $$153$i : $$sroa$18$0;
   $spec$select8 = $33 ? $$153$i : $34;
   $or$cond5$i = $19 | $28;
   if ($or$cond5$i) {
    $35 = $$1$i >>> 0 > $36 >>> 0;
    $spec$select9 = $35 ? $$1$i : $$sroa$12$0;
    $spec$select10 = $35 ? $$1$i : $36;
    $$2$i = 0;
    $$sroa$12$1 = $spec$select9;
    $$sroa$14$2 = $$sroa$14$1;
    $$sroa$16$2 = $$sroa$16$1;
    $$sroa$18$2 = $spec$select;
    $42 = $spec$select10;
    $43 = $spec$select8;
    $44 = $46;
    $45 = $47;
   } else {
    $$2$i = $$1$i;
    $$sroa$12$1 = $$sroa$12$0;
    $$sroa$14$2 = $$sroa$14$1;
    $$sroa$16$2 = $$sroa$16$1;
    $$sroa$18$2 = $spec$select;
    $42 = $36;
    $43 = $spec$select8;
    $44 = $46;
    $45 = $47;
   }
  }
  if ($19) {
   break;
  } else {
   $$05159$i = $$2$i;
   $$05258$i = $$153$i;
   $$05457$i = $18;
   $$sroa$12$0 = $$sroa$12$1;
   $$sroa$14$0 = $$sroa$14$2;
   $$sroa$16$0 = $$sroa$16$2;
   $$sroa$18$0 = $$sroa$18$2;
   $12 = $41;
   $15 = $39;
   $30 = $44;
   $32 = $45;
   $34 = $43;
   $36 = $42;
  }
 }
 $37 = $0 - $1 | 0;
 $38 = $39 << 4;
 $40 = $41 << 4;
 HEAP32[$vararg_buffer >> 2] = $37;
 $vararg_ptr1 = $vararg_buffer + 4 | 0;
 HEAP32[$vararg_ptr1 >> 2] = $38;
 $vararg_ptr2 = $vararg_buffer + 8 | 0;
 HEAP32[$vararg_ptr2 >> 2] = $40;
 _mp_printf(13344, 22600, $vararg_buffer) | 0;
 HEAP32[$vararg_buffer3 >> 2] = $$sroa$14$2;
 $vararg_ptr6 = $vararg_buffer3 + 4 | 0;
 HEAP32[$vararg_ptr6 >> 2] = $$sroa$16$2;
 $vararg_ptr7 = $vararg_buffer3 + 8 | 0;
 HEAP32[$vararg_ptr7 >> 2] = $$sroa$18$2;
 $vararg_ptr8 = $vararg_buffer3 + 12 | 0;
 HEAP32[$vararg_ptr8 >> 2] = $$sroa$12$1;
 _mp_printf(13344, 22635, $vararg_buffer3) | 0;
 STACKTOP = sp;
 return;
}

function _mp_seq_get_fast_slice_indexes($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $spec$store$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = sp + 16 | 0;
 $7 = sp + 12 | 0;
 $8 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $11 = $4;
 _mp_obj_slice_get($11, $6, $7, $8);
 $12 = HEAP32[$8 >> 2] | 0;
 $13 = ($12 | 0) != (17668 | 0);
 $14 = HEAP32[$8 >> 2] | 0;
 $15 = ($14 | 0) != (3 | 0);
 $or$cond = $13 & $15;
 if ($or$cond) {
  $16 = HEAP32[$8 >> 2] | 0;
  $17 = _mp_obj_get_int($16) | 0;
  $18 = $5;
  $19 = $18 + 8 | 0;
  HEAP32[$19 >> 2] = $17;
  $20 = $5;
  $21 = $20 + 8 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = ($22 | 0) == 0;
  if ($23) {
   _mp_raise_ValueError(33422);
  }
 } else {
  $24 = $5;
  $25 = $24 + 8 | 0;
  HEAP32[$25 >> 2] = 1;
 }
 $26 = HEAP32[$6 >> 2] | 0;
 $27 = ($26 | 0) == (17668 | 0);
 do {
  if ($27) {
   $28 = $5;
   $29 = $28 + 8 | 0;
   $30 = HEAP32[$29 >> 2] | 0;
   $31 = ($30 | 0) > 0;
   if ($31) {
    $9 = 0;
    break;
   } else {
    $32 = $3;
    $33 = $32 - 1 | 0;
    $9 = $33;
    break;
   }
  } else {
   $34 = HEAP32[$6 >> 2] | 0;
   $35 = _mp_obj_get_int($34) | 0;
   $9 = $35;
  }
 } while (0);
 $36 = HEAP32[$7 >> 2] | 0;
 $37 = ($36 | 0) == (17668 | 0);
 do {
  if ($37) {
   $38 = $5;
   $39 = $38 + 8 | 0;
   $40 = HEAP32[$39 >> 2] | 0;
   $41 = ($40 | 0) > 0;
   if ($41) {
    $42 = $3;
    $10 = $42;
    break;
   } else {
    $10 = 0;
    break;
   }
  } else {
   $43 = HEAP32[$7 >> 2] | 0;
   $44 = _mp_obj_get_int($43) | 0;
   $10 = $44;
   $45 = $10;
   $46 = ($45 | 0) >= 0;
   if ($46) {
    $47 = $5;
    $48 = $47 + 8 | 0;
    $49 = HEAP32[$48 >> 2] | 0;
    $50 = ($49 | 0) < 0;
    if ($50) {
     $51 = $10;
     $52 = $51 + 1 | 0;
     $10 = $52;
    }
   }
  }
 } while (0);
 $53 = $9;
 $54 = ($53 | 0) < 0;
 do {
  if ($54) {
   $55 = $3;
   $56 = $9;
   $57 = $55 + $56 | 0;
   $9 = $57;
   $58 = $9;
   $59 = ($58 | 0) < 0;
   if ($59) {
    $60 = $5;
    $61 = $60 + 8 | 0;
    $62 = HEAP32[$61 >> 2] | 0;
    $63 = ($62 | 0) < 0;
    if ($63) {
     $9 = -1;
     break;
    } else {
     $9 = 0;
     break;
    }
   }
  } else {
   $64 = $5;
   $65 = $64 + 8 | 0;
   $66 = HEAP32[$65 >> 2] | 0;
   $67 = ($66 | 0) > 0;
   if ($67) {
    $68 = $9;
    $69 = $3;
    $70 = $68 >>> 0 > $69 >>> 0;
    if ($70) {
     $71 = $3;
     $9 = $71;
     break;
    }
   }
   $72 = $5;
   $73 = $72 + 8 | 0;
   $74 = HEAP32[$73 >> 2] | 0;
   $75 = ($74 | 0) < 0;
   if ($75) {
    $76 = $9;
    $77 = $3;
    $78 = $76 >>> 0 >= $77 >>> 0;
    if ($78) {
     $79 = $3;
     $80 = $79 - 1 | 0;
     $9 = $80;
    }
   }
  }
 } while (0);
 $81 = $10;
 $82 = ($81 | 0) < 0;
 if ($82) {
  $83 = $3;
  $84 = $10;
  $85 = $83 + $84 | 0;
  $10 = $85;
  $86 = $10;
  $87 = ($86 | 0) < 0;
  $spec$store$select = $87 ? -1 : $85;
  $10 = $spec$store$select;
  $88 = $5;
  $89 = $88 + 8 | 0;
  $90 = HEAP32[$89 >> 2] | 0;
  $91 = ($90 | 0) < 0;
  if ($91) {
   $92 = $10;
   $93 = $92 + 1 | 0;
   $10 = $93;
  }
 } else {
  $94 = $10;
  $95 = $3;
  $96 = $94 >>> 0 > $95 >>> 0;
  if ($96) {
   $97 = $3;
   $10 = $97;
  }
 }
 $98 = $5;
 $99 = $98 + 8 | 0;
 $100 = HEAP32[$99 >> 2] | 0;
 $101 = ($100 | 0) > 0;
 if ($101) {
  $102 = $9;
  $103 = $10;
  $104 = ($102 | 0) > ($103 | 0);
  if ($104) {
   $105 = $9;
   $10 = $105;
  } else {
   label = 36;
  }
 } else {
  label = 36;
 }
 if ((label | 0) == 36) {
  $106 = $5;
  $107 = $106 + 8 | 0;
  $108 = HEAP32[$107 >> 2] | 0;
  $109 = ($108 | 0) < 0;
  if ($109) {
   $110 = $9;
   $111 = $10;
   $112 = ($110 | 0) < ($111 | 0);
   if ($112) {
    $113 = $9;
    $114 = $113 + 1 | 0;
    $10 = $114;
   }
  }
 }
 $115 = $9;
 $116 = $5;
 HEAP32[$116 >> 2] = $115;
 $117 = $10;
 $118 = $5;
 $119 = $118 + 4 | 0;
 HEAP32[$119 >> 2] = $117;
 $120 = $5;
 $121 = $120 + 8 | 0;
 $122 = HEAP32[$121 >> 2] | 0;
 $123 = ($122 | 0) == 1;
 STACKTOP = sp;
 return $123 | 0;
}

function _dict_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $10 = sp + 28 | 0;
 $11 = sp + 24 | 0;
 $15 = sp + 8 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $18 = $5;
 $7 = $18;
 $19 = $4;
 switch ($19 | 0) {
 case 34:
  {
   $20 = $7;
   $21 = $20 + 4 | 0;
   $22 = $6;
   $23 = _mp_map_lookup($21, $22, 0) | 0;
   $8 = $23;
   $24 = $8;
   $25 = ($24 | 0) != (0 | 0);
   $26 = $25 & 1;
   $27 = _mp_obj_new_bool_892($26) | 0;
   $3 = $27;
   $100 = $3;
   STACKTOP = sp;
   return $100 | 0;
   break;
  }
 case 2:
  {
   $28 = $5;
   $29 = _mp_obj_is_obj_883($28) | 0;
   if ($29) {
    $30 = $5;
    $31 = HEAP32[$30 >> 2] | 0;
    $32 = ($31 | 0) == (14436 | 0);
    if ($32) {
     $33 = $6;
     $34 = _mp_obj_is_obj_883($33) | 0;
     if ($34) {
      $35 = $6;
      $36 = HEAP32[$35 >> 2] | 0;
      $37 = ($36 | 0) == (14436 | 0);
      $101 = $37;
     } else {
      $101 = 0;
     }
    } else {
     $101 = 0;
    }
   } else {
    $101 = 0;
   }
   $38 = $6;
   if ($101) {
    $9 = $38;
    HEAP32[$10 >> 2] = 0;
    HEAP32[$11 >> 2] = 0;
    $39 = $7;
    $40 = _dict_iter_next($39, $10) | 0;
    $12 = $40;
    $41 = $9;
    $42 = _dict_iter_next($41, $11) | 0;
    $13 = $42;
    while (1) {
     $43 = $12;
     $44 = ($43 | 0) != (0 | 0);
     $45 = $13;
     $46 = ($45 | 0) != (0 | 0);
     $47 = $44 ? $46 : 0;
     $48 = $12;
     if (!$47) {
      label = 14;
      break;
     }
     $49 = HEAP32[$48 >> 2] | 0;
     $50 = $13;
     $51 = HEAP32[$50 >> 2] | 0;
     $52 = _mp_obj_equal($49, $51) | 0;
     if (!$52) {
      label = 12;
      break;
     }
     $53 = $12;
     $54 = $53 + 4 | 0;
     $55 = HEAP32[$54 >> 2] | 0;
     $56 = $13;
     $57 = $56 + 4 | 0;
     $58 = HEAP32[$57 >> 2] | 0;
     $59 = _mp_obj_equal($55, $58) | 0;
     if (!$59) {
      label = 12;
      break;
     }
     $60 = $7;
     $61 = _dict_iter_next($60, $10) | 0;
     $12 = $61;
     $62 = $9;
     $63 = _dict_iter_next($62, $11) | 0;
     $13 = $63;
    }
    if ((label | 0) == 12) {
     $3 = 13856;
     $100 = $3;
     STACKTOP = sp;
     return $100 | 0;
    } else if ((label | 0) == 14) {
     $64 = ($48 | 0) == (0 | 0);
     $65 = $13;
     $66 = ($65 | 0) == (0 | 0);
     $67 = $64 ? $66 : 0;
     $68 = $67 ? 13864 : 13856;
     $3 = $68;
     $100 = $3;
     STACKTOP = sp;
     return $100 | 0;
    }
   }
   $69 = _mp_obj_is_obj_883($38) | 0;
   if ($69) {
    $70 = $6;
    $71 = HEAP32[$70 >> 2] | 0;
    $72 = ($71 | 0) == (14112 | 0);
    if ($72) {
     $73 = $6;
     $14 = $73;
     $74 = $7;
     $75 = $74 + 4 | 0;
     $76 = HEAP32[$75 >> 2] | 0;
     $77 = $76 >>> 3;
     $78 = $14;
     $79 = $78 + 4 | 0;
     $80 = HEAP32[$79 >> 2] | 0;
     $81 = $80 >>> 3;
     $82 = ($77 | 0) != ($81 | 0);
     if ($82) {
      $3 = 13856;
      $100 = $3;
      STACKTOP = sp;
      return $100 | 0;
     }
     HEAP32[$15 >> 2] = 0;
     $16 = 0;
     while (1) {
      $83 = $7;
      $84 = _dict_iter_next($83, $15) | 0;
      $16 = $84;
      $85 = ($84 | 0) != (0 | 0);
      if (!$85) {
       label = 25;
       break;
      }
      $86 = $14;
      $87 = $86 + 4 | 0;
      $88 = $16;
      $89 = HEAP32[$88 >> 2] | 0;
      $90 = _mp_map_lookup($87, $89, 0) | 0;
      $17 = $90;
      $91 = $17;
      $92 = ($91 | 0) == (0 | 0);
      if ($92) {
       label = 23;
       break;
      }
      $93 = $16;
      $94 = $93 + 4 | 0;
      $95 = HEAP32[$94 >> 2] | 0;
      $96 = $17;
      $97 = $96 + 4 | 0;
      $98 = HEAP32[$97 >> 2] | 0;
      $99 = _mp_obj_equal($95, $98) | 0;
      if (!$99) {
       label = 23;
       break;
      }
     }
     if ((label | 0) == 23) {
      $3 = 13856;
      $100 = $3;
      STACKTOP = sp;
      return $100 | 0;
     } else if ((label | 0) == 25) {
      $3 = 13864;
      $100 = $3;
      STACKTOP = sp;
      return $100 | 0;
     }
    }
   }
   $3 = 13856;
   $100 = $3;
   STACKTOP = sp;
   return $100 | 0;
   break;
  }
 default:
  {
   $3 = 0;
   $100 = $3;
   STACKTOP = sp;
   return $100 | 0;
  }
 }
 return 0 | 0;
}

function _str_join($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $3 = sp + 64 | 0;
 $6 = sp + 52 | 0;
 $7 = sp + 48 | 0;
 $8 = sp + 44 | 0;
 $12 = sp + 16 | 0;
 $16 = sp;
 $2 = $0;
 HEAP32[$3 >> 2] = $1;
 $17 = $2;
 $18 = _mp_obj_get_type($17) | 0;
 $4 = $18;
 $19 = $2;
 $20 = _mp_obj_is_qstr_1128($19) | 0;
 $21 = $2;
 if ($20) {
  $22 = $21;
  $23 = $22 >>> 2;
  $24 = _qstr_data($23, $6) | 0;
  $5 = $24;
 } else {
  $25 = $21 + 8 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  HEAP32[$6 >> 2] = $26;
  $27 = $2;
  $28 = $27 + 12 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  $5 = $29;
 }
 $30 = HEAP32[$3 >> 2] | 0;
 $31 = _mp_obj_is_obj_1154($30) | 0;
 if ($31) {
  $32 = HEAP32[$3 >> 2] | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = ($33 | 0) == (17028 | 0);
  if (!$34) {
   label = 6;
  }
 } else {
  label = 6;
 }
 do {
  if ((label | 0) == 6) {
   $35 = HEAP32[$3 >> 2] | 0;
   $36 = _mp_obj_is_obj_1154($35) | 0;
   if ($36) {
    $37 = HEAP32[$3 >> 2] | 0;
    $38 = HEAP32[$37 >> 2] | 0;
    $39 = ($38 | 0) == (18952 | 0);
    if ($39) {
     break;
    }
   }
   $40 = HEAP32[17040 >> 2] | 0;
   $41 = FUNCTION_TABLE_iiiii[$40 & 1023](17028, 1, 0, $3) | 0;
   HEAP32[$3 >> 2] = $41;
  }
 } while (0);
 $42 = HEAP32[$3 >> 2] | 0;
 _mp_obj_get_array($42, $7, $8);
 $9 = 0;
 $10 = 0;
 while (1) {
  $43 = $10;
  $44 = HEAP32[$7 >> 2] | 0;
  $45 = $43 >>> 0 < $44 >>> 0;
  if (!$45) {
   break;
  }
  $46 = HEAP32[$8 >> 2] | 0;
  $47 = $10;
  $48 = $46 + ($47 << 2) | 0;
  $49 = HEAP32[$48 >> 2] | 0;
  $50 = _mp_obj_get_type($49) | 0;
  $51 = $4;
  $52 = ($50 | 0) != ($51 | 0);
  if ($52) {
   label = 12;
   break;
  }
  $53 = $10;
  $54 = $53 >>> 0 > 0;
  if ($54) {
   $55 = HEAP32[$6 >> 2] | 0;
   $56 = $9;
   $57 = $56 + $55 | 0;
   $9 = $57;
  }
  $58 = HEAP32[$8 >> 2] | 0;
  $59 = $10;
  $60 = $58 + ($59 << 2) | 0;
  $61 = HEAP32[$60 >> 2] | 0;
  $62 = _mp_obj_is_qstr_1128($61) | 0;
  $63 = HEAP32[$8 >> 2] | 0;
  $64 = $10;
  $65 = $63 + ($64 << 2) | 0;
  $66 = HEAP32[$65 >> 2] | 0;
  if ($62) {
   $67 = $66;
   $68 = $67 >>> 2;
   $69 = _qstr_len($68) | 0;
   $11 = $69;
  } else {
   $70 = $66 + 8 | 0;
   $71 = HEAP32[$70 >> 2] | 0;
   $11 = $71;
  }
  $72 = $11;
  $73 = $9;
  $74 = $73 + $72 | 0;
  $9 = $74;
  $75 = $10;
  $76 = $75 + 1 | 0;
  $10 = $76;
 }
 if ((label | 0) == 12) {
  _mp_raise_TypeError(32385);
 }
 $77 = $9;
 _vstr_init_len($12, $77);
 $78 = $12 + 8 | 0;
 $79 = HEAP32[$78 >> 2] | 0;
 $13 = $79;
 $14 = 0;
 while (1) {
  $80 = $14;
  $81 = HEAP32[$7 >> 2] | 0;
  $82 = $80 >>> 0 < $81 >>> 0;
  if (!$82) {
   break;
  }
  $83 = $14;
  $84 = $83 >>> 0 > 0;
  if ($84) {
   $85 = $13;
   $86 = $5;
   $87 = HEAP32[$6 >> 2] | 0;
   _memcpy($85 | 0, $86 | 0, $87 | 0) | 0;
   $88 = HEAP32[$6 >> 2] | 0;
   $89 = $13;
   $90 = $89 + $88 | 0;
   $13 = $90;
  }
  $91 = HEAP32[$8 >> 2] | 0;
  $92 = $14;
  $93 = $91 + ($92 << 2) | 0;
  $94 = HEAP32[$93 >> 2] | 0;
  $95 = _mp_obj_is_qstr_1128($94) | 0;
  $96 = HEAP32[$8 >> 2] | 0;
  $97 = $14;
  $98 = $96 + ($97 << 2) | 0;
  $99 = HEAP32[$98 >> 2] | 0;
  if ($95) {
   $100 = $99;
   $101 = $100 >>> 2;
   $102 = _qstr_data($101, $16) | 0;
   $15 = $102;
  } else {
   $103 = $99 + 8 | 0;
   $104 = HEAP32[$103 >> 2] | 0;
   HEAP32[$16 >> 2] = $104;
   $105 = HEAP32[$8 >> 2] | 0;
   $106 = $14;
   $107 = $105 + ($106 << 2) | 0;
   $108 = HEAP32[$107 >> 2] | 0;
   $109 = $108 + 12 | 0;
   $110 = HEAP32[$109 >> 2] | 0;
   $15 = $110;
  }
  $111 = $13;
  $112 = $15;
  $113 = HEAP32[$16 >> 2] | 0;
  _memcpy($111 | 0, $112 | 0, $113 | 0) | 0;
  $114 = HEAP32[$16 >> 2] | 0;
  $115 = $13;
  $116 = $115 + $114 | 0;
  $13 = $116;
  $117 = $14;
  $118 = $117 + 1 | 0;
  $14 = $118;
 }
 $119 = $4;
 $120 = _mp_obj_new_str_from_vstr($119, $12) | 0;
 STACKTOP = sp;
 return $120 | 0;
}

function _c_assign_atom_expr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $5;
 $10 = ($9 | 0) != 2;
 if ($10) {
  $11 = $3;
  $12 = $4;
  $13 = $12 + 8 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  _compile_node($11, $14);
 }
 $15 = $4;
 $16 = $15 + 8 | 0;
 $17 = $16 + 4 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = ($18 | 0) != 0;
 do {
  if ($19) {
   $20 = $4;
   $21 = $20 + 8 | 0;
   $22 = $21 + 4 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   $24 = $23 & 3;
   $25 = ($24 | 0) == 0;
   if ($25) {
    $26 = $4;
    $27 = $26 + 8 | 0;
    $28 = $27 + 4 | 0;
    $29 = HEAP32[$28 >> 2] | 0;
    $30 = $29;
    $6 = $30;
    $31 = $6;
    $32 = $31 + 4 | 0;
    $33 = HEAP32[$32 >> 2] | 0;
    $34 = $33 & 255;
    $35 = ($34 | 0) == 140;
    if ($35) {
     $36 = $6;
     $37 = $36 + 4 | 0;
     $38 = HEAP32[$37 >> 2] | 0;
     $39 = $38 >>> 8;
     $7 = $39;
     $40 = $5;
     $41 = ($40 | 0) != 2;
     L9 : do {
      if ($41) {
       $8 = 0;
       while (1) {
        $42 = $8;
        $43 = $7;
        $44 = $43 - 1 | 0;
        $45 = ($42 | 0) < ($44 | 0);
        if (!$45) {
         break L9;
        }
        $46 = $3;
        $47 = $6;
        $48 = $47 + 8 | 0;
        $49 = $8;
        $50 = $48 + ($49 << 2) | 0;
        $51 = HEAP32[$50 >> 2] | 0;
        _compile_node($46, $51);
        $52 = $8;
        $53 = $52 + 1 | 0;
        $8 = $53;
       }
      }
     } while (0);
     $54 = $6;
     $55 = $54 + 8 | 0;
     $56 = $7;
     $57 = $56 - 1 | 0;
     $58 = $55 + ($57 << 2) | 0;
     $59 = HEAP32[$58 >> 2] | 0;
     $60 = $59;
     $6 = $60;
    }
    $61 = $6;
    $62 = $61 + 4 | 0;
    $63 = HEAP32[$62 >> 2] | 0;
    $64 = $63 & 255;
    $65 = ($64 | 0) == 48;
    if ($65) {
     $66 = $5;
     $67 = ($66 | 0) == 2;
     $68 = $3;
     if ($67) {
      $69 = $68 + 40 | 0;
      $70 = HEAP32[$69 >> 2] | 0;
      _mp_emit_bc_rot_three($70);
      $71 = $3;
      $72 = $71 + 40 | 0;
      $73 = HEAP32[$72 >> 2] | 0;
      _mp_emit_bc_subscr($73, 1);
      STACKTOP = sp;
      return;
     }
     $74 = $6;
     $75 = $74 + 8 | 0;
     $76 = HEAP32[$75 >> 2] | 0;
     _compile_node($68, $76);
     $77 = $5;
     $78 = ($77 | 0) == 1;
     $79 = $3;
     $80 = $79 + 40 | 0;
     $81 = HEAP32[$80 >> 2] | 0;
     if ($78) {
      _mp_emit_bc_dup_top_two($81);
      $82 = $3;
      $83 = $82 + 40 | 0;
      $84 = HEAP32[$83 >> 2] | 0;
      _mp_emit_bc_subscr($84, 0);
      STACKTOP = sp;
      return;
     } else {
      _mp_emit_bc_subscr($81, 1);
      STACKTOP = sp;
      return;
     }
    } else {
     $85 = $6;
     $86 = $85 + 4 | 0;
     $87 = HEAP32[$86 >> 2] | 0;
     $88 = $87 & 255;
     $89 = ($88 | 0) == 49;
     if (!$89) {
      break;
     }
     $90 = $5;
     $91 = ($90 | 0) == 1;
     if ($91) {
      $92 = $3;
      $93 = $92 + 40 | 0;
      $94 = HEAP32[$93 >> 2] | 0;
      _mp_emit_bc_dup_top($94);
      $95 = $3;
      $96 = $95 + 40 | 0;
      $97 = HEAP32[$96 >> 2] | 0;
      $98 = $6;
      $99 = $98 + 8 | 0;
      $100 = HEAP32[$99 >> 2] | 0;
      $101 = $100 >>> 4;
      _mp_emit_bc_attr($97, $101, 0);
      STACKTOP = sp;
      return;
     }
     $102 = $5;
     $103 = ($102 | 0) == 2;
     if ($103) {
      $104 = $3;
      $105 = $104 + 40 | 0;
      $106 = HEAP32[$105 >> 2] | 0;
      _mp_emit_bc_rot_two($106);
     }
     $107 = $3;
     $108 = $107 + 40 | 0;
     $109 = HEAP32[$108 >> 2] | 0;
     $110 = $6;
     $111 = $110 + 8 | 0;
     $112 = HEAP32[$111 >> 2] | 0;
     $113 = $112 >>> 4;
     _mp_emit_bc_attr($109, $113, 1);
     STACKTOP = sp;
     return;
    }
   }
  }
 } while (0);
 $114 = $3;
 $115 = $4;
 $116 = $115;
 _compile_syntax_error($114, $116, 28734);
 STACKTOP = sp;
 return;
}

function _do_import_name($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $125 = 0, $126 = 0, $127 = 0, $128 = 0, $129 = 0, $13 = 0, $130 = 0, $131 = 0, $132 = 0, $133 = 0, $134 = 0, $135 = 0, $136 = 0, $137 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $16 = sp + 12 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = 0;
 $20 = $4;
 $21 = ($20 | 0) != 0;
 if ($21) {
  $22 = $4;
  $23 = $22 & 3;
  $24 = ($23 | 0) == 0;
  if ($24) {
   $25 = $4;
   $26 = $25;
   $27 = $26 + 4 | 0;
   $28 = HEAP32[$27 >> 2] | 0;
   $29 = $28 & 255;
   $30 = ($29 | 0) == 103;
   if ($30) {
    $31 = $4;
    $32 = $31;
    $7 = $32;
    $33 = $7;
    $34 = $33 + 8 | 0;
    $35 = $34 + 4 | 0;
    $36 = HEAP32[$35 >> 2] | 0;
    $37 = $36 >>> 4;
    $38 = $5;
    HEAP32[$38 >> 2] = $37;
    $39 = $7;
    $40 = $39 + 8 | 0;
    $41 = HEAP32[$40 >> 2] | 0;
    $4 = $41;
    $6 = 1;
   }
  }
 }
 $42 = $4;
 $43 = ($42 | 0) == 0;
 if ($43) {
  $44 = $5;
  HEAP32[$44 >> 2] = 1;
  $45 = $3;
  $46 = $45 + 40 | 0;
  $47 = HEAP32[$46 >> 2] | 0;
  _mp_emit_bc_import($47, 1, 0);
  STACKTOP = sp;
  return;
 }
 $48 = $4;
 $49 = $48 & 15;
 $50 = ($49 | 0) == 2;
 $51 = $4;
 if ($50) {
  $52 = $51 >>> 4;
  $8 = $52;
  $53 = $6;
  $54 = $53 & 1;
  if (!$54) {
   $55 = $8;
   $56 = $5;
   HEAP32[$56 >> 2] = $55;
  }
  $57 = $3;
  $58 = $57 + 40 | 0;
  $59 = HEAP32[$58 >> 2] | 0;
  $60 = $8;
  _mp_emit_bc_import($59, $60, 0);
  STACKTOP = sp;
  return;
 }
 $61 = $51;
 $9 = $61;
 $62 = $6;
 $63 = $62 & 1;
 if (!$63) {
  $64 = $9;
  $65 = $64 + 8 | 0;
  $66 = HEAP32[$65 >> 2] | 0;
  $67 = $66 >>> 4;
  $68 = $5;
  HEAP32[$68 >> 2] = $67;
 }
 $69 = $9;
 $70 = $69 + 4 | 0;
 $71 = HEAP32[$70 >> 2] | 0;
 $72 = $71 >>> 8;
 $10 = $72;
 $73 = $10;
 $74 = $73 - 1 | 0;
 $11 = $74;
 $12 = 0;
 while (1) {
  $75 = $12;
  $76 = $10;
  $77 = ($75 | 0) < ($76 | 0);
  if (!$77) {
   break;
  }
  $78 = $9;
  $79 = $78 + 8 | 0;
  $80 = $12;
  $81 = $79 + ($80 << 2) | 0;
  $82 = HEAP32[$81 >> 2] | 0;
  $83 = $82 >>> 4;
  $84 = _qstr_len($83) | 0;
  $85 = $11;
  $86 = $85 + $84 | 0;
  $11 = $86;
  $87 = $12;
  $88 = $87 + 1 | 0;
  $12 = $88;
 }
 $89 = $11;
 $90 = _mp_local_alloc($89) | 0;
 $13 = $90;
 $91 = $13;
 $14 = $91;
 $15 = 0;
 while (1) {
  $92 = $15;
  $93 = $10;
  $94 = ($92 | 0) < ($93 | 0);
  if (!$94) {
   break;
  }
  $95 = $15;
  $96 = ($95 | 0) > 0;
  if ($96) {
   $97 = $14;
   $98 = $97 + 1 | 0;
   $14 = $98;
   HEAP8[$97 >> 0] = 46;
  }
  $99 = $9;
  $100 = $99 + 8 | 0;
  $101 = $15;
  $102 = $100 + ($101 << 2) | 0;
  $103 = HEAP32[$102 >> 2] | 0;
  $104 = $103 >>> 4;
  $105 = _qstr_data($104, $16) | 0;
  $17 = $105;
  $106 = $14;
  $107 = $17;
  $108 = HEAP32[$16 >> 2] | 0;
  _memcpy($106 | 0, $107 | 0, $108 | 0) | 0;
  $109 = HEAP32[$16 >> 2] | 0;
  $110 = $14;
  $111 = $110 + $109 | 0;
  $14 = $111;
  $112 = $15;
  $113 = $112 + 1 | 0;
  $15 = $113;
 }
 $114 = $13;
 $115 = $11;
 $116 = _qstr_from_strn($114, $115) | 0;
 $18 = $116;
 $117 = $13;
 _mp_local_free($117);
 $118 = $3;
 $119 = $118 + 40 | 0;
 $120 = HEAP32[$119 >> 2] | 0;
 $121 = $18;
 _mp_emit_bc_import($120, $121, 0);
 $122 = $6;
 $123 = $122 & 1;
 if (!$123) {
  STACKTOP = sp;
  return;
 }
 $19 = 1;
 while (1) {
  $124 = $19;
  $125 = $10;
  $126 = ($124 | 0) < ($125 | 0);
  if (!$126) {
   break;
  }
  $127 = $3;
  $128 = $127 + 40 | 0;
  $129 = HEAP32[$128 >> 2] | 0;
  $130 = $9;
  $131 = $130 + 8 | 0;
  $132 = $19;
  $133 = $131 + ($132 << 2) | 0;
  $134 = HEAP32[$133 >> 2] | 0;
  $135 = $134 >>> 4;
  _mp_emit_bc_attr($129, $135, 0);
  $136 = $19;
  $137 = $136 + 1 | 0;
  $19 = $137;
 }
 STACKTOP = sp;
 return;
}

function _mp_set_lookup($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $12 = $4;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = ($13 | 0) == 0;
 do {
  if ($14) {
   $15 = $6;
   $16 = $15 & 1;
   $17 = ($16 | 0) != 0;
   if ($17) {
    $18 = $4;
    _mp_set_rehash($18);
    break;
   }
   $3 = 0;
   $113 = $3;
   STACKTOP = sp;
   return $113 | 0;
  }
 } while (0);
 $19 = $5;
 $20 = _mp_unary_op(6, $19) | 0;
 $21 = $20;
 $22 = $21 >> 1;
 $7 = $22;
 $23 = $7;
 $24 = $4;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = ($23 >>> 0) % ($25 >>> 0) & -1;
 $8 = $26;
 $27 = $8;
 $9 = $27;
 $10 = 0;
 while (1) {
  $28 = $4;
  $29 = $28 + 8 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = $8;
  $32 = $30 + ($31 << 2) | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $11 = $33;
  $34 = $11;
  $35 = ($34 | 0) == (0 | 0);
  if ($35) {
   label = 7;
   break;
  }
  $53 = $11;
  $54 = ($53 | 0) == (4 | 0);
  if ($54) {
   $55 = $10;
   $56 = ($55 | 0) == (0 | 0);
   if ($56) {
    $57 = $4;
    $58 = $57 + 8 | 0;
    $59 = HEAP32[$58 >> 2] | 0;
    $60 = $8;
    $61 = $59 + ($60 << 2) | 0;
    $10 = $61;
   }
  } else {
   $62 = $11;
   $63 = $5;
   $64 = _mp_obj_equal($62, $63) | 0;
   if ($64) {
    label = 16;
    break;
   }
  }
  $89 = $8;
  $90 = $89 + 1 | 0;
  $91 = $4;
  $92 = HEAP32[$91 >> 2] | 0;
  $93 = ($90 >>> 0) % ($92 >>> 0) & -1;
  $8 = $93;
  $94 = $8;
  $95 = $9;
  $96 = ($94 | 0) == ($95 | 0);
  if ($96) {
   $97 = $6;
   $98 = $97 & 1;
   $99 = ($98 | 0) != 0;
   if (!$99) {
    label = 26;
    break;
   }
   $100 = $10;
   $101 = ($100 | 0) != (0 | 0);
   $102 = $4;
   if ($101) {
    label = 24;
    break;
   }
   _mp_set_rehash($102);
   $109 = $7;
   $110 = $4;
   $111 = HEAP32[$110 >> 2] | 0;
   $112 = ($109 >>> 0) % ($111 >>> 0) & -1;
   $8 = $112;
   $9 = $112;
  }
 }
 if ((label | 0) == 7) {
  $36 = $6;
  $37 = $36 & 1;
  $38 = ($37 | 0) != 0;
  if (!$38) {
   $3 = 0;
   $113 = $3;
   STACKTOP = sp;
   return $113 | 0;
  }
  $39 = $10;
  $40 = ($39 | 0) == (0 | 0);
  if ($40) {
   $41 = $4;
   $42 = $41 + 8 | 0;
   $43 = HEAP32[$42 >> 2] | 0;
   $44 = $8;
   $45 = $43 + ($44 << 2) | 0;
   $10 = $45;
  }
  $46 = $4;
  $47 = $46 + 4 | 0;
  $48 = HEAP32[$47 >> 2] | 0;
  $49 = $48 + 1 | 0;
  HEAP32[$47 >> 2] = $49;
  $50 = $5;
  $51 = $10;
  HEAP32[$51 >> 2] = $50;
  $52 = $5;
  $3 = $52;
  $113 = $3;
  STACKTOP = sp;
  return $113 | 0;
 } else if ((label | 0) == 16) {
  $65 = $6;
  $66 = $65 & 2;
  $67 = ($66 | 0) != 0;
  do {
   if ($67) {
    $68 = $4;
    $69 = $68 + 4 | 0;
    $70 = HEAP32[$69 >> 2] | 0;
    $71 = $70 + -1 | 0;
    HEAP32[$69 >> 2] = $71;
    $72 = $4;
    $73 = $72 + 8 | 0;
    $74 = HEAP32[$73 >> 2] | 0;
    $75 = $8;
    $76 = $75 + 1 | 0;
    $77 = $4;
    $78 = HEAP32[$77 >> 2] | 0;
    $79 = ($76 >>> 0) % ($78 >>> 0) & -1;
    $80 = $74 + ($79 << 2) | 0;
    $81 = HEAP32[$80 >> 2] | 0;
    $82 = ($81 | 0) == (0 | 0);
    $83 = $4;
    $84 = $83 + 8 | 0;
    $85 = HEAP32[$84 >> 2] | 0;
    $86 = $8;
    $87 = $85 + ($86 << 2) | 0;
    if ($82) {
     HEAP32[$87 >> 2] = 0;
     break;
    } else {
     HEAP32[$87 >> 2] = 4;
     break;
    }
   }
  } while (0);
  $88 = $11;
  $3 = $88;
  $113 = $3;
  STACKTOP = sp;
  return $113 | 0;
 } else if ((label | 0) == 24) {
  $103 = $102 + 4 | 0;
  $104 = HEAP32[$103 >> 2] | 0;
  $105 = $104 + 1 | 0;
  HEAP32[$103 >> 2] = $105;
  $106 = $5;
  $107 = $10;
  HEAP32[$107 >> 2] = $106;
  $108 = $5;
  $3 = $108;
  $113 = $3;
  STACKTOP = sp;
  return $113 | 0;
 } else if ((label | 0) == 26) {
  $3 = 0;
  $113 = $3;
  STACKTOP = sp;
  return $113 | 0;
 }
 return 0 | 0;
}

function _compile_comparison($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $2 = $0;
 $3 = $1;
 $12 = $3;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $14 >>> 8;
 $4 = $15;
 $16 = $2;
 $17 = $3;
 $18 = $17 + 8 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 _compile_node($16, $19);
 $20 = $4;
 $21 = ($20 | 0) > 3;
 $22 = $21 & 1;
 $5 = $22;
 $6 = 0;
 $23 = $5;
 $24 = $23 & 1;
 if ($24) {
  $25 = $2;
  $26 = _comp_next_label($25) | 0;
  $6 = $26;
 }
 $7 = 1;
 while (1) {
  $27 = $7;
  $28 = $27 + 1 | 0;
  $29 = $4;
  $30 = ($28 | 0) < ($29 | 0);
  if (!$30) {
   break;
  }
  $31 = $2;
  $32 = $3;
  $33 = $32 + 8 | 0;
  $34 = $7;
  $35 = $34 + 1 | 0;
  $36 = $33 + ($35 << 2) | 0;
  $37 = HEAP32[$36 >> 2] | 0;
  _compile_node($31, $37);
  $38 = $7;
  $39 = $38 + 2 | 0;
  $40 = $4;
  $41 = ($39 | 0) < ($40 | 0);
  if ($41) {
   $42 = $2;
   $43 = $42 + 40 | 0;
   $44 = HEAP32[$43 >> 2] | 0;
   _mp_emit_bc_dup_top($44);
   $45 = $2;
   $46 = $45 + 40 | 0;
   $47 = HEAP32[$46 >> 2] | 0;
   _mp_emit_bc_rot_three($47);
  }
  $48 = $3;
  $49 = $48 + 8 | 0;
  $50 = $7;
  $51 = $49 + ($50 << 2) | 0;
  $52 = HEAP32[$51 >> 2] | 0;
  $53 = $52 & 15;
  $54 = ($53 | 0) == 14;
  $55 = $3;
  $56 = $55 + 8 | 0;
  $57 = $7;
  $58 = $56 + ($57 << 2) | 0;
  $59 = HEAP32[$58 >> 2] | 0;
  do {
   if ($54) {
    $60 = $59 >>> 4;
    switch ($60 | 0) {
    case 56:
     {
      $8 = 0;
      break;
     }
    case 58:
     {
      $8 = 1;
      break;
     }
    case 66:
     {
      $8 = 2;
      break;
     }
    case 64:
     {
      $8 = 3;
      break;
     }
    case 65:
     {
      $8 = 4;
      break;
     }
    case 67:
     {
      $8 = 5;
      break;
     }
    default:
     {
      $8 = 6;
     }
    }
    $61 = $2;
    $62 = $61 + 40 | 0;
    $63 = HEAP32[$62 >> 2] | 0;
    $64 = $8;
    _mp_emit_bc_binary_op($63, $64);
   } else {
    $65 = $59;
    $9 = $65;
    $66 = $9;
    $67 = $66 + 4 | 0;
    $68 = HEAP32[$67 >> 2] | 0;
    $69 = $68 & 255;
    $10 = $69;
    $70 = $10;
    $71 = ($70 | 0) == 131;
    if ($71) {
     $72 = $2;
     $73 = $72 + 40 | 0;
     $74 = HEAP32[$73 >> 2] | 0;
     _mp_emit_bc_binary_op($74, 36);
     break;
    }
    $75 = $9;
    $76 = $75 + 8 | 0;
    $77 = HEAP32[$76 >> 2] | 0;
    $78 = ($77 | 0) == 0;
    $79 = $2;
    $80 = $79 + 40 | 0;
    $81 = HEAP32[$80 >> 2] | 0;
    if ($78) {
     _mp_emit_bc_binary_op($81, 7);
     break;
    } else {
     _mp_emit_bc_binary_op($81, 37);
     break;
    }
   }
  } while (0);
  $82 = $7;
  $83 = $82 + 2 | 0;
  $84 = $4;
  $85 = ($83 | 0) < ($84 | 0);
  if ($85) {
   $86 = $2;
   $87 = $86 + 40 | 0;
   $88 = HEAP32[$87 >> 2] | 0;
   $89 = $6;
   _mp_emit_bc_jump_if_or_pop($88, 0, $89);
  }
  $90 = $7;
  $91 = $90 + 2 | 0;
  $7 = $91;
 }
 $92 = $5;
 $93 = $92 & 1;
 if (!$93) {
  STACKTOP = sp;
  return;
 }
 $94 = $2;
 $95 = _comp_next_label($94) | 0;
 $11 = $95;
 $96 = $2;
 $97 = $96 + 40 | 0;
 $98 = HEAP32[$97 >> 2] | 0;
 $99 = $11;
 _mp_emit_bc_jump($98, $99);
 $100 = $2;
 $101 = $100 + 40 | 0;
 $102 = HEAP32[$101 >> 2] | 0;
 $103 = $6;
 _mp_emit_bc_label_assign($102, $103);
 $104 = $2;
 $105 = $104 + 40 | 0;
 $106 = HEAP32[$105 >> 2] | 0;
 _mp_emit_bc_adjust_stack_size($106, 1);
 $107 = $2;
 $108 = $107 + 40 | 0;
 $109 = HEAP32[$108 >> 2] | 0;
 _mp_emit_bc_rot_two($109);
 $110 = $2;
 $111 = $110 + 40 | 0;
 $112 = HEAP32[$111 >> 2] | 0;
 _mp_emit_bc_pop_top($112);
 $113 = $2;
 $114 = $113 + 40 | 0;
 $115 = HEAP32[$114 >> 2] | 0;
 $116 = $11;
 _mp_emit_bc_label_assign($115, $116);
 STACKTOP = sp;
 return;
}

function _list_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $10 = sp + 8 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $14 = $5;
 $7 = $14;
 $15 = $4;
 switch ($15 | 0) {
 case 26:
  {
   $16 = $6;
   $17 = _mp_obj_is_obj_1061($16) | 0;
   if ($17) {
    $18 = $6;
    $19 = HEAP32[$18 >> 2] | 0;
    $20 = ($19 | 0) == (17028 | 0);
    if ($20) {
     $21 = $6;
     $8 = $21;
     $22 = $7;
     $23 = $22 + 8 | 0;
     $24 = HEAP32[$23 >> 2] | 0;
     $25 = $8;
     $26 = $25 + 8 | 0;
     $27 = HEAP32[$26 >> 2] | 0;
     $28 = $24 + $27 | 0;
     $29 = _list_new($28) | 0;
     $9 = $29;
     $30 = $9;
     $31 = $30 + 12 | 0;
     $32 = HEAP32[$31 >> 2] | 0;
     $33 = $7;
     $34 = $33 + 12 | 0;
     $35 = HEAP32[$34 >> 2] | 0;
     $36 = $7;
     $37 = $36 + 8 | 0;
     $38 = HEAP32[$37 >> 2] | 0;
     $39 = $38 << 2;
     _memcpy($32 | 0, $35 | 0, $39 | 0) | 0;
     $40 = $9;
     $41 = $40 + 12 | 0;
     $42 = HEAP32[$41 >> 2] | 0;
     $43 = $7;
     $44 = $43 + 8 | 0;
     $45 = HEAP32[$44 >> 2] | 0;
     $46 = $42 + ($45 << 2) | 0;
     $47 = $8;
     $48 = $47 + 12 | 0;
     $49 = HEAP32[$48 >> 2] | 0;
     $50 = $8;
     $51 = $50 + 8 | 0;
     $52 = HEAP32[$51 >> 2] | 0;
     $53 = $52 << 2;
     _memcpy($46 | 0, $49 | 0, $53 | 0) | 0;
     $54 = $9;
     $3 = $54;
     $106 = $3;
     STACKTOP = sp;
     return $106 | 0;
    }
   }
   $3 = 0;
   $106 = $3;
   STACKTOP = sp;
   return $106 | 0;
   break;
  }
 case 14:
  {
   $55 = $5;
   $56 = $6;
   _list_extend($55, $56) | 0;
   $57 = $5;
   $3 = $57;
   $106 = $3;
   STACKTOP = sp;
   return $106 | 0;
   break;
  }
 case 28:
  {
   $58 = $6;
   $59 = _mp_obj_get_int_maybe($58, $10) | 0;
   if (!$59) {
    $3 = 0;
    $106 = $3;
    STACKTOP = sp;
    return $106 | 0;
   }
   $60 = HEAP32[$10 >> 2] | 0;
   $61 = ($60 | 0) < 0;
   if ($61) {
    HEAP32[$10 >> 2] = 0;
   }
   $62 = $7;
   $63 = $62 + 8 | 0;
   $64 = HEAP32[$63 >> 2] | 0;
   $65 = HEAP32[$10 >> 2] | 0;
   $66 = Math_imul($64, $65) | 0;
   $67 = _list_new($66) | 0;
   $11 = $67;
   $68 = $7;
   $69 = $68 + 12 | 0;
   $70 = HEAP32[$69 >> 2] | 0;
   $71 = $7;
   $72 = $71 + 8 | 0;
   $73 = HEAP32[$72 >> 2] | 0;
   $74 = HEAP32[$10 >> 2] | 0;
   $75 = $11;
   $76 = $75 + 12 | 0;
   $77 = HEAP32[$76 >> 2] | 0;
   _mp_seq_multiply($70, 4, $73, $74, $77);
   $78 = $11;
   $3 = $78;
   $106 = $3;
   STACKTOP = sp;
   return $106 | 0;
   break;
  }
 case 4:
 case 1:
 case 3:
 case 0:
 case 2:
  {
   $79 = $6;
   $80 = _mp_obj_is_obj_1061($79) | 0;
   if ($80) {
    $81 = $6;
    $82 = HEAP32[$81 >> 2] | 0;
    $83 = ($82 | 0) == (17028 | 0);
    if ($83) {
     $86 = $6;
     $12 = $86;
     $87 = $4;
     $88 = $7;
     $89 = $88 + 12 | 0;
     $90 = HEAP32[$89 >> 2] | 0;
     $91 = $7;
     $92 = $91 + 8 | 0;
     $93 = HEAP32[$92 >> 2] | 0;
     $94 = $12;
     $95 = $94 + 12 | 0;
     $96 = HEAP32[$95 >> 2] | 0;
     $97 = $12;
     $98 = $97 + 8 | 0;
     $99 = HEAP32[$98 >> 2] | 0;
     $100 = _mp_seq_cmp_objs($87, $90, $93, $96, $99) | 0;
     $101 = $100 & 1;
     $13 = $101;
     $102 = $13;
     $103 = $102 & 1;
     $104 = $103 & 1;
     $105 = _mp_obj_new_bool_1064($104) | 0;
     $3 = $105;
     $106 = $3;
     STACKTOP = sp;
     return $106 | 0;
    }
   }
   $84 = $4;
   $85 = ($84 | 0) == 2;
   if ($85) {
    $3 = 13856;
    $106 = $3;
    STACKTOP = sp;
    return $106 | 0;
   } else {
    $3 = 0;
    $106 = $3;
    STACKTOP = sp;
    return $106 | 0;
   }
   break;
  }
 default:
  {
   $3 = 0;
   $106 = $3;
   STACKTOP = sp;
   return $106 | 0;
  }
 }
 return 0 | 0;
}

function _compile_decorated($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $124 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $4 = sp + 52 | 0;
 $6 = sp + 44 | 0;
 $10 = sp + 28 | 0;
 $2 = $0;
 $3 = $1;
 $18 = $3;
 $19 = $18 + 8 | 0;
 $20 = _mp_parse_node_extract_list($19, 63, $4) | 0;
 $5 = $20;
 $21 = $2;
 $22 = $21 + 36 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $23 + 26 | 0;
 $25 = HEAP16[$24 >> 1] | 0;
 $26 = $25 & 65535;
 HEAP32[$6 >> 2] = $26;
 $7 = 0;
 $8 = 0;
 while (1) {
  $27 = $8;
  $28 = $5;
  $29 = ($27 | 0) < ($28 | 0);
  if (!$29) {
   break;
  }
  $30 = HEAP32[$4 >> 2] | 0;
  $31 = $8;
  $32 = $30 + ($31 << 2) | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = $33;
  $9 = $34;
  $35 = $9;
  $36 = $35 + 8 | 0;
  $37 = _mp_parse_node_extract_list($36, 107, $10) | 0;
  $11 = $37;
  $38 = $2;
  $39 = $11;
  $40 = HEAP32[$10 >> 2] | 0;
  $41 = _compile_built_in_decorator($38, $39, $40, $6) | 0;
  if ($41) {
   $42 = $7;
   $43 = $42 + 1 | 0;
   $7 = $43;
  } else {
   $44 = $2;
   $45 = HEAP32[$10 >> 2] | 0;
   $46 = HEAP32[$45 >> 2] | 0;
   _compile_node($44, $46);
   $12 = 1;
   while (1) {
    $47 = $12;
    $48 = $11;
    $49 = ($47 | 0) < ($48 | 0);
    if (!$49) {
     break;
    }
    $50 = $2;
    $51 = $50 + 40 | 0;
    $52 = HEAP32[$51 >> 2] | 0;
    $53 = HEAP32[$10 >> 2] | 0;
    $54 = $12;
    $55 = $53 + ($54 << 2) | 0;
    $56 = HEAP32[$55 >> 2] | 0;
    $57 = $56 >>> 4;
    _mp_emit_bc_attr($52, $57, 0);
    $58 = $12;
    $59 = $58 + 1 | 0;
    $12 = $59;
   }
   $60 = $9;
   $61 = $60 + 8 | 0;
   $62 = $61 + 4 | 0;
   $63 = HEAP32[$62 >> 2] | 0;
   $64 = ($63 | 0) == 0;
   if (!$64) {
    $65 = $2;
    $66 = $9;
    $67 = $66 + 8 | 0;
    $68 = $67 + 4 | 0;
    $69 = HEAP32[$68 >> 2] | 0;
    _compile_node($65, $69);
   }
  }
  $70 = $8;
  $71 = $70 + 1 | 0;
  $8 = $71;
 }
 $72 = $3;
 $73 = $72 + 8 | 0;
 $74 = $73 + 4 | 0;
 $75 = HEAP32[$74 >> 2] | 0;
 $76 = $75;
 $13 = $76;
 $14 = 0;
 $77 = $13;
 $78 = $77 + 4 | 0;
 $79 = HEAP32[$78 >> 2] | 0;
 $80 = $79 & 255;
 $81 = ($80 | 0) == 3;
 do {
  if ($81) {
   $82 = $2;
   $83 = $13;
   $84 = HEAP32[$6 >> 2] | 0;
   $85 = _compile_funcdef_helper($82, $83, $84) | 0;
   $14 = $85;
  } else {
   $86 = $13;
   $87 = $86 + 4 | 0;
   $88 = HEAP32[$87 >> 2] | 0;
   $89 = $88 & 255;
   $90 = ($89 | 0) == 65;
   if ($90) {
    $91 = $13;
    $92 = $91 + 8 | 0;
    $93 = HEAP32[$92 >> 2] | 0;
    $94 = $93;
    $15 = $94;
    $95 = $2;
    $96 = $15;
    $97 = HEAP32[$6 >> 2] | 0;
    $98 = _compile_funcdef_helper($95, $96, $97) | 0;
    $14 = $98;
    $99 = $15;
    $100 = $99 + 8 | 0;
    $101 = $100 + 16 | 0;
    $102 = HEAP32[$101 >> 2] | 0;
    $103 = $102;
    $16 = $103;
    $104 = $16;
    $105 = $104 + 24 | 0;
    $106 = HEAP16[$105 >> 1] | 0;
    $107 = $106 & 65535;
    $108 = $107 | 4;
    $109 = $108 & 65535;
    HEAP16[$105 >> 1] = $109;
    break;
   } else {
    $110 = $2;
    $111 = $13;
    $112 = HEAP32[$6 >> 2] | 0;
    $113 = _compile_classdef_helper($110, $111, $112) | 0;
    $14 = $113;
    break;
   }
  }
 } while (0);
 $17 = 0;
 while (1) {
  $114 = $17;
  $115 = $5;
  $116 = $7;
  $117 = $115 - $116 | 0;
  $118 = ($114 | 0) < ($117 | 0);
  $119 = $2;
  if (!$118) {
   break;
  }
  $120 = $119 + 40 | 0;
  $121 = HEAP32[$120 >> 2] | 0;
  _mp_emit_bc_call_function($121, 1, 0, 0);
  $122 = $17;
  $123 = $122 + 1 | 0;
  $17 = $123;
 }
 $124 = $14;
 _compile_store_id($119, $124);
 STACKTOP = sp;
 return;
}

function _mp_arg_parse_all($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer = sp;
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 $12 = 0;
 $13 = 0;
 $14 = 0;
 L1 : while (1) {
  $17 = $14;
  $18 = $9;
  $19 = $17 >>> 0 < $18 >>> 0;
  if (!$19) {
   label = 17;
   break;
  }
  $20 = $14;
  $21 = $6;
  $22 = $20 >>> 0 < $21 >>> 0;
  do {
   if ($22) {
    $23 = $10;
    $24 = $14;
    $25 = $23 + ($24 << 3) | 0;
    $26 = $25 + 2 | 0;
    $27 = HEAP16[$26 >> 1] | 0;
    $28 = $27 & 65535;
    $29 = $28 & 512;
    $30 = ($29 | 0) != 0;
    if ($30) {
     label = 18;
     break L1;
    }
    $31 = $12;
    $32 = $31 + 1 | 0;
    $12 = $32;
    $33 = $7;
    $34 = $14;
    $35 = $33 + ($34 << 2) | 0;
    $36 = HEAP32[$35 >> 2] | 0;
    $15 = $36;
    label = 11;
   } else {
    $37 = $8;
    $38 = $10;
    $39 = $14;
    $40 = $38 + ($39 << 3) | 0;
    $41 = HEAP16[$40 >> 1] | 0;
    $42 = $41 & 65535;
    $43 = $42 << 2;
    $44 = $43 | 2;
    $45 = $44;
    $46 = _mp_map_lookup($37, $45, 0) | 0;
    $16 = $46;
    $47 = $16;
    $48 = ($47 | 0) == (0 | 0);
    if (!$48) {
     $70 = $13;
     $71 = $70 + 1 | 0;
     $13 = $71;
     $72 = $16;
     $73 = $72 + 4 | 0;
     $74 = HEAP32[$73 >> 2] | 0;
     $15 = $74;
     label = 11;
     break;
    }
    $49 = $10;
    $50 = $14;
    $51 = $49 + ($50 << 3) | 0;
    $52 = $51 + 2 | 0;
    $53 = HEAP16[$52 >> 1] | 0;
    $54 = $53 & 65535;
    $55 = $54 & 256;
    $56 = ($55 | 0) != 0;
    if ($56) {
     label = 8;
     break L1;
    }
    $63 = $11;
    $64 = $14;
    $65 = $63 + ($64 << 2) | 0;
    $66 = $10;
    $67 = $14;
    $68 = $66 + ($67 << 3) | 0;
    $69 = $68 + 4 | 0;
    HEAP32[$65 >> 2] = HEAP32[$69 >> 2] | 0;
   }
  } while (0);
  do {
   if ((label | 0) == 11) {
    label = 0;
    $75 = $10;
    $76 = $14;
    $77 = $75 + ($76 << 3) | 0;
    $78 = $77 + 2 | 0;
    $79 = HEAP16[$78 >> 1] | 0;
    $80 = $79 & 65535;
    $81 = $80 & 255;
    $82 = ($81 | 0) == 1;
    if ($82) {
     $83 = $15;
     $84 = _mp_obj_is_true($83) | 0;
     $85 = $11;
     $86 = $14;
     $87 = $85 + ($86 << 2) | 0;
     $88 = $84 & 1;
     HEAP8[$87 >> 0] = $88;
     break;
    }
    $89 = $10;
    $90 = $14;
    $91 = $89 + ($90 << 3) | 0;
    $92 = $91 + 2 | 0;
    $93 = HEAP16[$92 >> 1] | 0;
    $94 = $93 & 65535;
    $95 = $94 & 255;
    $96 = ($95 | 0) == 2;
    $97 = $15;
    if ($96) {
     $98 = _mp_obj_get_int($97) | 0;
     $99 = $11;
     $100 = $14;
     $101 = $99 + ($100 << 2) | 0;
     HEAP32[$101 >> 2] = $98;
     break;
    } else {
     $102 = $11;
     $103 = $14;
     $104 = $102 + ($103 << 2) | 0;
     HEAP32[$104 >> 2] = $97;
     break;
    }
   }
  } while (0);
  $105 = $14;
  $106 = $105 + 1 | 0;
  $14 = $106;
 }
 if ((label | 0) == 8) {
  $57 = $10;
  $58 = $14;
  $59 = $57 + ($58 << 3) | 0;
  $60 = HEAP16[$59 >> 1] | 0;
  $61 = $60 & 65535;
  HEAP32[$vararg_buffer >> 2] = $61;
  $62 = _mp_obj_new_exception_msg_varg(16012, 30192, $vararg_buffer) | 0;
  _nlr_jump($62);
 } else if ((label | 0) == 17) {
  $107 = $12;
  $108 = $6;
  $109 = $107 >>> 0 < $108 >>> 0;
  if ($109) {
   _mp_raise_TypeError(30215);
  }
  $110 = $13;
  $111 = $8;
  $112 = HEAP32[$111 >> 2] | 0;
  $113 = $112 >>> 3;
  $114 = $110 >>> 0 < $113 >>> 0;
  if ($114) {
   _mp_raise_TypeError(30248);
  } else {
   STACKTOP = sp;
   return;
  }
 } else if ((label | 0) == 18) {
  _mp_raise_TypeError(30215);
 }
}

function _gc_dump_alloc_table() {
 var $$ = 0, $$037$lcssa = 0, $$03741 = 0, $$044 = 0, $$1 = 0, $$136 = 0, $$3 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond39 = 0, $spec$select = 0, $trunc = 0, $trunc$clear = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $0 = HEAP32[40752 >> 2] | 0;
 HEAP32[$vararg_buffer >> 2] = $0;
 _mp_printf(13344, 22704, $vararg_buffer) | 0;
 $1 = HEAP32[40748 >> 2] | 0;
 $2 = $1 << 2;
 $3 = ($2 | 0) == 0;
 if ($3) {
  _mp_print_str(13344, 34812) | 0;
  STACKTOP = sp;
  return;
 }
 $$044 = 0;
 $7 = $2;
 L4 : while (1) {
  $4 = $$044 & 63;
  $5 = ($4 | 0) == 0;
  if ($5) {
   $6 = $$044 >>> 0 < $7 >>> 0;
   L8 : do {
    if ($6) {
     $8 = HEAP32[40744 >> 2] | 0;
     $$03741 = $$044;
     while (1) {
      $9 = $$03741 >>> 2;
      $10 = $8 + $9 | 0;
      $11 = HEAP8[$10 >> 0] | 0;
      $12 = $11 & 255;
      $13 = $$03741 << 1;
      $14 = $13 & 6;
      $15 = 3 << $14;
      $16 = $15 & $12;
      $17 = ($16 | 0) == 0;
      if (!$17) {
       $$037$lcssa = $$03741;
       break L8;
      }
      $18 = $$03741 + 1 | 0;
      $19 = $18 >>> 0 < $7 >>> 0;
      if ($19) {
       $$03741 = $18;
      } else {
       $$037$lcssa = $18;
       break;
      }
     }
    } else {
     $$037$lcssa = $$044;
    }
   } while (0);
   $20 = $$037$lcssa - $$044 | 0;
   $21 = $20 >>> 0 > 127;
   if ($21) {
    $22 = $20 >>> 6;
    HEAP32[$vararg_buffer1 >> 2] = $22;
    _mp_printf(13344, 22731, $vararg_buffer1) | 0;
    $23 = $$037$lcssa & -64;
    $24 = HEAP32[40748 >> 2] | 0;
    $25 = $24 << 2;
    $26 = $23 >>> 0 < $25 >>> 0;
    if ($26) {
     $$1 = $23;
    } else {
     label = 23;
     break;
    }
   } else {
    $$1 = $$044;
   }
   $27 = $$1 << 4;
   $28 = $27 & 1048560;
   HEAP32[$vararg_buffer4 >> 2] = $28;
   _mp_printf(13344, 22759, $vararg_buffer4) | 0;
   $$3 = $$1;
  } else {
   $$3 = $$044;
  }
  $29 = HEAP32[40744 >> 2] | 0;
  $30 = $$3 >>> 2;
  $31 = $29 + $30 | 0;
  $32 = HEAP8[$31 >> 0] | 0;
  $33 = $32 & 255;
  $34 = $$3 << 1;
  $35 = $34 & 6;
  $36 = $33 >>> $35;
  $trunc = $36 & 255;
  $trunc$clear = $trunc & 3;
  switch ($trunc$clear << 24 >> 24) {
  case 0:
   {
    $$136 = 46;
    break;
   }
  case 1:
   {
    $37 = HEAP32[40752 >> 2] | 0;
    $38 = $$3 << 4;
    $39 = $37 + $38 | 0;
    $40 = HEAP32[$39 >> 2] | 0;
    $41 = ($40 | 0) == (18952 | 0);
    if ($41) {
     $$136 = 84;
    } else {
     $42 = ($40 | 0) == (17028 | 0);
     if ($42) {
      $$136 = 76;
     } else {
      $43 = ($40 | 0) == (14112 | 0);
      if ($43) {
       $$136 = 68;
      } else {
       $44 = ($40 | 0) == (18680 | 0);
       $45 = ($40 | 0) == (18304 | 0);
       $or$cond = $44 | $45;
       if ($or$cond) {
        $$136 = 83;
       } else {
        $46 = ($40 | 0) == (13584 | 0);
        $47 = ($40 | 0) == (13644 | 0);
        $or$cond39 = $46 | $47;
        if ($or$cond39) {
         $$136 = 65;
        } else {
         $48 = ($40 | 0) == (16252 | 0);
         if ($48) {
          $$136 = 70;
         } else {
          $49 = ($40 | 0) == (16612 | 0);
          $50 = ($40 | 0) == (17264 | 0);
          $$ = $50 ? 77 : 104;
          $spec$select = $49 ? 66 : $$;
          $$136 = $spec$select;
         }
        }
       }
      }
     }
    }
    break;
   }
  case 2:
   {
    $$136 = 61;
    break;
   }
  case 3:
   {
    $$136 = 109;
    break;
   }
  default:
   {
    label = 21;
    break L4;
   }
  }
  HEAP32[$vararg_buffer7 >> 2] = $$136;
  _mp_printf(13344, 32828, $vararg_buffer7) | 0;
  $51 = $$3 + 1 | 0;
  $52 = HEAP32[40748 >> 2] | 0;
  $53 = $52 << 2;
  $54 = $51 >>> 0 < $53 >>> 0;
  if ($54) {
   $$044 = $51;
   $7 = $53;
  } else {
   label = 23;
   break;
  }
 }
 if ((label | 0) == 21) {} else if ((label | 0) == 23) {
  _mp_print_str(13344, 34812) | 0;
  STACKTOP = sp;
  return;
 }
}

function _atan2($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $$0 = 0.0, $$053 = 0.0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0.0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0.0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0.0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0.0, $44 = 0, $45 = 0, $46 = 0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond59 = 0, $trunc = 0, $trunc$clear = 0, $trunc55 = 0, $trunc55$clear = 0, $trunc55$clear1 = 0, $trunc56 = 0, $trunc56$clear = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $1;
 $2 = HEAP32[tempDoublePtr >> 2] | 0;
 $3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $4 = $3 & 2147483647;
 $5 = $4 >>> 0 > 2146435072;
 $6 = $2 >>> 0 > 0;
 $7 = ($4 | 0) == 2146435072;
 $8 = $7 & $6;
 $9 = $5 | $8;
 if (!$9) {
  HEAPF64[tempDoublePtr >> 3] = $0;
  $10 = HEAP32[tempDoublePtr >> 2] | 0;
  $11 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  $12 = $11 & 2147483647;
  $13 = $12 >>> 0 > 2146435072;
  $14 = $10 >>> 0 > 0;
  $15 = ($12 | 0) == 2146435072;
  $16 = $15 & $14;
  $17 = $13 | $16;
  if (!$17) {
   $19 = $3 + -1072693248 | 0;
   $20 = $19 | $2;
   $21 = ($20 | 0) == 0;
   if ($21) {
    $22 = +_atan($0);
    $$0 = $22;
    return +$$0;
   }
   $23 = _bitshift64Lshr($10 | 0, $11 | 0, 63) | 0;
   $24 = getTempRet0() | 0;
   $25 = _bitshift64Lshr($2 | 0, $3 | 0, 62) | 0;
   $26 = getTempRet0() | 0;
   $27 = $25 & 2;
   $28 = $27 | $23;
   $29 = $3 & 2147483647;
   $30 = $11 & 2147483647;
   $31 = $30 | $10;
   $32 = ($31 | 0) == 0;
   if ($32) {
    $trunc56 = $28 & 255;
    $trunc56$clear = $trunc56 & 3;
    switch ($trunc56$clear << 24 >> 24) {
    case 2:
     {
      $$0 = 3.141592653589793;
      return +$$0;
      break;
     }
    case 3:
     {
      $$0 = -3.141592653589793;
      return +$$0;
      break;
     }
    case 1:
    case 0:
     {
      $$0 = $0;
      return +$$0;
      break;
     }
    default:
     {}
    }
   }
   $33 = $29 | $2;
   $34 = ($33 | 0) == 0;
   if ($34) {
    $35 = ($23 | 0) == 0;
    $36 = $35 ? 1.5707963267948966 : -1.5707963267948966;
    $$0 = $36;
    return +$$0;
   }
   $37 = ($29 | 0) == 2146435072;
   if (!$37) {
    $39 = $29 + 67108864 | 0;
    $40 = $39 >>> 0 < $30 >>> 0;
    $41 = ($30 | 0) == 2146435072;
    $or$cond = $41 | $40;
    if ($or$cond) {
     $42 = ($23 | 0) == 0;
     $43 = $42 ? 1.5707963267948966 : -1.5707963267948966;
     $$0 = $43;
     return +$$0;
    }
    $44 = ($27 | 0) != 0;
    $45 = $30 + 67108864 | 0;
    $46 = $45 >>> 0 < $29 >>> 0;
    $or$cond59 = $44 & $46;
    if ($or$cond59) {
     $$053 = 0.0;
    } else {
     $47 = $0 / $1;
     $48 = +Math_abs(+$47);
     $49 = +_atan($48);
     $$053 = $49;
    }
    $trunc = $28 & 255;
    $trunc$clear = $trunc & 3;
    switch ($trunc$clear << 24 >> 24) {
    case 1:
     {
      $50 = -$$053;
      $$0 = $50;
      return +$$0;
      break;
     }
    case 2:
     {
      $51 = $$053 + -1.2246467991473532e-16;
      $52 = 3.141592653589793 - $51;
      $$0 = $52;
      return +$$0;
      break;
     }
    case 0:
     {
      $$0 = $$053;
      return +$$0;
      break;
     }
    default:
     {
      $53 = $$053 + -1.2246467991473532e-16;
      $54 = $53 + -3.141592653589793;
      $$0 = $54;
      return +$$0;
     }
    }
   }
   $38 = ($30 | 0) == 2146435072;
   $trunc55 = $28 & 255;
   if ($38) {
    $trunc55$clear = $trunc55 & 3;
    switch ($trunc55$clear << 24 >> 24) {
    case 1:
     {
      $$0 = -.7853981633974483;
      return +$$0;
      break;
     }
    case 2:
     {
      $$0 = 2.356194490192345;
      return +$$0;
      break;
     }
    case 3:
     {
      $$0 = -2.356194490192345;
      return +$$0;
      break;
     }
    case 0:
     {
      $$0 = .7853981633974483;
      return +$$0;
      break;
     }
    default:
     {}
    }
   } else {
    $trunc55$clear1 = $trunc55 & 3;
    switch ($trunc55$clear1 << 24 >> 24) {
    case 1:
     {
      $$0 = -0.0;
      return +$$0;
      break;
     }
    case 2:
     {
      $$0 = 3.141592653589793;
      return +$$0;
      break;
     }
    case 3:
     {
      $$0 = -3.141592653589793;
      return +$$0;
      break;
     }
    case 0:
     {
      $$0 = 0.0;
      return +$$0;
      break;
     }
    default:
     {}
    }
   }
  }
 }
 $18 = $0 + $1;
 $$0 = $18;
 return +$$0;
}

function _gc_alloc($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$05882 = 0, $$06284 = 0, $$06483 = 0, $$1 = 0, $$161 = 0, $$161$ph = 0, $$163 = 0, $$165$ph = 0, $$2 = 0, $$3 = 0, $$5 = 0, $$5$ph = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = $0 + 15 | 0;
 $3 = $2 >>> 4;
 $4 = ($3 | 0) != 0;
 $5 = HEAP16[41020 >> 1] | 0;
 $6 = $5 << 16 >> 16 == 0;
 $or$cond = $4 & $6;
 if (!$or$cond) {
  $$1 = 0;
  return $$1 | 0;
 }
 $7 = HEAP16[41022 >> 1] | 0;
 $8 = $7 << 16 >> 16 == 0;
 if ($8) {
  $$161$ph = 1;
 } else {
  $9 = HEAP32[41024 >> 2] | 0;
  $10 = HEAP32[41028 >> 2] | 0;
  $11 = $9 >>> 0 < $10 >>> 0;
  if ($11) {
   $$161$ph = 0;
  } else {
   _gc_collect();
   $$161$ph = 1;
  }
 }
 $$161 = $$161$ph;
 L8 : while (1) {
  $12 = HEAP32[41032 >> 2] | 0;
  $13 = HEAP32[40748 >> 2] | 0;
  $14 = $12 >>> 0 < $13 >>> 0;
  if ($14) {
   $15 = HEAP32[40744 >> 2] | 0;
   $$06284 = 0;
   $$06483 = $12;
   while (1) {
    $16 = $15 + $$06483 | 0;
    $17 = HEAP8[$16 >> 0] | 0;
    $18 = $17 & 255;
    $19 = $18 & 3;
    $20 = ($19 | 0) == 0;
    if ($20) {
     $21 = $$06284 + 1 | 0;
     $22 = $21 >>> 0 < $3 >>> 0;
     if ($22) {
      $$163 = $21;
     } else {
      label = 10;
      break L8;
     }
    } else {
     $$163 = 0;
    }
    $24 = $18 & 12;
    $25 = ($24 | 0) == 0;
    if ($25) {
     $26 = $$163 + 1 | 0;
     $27 = $26 >>> 0 < $3 >>> 0;
     if ($27) {
      $$2 = $26;
     } else {
      label = 13;
      break L8;
     }
    } else {
     $$2 = 0;
    }
    $30 = $18 & 48;
    $31 = ($30 | 0) == 0;
    if ($31) {
     $32 = $$2 + 1 | 0;
     $33 = $32 >>> 0 < $3 >>> 0;
     if ($33) {
      $$3 = $32;
     } else {
      label = 16;
      break L8;
     }
    } else {
     $$3 = 0;
    }
    $36 = $18 & 192;
    $37 = ($36 | 0) == 0;
    if ($37) {
     $38 = $$3 + 1 | 0;
     $39 = $38 >>> 0 < $3 >>> 0;
     if ($39) {
      $$5 = $38;
     } else {
      label = 22;
      break L8;
     }
    } else {
     $$5 = 0;
    }
    $40 = $$06483 + 1 | 0;
    $41 = $40 >>> 0 < $13 >>> 0;
    if ($41) {
     $$06284 = $$5;
     $$06483 = $40;
    } else {
     break;
    }
   }
  }
  $42 = ($$161 | 0) == 0;
  if (!$42) {
   $$1 = 0;
   label = 29;
   break;
  }
  _gc_collect();
  $$161 = 1;
 }
 if ((label | 0) == 10) {
  $23 = $$06483 << 2;
  $$165$ph = $23;
  $$5$ph = $21;
 } else if ((label | 0) == 13) {
  $28 = $$06483 << 2;
  $29 = $28 | 1;
  $$165$ph = $29;
  $$5$ph = $26;
 } else if ((label | 0) == 16) {
  $34 = $$06483 << 2;
  $35 = $34 | 2;
  $$165$ph = $35;
  $$5$ph = $32;
 } else if ((label | 0) == 22) {
  $43 = $$06483 << 2;
  $44 = $43 | 3;
  $$165$ph = $44;
  $$5$ph = $38;
 } else if ((label | 0) == 29) {
  return $$1 | 0;
 }
 $45 = $$165$ph - $$5$ph | 0;
 $46 = $45 + 1 | 0;
 $47 = ($$5$ph | 0) == 1;
 if ($47) {
  $48 = $$165$ph + 1 | 0;
  $49 = $48 >>> 2;
  HEAP32[41032 >> 2] = $49;
 }
 $50 = $46 << 1;
 $51 = $50 & 6;
 $52 = 1 << $51;
 $53 = $46 >>> 2;
 $54 = $15 + $53 | 0;
 $55 = HEAP8[$54 >> 0] | 0;
 $56 = $55 & 255;
 $57 = $52 | $56;
 $58 = $57 & 255;
 HEAP8[$54 >> 0] = $58;
 $59 = $45 + 2 | 0;
 $60 = $59 >>> 0 > $$165$ph >>> 0;
 if (!$60) {
  $$05882 = $59;
  while (1) {
   $69 = $$05882 << 1;
   $70 = $69 & 6;
   $71 = 2 << $70;
   $72 = HEAP32[40744 >> 2] | 0;
   $73 = $$05882 >>> 2;
   $74 = $72 + $73 | 0;
   $75 = HEAP8[$74 >> 0] | 0;
   $76 = $75 & 255;
   $77 = $71 | $76;
   $78 = $77 & 255;
   HEAP8[$74 >> 0] = $78;
   $79 = $$05882 + 1 | 0;
   $80 = $79 >>> 0 > $$165$ph >>> 0;
   if ($80) {
    break;
   } else {
    $$05882 = $79;
   }
  }
 }
 $61 = HEAP32[40752 >> 2] | 0;
 $62 = $46 << 4;
 $63 = $61 + $62 | 0;
 $64 = HEAP32[41024 >> 2] | 0;
 $65 = $64 + $3 | 0;
 HEAP32[41024 >> 2] = $65;
 $66 = $$165$ph - $46 | 0;
 $67 = $66 << 4;
 $68 = $67 + 16 | 0;
 _memset($63 | 0, 0, $68 | 0) | 0;
 $$1 = $63;
 return $$1 | 0;
}

function _compile_if_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $6 = sp + 16 | 0;
 $2 = $0;
 $3 = $1;
 $11 = $2;
 $12 = _comp_next_label($11) | 0;
 $4 = $12;
 $13 = $3;
 $14 = $13 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = _mp_parse_node_is_const_false($15) | 0;
 if (!$16) {
  $17 = $2;
  $18 = _comp_next_label($17) | 0;
  $5 = $18;
  $19 = $2;
  $20 = $3;
  $21 = $20 + 8 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $5;
  _c_if_cond($19, $22, 0, $23);
  $24 = $2;
  $25 = $3;
  $26 = $25 + 8 | 0;
  $27 = $26 + 4 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  _compile_node($24, $28);
  $29 = $3;
  $30 = $29 + 8 | 0;
  $31 = HEAP32[$30 >> 2] | 0;
  $32 = _mp_parse_node_is_const_true($31) | 0;
  if ($32) {
   $106 = $2;
   $107 = $106 + 40 | 0;
   $108 = HEAP32[$107 >> 2] | 0;
   $109 = $4;
   _mp_emit_bc_label_assign($108, $109);
   STACKTOP = sp;
   return;
  }
  $33 = $3;
  $34 = $33 + 8 | 0;
  $35 = $34 + 8 | 0;
  $36 = HEAP32[$35 >> 2] | 0;
  $37 = ($36 | 0) == 0;
  if ($37) {
   $38 = $3;
   $39 = $38 + 8 | 0;
   $40 = $39 + 12 | 0;
   $41 = HEAP32[$40 >> 2] | 0;
   $42 = ($41 | 0) == 0;
   if (!$42) {
    label = 5;
   }
  } else {
   label = 5;
  }
  if ((label | 0) == 5) {
   $43 = $2;
   $44 = $43 + 40 | 0;
   $45 = HEAP32[$44 >> 2] | 0;
   $46 = _mp_emit_bc_last_emit_was_return_value($45) | 0;
   if (!$46) {
    $47 = $2;
    $48 = $47 + 40 | 0;
    $49 = HEAP32[$48 >> 2] | 0;
    $50 = $4;
    _mp_emit_bc_jump($49, $50);
   }
  }
  $51 = $2;
  $52 = $51 + 40 | 0;
  $53 = HEAP32[$52 >> 2] | 0;
  $54 = $5;
  _mp_emit_bc_label_assign($53, $54);
 }
 $55 = $3;
 $56 = $55 + 8 | 0;
 $57 = $56 + 8 | 0;
 $58 = _mp_parse_node_extract_list($57, 112, $6) | 0;
 $7 = $58;
 $8 = 0;
 while (1) {
  $59 = $8;
  $60 = $7;
  $61 = ($59 | 0) < ($60 | 0);
  if (!$61) {
   break;
  }
  $62 = HEAP32[$6 >> 2] | 0;
  $63 = $8;
  $64 = $62 + ($63 << 2) | 0;
  $65 = HEAP32[$64 >> 2] | 0;
  $66 = $65;
  $9 = $66;
  $67 = $9;
  $68 = $67 + 8 | 0;
  $69 = HEAP32[$68 >> 2] | 0;
  $70 = _mp_parse_node_is_const_false($69) | 0;
  if (!$70) {
   $71 = $2;
   $72 = _comp_next_label($71) | 0;
   $10 = $72;
   $73 = $2;
   $74 = $9;
   $75 = $74 + 8 | 0;
   $76 = HEAP32[$75 >> 2] | 0;
   $77 = $10;
   _c_if_cond($73, $76, 0, $77);
   $78 = $2;
   $79 = $9;
   $80 = $79 + 8 | 0;
   $81 = $80 + 4 | 0;
   $82 = HEAP32[$81 >> 2] | 0;
   _compile_node($78, $82);
   $83 = $9;
   $84 = $83 + 8 | 0;
   $85 = HEAP32[$84 >> 2] | 0;
   $86 = _mp_parse_node_is_const_true($85) | 0;
   if ($86) {
    label = 17;
    break;
   }
   $87 = $2;
   $88 = $87 + 40 | 0;
   $89 = HEAP32[$88 >> 2] | 0;
   $90 = _mp_emit_bc_last_emit_was_return_value($89) | 0;
   if (!$90) {
    $91 = $2;
    $92 = $91 + 40 | 0;
    $93 = HEAP32[$92 >> 2] | 0;
    $94 = $4;
    _mp_emit_bc_jump($93, $94);
   }
   $95 = $2;
   $96 = $95 + 40 | 0;
   $97 = HEAP32[$96 >> 2] | 0;
   $98 = $10;
   _mp_emit_bc_label_assign($97, $98);
  }
  $99 = $8;
  $100 = $99 + 1 | 0;
  $8 = $100;
 }
 if ((label | 0) == 17) {
  $106 = $2;
  $107 = $106 + 40 | 0;
  $108 = HEAP32[$107 >> 2] | 0;
  $109 = $4;
  _mp_emit_bc_label_assign($108, $109);
  STACKTOP = sp;
  return;
 }
 $101 = $2;
 $102 = $3;
 $103 = $102 + 8 | 0;
 $104 = $103 + 12 | 0;
 $105 = HEAP32[$104 >> 2] | 0;
 _compile_node($101, $105);
 $106 = $2;
 $107 = $106 + 40 | 0;
 $108 = HEAP32[$107 >> 2] | 0;
 $109 = $4;
 _mp_emit_bc_label_assign($108, $109);
 STACKTOP = sp;
 return;
}

function _set_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $7 = sp + 8 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $11 = $5;
 HEAP32[$7 >> 2] = $11;
 $12 = $7 + 4 | 0;
 $13 = $6;
 HEAP32[$12 >> 2] = $13;
 $14 = $5;
 $15 = _mp_obj_is_obj_1105($14) | 0;
 if ($15) {
  $16 = $5;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = ($17 | 0) == (17860 | 0);
  $20 = $18;
 } else {
  $20 = 0;
 }
 $19 = $20 & 1;
 $8 = $19;
 $21 = $4;
 $22 = ($21 | 0) != 34;
 if ($22) {
  $23 = $6;
  $24 = _is_set_or_frozenset($23) | 0;
  if ($24) {
   label = 6;
  } else {
   $3 = 0;
  }
 } else {
  label = 6;
 }
 L7 : do {
  if ((label | 0) == 6) {
   $25 = $4;
   do {
    switch ($25 | 0) {
    case 21:
     {
      $26 = $5;
      $27 = $6;
      $28 = _set_union($26, $27) | 0;
      $3 = $28;
      break L7;
      break;
     }
    case 22:
     {
      $29 = $5;
      $30 = $6;
      $31 = _set_symmetric_difference($29, $30) | 0;
      $3 = $31;
      break L7;
      break;
     }
    case 23:
     {
      $32 = $5;
      $33 = $6;
      $34 = _set_intersect($32, $33) | 0;
      $3 = $34;
      break L7;
      break;
     }
    case 27:
     {
      $35 = _set_diff(2, $7) | 0;
      $3 = $35;
      break L7;
      break;
     }
    case 9:
     {
      $36 = $8;
      $37 = $36 & 1;
      if ($37) {
       _set_update(2, $7) | 0;
       $38 = $5;
       $3 = $38;
       break L7;
      } else {
       $39 = $5;
       $40 = $6;
       $41 = _set_union($39, $40) | 0;
       $3 = $41;
       break L7;
      }
      break;
     }
    case 10:
     {
      $42 = $8;
      $43 = $42 & 1;
      $44 = $5;
      $45 = $6;
      if ($43) {
       _set_symmetric_difference_update($44, $45) | 0;
       $46 = $5;
       $3 = $46;
       break L7;
      } else {
       $47 = _set_symmetric_difference($44, $45) | 0;
       $3 = $47;
       break L7;
      }
      break;
     }
    case 11:
     {
      $48 = $5;
      $49 = $6;
      $50 = $8;
      $51 = $50 & 1;
      $52 = _set_intersect_int($48, $49, $51) | 0;
      $6 = $52;
      $53 = $8;
      $54 = $53 & 1;
      if ($54) {
       $55 = $5;
       $3 = $55;
       break L7;
      } else {
       $56 = $6;
       $3 = $56;
       break L7;
      }
      break;
     }
    case 15:
     {
      $57 = $8;
      $58 = $57 & 1;
      $59 = _set_diff_int(2, $7, $58) | 0;
      $3 = $59;
      break L7;
      break;
     }
    case 0:
     {
      $60 = $5;
      $61 = $6;
      $62 = _set_issubset_proper($60, $61) | 0;
      $3 = $62;
      break L7;
      break;
     }
    case 1:
     {
      $63 = $5;
      $64 = $6;
      $65 = _set_issuperset_proper($63, $64) | 0;
      $3 = $65;
      break L7;
      break;
     }
    case 2:
     {
      $66 = $5;
      $67 = $6;
      $68 = _set_equal($66, $67) | 0;
      $3 = $68;
      break L7;
      break;
     }
    case 3:
     {
      $69 = $5;
      $70 = $6;
      $71 = _set_issubset($69, $70) | 0;
      $3 = $71;
      break L7;
      break;
     }
    case 4:
     {
      $72 = $5;
      $73 = $6;
      $74 = _set_issuperset($72, $73) | 0;
      $3 = $74;
      break L7;
      break;
     }
    case 34:
     {
      $75 = $5;
      $9 = $75;
      $76 = $9;
      $77 = $76 + 4 | 0;
      $78 = $6;
      $79 = _mp_set_lookup($77, $78, 0) | 0;
      $10 = $79;
      $80 = $10;
      $81 = ($80 | 0) != (0 | 0);
      $82 = $81 & 1;
      $83 = _mp_obj_new_bool_1106($82) | 0;
      $3 = $83;
      break L7;
      break;
     }
    default:
     {
      $3 = 0;
      break L7;
     }
    }
   } while (0);
  }
 } while (0);
 $84 = $3;
 STACKTOP = sp;
 return $84 | 0;
}

function _str_uni_strip($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $11 = sp + 32 | 0;
 $13 = sp + 24 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $21 = $6;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = _mp_obj_get_type($22) | 0;
 $7 = $23;
 $24 = $5;
 $25 = ($24 | 0) == 1;
 if ($25) {
  $8 = 32345;
  $9 = 6;
 } else {
  $26 = $6;
  $27 = $26 + 4 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = _mp_obj_get_type($28) | 0;
  $30 = $7;
  $31 = ($29 | 0) != ($30 | 0);
  $32 = $6;
  $33 = $32 + 4 | 0;
  $34 = HEAP32[$33 >> 2] | 0;
  if ($31) {
   _bad_implicit_conversion($34);
  }
  $35 = _mp_obj_is_qstr_1128($34) | 0;
  $36 = $6;
  $37 = $36 + 4 | 0;
  $38 = HEAP32[$37 >> 2] | 0;
  if ($35) {
   $39 = $38;
   $40 = $39 >>> 2;
   $41 = _qstr_data($40, $11) | 0;
   $10 = $41;
  } else {
   $42 = $38 + 8 | 0;
   $43 = HEAP32[$42 >> 2] | 0;
   HEAP32[$11 >> 2] = $43;
   $44 = $6;
   $45 = $44 + 4 | 0;
   $46 = HEAP32[$45 >> 2] | 0;
   $47 = $46 + 12 | 0;
   $48 = HEAP32[$47 >> 2] | 0;
   $10 = $48;
  }
  $49 = $10;
  $8 = $49;
  $50 = HEAP32[$11 >> 2] | 0;
  $9 = $50;
 }
 $51 = $6;
 $52 = HEAP32[$51 >> 2] | 0;
 $53 = _mp_obj_is_qstr_1128($52) | 0;
 $54 = $6;
 $55 = HEAP32[$54 >> 2] | 0;
 if ($53) {
  $56 = $55;
  $57 = $56 >>> 2;
  $58 = _qstr_data($57, $13) | 0;
  $12 = $58;
 } else {
  $59 = $55 + 8 | 0;
  $60 = HEAP32[$59 >> 2] | 0;
  HEAP32[$13 >> 2] = $60;
  $61 = $6;
  $62 = HEAP32[$61 >> 2] | 0;
  $63 = $62 + 12 | 0;
  $64 = HEAP32[$63 >> 2] | 0;
  $12 = $64;
 }
 $14 = 0;
 $15 = 0;
 $16 = 0;
 $17 = 0;
 $18 = 1;
 $65 = $4;
 $66 = ($65 | 0) == 1;
 if ($66) {
  $67 = HEAP32[$13 >> 2] | 0;
  $68 = $67 - 1 | 0;
  $17 = $68;
  $18 = -1;
 }
 $69 = HEAP32[$13 >> 2] | 0;
 $19 = $69;
 while (1) {
  $70 = $19;
  $71 = $70 >>> 0 > 0;
  if (!$71) {
   break;
  }
  $72 = $8;
  $73 = $9;
  $74 = $12;
  $75 = $17;
  $76 = $74 + $75 | 0;
  $77 = _find_subbytes($72, $73, $76, 1, 1) | 0;
  $78 = ($77 | 0) == (0 | 0);
  if ($78) {
   $79 = $15;
   $80 = $79 & 1;
   if (!$80) {
    $15 = 1;
    $81 = $17;
    $14 = $81;
    $82 = $4;
    $83 = ($82 | 0) == 0;
    if ($83) {
     label = 19;
     break;
    }
    $86 = $4;
    $87 = ($86 | 0) == 1;
    if ($87) {
     label = 21;
     break;
    }
   }
   $89 = $17;
   $16 = $89;
  }
  $90 = $18;
  $91 = $17;
  $92 = $91 + $90 | 0;
  $17 = $92;
  $93 = $19;
  $94 = $93 + -1 | 0;
  $19 = $94;
 }
 if ((label | 0) == 19) {
  $84 = HEAP32[$13 >> 2] | 0;
  $85 = $84 - 1 | 0;
  $16 = $85;
 } else if ((label | 0) == 21) {
  $14 = 0;
  $88 = $17;
  $16 = $88;
 }
 $95 = $15;
 $96 = $95 & 1;
 if ($96) {
  $99 = $16;
  $100 = $14;
  $101 = $99 - $100 | 0;
  $102 = $101 + 1 | 0;
  $20 = $102;
  $103 = $20;
  $104 = HEAP32[$13 >> 2] | 0;
  $105 = ($103 | 0) == ($104 | 0);
  if ($105) {
   $106 = $6;
   $107 = HEAP32[$106 >> 2] | 0;
   $3 = $107;
   $114 = $3;
   STACKTOP = sp;
   return $114 | 0;
  } else {
   $108 = $7;
   $109 = $12;
   $110 = $14;
   $111 = $109 + $110 | 0;
   $112 = $20;
   $113 = _mp_obj_new_str_of_type($108, $111, $112) | 0;
   $3 = $113;
   $114 = $3;
   STACKTOP = sp;
   return $114 | 0;
  }
 } else {
  $97 = $7;
  $98 = ($97 | 0) == (18680 | 0);
  if ($98) {
   $3 = 6;
   $114 = $3;
   STACKTOP = sp;
   return $114 | 0;
  } else {
   $3 = 18288;
   $114 = $3;
   STACKTOP = sp;
   return $114 | 0;
  }
 }
 return 0 | 0;
}

function _str_finder($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $122 = 0, $123 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $11 = sp + 20 | 0;
 $13 = sp + 12 | 0;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $17 = $3 & 1;
 $8 = $17;
 $18 = $6;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = _mp_obj_get_type($19) | 0;
 $9 = $20;
 $21 = $6;
 $22 = $21 + 4 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = _mp_obj_get_type($23) | 0;
 $25 = $9;
 $26 = ($24 | 0) != ($25 | 0);
 $27 = $6;
 if ($26) {
  $28 = $27 + 4 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  _bad_implicit_conversion($29);
 }
 $30 = HEAP32[$27 >> 2] | 0;
 $31 = _mp_obj_is_qstr_1128($30) | 0;
 $32 = $6;
 $33 = HEAP32[$32 >> 2] | 0;
 if ($31) {
  $34 = $33;
  $35 = $34 >>> 2;
  $36 = _qstr_data($35, $11) | 0;
  $10 = $36;
 } else {
  $37 = $33 + 8 | 0;
  $38 = HEAP32[$37 >> 2] | 0;
  HEAP32[$11 >> 2] = $38;
  $39 = $6;
  $40 = HEAP32[$39 >> 2] | 0;
  $41 = $40 + 12 | 0;
  $42 = HEAP32[$41 >> 2] | 0;
  $10 = $42;
 }
 $43 = $6;
 $44 = $43 + 4 | 0;
 $45 = HEAP32[$44 >> 2] | 0;
 $46 = _mp_obj_is_qstr_1128($45) | 0;
 $47 = $6;
 $48 = $47 + 4 | 0;
 $49 = HEAP32[$48 >> 2] | 0;
 if ($46) {
  $50 = $49;
  $51 = $50 >>> 2;
  $52 = _qstr_data($51, $13) | 0;
  $12 = $52;
 } else {
  $53 = $49 + 8 | 0;
  $54 = HEAP32[$53 >> 2] | 0;
  HEAP32[$13 >> 2] = $54;
  $55 = $6;
  $56 = $55 + 4 | 0;
  $57 = HEAP32[$56 >> 2] | 0;
  $58 = $57 + 12 | 0;
  $59 = HEAP32[$58 >> 2] | 0;
  $12 = $59;
 }
 $60 = $10;
 $14 = $60;
 $61 = $10;
 $62 = HEAP32[$11 >> 2] | 0;
 $63 = $61 + $62 | 0;
 $15 = $63;
 $64 = $5;
 $65 = $64 >>> 0 >= 3;
 if ($65) {
  $66 = $6;
  $67 = $66 + 8 | 0;
  $68 = HEAP32[$67 >> 2] | 0;
  $69 = ($68 | 0) != (17668 | 0);
  if ($69) {
   $70 = $9;
   $71 = $10;
   $72 = HEAP32[$11 >> 2] | 0;
   $73 = $6;
   $74 = $73 + 8 | 0;
   $75 = HEAP32[$74 >> 2] | 0;
   $76 = _str_index_to_ptr($70, $71, $72, $75, 1) | 0;
   $14 = $76;
  }
 }
 $77 = $5;
 $78 = $77 >>> 0 >= 4;
 if ($78) {
  $79 = $6;
  $80 = $79 + 12 | 0;
  $81 = HEAP32[$80 >> 2] | 0;
  $82 = ($81 | 0) != (17668 | 0);
  if ($82) {
   $83 = $9;
   $84 = $10;
   $85 = HEAP32[$11 >> 2] | 0;
   $86 = $6;
   $87 = $86 + 12 | 0;
   $88 = HEAP32[$87 >> 2] | 0;
   $89 = _str_index_to_ptr($83, $84, $85, $88, 1) | 0;
   $15 = $89;
  }
 }
 $90 = $15;
 $91 = $14;
 $92 = $90 >>> 0 < $91 >>> 0;
 if (!$92) {
  $93 = $14;
  $94 = $15;
  $95 = $14;
  $96 = $94;
  $97 = $95;
  $98 = $96 - $97 | 0;
  $99 = $12;
  $100 = HEAP32[$13 >> 2] | 0;
  $101 = $7;
  $102 = _find_subbytes($93, $98, $99, $100, $101) | 0;
  $16 = $102;
  $103 = $16;
  $104 = ($103 | 0) == (0 | 0);
  if (!$104) {
   $107 = $9;
   $108 = ($107 | 0) == (18680 | 0);
   if ($108) {
    $109 = $10;
    $110 = $16;
    $111 = _utf8_ptr_to_index($109, $110) | 0;
    $112 = $111 << 1;
    $113 = $112 | 1;
    $114 = $113;
    $4 = $114;
    $123 = $4;
    STACKTOP = sp;
    return $123 | 0;
   } else {
    $115 = $16;
    $116 = $10;
    $117 = $115;
    $118 = $116;
    $119 = $117 - $118 | 0;
    $120 = $119 << 1;
    $121 = $120 | 1;
    $122 = $121;
    $4 = $122;
    $123 = $4;
    STACKTOP = sp;
    return $123 | 0;
   }
  }
 }
 $105 = $8;
 $106 = $105 & 1;
 if ($106) {
  _mp_raise_ValueError(32454);
 }
 $4 = -1;
 $123 = $4;
 STACKTOP = sp;
 return $123 | 0;
}

function _mp_obj_equal($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val11 = 0, $$expand_i1_val13 = 0, $$expand_i1_val3 = 0, $$expand_i1_val5 = 0, $$expand_i1_val7 = 0, $$expand_i1_val9 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 20 | 0;
 $3 = $0;
 $4 = $1;
 $8 = $3;
 $9 = $4;
 $10 = ($8 | 0) == ($9 | 0);
 do {
  if ($10) {
   $11 = $3;
   $12 = _mp_obj_is_obj_786($11) | 0;
   if ($12) {
    $13 = $3;
    $14 = HEAP32[$13 >> 2] | 0;
    $15 = ($14 | 0) == (16252 | 0);
    if ($15) {
     label = 7;
     break;
    }
   }
   $16 = $3;
   $17 = _mp_obj_is_obj_786($16) | 0;
   if ($17) {
    $18 = $3;
    $19 = HEAP32[$18 >> 2] | 0;
    $20 = ($19 | 0) == (14052 | 0);
    if ($20) {
     label = 7;
     break;
    }
   }
   $$expand_i1_val = 1;
   HEAP8[$2 >> 0] = $$expand_i1_val;
  } else {
   label = 7;
  }
 } while (0);
 L9 : do {
  if ((label | 0) == 7) {
   $21 = $3;
   $22 = ($21 | 0) == (17668 | 0);
   $23 = $4;
   $24 = ($23 | 0) == (17668 | 0);
   $or$cond = $22 | $24;
   if ($or$cond) {
    $$expand_i1_val3 = 0;
    HEAP8[$2 >> 0] = $$expand_i1_val3;
    break;
   }
   $25 = $3;
   $26 = _mp_obj_is_small_int_784($25) | 0;
   do {
    if ($26) {
     $27 = $4;
     $28 = _mp_obj_is_small_int_784($27) | 0;
     if ($28) {
      $$expand_i1_val5 = 0;
      HEAP8[$2 >> 0] = $$expand_i1_val5;
      break L9;
     } else {
      $29 = $4;
      $5 = $29;
      $30 = $3;
      $4 = $30;
      $31 = $5;
      $3 = $31;
      break;
     }
    }
   } while (0);
   $32 = $3;
   $33 = _mp_obj_is_qstr_785($32) | 0;
   do {
    if ($33) {
     label = 16;
    } else {
     $34 = $3;
     $35 = _mp_obj_is_obj_786($34) | 0;
     if ($35) {
      $36 = $3;
      $37 = HEAP32[$36 >> 2] | 0;
      $38 = ($37 | 0) == (18680 | 0);
      if ($38) {
       label = 16;
       break;
      }
     }
     $49 = $4;
     $50 = _mp_obj_is_qstr_785($49) | 0;
     if (!$50) {
      $51 = $4;
      $52 = _mp_obj_is_obj_786($51) | 0;
      if ($52) {
       $53 = $4;
       $54 = HEAP32[$53 >> 2] | 0;
       $55 = ($54 | 0) == (18680 | 0);
       if ($55) {
        break;
       }
      }
      $56 = $3;
      $57 = _mp_obj_get_type($56) | 0;
      $6 = $57;
      $58 = $6;
      $59 = $58 + 24 | 0;
      $60 = HEAP32[$59 >> 2] | 0;
      $61 = ($60 | 0) != (0 | 0);
      if ($61) {
       $62 = $6;
       $63 = $62 + 24 | 0;
       $64 = HEAP32[$63 >> 2] | 0;
       $65 = $3;
       $66 = $4;
       $67 = FUNCTION_TABLE_iiii[$64 & 1023](2, $65, $66) | 0;
       $7 = $67;
       $68 = $7;
       $69 = ($68 | 0) != (0 | 0);
       if ($69) {
        $70 = $7;
        $71 = ($70 | 0) == (13864 | 0);
        $72 = $71 ? 1 : 0;
        $73 = ($72 | 0) != 0;
        $$expand_i1_val11 = $73 & 1;
        HEAP8[$2 >> 0] = $$expand_i1_val11;
        break L9;
       }
      }
      $$expand_i1_val13 = 0;
      HEAP8[$2 >> 0] = $$expand_i1_val13;
      break L9;
     }
    }
   } while (0);
   do {
    if ((label | 0) == 16) {
     $39 = $4;
     $40 = _mp_obj_is_qstr_785($39) | 0;
     if (!$40) {
      $41 = $4;
      $42 = _mp_obj_is_obj_786($41) | 0;
      if (!$42) {
       break;
      }
      $43 = $4;
      $44 = HEAP32[$43 >> 2] | 0;
      $45 = ($44 | 0) == (18680 | 0);
      if (!$45) {
       break;
      }
     }
     $46 = $3;
     $47 = $4;
     $48 = _mp_obj_str_equal($46, $47) | 0;
     $$expand_i1_val7 = $48 & 1;
     HEAP8[$2 >> 0] = $$expand_i1_val7;
     break L9;
    }
   } while (0);
   $$expand_i1_val9 = 0;
   HEAP8[$2 >> 0] = $$expand_i1_val9;
  }
 } while (0);
 $$pre_trunc = HEAP8[$2 >> 0] | 0;
 $74 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $74 | 0;
}

function _mp_str_print_quoted($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer10 = 0, $vararg_buffer4 = 0, $vararg_buffer7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $vararg_buffer10 = sp + 32 | 0;
 $vararg_buffer7 = sp + 24 | 0;
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $15 = $3 & 1;
 $7 = $15;
 $8 = 0;
 $9 = 0;
 $16 = $5;
 $10 = $16;
 $17 = $5;
 $18 = $6;
 $19 = $17 + $18 | 0;
 $11 = $19;
 while (1) {
  $20 = $9;
  $21 = $20 & 1;
  if ($21) {
   break;
  }
  $22 = $10;
  $23 = $11;
  $24 = $22 >>> 0 < $23 >>> 0;
  if (!$24) {
   break;
  }
  $25 = $10;
  $26 = HEAP8[$25 >> 0] | 0;
  $27 = $26 & 255;
  $28 = ($27 | 0) == 39;
  if ($28) {
   $8 = 1;
  } else {
   $29 = $10;
   $30 = HEAP8[$29 >> 0] | 0;
   $31 = $30 & 255;
   $32 = ($31 | 0) == 34;
   if ($32) {
    $9 = 1;
   }
  }
  $33 = $10;
  $34 = $33 + 1 | 0;
  $10 = $34;
 }
 $12 = 39;
 $35 = $8;
 $36 = $35 & 1;
 if ($36) {
  $37 = $9;
  $38 = $37 & 1;
  if (!$38) {
   $12 = 34;
  }
 }
 $39 = $4;
 $40 = $12;
 HEAP32[$vararg_buffer >> 2] = $40;
 _mp_printf($39, 32828, $vararg_buffer) | 0;
 $41 = $5;
 $13 = $41;
 $42 = $5;
 $43 = $6;
 $44 = $42 + $43 | 0;
 $14 = $44;
 while (1) {
  $45 = $13;
  $46 = $14;
  $47 = $45 >>> 0 < $46 >>> 0;
  if (!$47) {
   break;
  }
  $48 = $13;
  $49 = HEAP8[$48 >> 0] | 0;
  $50 = $49 & 255;
  $51 = $12;
  $52 = ($50 | 0) == ($51 | 0);
  L18 : do {
   if ($52) {
    $53 = $4;
    $54 = $12;
    HEAP32[$vararg_buffer1 >> 2] = $54;
    _mp_printf($53, 32831, $vararg_buffer1) | 0;
   } else {
    $55 = $13;
    $56 = HEAP8[$55 >> 0] | 0;
    $57 = $56 & 255;
    $58 = ($57 | 0) == 92;
    if ($58) {
     $59 = $4;
     _mp_print_str($59, 32835) | 0;
     break;
    }
    $60 = $13;
    $61 = HEAP8[$60 >> 0] | 0;
    $62 = $61 & 255;
    $63 = ($62 | 0) >= 32;
    do {
     if ($63) {
      $64 = $13;
      $65 = HEAP8[$64 >> 0] | 0;
      $66 = $65 & 255;
      $67 = ($66 | 0) != 127;
      if ($67) {
       $68 = $7;
       $69 = $68 & 1;
       if ($69) {
        $70 = $13;
        $71 = HEAP8[$70 >> 0] | 0;
        $72 = $71 & 255;
        $73 = ($72 | 0) < 128;
        if (!$73) {
         break;
        }
       }
       $74 = $4;
       $75 = $13;
       $76 = HEAP8[$75 >> 0] | 0;
       $77 = $76 & 255;
       HEAP32[$vararg_buffer4 >> 2] = $77;
       _mp_printf($74, 32828, $vararg_buffer4) | 0;
       break L18;
      }
     }
    } while (0);
    $78 = $13;
    $79 = HEAP8[$78 >> 0] | 0;
    $80 = $79 & 255;
    $81 = ($80 | 0) == 10;
    if ($81) {
     $82 = $4;
     _mp_print_str($82, 32838) | 0;
     break;
    }
    $83 = $13;
    $84 = HEAP8[$83 >> 0] | 0;
    $85 = $84 & 255;
    $86 = ($85 | 0) == 13;
    if ($86) {
     $87 = $4;
     _mp_print_str($87, 32841) | 0;
     break;
    }
    $88 = $13;
    $89 = HEAP8[$88 >> 0] | 0;
    $90 = $89 & 255;
    $91 = ($90 | 0) == 9;
    $92 = $4;
    if ($91) {
     _mp_print_str($92, 32844) | 0;
     break;
    } else {
     $93 = $13;
     $94 = HEAP8[$93 >> 0] | 0;
     $95 = $94 & 255;
     HEAP32[$vararg_buffer7 >> 2] = $95;
     _mp_printf($92, 32847, $vararg_buffer7) | 0;
     break;
    }
   }
  } while (0);
  $96 = $13;
  $97 = $96 + 1 | 0;
  $13 = $97;
 }
 $98 = $4;
 $99 = $12;
 HEAP32[$vararg_buffer10 >> 2] = $99;
 _mp_printf($98, 32828, $vararg_buffer10) | 0;
 STACKTOP = sp;
 return;
}

function _pyexec_friendly_repl_process_char($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = sp + 20 | 0;
 $2 = $0;
 $7 = HEAP8[41655] | 0;
 $8 = $7 & 1;
 $9 = $2;
 do {
  if ($8) {
   $10 = ($9 | 0) == 3;
   if ($10) {
    _mp_hal_stdout_tx_str(35325);
    break;
   }
   $11 = $2;
   $12 = ($11 | 0) == 4;
   if ($12) {
    _mp_hal_stdout_tx_str(35325);
    $13 = HEAP32[40720 >> 2] | 0;
    $14 = _parse_compile_execute($13, 1, 22) | 0;
    $3 = $14;
    $15 = $3;
    $16 = $15 & 256;
    $17 = ($16 | 0) != 0;
    if (!$17) {
     break;
    }
    $18 = $3;
    $1 = $18;
    $64 = $1;
    STACKTOP = sp;
    return $64 | 0;
   }
   $19 = HEAP32[40720 >> 2] | 0;
   $20 = $2;
   $21 = $20 & 255;
   _vstr_add_byte($19, $21);
   $22 = $2;
   $23 = ($22 | 0) == 13;
   if ($23) {
    _mp_hal_stdout_tx_str(35022);
   } else {
    $24 = $2;
    $25 = $24 & 255;
    HEAP8[$4 >> 0] = $25;
    _mp_hal_stdout_tx_strn($4, 1);
   }
   $1 = 0;
   $64 = $1;
   STACKTOP = sp;
   return $64 | 0;
  } else {
   $26 = _readline_process_char($9) | 0;
   $5 = $26;
   $27 = HEAP8[41654] | 0;
   $28 = $27 & 1;
   $29 = $5;
   if ($28) {
    $47 = ($29 | 0) == 3;
    if ($47) {
     _mp_hal_stdout_tx_str(35325);
     HEAP8[41654] = 0;
     break;
    }
    $48 = $5;
    $49 = ($48 | 0) == 4;
    if (!$49) {
     $50 = $5;
     $51 = ($50 | 0) < 0;
     if ($51) {
      $1 = 0;
      $64 = $1;
      STACKTOP = sp;
      return $64 | 0;
     }
     $52 = HEAP32[40720 >> 2] | 0;
     $53 = _vstr_null_terminated_str($52) | 0;
     $54 = _mp_repl_continue_with_input($53) | 0;
     if ($54) {
      $55 = HEAP32[40720 >> 2] | 0;
      _vstr_add_byte($55, 10);
      _readline_note_newline(35197);
      $1 = 0;
      $64 = $1;
      STACKTOP = sp;
      return $64 | 0;
     }
    }
   } else {
    $30 = ($29 | 0) == 1;
    if ($30) {
     HEAP32[5566] = 0;
     _mp_hal_stdout_tx_str(35325);
     _pyexec_raw_repl_process_char(1) | 0;
     $1 = 0;
     $64 = $1;
     STACKTOP = sp;
     return $64 | 0;
    }
    $31 = $5;
    $32 = ($31 | 0) == 2;
    if ($32) {
     _mp_hal_stdout_tx_str(35325);
     _mp_hal_stdout_tx_str(35029);
     _mp_hal_stdout_tx_str(35104);
     break;
    }
    $33 = $5;
    $34 = ($33 | 0) == 3;
    if ($34) {
     _mp_hal_stdout_tx_str(35325);
     break;
    }
    $35 = $5;
    $36 = ($35 | 0) == 4;
    if ($36) {
     _mp_hal_stdout_tx_str(35325);
     $37 = HEAP32[40720 >> 2] | 0;
     _vstr_clear($37);
     $1 = 256;
     $64 = $1;
     STACKTOP = sp;
     return $64 | 0;
    }
    $38 = $5;
    $39 = ($38 | 0) == 5;
    if ($39) {
     _mp_hal_stdout_tx_str(35142);
     $40 = HEAP32[40720 >> 2] | 0;
     _vstr_reset_1555($40);
     HEAP8[41655] = 1;
     $1 = 0;
     $64 = $1;
     STACKTOP = sp;
     return $64 | 0;
    }
    $41 = $5;
    $42 = ($41 | 0) < 0;
    if ($42) {
     $1 = 0;
     $64 = $1;
     STACKTOP = sp;
     return $64 | 0;
    }
    $43 = HEAP32[40720 >> 2] | 0;
    $44 = _vstr_null_terminated_str($43) | 0;
    $45 = _mp_repl_continue_with_input($44) | 0;
    if ($45) {
     $46 = HEAP32[40720 >> 2] | 0;
     _vstr_add_byte($46, 10);
     HEAP8[41654] = 1;
     _readline_note_newline(35197);
     $1 = 0;
     $64 = $1;
     STACKTOP = sp;
     return $64 | 0;
    }
   }
   $56 = HEAP32[40720 >> 2] | 0;
   $57 = _parse_compile_execute($56, 0, 22) | 0;
   $6 = $57;
   $58 = $6;
   $59 = $58 & 256;
   $60 = ($59 | 0) != 0;
   if ($60) {
    $61 = $6;
    $1 = $61;
    $64 = $1;
    STACKTOP = sp;
    return $64 | 0;
   }
  }
 } while (0);
 $62 = HEAP32[40720 >> 2] | 0;
 _vstr_reset_1555($62);
 HEAP8[41654] = 0;
 HEAP8[41655] = 0;
 $63 = HEAP32[40720 >> 2] | 0;
 _readline_init($63, 35202);
 $1 = 0;
 $64 = $1;
 STACKTOP = sp;
 return $64 | 0;
}

function _dict_update($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $7 = sp + 32 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $16 = $4;
 $17 = HEAP32[$16 >> 2] | 0;
 $6 = $17;
 $18 = $6;
 _mp_ensure_not_fixed($18);
 $19 = $3;
 $20 = $5;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $21 >>> 3;
 _mp_arg_check_num_882($19, $22, 1, 2, 1);
 $23 = $3;
 $24 = ($23 | 0) == 2;
 L1 : do {
  if ($24) {
   $25 = $4;
   $26 = $25 + 4 | 0;
   $27 = HEAP32[$26 >> 2] | 0;
   $28 = _mp_obj_is_obj_883($27) | 0;
   if ($28) {
    $29 = $4;
    $30 = $29 + 4 | 0;
    $31 = HEAP32[$30 >> 2] | 0;
    $32 = HEAP32[$31 >> 2] | 0;
    $33 = $32 + 12 | 0;
    $34 = HEAP32[$33 >> 2] | 0;
    $35 = ($34 | 0) == (85 | 0);
    if ($35) {
     $36 = $4;
     $37 = $36 + 4 | 0;
     $38 = HEAP32[$37 >> 2] | 0;
     $39 = $4;
     $40 = HEAP32[$39 >> 2] | 0;
     $41 = ($38 | 0) != ($40 | 0);
     if (!$41) {
      break;
     }
     HEAP32[$7 >> 2] = 0;
     $8 = 0;
     while (1) {
      $42 = $4;
      $43 = $42 + 4 | 0;
      $44 = HEAP32[$43 >> 2] | 0;
      $45 = _dict_iter_next($44, $7) | 0;
      $8 = $45;
      $46 = ($45 | 0) != (0 | 0);
      if (!$46) {
       break L1;
      }
      $47 = $8;
      $48 = $47 + 4 | 0;
      $49 = HEAP32[$48 >> 2] | 0;
      $50 = $6;
      $51 = $50 + 4 | 0;
      $52 = $8;
      $53 = HEAP32[$52 >> 2] | 0;
      $54 = _mp_map_lookup($51, $53, 1) | 0;
      $55 = $54 + 4 | 0;
      HEAP32[$55 >> 2] = $49;
     }
    }
   }
   $56 = $4;
   $57 = $56 + 4 | 0;
   $58 = HEAP32[$57 >> 2] | 0;
   $59 = _mp_getiter($58, 0) | 0;
   $9 = $59;
   $10 = 0;
   while (1) {
    $60 = $9;
    $61 = _mp_iternext($60) | 0;
    $10 = $61;
    $62 = ($61 | 0) != (0 | 0);
    if (!$62) {
     break L1;
    }
    $63 = $10;
    $64 = _mp_getiter($63, 0) | 0;
    $11 = $64;
    $65 = $11;
    $66 = _mp_iternext($65) | 0;
    $12 = $66;
    $67 = $11;
    $68 = _mp_iternext($67) | 0;
    $13 = $68;
    $69 = $11;
    $70 = _mp_iternext($69) | 0;
    $14 = $70;
    $71 = $12;
    $72 = ($71 | 0) == (0 | 0);
    $73 = $13;
    $74 = ($73 | 0) == (0 | 0);
    $or$cond = $72 | $74;
    $75 = $14;
    $76 = ($75 | 0) != (0 | 0);
    $or$cond3 = $or$cond | $76;
    if ($or$cond3) {
     break;
    }
    $77 = $13;
    $78 = $6;
    $79 = $78 + 4 | 0;
    $80 = $12;
    $81 = _mp_map_lookup($79, $80, 1) | 0;
    $82 = $81 + 4 | 0;
    HEAP32[$82 >> 2] = $77;
   }
   _mp_raise_ValueError(31017);
  }
 } while (0);
 $15 = 0;
 while (1) {
  $83 = $15;
  $84 = $5;
  $85 = $84 + 4 | 0;
  $86 = HEAP32[$85 >> 2] | 0;
  $87 = $83 >>> 0 < $86 >>> 0;
  if (!$87) {
   break;
  }
  $88 = $5;
  $89 = $15;
  $90 = _mp_map_slot_is_filled_875($88, $89) | 0;
  if ($90) {
   $91 = $5;
   $92 = $91 + 8 | 0;
   $93 = HEAP32[$92 >> 2] | 0;
   $94 = $15;
   $95 = $93 + ($94 << 3) | 0;
   $96 = $95 + 4 | 0;
   $97 = HEAP32[$96 >> 2] | 0;
   $98 = $6;
   $99 = $98 + 4 | 0;
   $100 = $5;
   $101 = $100 + 8 | 0;
   $102 = HEAP32[$101 >> 2] | 0;
   $103 = $15;
   $104 = $102 + ($103 << 3) | 0;
   $105 = HEAP32[$104 >> 2] | 0;
   $106 = _mp_map_lookup($99, $105, 1) | 0;
   $107 = $106 + 4 | 0;
   HEAP32[$107 >> 2] = $97;
  }
  $108 = $15;
  $109 = $108 + 1 | 0;
  $15 = $109;
 }
 STACKTOP = sp;
 return 17668 | 0;
}

function _mp_obj_instance_store_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val10 = 0, $$expand_i1_val2 = 0, $$expand_i1_val4 = 0, $$expand_i1_val6 = 0, $$expand_i1_val8 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $3 = sp + 64 | 0;
 $8 = sp + 40 | 0;
 $9 = sp + 20 | 0;
 $11 = sp + 8 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $13 = $4;
 $7 = $13;
 $14 = $7;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $15 + 4 | 0;
 $17 = HEAP16[$16 >> 1] | 0;
 $18 = $17 & 65535;
 $19 = $18 & 2;
 $20 = ($19 | 0) != 0;
 if ($20) {
  HEAP32[$8 >> 2] = 0 | 0;
  HEAP32[$8 + 4 >> 2] = 0 | 0;
  $21 = $7;
  HEAP32[$9 >> 2] = $21;
  $22 = $9 + 4 | 0;
  $23 = $5;
  HEAP32[$22 >> 2] = $23;
  $24 = $9 + 8 | 0;
  HEAP32[$24 >> 2] = 0;
  $25 = $9 + 12 | 0;
  HEAP32[$25 >> 2] = $8;
  $26 = $9 + 16 | 0;
  HEAP8[$26 >> 0] = 0;
  $27 = $7;
  $28 = HEAP32[$27 >> 2] | 0;
  _mp_obj_class_lookup($9, $28);
  $29 = HEAP32[$8 >> 2] | 0;
  $30 = ($29 | 0) != (0 | 0);
  if ($30) {
   $31 = HEAP32[$8 >> 2] | 0;
   $32 = _mp_obj_is_obj_1260($31) | 0;
   if ($32) {
    $33 = HEAP32[$8 >> 2] | 0;
    $34 = HEAP32[$33 >> 2] | 0;
    $35 = ($34 | 0) == (17508 | 0);
    if ($35) {
     $36 = HEAP32[$8 >> 2] | 0;
     $37 = _mp_obj_property_get($36) | 0;
     $10 = $37;
     $38 = $4;
     HEAP32[$11 >> 2] = $38;
     $39 = $11 + 4 | 0;
     $40 = $6;
     HEAP32[$39 >> 2] = $40;
     $41 = $6;
     $42 = ($41 | 0) == (0 | 0);
     $43 = $10;
     if ($42) {
      $44 = $43 + 8 | 0;
      $45 = HEAP32[$44 >> 2] | 0;
      $46 = ($45 | 0) == (17668 | 0);
      if ($46) {
       $$expand_i1_val = 0;
       HEAP8[$3 >> 0] = $$expand_i1_val;
       $$pre_trunc = HEAP8[$3 >> 0] | 0;
       $76 = $$pre_trunc & 1;
       STACKTOP = sp;
       return $76 | 0;
      } else {
       $47 = $10;
       $48 = $47 + 8 | 0;
       $49 = HEAP32[$48 >> 2] | 0;
       _mp_call_function_n_kw($49, 1, 0, $11) | 0;
       $$expand_i1_val2 = 1;
       HEAP8[$3 >> 0] = $$expand_i1_val2;
       $$pre_trunc = HEAP8[$3 >> 0] | 0;
       $76 = $$pre_trunc & 1;
       STACKTOP = sp;
       return $76 | 0;
      }
     } else {
      $50 = $43 + 4 | 0;
      $51 = HEAP32[$50 >> 2] | 0;
      $52 = ($51 | 0) == (17668 | 0);
      if ($52) {
       $$expand_i1_val4 = 0;
       HEAP8[$3 >> 0] = $$expand_i1_val4;
       $$pre_trunc = HEAP8[$3 >> 0] | 0;
       $76 = $$pre_trunc & 1;
       STACKTOP = sp;
       return $76 | 0;
      } else {
       $53 = $10;
       $54 = $53 + 4 | 0;
       $55 = HEAP32[$54 >> 2] | 0;
       _mp_call_function_n_kw($55, 2, 0, $11) | 0;
       $$expand_i1_val6 = 1;
       HEAP8[$3 >> 0] = $$expand_i1_val6;
       $$pre_trunc = HEAP8[$3 >> 0] | 0;
       $76 = $$pre_trunc & 1;
       STACKTOP = sp;
       return $76 | 0;
      }
     }
    }
   }
  }
 }
 $56 = $6;
 $57 = ($56 | 0) == (0 | 0);
 if ($57) {
  $58 = $7;
  $59 = $58 + 4 | 0;
  $60 = $5;
  $61 = $60 << 2;
  $62 = $61 | 2;
  $63 = $62;
  $64 = _mp_map_lookup($59, $63, 2) | 0;
  $12 = $64;
  $65 = $12;
  $66 = ($65 | 0) != (0 | 0);
  $$expand_i1_val8 = $66 & 1;
  HEAP8[$3 >> 0] = $$expand_i1_val8;
  $$pre_trunc = HEAP8[$3 >> 0] | 0;
  $76 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $76 | 0;
 } else {
  $67 = $6;
  $68 = $7;
  $69 = $68 + 4 | 0;
  $70 = $5;
  $71 = $70 << 2;
  $72 = $71 | 2;
  $73 = $72;
  $74 = _mp_map_lookup($69, $73, 1) | 0;
  $75 = $74 + 4 | 0;
  HEAP32[$75 >> 2] = $67;
  $$expand_i1_val10 = 1;
  HEAP8[$3 >> 0] = $$expand_i1_val10;
  $$pre_trunc = HEAP8[$3 >> 0] | 0;
  $76 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $76 | 0;
 }
 return 0 | 0;
}

function _str_count($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $111 = 0, $112 = 0, $113 = 0, $114 = 0, $115 = 0, $116 = 0, $117 = 0, $118 = 0, $119 = 0, $12 = 0, $120 = 0, $121 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $7 = sp + 24 | 0;
 $9 = sp + 16 | 0;
 $3 = $0;
 $4 = $1;
 $14 = $4;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = _mp_obj_get_type($15) | 0;
 $5 = $16;
 $17 = $4;
 $18 = $17 + 4 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = _mp_obj_get_type($19) | 0;
 $21 = $5;
 $22 = ($20 | 0) != ($21 | 0);
 $23 = $4;
 if ($22) {
  $24 = $23 + 4 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  _bad_implicit_conversion($25);
 }
 $26 = HEAP32[$23 >> 2] | 0;
 $27 = _mp_obj_is_qstr_1128($26) | 0;
 $28 = $4;
 $29 = HEAP32[$28 >> 2] | 0;
 if ($27) {
  $30 = $29;
  $31 = $30 >>> 2;
  $32 = _qstr_data($31, $7) | 0;
  $6 = $32;
 } else {
  $33 = $29 + 8 | 0;
  $34 = HEAP32[$33 >> 2] | 0;
  HEAP32[$7 >> 2] = $34;
  $35 = $4;
  $36 = HEAP32[$35 >> 2] | 0;
  $37 = $36 + 12 | 0;
  $38 = HEAP32[$37 >> 2] | 0;
  $6 = $38;
 }
 $39 = $4;
 $40 = $39 + 4 | 0;
 $41 = HEAP32[$40 >> 2] | 0;
 $42 = _mp_obj_is_qstr_1128($41) | 0;
 $43 = $4;
 $44 = $43 + 4 | 0;
 $45 = HEAP32[$44 >> 2] | 0;
 if ($42) {
  $46 = $45;
  $47 = $46 >>> 2;
  $48 = _qstr_data($47, $9) | 0;
  $8 = $48;
 } else {
  $49 = $45 + 8 | 0;
  $50 = HEAP32[$49 >> 2] | 0;
  HEAP32[$9 >> 2] = $50;
  $51 = $4;
  $52 = $51 + 4 | 0;
  $53 = HEAP32[$52 >> 2] | 0;
  $54 = $53 + 12 | 0;
  $55 = HEAP32[$54 >> 2] | 0;
  $8 = $55;
 }
 $56 = $6;
 $10 = $56;
 $57 = $6;
 $58 = HEAP32[$7 >> 2] | 0;
 $59 = $57 + $58 | 0;
 $11 = $59;
 $60 = $3;
 $61 = $60 >>> 0 >= 3;
 if ($61) {
  $62 = $4;
  $63 = $62 + 8 | 0;
  $64 = HEAP32[$63 >> 2] | 0;
  $65 = ($64 | 0) != (17668 | 0);
  if ($65) {
   $66 = $5;
   $67 = $6;
   $68 = HEAP32[$7 >> 2] | 0;
   $69 = $4;
   $70 = $69 + 8 | 0;
   $71 = HEAP32[$70 >> 2] | 0;
   $72 = _str_index_to_ptr($66, $67, $68, $71, 1) | 0;
   $10 = $72;
  }
 }
 $73 = $3;
 $74 = $73 >>> 0 >= 4;
 if ($74) {
  $75 = $4;
  $76 = $75 + 12 | 0;
  $77 = HEAP32[$76 >> 2] | 0;
  $78 = ($77 | 0) != (17668 | 0);
  if ($78) {
   $79 = $5;
   $80 = $6;
   $81 = HEAP32[$7 >> 2] | 0;
   $82 = $4;
   $83 = $82 + 12 | 0;
   $84 = HEAP32[$83 >> 2] | 0;
   $85 = _str_index_to_ptr($79, $80, $81, $84, 1) | 0;
   $11 = $85;
  }
 }
 $86 = HEAP32[$9 >> 2] | 0;
 $87 = ($86 | 0) == 0;
 if ($87) {
  $88 = $10;
  $89 = $11;
  $90 = $10;
  $91 = $89;
  $92 = $90;
  $93 = $91 - $92 | 0;
  $94 = _utf8_charlen($88, $93) | 0;
  $95 = $94 + 1 | 0;
  $96 = $95 << 1;
  $97 = $96 | 1;
  $98 = $97;
  $2 = $98;
  $121 = $2;
  STACKTOP = sp;
  return $121 | 0;
 }
 $12 = 0;
 $99 = $10;
 $13 = $99;
 while (1) {
  $100 = $13;
  $101 = HEAP32[$9 >> 2] | 0;
  $102 = $100 + $101 | 0;
  $103 = $11;
  $104 = $102 >>> 0 <= $103 >>> 0;
  if (!$104) {
   break;
  }
  $105 = $13;
  $106 = $8;
  $107 = HEAP32[$9 >> 2] | 0;
  $108 = _memcmp($105, $106, $107) | 0;
  $109 = ($108 | 0) == 0;
  if ($109) {
   $110 = $12;
   $111 = $110 + 1 | 0;
   $12 = $111;
   $112 = HEAP32[$9 >> 2] | 0;
   $113 = $13;
   $114 = $113 + $112 | 0;
   $13 = $114;
  } else {
   $115 = $13;
   $116 = _utf8_next_char($115) | 0;
   $13 = $116;
  }
 }
 $117 = $12;
 $118 = $117 << 1;
 $119 = $118 | 1;
 $120 = $119;
 $2 = $120;
 $121 = $2;
 STACKTOP = sp;
 return $121 | 0;
}

function _complex_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0.0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0.0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0.0, $73 = 0.0, $74 = 0.0, $75 = 0.0, $76 = 0.0, $77 = 0.0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0.0, $82 = 0.0, $83 = 0.0, $84 = 0.0, $85 = 0.0, $86 = 0, $87 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $9 = sp + 36 | 0;
 $11 = sp + 24 | 0;
 $12 = sp + 16 | 0;
 $13 = sp + 8 | 0;
 $14 = sp;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $15 = $6;
 $16 = $7;
 _mp_arg_check_num_862($15, $16, 0, 2, 0);
 $17 = $6;
 switch ($17 | 0) {
 case 0:
  {
   $18 = _mp_obj_new_complex(0.0, 0.0) | 0;
   $4 = $18;
   $87 = $4;
   STACKTOP = sp;
   return $87 | 0;
   break;
  }
 case 1:
  {
   $19 = $8;
   $20 = HEAP32[$19 >> 2] | 0;
   $21 = _mp_obj_is_qstr_863($20) | 0;
   do {
    if (!$21) {
     $22 = $8;
     $23 = HEAP32[$22 >> 2] | 0;
     $24 = _mp_obj_is_obj_864($23) | 0;
     if ($24) {
      $25 = $8;
      $26 = HEAP32[$25 >> 2] | 0;
      $27 = HEAP32[$26 >> 2] | 0;
      $28 = ($27 | 0) == (18680 | 0);
      if ($28) {
       break;
      }
     }
     $35 = $8;
     $36 = HEAP32[$35 >> 2] | 0;
     $37 = _mp_obj_is_obj_864($36) | 0;
     if ($37) {
      $38 = $8;
      $39 = HEAP32[$38 >> 2] | 0;
      $40 = HEAP32[$39 >> 2] | 0;
      $41 = ($40 | 0) == (14052 | 0);
      if ($41) {
       $42 = $8;
       $43 = HEAP32[$42 >> 2] | 0;
       $4 = $43;
       $87 = $4;
       STACKTOP = sp;
       return $87 | 0;
      }
     }
     $44 = $8;
     $45 = HEAP32[$44 >> 2] | 0;
     $46 = +_mp_obj_get_float($45);
     $47 = _mp_obj_new_complex($46, 0.0) | 0;
     $4 = $47;
     $87 = $4;
     STACKTOP = sp;
     return $87 | 0;
    }
   } while (0);
   $29 = $8;
   $30 = HEAP32[$29 >> 2] | 0;
   $31 = _mp_obj_str_get_data($30, $9) | 0;
   $10 = $31;
   $32 = $10;
   $33 = HEAP32[$9 >> 2] | 0;
   $34 = _mp_parse_num_decimal($32, $33, 1, 1, 0) | 0;
   $4 = $34;
   $87 = $4;
   STACKTOP = sp;
   return $87 | 0;
   break;
  }
 default:
  {
   $48 = $8;
   $49 = HEAP32[$48 >> 2] | 0;
   $50 = _mp_obj_is_obj_864($49) | 0;
   if ($50) {
    $51 = $8;
    $52 = HEAP32[$51 >> 2] | 0;
    $53 = HEAP32[$52 >> 2] | 0;
    $54 = ($53 | 0) == (14052 | 0);
    if ($54) {
     $55 = $8;
     $56 = HEAP32[$55 >> 2] | 0;
     _mp_obj_complex_get($56, $11, $12);
    } else {
     label = 14;
    }
   } else {
    label = 14;
   }
   if ((label | 0) == 14) {
    $57 = $8;
    $58 = HEAP32[$57 >> 2] | 0;
    $59 = +_mp_obj_get_float($58);
    HEAPF64[$11 >> 3] = $59;
    HEAPF64[$12 >> 3] = 0.0;
   }
   $60 = $8;
   $61 = $60 + 4 | 0;
   $62 = HEAP32[$61 >> 2] | 0;
   $63 = _mp_obj_is_obj_864($62) | 0;
   if ($63) {
    $64 = $8;
    $65 = $64 + 4 | 0;
    $66 = HEAP32[$65 >> 2] | 0;
    $67 = HEAP32[$66 >> 2] | 0;
    $68 = ($67 | 0) == (14052 | 0);
    if ($68) {
     $69 = $8;
     $70 = $69 + 4 | 0;
     $71 = HEAP32[$70 >> 2] | 0;
     _mp_obj_complex_get($71, $13, $14);
     $72 = +HEAPF64[$14 >> 3];
     $73 = +HEAPF64[$11 >> 3];
     $74 = $73 - $72;
     HEAPF64[$11 >> 3] = $74;
     $75 = +HEAPF64[$13 >> 3];
     $76 = +HEAPF64[$12 >> 3];
     $77 = $76 + $75;
     HEAPF64[$12 >> 3] = $77;
    } else {
     label = 18;
    }
   } else {
    label = 18;
   }
   if ((label | 0) == 18) {
    $78 = $8;
    $79 = $78 + 4 | 0;
    $80 = HEAP32[$79 >> 2] | 0;
    $81 = +_mp_obj_get_float($80);
    $82 = +HEAPF64[$12 >> 3];
    $83 = $82 + $81;
    HEAPF64[$12 >> 3] = $83;
   }
   $84 = +HEAPF64[$11 >> 3];
   $85 = +HEAPF64[$12 >> 3];
   $86 = _mp_obj_new_complex($84, $85) | 0;
   $4 = $86;
   $87 = $4;
   STACKTOP = sp;
   return $87 | 0;
  }
 }
 return 0 | 0;
}

function _compile_atom_bracket($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = $6 + 8 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) == 0;
 if ($9) {
  $10 = $2;
  $11 = $10 + 40 | 0;
  $12 = HEAP32[$11 >> 2] | 0;
  _mp_emit_bc_build($12, 0, 1);
  STACKTOP = sp;
  return;
 }
 $13 = $3;
 $14 = $13 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = ($15 | 0) != 0;
 if ($16) {
  $17 = $3;
  $18 = $17 + 8 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = $19 & 3;
  $21 = ($20 | 0) == 0;
  if ($21) {
   $22 = $3;
   $23 = $22 + 8 | 0;
   $24 = HEAP32[$23 >> 2] | 0;
   $25 = $24;
   $26 = $25 + 4 | 0;
   $27 = HEAP32[$26 >> 2] | 0;
   $28 = $27 & 255;
   $29 = ($28 | 0) == 144;
   if ($29) {
    $30 = $3;
    $31 = $30 + 8 | 0;
    $32 = HEAP32[$31 >> 2] | 0;
    $33 = $32;
    $4 = $33;
    $34 = $4;
    $35 = $34 + 8 | 0;
    $36 = $35 + 4 | 0;
    $37 = HEAP32[$36 >> 2] | 0;
    $38 = ($37 | 0) != 0;
    if ($38) {
     $39 = $4;
     $40 = $39 + 8 | 0;
     $41 = $40 + 4 | 0;
     $42 = HEAP32[$41 >> 2] | 0;
     $43 = $42 & 3;
     $44 = ($43 | 0) == 0;
     if ($44) {
      $45 = $4;
      $46 = $45 + 8 | 0;
      $47 = $46 + 4 | 0;
      $48 = HEAP32[$47 >> 2] | 0;
      $49 = $48;
      $5 = $49;
      $50 = $5;
      $51 = $50 + 4 | 0;
      $52 = HEAP32[$51 >> 2] | 0;
      $53 = $52 & 255;
      $54 = ($53 | 0) == 147;
      if ($54) {
       $55 = $2;
       $56 = $4;
       $57 = $56 + 8 | 0;
       $58 = HEAP32[$57 >> 2] | 0;
       _compile_node($55, $58);
       $59 = $2;
       $60 = $59 + 40 | 0;
       $61 = HEAP32[$60 >> 2] | 0;
       _mp_emit_bc_build($61, 1, 1);
       STACKTOP = sp;
       return;
      }
      $62 = $5;
      $63 = $62 + 4 | 0;
      $64 = HEAP32[$63 >> 2] | 0;
      $65 = $64 & 255;
      $66 = ($65 | 0) == 148;
      if ($66) {
       $67 = $2;
       $68 = $4;
       $69 = $68 + 8 | 0;
       $70 = HEAP32[$69 >> 2] | 0;
       _compile_node($67, $70);
       $71 = $2;
       $72 = $5;
       _compile_generic_all_nodes($71, $72);
       $73 = $2;
       $74 = $73 + 40 | 0;
       $75 = HEAP32[$74 >> 2] | 0;
       $76 = $5;
       $77 = $76 + 4 | 0;
       $78 = HEAP32[$77 >> 2] | 0;
       $79 = $78 >>> 8;
       $80 = 1 + $79 | 0;
       _mp_emit_bc_build($75, $80, 1);
       STACKTOP = sp;
       return;
      }
      $81 = $5;
      $82 = $81 + 4 | 0;
      $83 = HEAP32[$82 >> 2] | 0;
      $84 = $83 & 255;
      $85 = ($84 | 0) == 171;
      if ($85) {
       $86 = $2;
       $87 = $4;
       _compile_comprehension($86, $87, 3);
       STACKTOP = sp;
       return;
      }
     }
    }
    $88 = $2;
    $89 = $4;
    $90 = $89 + 8 | 0;
    $91 = HEAP32[$90 >> 2] | 0;
    _compile_node($88, $91);
    $92 = $2;
    $93 = $4;
    $94 = $93 + 8 | 0;
    $95 = $94 + 4 | 0;
    $96 = HEAP32[$95 >> 2] | 0;
    _compile_node($92, $96);
    $97 = $2;
    $98 = $97 + 40 | 0;
    $99 = HEAP32[$98 >> 2] | 0;
    _mp_emit_bc_build($99, 2, 1);
    STACKTOP = sp;
    return;
   }
  }
 }
 $100 = $2;
 $101 = $3;
 $102 = $101 + 8 | 0;
 $103 = HEAP32[$102 >> 2] | 0;
 _compile_node($100, $103);
 $104 = $2;
 $105 = $104 + 40 | 0;
 $106 = HEAP32[$105 >> 2] | 0;
 _mp_emit_bc_build($106, 1, 1);
 STACKTOP = sp;
 return;
}

function _mp_obj_str_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $9 = sp + 40 | 0;
 $10 = sp + 32 | 0;
 $12 = sp + 24 | 0;
 $16 = sp;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $17 = $7;
 $18 = ($17 | 0) != 0;
 if ($18) {
  _mp_arg_error_unimpl_kw();
 }
 $19 = $6;
 $20 = $7;
 _mp_arg_check_num_1165($19, $20, 0, 3, 0);
 $21 = $6;
 switch ($21 | 0) {
 case 0:
  {
   $4 = 6;
   $94 = $4;
   STACKTOP = sp;
   return $94 | 0;
   break;
  }
 case 1:
  {
   _vstr_init_print($9, 16, $10);
   $22 = $8;
   $23 = HEAP32[$22 >> 2] | 0;
   _mp_obj_print_helper($10, $23, 0);
   $24 = $5;
   $25 = _mp_obj_new_str_from_vstr($24, $9) | 0;
   $4 = $25;
   $94 = $4;
   STACKTOP = sp;
   return $94 | 0;
   break;
  }
 default:
  {
   $26 = $8;
   $27 = HEAP32[$26 >> 2] | 0;
   $28 = _mp_obj_is_obj_1154($27) | 0;
   if ($28) {
    $29 = $8;
    $30 = HEAP32[$29 >> 2] | 0;
    $31 = HEAP32[$30 >> 2] | 0;
    $32 = ($31 | 0) == (18304 | 0);
    if ($32) {
     $33 = $8;
     $34 = HEAP32[$33 >> 2] | 0;
     $35 = _mp_obj_is_qstr_1128($34) | 0;
     $36 = $8;
     $37 = HEAP32[$36 >> 2] | 0;
     if ($35) {
      $38 = $37;
      $39 = $38 >>> 2;
      $40 = _qstr_data($39, $12) | 0;
      $11 = $40;
     } else {
      $41 = $37 + 8 | 0;
      $42 = HEAP32[$41 >> 2] | 0;
      HEAP32[$12 >> 2] = $42;
      $43 = $8;
      $44 = HEAP32[$43 >> 2] | 0;
      $45 = $44 + 12 | 0;
      $46 = HEAP32[$45 >> 2] | 0;
      $11 = $46;
     }
     $47 = $8;
     $48 = HEAP32[$47 >> 2] | 0;
     $49 = _mp_obj_is_qstr_1128($48) | 0;
     $50 = $8;
     $51 = HEAP32[$50 >> 2] | 0;
     if ($49) {
      $52 = $51;
      $53 = $52 >>> 2;
      $54 = _qstr_hash($53) | 0;
      $13 = $54;
     } else {
      $55 = $51 + 4 | 0;
      $56 = HEAP32[$55 >> 2] | 0;
      $13 = $56;
     }
     $57 = $13;
     $58 = ($57 | 0) == 0;
     if ($58) {
      $59 = $11;
      $60 = HEAP32[$12 >> 2] | 0;
      $61 = _qstr_compute_hash($59, $60) | 0;
      $13 = $61;
     }
     $62 = $11;
     $63 = HEAP32[$12 >> 2] | 0;
     $64 = _utf8_check($62, $63) | 0;
     if (!$64) {
      _mp_raise_msg(16132, 0);
     }
     $65 = $11;
     $66 = HEAP32[$12 >> 2] | 0;
     $67 = _qstr_find_strn($65, $66) | 0;
     $14 = $67;
     $68 = $14;
     $69 = ($68 | 0) != 0;
     if ($69) {
      $70 = $14;
      $71 = $70 << 2;
      $72 = $71 | 2;
      $73 = $72;
      $4 = $73;
      $94 = $4;
      STACKTOP = sp;
      return $94 | 0;
     } else {
      $74 = $5;
      $75 = HEAP32[$12 >> 2] | 0;
      $76 = _mp_obj_new_str_copy($74, 0, $75) | 0;
      $15 = $76;
      $77 = $11;
      $78 = $15;
      $79 = $78 + 12 | 0;
      HEAP32[$79 >> 2] = $77;
      $80 = $13;
      $81 = $15;
      $82 = $81 + 4 | 0;
      HEAP32[$82 >> 2] = $80;
      $83 = $15;
      $4 = $83;
      $94 = $4;
      STACKTOP = sp;
      return $94 | 0;
     }
    }
   }
   $84 = $8;
   $85 = HEAP32[$84 >> 2] | 0;
   _mp_get_buffer_raise($85, $16, 1);
   $86 = HEAP32[$16 >> 2] | 0;
   $87 = $16 + 4 | 0;
   $88 = HEAP32[$87 >> 2] | 0;
   $89 = _utf8_check($86, $88) | 0;
   if (!$89) {
    _mp_raise_msg(16132, 0);
   }
   $90 = HEAP32[$16 >> 2] | 0;
   $91 = $16 + 4 | 0;
   $92 = HEAP32[$91 >> 2] | 0;
   $93 = _mp_obj_new_str($90, $92) | 0;
   $4 = $93;
   $94 = $4;
   STACKTOP = sp;
   return $94 | 0;
  }
 }
 return 0 | 0;
}

function _mp_obj_instance_load_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $3 = sp + 68 | 0;
 $11 = sp + 20 | 0;
 $14 = sp;
 HEAP32[$3 >> 2] = $0;
 $4 = $1;
 $5 = $2;
 $15 = HEAP32[$3 >> 2] | 0;
 $6 = $15;
 $16 = $6;
 $17 = $16 + 4 | 0;
 $18 = $4;
 $19 = $18 << 2;
 $20 = $19 | 2;
 $21 = $20;
 $22 = _mp_map_lookup($17, $21, 0) | 0;
 $7 = $22;
 $23 = $7;
 $24 = ($23 | 0) != (0 | 0);
 if ($24) {
  $25 = $7;
  $26 = $25 + 4 | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $28 = $5;
  HEAP32[$28 >> 2] = $27;
  STACKTOP = sp;
  return;
 }
 $29 = $4;
 $30 = ($29 | 0) == 176;
 if ($30) {
  $31 = $6;
  $32 = $31 + 4 | 0;
  $8 = $32;
  $33 = $8;
  $34 = HEAP32[$33 >> 2] | 0;
  $35 = $34 >>> 3;
  $36 = _mp_obj_new_dict($35) | 0;
  $9 = $36;
  $10 = 0;
  while (1) {
   $37 = $10;
   $38 = $8;
   $39 = $38 + 4 | 0;
   $40 = HEAP32[$39 >> 2] | 0;
   $41 = $37 >>> 0 < $40 >>> 0;
   if (!$41) {
    break;
   }
   $42 = $8;
   $43 = $10;
   $44 = _mp_map_slot_is_filled_1272($42, $43) | 0;
   if ($44) {
    $45 = $9;
    $46 = $8;
    $47 = $46 + 8 | 0;
    $48 = HEAP32[$47 >> 2] | 0;
    $49 = $10;
    $50 = $48 + ($49 << 3) | 0;
    $51 = HEAP32[$50 >> 2] | 0;
    $52 = $8;
    $53 = $52 + 8 | 0;
    $54 = HEAP32[$53 >> 2] | 0;
    $55 = $10;
    $56 = $54 + ($55 << 3) | 0;
    $57 = $56 + 4 | 0;
    $58 = HEAP32[$57 >> 2] | 0;
    _mp_obj_dict_store($45, $51, $58) | 0;
   }
   $59 = $10;
   $60 = $59 + 1 | 0;
   $10 = $60;
  }
  $61 = $9;
  $62 = $5;
  HEAP32[$62 >> 2] = $61;
  STACKTOP = sp;
  return;
 }
 $63 = $6;
 HEAP32[$11 >> 2] = $63;
 $64 = $11 + 4 | 0;
 $65 = $4;
 HEAP32[$64 >> 2] = $65;
 $66 = $11 + 8 | 0;
 HEAP32[$66 >> 2] = 0;
 $67 = $11 + 12 | 0;
 $68 = $5;
 HEAP32[$67 >> 2] = $68;
 $69 = $11 + 16 | 0;
 HEAP8[$69 >> 0] = 0;
 $70 = $6;
 $71 = HEAP32[$70 >> 2] | 0;
 _mp_obj_class_lookup($11, $71);
 $72 = $5;
 $73 = HEAP32[$72 >> 2] | 0;
 $12 = $73;
 $74 = $12;
 $75 = ($74 | 0) != (0 | 0);
 if (!$75) {
  $97 = $4;
  $98 = ($97 | 0) != 14;
  if (!$98) {
   STACKTOP = sp;
   return;
  }
  $99 = HEAP32[$3 >> 2] | 0;
  _mp_load_method_maybe($99, 14, $14);
  $100 = HEAP32[$14 >> 2] | 0;
  $101 = ($100 | 0) != (0 | 0);
  if (!$101) {
   STACKTOP = sp;
   return;
  }
  $102 = $4;
  $103 = $102 << 2;
  $104 = $103 | 2;
  $105 = $104;
  $106 = $14 + 8 | 0;
  HEAP32[$106 >> 2] = $105;
  $107 = _mp_call_method_n_kw(1, 0, $14) | 0;
  $108 = $5;
  HEAP32[$108 >> 2] = $107;
  STACKTOP = sp;
  return;
 }
 $76 = $6;
 $77 = HEAP32[$76 >> 2] | 0;
 $78 = $77 + 4 | 0;
 $79 = HEAP16[$78 >> 1] | 0;
 $80 = $79 & 65535;
 $81 = $80 & 2;
 $82 = ($81 | 0) != 0;
 if (!$82) {
  STACKTOP = sp;
  return;
 }
 $83 = $12;
 $84 = _mp_obj_is_obj_1260($83) | 0;
 if (!$84) {
  STACKTOP = sp;
  return;
 }
 $85 = $12;
 $86 = HEAP32[$85 >> 2] | 0;
 $87 = ($86 | 0) == (17508 | 0);
 if (!$87) {
  STACKTOP = sp;
  return;
 }
 $88 = $12;
 $89 = _mp_obj_property_get($88) | 0;
 $13 = $89;
 $90 = $13;
 $91 = HEAP32[$90 >> 2] | 0;
 $92 = ($91 | 0) == (17668 | 0);
 if ($92) {
  _mp_raise_msg(15292, 33239);
 }
 $93 = $13;
 $94 = HEAP32[$93 >> 2] | 0;
 $95 = _mp_call_function_n_kw($94, 1, 0, $3) | 0;
 $96 = $5;
 HEAP32[$96 >> 2] = $95;
 STACKTOP = sp;
 return;
}

function _mp_obj_gen_resume($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $11 = $5;
 $9 = $11;
 $12 = $9;
 $13 = $12 + 8 | 0;
 $14 = $13 + 4 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = ($15 | 0) == (0 | 0);
 if ($16) {
  $17 = $8;
  HEAP32[$17 >> 2] = 0;
  $4 = 0;
  $108 = $4;
  STACKTOP = sp;
  return $108 | 0;
 }
 $18 = $9;
 $19 = $18 + 8 | 0;
 $20 = $19 + 8 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $9;
 $23 = $22 + 8 | 0;
 $24 = $23 + 20 | 0;
 $25 = $24 + -4 | 0;
 $26 = ($21 | 0) == ($25 | 0);
 do {
  if ($26) {
   $27 = $6;
   $28 = ($27 | 0) != (17668 | 0);
   if ($28) {
    _mp_raise_TypeError(31175);
   }
  } else {
   $29 = $9;
   $30 = $29 + 8 | 0;
   $31 = $30 + 8 | 0;
   $32 = HEAP32[$31 >> 2] | 0;
   $33 = HEAP32[$32 >> 2] | 0;
   $34 = ($33 | 0) != (17668 | 0);
   if ($34) {
    $35 = $9;
    $36 = $35 + 8 | 0;
    $37 = $36 + 8 | 0;
    $38 = HEAP32[$37 >> 2] | 0;
    $39 = HEAP32[$38 >> 2] | 0;
    $7 = $39;
    $40 = $9;
    $41 = $40 + 8 | 0;
    $42 = $41 + 8 | 0;
    $43 = HEAP32[$42 >> 2] | 0;
    HEAP32[$43 >> 2] = 0;
    break;
   } else {
    $44 = $6;
    $45 = $9;
    $46 = $45 + 8 | 0;
    $47 = $46 + 8 | 0;
    $48 = HEAP32[$47 >> 2] | 0;
    HEAP32[$48 >> 2] = $44;
    break;
   }
  }
 } while (0);
 $49 = $9;
 $50 = $49 + 4 | 0;
 $51 = HEAP32[$50 >> 2] | 0;
 $52 = ($51 | 0) == (0 | 0);
 if ($52) {
  _mp_raise_ValueError(31229);
 }
 $53 = _mp_globals_get_1003() | 0;
 $54 = $9;
 $55 = $54 + 8 | 0;
 $56 = $55 + 16 | 0;
 HEAP32[$56 >> 2] = $53;
 $57 = $9;
 $58 = $57 + 4 | 0;
 $59 = HEAP32[$58 >> 2] | 0;
 _mp_globals_set_1004($59);
 $60 = $9;
 $61 = $60 + 4 | 0;
 HEAP32[$61 >> 2] = 0;
 $62 = $9;
 $63 = $62 + 8 | 0;
 $64 = $7;
 $65 = _mp_execute_bytecode($63, $64) | 0;
 $10 = $65;
 $66 = _mp_globals_get_1003() | 0;
 $67 = $9;
 $68 = $67 + 4 | 0;
 HEAP32[$68 >> 2] = $66;
 $69 = $9;
 $70 = $69 + 8 | 0;
 $71 = $70 + 16 | 0;
 $72 = HEAP32[$71 >> 2] | 0;
 _mp_globals_set_1004($72);
 $73 = $10;
 switch ($73 | 0) {
 case 2:
  {
   $93 = $9;
   $94 = $93 + 8 | 0;
   $95 = $94 + 4 | 0;
   HEAP32[$95 >> 2] = 0;
   $96 = $9;
   $97 = $96 + 8 | 0;
   $98 = $97 + 20 | 0;
   $99 = HEAP32[$98 >> 2] | 0;
   $100 = $8;
   HEAP32[$100 >> 2] = $99;
   $101 = $8;
   $102 = HEAP32[$101 >> 2] | 0;
   $103 = _mp_obj_get_type($102) | 0;
   $104 = _mp_obj_is_subclass_fast($103, 14676) | 0;
   if ($104) {
    $105 = _mp_obj_new_exception_msg(15772, 31257) | 0;
    $106 = $8;
    HEAP32[$106 >> 2] = $105;
   }
   break;
  }
 case 1:
  {
   $83 = $9;
   $84 = $83 + 8 | 0;
   $85 = $84 + 8 | 0;
   $86 = HEAP32[$85 >> 2] | 0;
   $87 = HEAP32[$86 >> 2] | 0;
   $88 = $8;
   HEAP32[$88 >> 2] = $87;
   $89 = $9;
   $90 = $89 + 8 | 0;
   $91 = $90 + 8 | 0;
   $92 = HEAP32[$91 >> 2] | 0;
   HEAP32[$92 >> 2] = 17668;
   break;
  }
 default:
  {
   $74 = $9;
   $75 = $74 + 8 | 0;
   $76 = $75 + 4 | 0;
   HEAP32[$76 >> 2] = 0;
   $77 = $9;
   $78 = $77 + 8 | 0;
   $79 = $78 + 8 | 0;
   $80 = HEAP32[$79 >> 2] | 0;
   $81 = HEAP32[$80 >> 2] | 0;
   $82 = $8;
   HEAP32[$82 >> 2] = $81;
  }
 }
 $107 = $10;
 $4 = $107;
 $108 = $4;
 STACKTOP = sp;
 return $108 | 0;
}

function _acos($0) {
 $0 = +$0;
 var $$ = 0.0, $$1 = 0.0, $1 = 0, $10 = 0.0, $100 = 0.0, $11 = 0, $12 = 0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0, $60 = 0.0, $61 = 0.0, $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0, $71 = 0, $72 = 0.0, $73 = 0.0, $74 = 0.0, $75 = 0.0, $76 = 0.0, $77 = 0.0, $78 = 0.0, $79 = 0.0, $8 = 0, $80 = 0.0, $81 = 0.0, $82 = 0.0, $83 = 0.0, $84 = 0.0, $85 = 0.0, $86 = 0.0, $87 = 0.0, $88 = 0.0, $89 = 0.0, $9 = 0.0, $90 = 0.0, $91 = 0.0, $92 = 0.0, $93 = 0.0, $94 = 0.0, $95 = 0.0, $96 = 0.0, $97 = 0.0, $98 = 0.0, $99 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = $2 & 2147483647;
 $4 = $3 >>> 0 > 1072693247;
 if ($4) {
  $5 = $3 + -1072693248 | 0;
  $6 = $5 | $1;
  $7 = ($6 | 0) == 0;
  if ($7) {
   $8 = ($2 | 0) < 0;
   $$ = $8 ? 3.141592653589793 : 0.0;
   $$1 = $$;
   return +$$1;
  } else {
   $9 = $0 - $0;
   $10 = 0.0 / $9;
   $$1 = $10;
   return +$$1;
  }
 }
 $11 = $3 >>> 0 < 1071644672;
 if ($11) {
  $12 = $3 >>> 0 < 1012924417;
  if ($12) {
   $$1 = 1.5707963267948966;
   return +$$1;
  }
  $13 = $0 * $0;
  $14 = $13 * 3.479331075960212e-05;
  $15 = $14 + 7.915349942898145e-04;
  $16 = $13 * $15;
  $17 = $16 + -.04005553450067941;
  $18 = $13 * $17;
  $19 = $18 + .20121253213486293;
  $20 = $13 * $19;
  $21 = $20 + -.3255658186224009;
  $22 = $13 * $21;
  $23 = $22 + .16666666666666666;
  $24 = $13 * $23;
  $25 = $13 * .07703815055590194;
  $26 = $25 + -.6882839716054533;
  $27 = $13 * $26;
  $28 = $27 + 2.0209457602335057;
  $29 = $13 * $28;
  $30 = $29 + -2.403394911734414;
  $31 = $13 * $30;
  $32 = $31 + 1.0;
  $33 = $24 / $32;
  $34 = $33 * $0;
  $35 = 6.123233995736766e-17 - $34;
  $36 = $0 - $35;
  $37 = 1.5707963267948966 - $36;
  $$1 = $37;
  return +$$1;
 }
 $38 = ($2 | 0) < 0;
 if ($38) {
  $39 = $0 + 1.0;
  $40 = $39 * .5;
  $41 = +Math_sqrt(+$40);
  $42 = $40 * 3.479331075960212e-05;
  $43 = $42 + 7.915349942898145e-04;
  $44 = $40 * $43;
  $45 = $44 + -.04005553450067941;
  $46 = $40 * $45;
  $47 = $46 + .20121253213486293;
  $48 = $40 * $47;
  $49 = $48 + -.3255658186224009;
  $50 = $40 * $49;
  $51 = $50 + .16666666666666666;
  $52 = $40 * $51;
  $53 = $40 * .07703815055590194;
  $54 = $53 + -.6882839716054533;
  $55 = $40 * $54;
  $56 = $55 + 2.0209457602335057;
  $57 = $40 * $56;
  $58 = $57 + -2.403394911734414;
  $59 = $40 * $58;
  $60 = $59 + 1.0;
  $61 = $52 / $60;
  $62 = $61 * $41;
  $63 = $62 + -6.123233995736766e-17;
  $64 = $41 + $63;
  $65 = 1.5707963267948966 - $64;
  $66 = $65 * 2.0;
  $$1 = $66;
  return +$$1;
 } else {
  $67 = 1.0 - $0;
  $68 = $67 * .5;
  $69 = +Math_sqrt(+$68);
  HEAPF64[tempDoublePtr >> 3] = $69;
  $70 = HEAP32[tempDoublePtr >> 2] | 0;
  $71 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  HEAP32[tempDoublePtr >> 2] = 0;
  HEAP32[tempDoublePtr + 4 >> 2] = $71;
  $72 = +HEAPF64[tempDoublePtr >> 3];
  $73 = $72 * $72;
  $74 = $68 - $73;
  $75 = $69 + $72;
  $76 = $74 / $75;
  $77 = $68 * 3.479331075960212e-05;
  $78 = $77 + 7.915349942898145e-04;
  $79 = $68 * $78;
  $80 = $79 + -.04005553450067941;
  $81 = $68 * $80;
  $82 = $81 + .20121253213486293;
  $83 = $68 * $82;
  $84 = $83 + -.3255658186224009;
  $85 = $68 * $84;
  $86 = $85 + .16666666666666666;
  $87 = $68 * $86;
  $88 = $68 * .07703815055590194;
  $89 = $88 + -.6882839716054533;
  $90 = $68 * $89;
  $91 = $90 + 2.0209457602335057;
  $92 = $68 * $91;
  $93 = $92 + -2.403394911734414;
  $94 = $68 * $93;
  $95 = $94 + 1.0;
  $96 = $87 / $95;
  $97 = $96 * $69;
  $98 = $97 + $76;
  $99 = $98 + $72;
  $100 = $99 * 2.0;
  $$1 = $100;
  return +$$1;
 }
 return +(0.0);
}

function _readline_auto_indent() {
 var $0 = 0, $1 = 0, $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = HEAP32[10405] | 0;
 $0 = $5;
 $6 = $0;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $8 >>> 0 > 1;
 if (!$9) {
  STACKTOP = sp;
  return;
 }
 $10 = $0;
 $11 = $10 + 8 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $0;
 $14 = $13 + 4 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $15 - 1 | 0;
 $17 = $12 + $16 | 0;
 $18 = HEAP8[$17 >> 0] | 0;
 $19 = $18 << 24 >> 24;
 $20 = ($19 | 0) == 10;
 if (!$20) {
  STACKTOP = sp;
  return;
 }
 $21 = $0;
 $22 = $21 + 4 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $23 - 1 | 0;
 $1 = $24;
 while (1) {
  $25 = $1;
  $26 = ($25 | 0) > 0;
  if (!$26) {
   break;
  }
  $27 = $0;
  $28 = $27 + 8 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  $30 = $1;
  $31 = $30 - 1 | 0;
  $32 = $29 + $31 | 0;
  $33 = HEAP8[$32 >> 0] | 0;
  $34 = $33 << 24 >> 24;
  $35 = ($34 | 0) == 10;
  if ($35) {
   break;
  }
  $36 = $1;
  $37 = $36 + -1 | 0;
  $1 = $37;
 }
 $38 = $1;
 $2 = $38;
 while (1) {
  $39 = $2;
  $40 = $0;
  $41 = $40 + 4 | 0;
  $42 = HEAP32[$41 >> 2] | 0;
  $43 = $39 >>> 0 < $42 >>> 0;
  if (!$43) {
   break;
  }
  $44 = $0;
  $45 = $44 + 8 | 0;
  $46 = HEAP32[$45 >> 2] | 0;
  $47 = $2;
  $48 = $46 + $47 | 0;
  $49 = HEAP8[$48 >> 0] | 0;
  $50 = $49 << 24 >> 24;
  $51 = ($50 | 0) != 32;
  if ($51) {
   break;
  }
  $52 = $2;
  $53 = $52 + 1 | 0;
  $2 = $53;
 }
 $54 = $1;
 $55 = ($54 | 0) > 0;
 L17 : do {
  if ($55) {
   $56 = $2;
   $57 = $56 + 1 | 0;
   $58 = $0;
   $59 = $58 + 4 | 0;
   $60 = HEAP32[$59 >> 2] | 0;
   $61 = ($57 | 0) == ($60 | 0);
   if ($61) {
    $62 = $1;
    $63 = $62 - 1 | 0;
    $3 = $63;
    while (1) {
     $64 = $3;
     $65 = $64 >>> 0 > 0;
     if (!$65) {
      break L17;
     }
     $66 = $0;
     $67 = $66 + 8 | 0;
     $68 = HEAP32[$67 >> 2] | 0;
     $69 = $3;
     $70 = $69 - 1 | 0;
     $71 = $68 + $70 | 0;
     $72 = HEAP8[$71 >> 0] | 0;
     $73 = $72 << 24 >> 24;
     $74 = ($73 | 0) == 10;
     if ($74) {
      break;
     }
     $75 = $0;
     $76 = $75 + 8 | 0;
     $77 = HEAP32[$76 >> 2] | 0;
     $78 = $3;
     $79 = $78 - 1 | 0;
     $80 = $77 + $79 | 0;
     $81 = HEAP8[$80 >> 0] | 0;
     $82 = $81 << 24 >> 24;
     $83 = ($82 | 0) != 32;
     if ($83) {
      break L17;
     }
     $84 = $3;
     $85 = $84 + -1 | 0;
     $3 = $85;
    }
    STACKTOP = sp;
    return;
   }
  }
 } while (0);
 $86 = $2;
 $87 = $1;
 $88 = $86 - $87 | 0;
 $89 = ($88 >>> 0) / 4 & -1;
 $4 = $89;
 $90 = $0;
 $91 = $90 + 8 | 0;
 $92 = HEAP32[$91 >> 2] | 0;
 $93 = $0;
 $94 = $93 + 4 | 0;
 $95 = HEAP32[$94 >> 2] | 0;
 $96 = $95 - 2 | 0;
 $97 = $92 + $96 | 0;
 $98 = HEAP8[$97 >> 0] | 0;
 $99 = $98 << 24 >> 24;
 $100 = ($99 | 0) == 58;
 if ($100) {
  $101 = $4;
  $102 = $101 + 1 | 0;
  $4 = $102;
 }
 while (1) {
  $103 = $4;
  $104 = $103 + -1 | 0;
  $4 = $104;
  $105 = ($103 | 0) > 0;
  if (!$105) {
   break;
  }
  $106 = $0;
  _vstr_add_strn($106, 35342, 4);
  _mp_hal_stdout_tx_strn(35342, 4);
  $107 = HEAP32[10409] | 0;
  $108 = $107 + 4 | 0;
  HEAP32[10409] = $108;
 }
 STACKTOP = sp;
 return;
}

function _c_assign_tuple($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $107 = 0, $108 = 0, $109 = 0, $11 = 0, $110 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $12 = $5;
 $13 = ($12 | 0) == 0;
 $14 = $13 ? 0 : 1;
 $8 = $14;
 $9 = -1;
 $15 = $8;
 $16 = ($15 | 0) != 0;
 $17 = $5;
 $18 = ($17 | 0) != 0;
 $or$cond = $16 & $18;
 if ($or$cond) {
  $19 = $5;
  $20 = $19 & 3;
  $21 = ($20 | 0) == 0;
  if ($21) {
   $22 = $5;
   $23 = $22;
   $24 = $23 + 4 | 0;
   $25 = HEAP32[$24 >> 2] | 0;
   $26 = $25 & 255;
   $27 = ($26 | 0) == 33;
   if ($27) {
    $28 = $4;
    $29 = $28 + 40 | 0;
    $30 = HEAP32[$29 >> 2] | 0;
    $31 = $6;
    _mp_emit_bc_unpack_ex($30, 0, $31);
    $9 = 0;
   }
  }
 }
 $10 = 0;
 while (1) {
  $32 = $10;
  $33 = $6;
  $34 = $32 >>> 0 < $33 >>> 0;
  if (!$34) {
   break;
  }
  $35 = $7;
  $36 = $10;
  $37 = $35 + ($36 << 2) | 0;
  $38 = HEAP32[$37 >> 2] | 0;
  $39 = ($38 | 0) != 0;
  if ($39) {
   $40 = $7;
   $41 = $10;
   $42 = $40 + ($41 << 2) | 0;
   $43 = HEAP32[$42 >> 2] | 0;
   $44 = $43 & 3;
   $45 = ($44 | 0) == 0;
   if ($45) {
    $46 = $7;
    $47 = $10;
    $48 = $46 + ($47 << 2) | 0;
    $49 = HEAP32[$48 >> 2] | 0;
    $50 = $49;
    $51 = $50 + 4 | 0;
    $52 = HEAP32[$51 >> 2] | 0;
    $53 = $52 & 255;
    $54 = ($53 | 0) == 33;
    if ($54) {
     $55 = $9;
     $56 = ($55 | 0) == -1;
     $57 = $4;
     if (!$56) {
      label = 12;
      break;
     }
     $58 = $57 + 40 | 0;
     $59 = HEAP32[$58 >> 2] | 0;
     $60 = $8;
     $61 = $10;
     $62 = $60 + $61 | 0;
     $63 = $6;
     $64 = $10;
     $65 = $63 - $64 | 0;
     $66 = $65 - 1 | 0;
     _mp_emit_bc_unpack_ex($59, $62, $66);
     $67 = $8;
     $68 = $10;
     $69 = $67 + $68 | 0;
     $9 = $69;
    }
   }
  }
  $74 = $10;
  $75 = $74 + 1 | 0;
  $10 = $75;
 }
 if ((label | 0) == 12) {
  $70 = $7;
  $71 = $10;
  $72 = $70 + ($71 << 2) | 0;
  $73 = HEAP32[$72 >> 2] | 0;
  _compile_syntax_error($57, $73, 28761);
  STACKTOP = sp;
  return;
 }
 $76 = $9;
 $77 = ($76 | 0) == -1;
 if ($77) {
  $78 = $4;
  $79 = $78 + 40 | 0;
  $80 = HEAP32[$79 >> 2] | 0;
  $81 = $8;
  $82 = $6;
  $83 = $81 + $82 | 0;
  _mp_emit_bc_unpack_sequence($80, $83);
 }
 $84 = $8;
 $85 = ($84 | 0) != 0;
 do {
  if ($85) {
   $86 = $9;
   $87 = 0 == ($86 | 0);
   $88 = $4;
   $89 = $5;
   if ($87) {
    $90 = $89;
    $91 = $90 + 8 | 0;
    $92 = HEAP32[$91 >> 2] | 0;
    _c_assign($88, $92, 0);
    break;
   } else {
    _c_assign($88, $89, 0);
    break;
   }
  }
 } while (0);
 $11 = 0;
 while (1) {
  $93 = $11;
  $94 = $6;
  $95 = $93 >>> 0 < $94 >>> 0;
  if (!$95) {
   break;
  }
  $96 = $8;
  $97 = $11;
  $98 = $96 + $97 | 0;
  $99 = $9;
  $100 = ($98 | 0) == ($99 | 0);
  $101 = $4;
  $102 = $7;
  $103 = $11;
  $104 = $102 + ($103 << 2) | 0;
  $105 = HEAP32[$104 >> 2] | 0;
  if ($100) {
   $106 = $105;
   $107 = $106 + 8 | 0;
   $108 = HEAP32[$107 >> 2] | 0;
   _c_assign($101, $108, 0);
  } else {
   _c_assign($101, $105, 0);
  }
  $109 = $11;
  $110 = $109 + 1 | 0;
  $11 = $110;
 }
 STACKTOP = sp;
 return;
}

function _mp_load_method_protected($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $$reg2mem17$0 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, $cond19 = 0, $cond20 = 0, $cond21 = 0, $cond22 = 0, _setjmpTable = 0, _setjmpTableSize = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 176 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(176 | 0);
 _setjmpTableSize = 4;
 _setjmpTable = _malloc(40) | 0;
 HEAP32[_setjmpTable >> 2] = 0;
 $4 = sp;
 $5 = $3 & 1;
 __THREW__ = 0;
 invoke_ii(496, $4 | 0) | 0;
 $6 = __THREW__;
 __THREW__ = 0;
 if (($6 | 0) != 0 & (threwValue | 0) != 0) {
  $7 = _testSetjmp(HEAP32[$6 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  if (($7 | 0) == 0) {
   _longjmp($6 | 0, threwValue | 0);
  }
  setTempRet0(threwValue | 0);
 } else {
  $7 = -1;
 }
 $8 = getTempRet0() | 0;
 $cond = ($7 | 0) == 1;
 if ($cond) {
  $$reg2mem17$0 = $8;
 } else {
  $9 = $4 + 8 | 0;
  _setjmpTable = _saveSetjmp($9, 1, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  _setjmpTableSize = getTempRet0() | 0;
  __THREW__ = 0;
  $10 = __THREW__;
  __THREW__ = 0;
  if (($10 | 0) != 0 & (threwValue | 0) != 0) {
   $11 = _testSetjmp(HEAP32[$10 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($11 | 0) == 0) {
    _longjmp($10 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $11 = -1;
  }
  $12 = getTempRet0() | 0;
  $cond19 = ($11 | 0) == 1;
  if ($cond19) {
   $$reg2mem17$0 = $12;
  } else {
   $$reg2mem17$0 = 0;
  }
 }
 while (1) {
  $13 = ($$reg2mem17$0 | 0) == 0;
  if ($13) {
   __THREW__ = 0;
   invoke_viii(495, $0 | 0, $1 | 0, $2 | 0);
   $14 = __THREW__;
   __THREW__ = 0;
   if (($14 | 0) != 0 & (threwValue | 0) != 0) {
    $15 = _testSetjmp(HEAP32[$14 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($15 | 0) == 0) {
     _longjmp($14 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $15 = -1;
   }
   $16 = getTempRet0() | 0;
   $cond21 = ($15 | 0) == 1;
   if ($cond21) {
    $$reg2mem17$0 = $16;
    continue;
   }
   __THREW__ = 0;
   invoke_v(498);
   $17 = __THREW__;
   __THREW__ = 0;
   if (($17 | 0) != 0 & (threwValue | 0) != 0) {
    $18 = _testSetjmp(HEAP32[$17 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($18 | 0) == 0) {
     _longjmp($17 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $18 = -1;
   }
   $19 = getTempRet0() | 0;
   $cond22 = ($18 | 0) == 1;
   if ($cond22) {
    $$reg2mem17$0 = $19;
    continue;
   } else {
    label = 7;
    break;
   }
  }
  $20 = $5 & 1;
  if ($20) {
   label = 12;
   break;
  }
  $21 = $4 + 4 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  __THREW__ = 0;
  $24 = invoke_iii(499, $23 | 0, 15292 | 0) | 0;
  $25 = __THREW__;
  __THREW__ = 0;
  if (($25 | 0) != 0 & (threwValue | 0) != 0) {
   $26 = _testSetjmp(HEAP32[$25 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($26 | 0) == 0) {
    _longjmp($25 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $26 = -1;
  }
  $27 = getTempRet0() | 0;
  $cond20 = ($26 | 0) == 1;
  if ($cond20) {
   $$reg2mem17$0 = $27;
   continue;
  }
  if ($24) {
   label = 12;
   break;
  }
  $28 = $4 + 4 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  __THREW__ = 0;
  invoke_vi(500, $29 | 0);
  $30 = __THREW__;
  __THREW__ = 0;
  if (($30 | 0) != 0 & (threwValue | 0) != 0) {
   $31 = _testSetjmp(HEAP32[$30 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($31 | 0) == 0) {
    _longjmp($30 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $31 = -1;
  }
  $32 = getTempRet0() | 0;
  $$reg2mem17$0 = $32;
 }
 if ((label | 0) == 7) {
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 12) {
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return;
 }
}

function _mp_binary_get_val_array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = Math_fround(0), $74 = 0.0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0.0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = 0;
 $8 = $4;
 $9 = $8 << 24 >> 24;
 do {
  switch ($9 | 0) {
  case 98:
   {
    $10 = $5;
    $11 = $6;
    $12 = $10 + $11 | 0;
    $13 = HEAP8[$12 >> 0] | 0;
    $14 = $13 << 24 >> 24;
    $7 = $14;
    label = 16;
    break;
   }
  case 66:
  case 1:
   {
    $15 = $5;
    $16 = $6;
    $17 = $15 + $16 | 0;
    $18 = HEAP8[$17 >> 0] | 0;
    $19 = $18 & 255;
    $7 = $19;
    label = 16;
    break;
   }
  case 104:
   {
    $20 = $5;
    $21 = $6;
    $22 = $20 + ($21 << 1) | 0;
    $23 = HEAP16[$22 >> 1] | 0;
    $24 = $23 << 16 >> 16;
    $7 = $24;
    label = 16;
    break;
   }
  case 72:
   {
    $25 = $5;
    $26 = $6;
    $27 = $25 + ($26 << 1) | 0;
    $28 = HEAP16[$27 >> 1] | 0;
    $29 = $28 & 65535;
    $7 = $29;
    label = 16;
    break;
   }
  case 105:
   {
    $30 = $5;
    $31 = $6;
    $32 = $30 + ($31 << 2) | 0;
    $33 = HEAP32[$32 >> 2] | 0;
    $34 = _mp_obj_new_int($33) | 0;
    $3 = $34;
    break;
   }
  case 73:
   {
    $35 = $5;
    $36 = $6;
    $37 = $35 + ($36 << 2) | 0;
    $38 = HEAP32[$37 >> 2] | 0;
    $39 = _mp_obj_new_int_from_uint($38) | 0;
    $3 = $39;
    break;
   }
  case 108:
   {
    $40 = $5;
    $41 = $6;
    $42 = $40 + ($41 << 2) | 0;
    $43 = HEAP32[$42 >> 2] | 0;
    $44 = _mp_obj_new_int($43) | 0;
    $3 = $44;
    break;
   }
  case 76:
   {
    $45 = $5;
    $46 = $6;
    $47 = $45 + ($46 << 2) | 0;
    $48 = HEAP32[$47 >> 2] | 0;
    $49 = _mp_obj_new_int_from_uint($48) | 0;
    $3 = $49;
    break;
   }
  case 113:
   {
    $50 = $5;
    $51 = $6;
    $52 = $50 + ($51 << 3) | 0;
    $53 = $52;
    $54 = $53;
    $55 = HEAP32[$54 >> 2] | 0;
    $56 = $53 + 4 | 0;
    $57 = $56;
    $58 = HEAP32[$57 >> 2] | 0;
    $59 = _mp_obj_new_int_from_ll($55, $58) | 0;
    $3 = $59;
    break;
   }
  case 81:
   {
    $60 = $5;
    $61 = $6;
    $62 = $60 + ($61 << 3) | 0;
    $63 = $62;
    $64 = $63;
    $65 = HEAP32[$64 >> 2] | 0;
    $66 = $63 + 4 | 0;
    $67 = $66;
    $68 = HEAP32[$67 >> 2] | 0;
    $69 = _mp_obj_new_int_from_ull($65, $68) | 0;
    $3 = $69;
    break;
   }
  case 102:
   {
    $70 = $5;
    $71 = $6;
    $72 = $70 + ($71 << 2) | 0;
    $73 = Math_fround(HEAPF32[$72 >> 2]);
    $74 = +$73;
    $75 = _mp_obj_new_float($74) | 0;
    $3 = $75;
    break;
   }
  case 100:
   {
    $76 = $5;
    $77 = $6;
    $78 = $76 + ($77 << 3) | 0;
    $79 = +HEAPF64[$78 >> 3];
    $80 = _mp_obj_new_float($79) | 0;
    $3 = $80;
    break;
   }
  case 79:
   {
    $81 = $5;
    $82 = $6;
    $83 = $81 + ($82 << 2) | 0;
    $84 = HEAP32[$83 >> 2] | 0;
    $3 = $84;
    break;
   }
  case 80:
   {
    $85 = $5;
    $86 = $6;
    $87 = $85 + ($86 << 2) | 0;
    $88 = HEAP32[$87 >> 2] | 0;
    $89 = $88;
    $90 = _mp_obj_new_int($89) | 0;
    $3 = $90;
    break;
   }
  default:
   {
    label = 16;
   }
  }
 } while (0);
 if ((label | 0) == 16) {
  $91 = $7;
  $92 = $91 << 1;
  $93 = $92 | 1;
  $94 = $93;
  $3 = $94;
 }
 $95 = $3;
 STACKTOP = sp;
 return $95 | 0;
}

function _close_over_variables_etc($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $13 = $7;
 $14 = ($13 | 0) > 0;
 if ($14) {
  $15 = $5;
  $16 = $15 + 24 | 0;
  $17 = HEAP16[$16 >> 1] | 0;
  $18 = $17 & 65535;
  $19 = $18 | 8;
  $20 = $19 & 65535;
  HEAP16[$16 >> 1] = $20;
 }
 $21 = $6;
 $22 = $21 & 65535;
 $23 = $5;
 $24 = $23 + 32 | 0;
 HEAP16[$24 >> 1] = $22;
 $8 = 0;
 $25 = $4;
 $26 = $25 + 36 | 0;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = ($28 | 0) != 0;
 L4 : do {
  if ($29) {
   $9 = 0;
   while (1) {
    $30 = $9;
    $31 = $4;
    $32 = $31 + 36 | 0;
    $33 = HEAP32[$32 >> 2] | 0;
    $34 = $33 + 42 | 0;
    $35 = HEAP16[$34 >> 1] | 0;
    $36 = $35 & 65535;
    $37 = ($30 | 0) < ($36 | 0);
    if (!$37) {
     break L4;
    }
    $38 = $4;
    $39 = $38 + 36 | 0;
    $40 = HEAP32[$39 >> 2] | 0;
    $41 = $40 + 44 | 0;
    $42 = HEAP32[$41 >> 2] | 0;
    $43 = $9;
    $44 = $42 + ($43 << 3) | 0;
    $10 = $44;
    $45 = $10;
    $46 = HEAP8[$45 >> 0] | 0;
    $47 = $46 & 255;
    $48 = ($47 | 0) == 4;
    if ($48) {
     label = 8;
    } else {
     $49 = $10;
     $50 = HEAP8[$49 >> 0] | 0;
     $51 = $50 & 255;
     $52 = ($51 | 0) == 5;
     if ($52) {
      label = 8;
     }
    }
    L11 : do {
     if ((label | 0) == 8) {
      label = 0;
      $11 = 0;
      while (1) {
       $53 = $11;
       $54 = $5;
       $55 = $54 + 42 | 0;
       $56 = HEAP16[$55 >> 1] | 0;
       $57 = $56 & 65535;
       $58 = ($53 | 0) < ($57 | 0);
       if (!$58) {
        break L11;
       }
       $59 = $5;
       $60 = $59 + 44 | 0;
       $61 = HEAP32[$60 >> 2] | 0;
       $62 = $11;
       $63 = $61 + ($62 << 3) | 0;
       $12 = $63;
       $64 = $12;
       $65 = HEAP8[$64 >> 0] | 0;
       $66 = $65 & 255;
       $67 = ($66 | 0) == 5;
       if ($67) {
        $68 = $10;
        $69 = $68 + 4 | 0;
        $70 = HEAP32[$69 >> 2] | 0;
        $71 = $12;
        $72 = $71 + 4 | 0;
        $73 = HEAP32[$72 >> 2] | 0;
        $74 = ($70 | 0) == ($73 | 0);
        if ($74) {
         $75 = $4;
         $76 = $75 + 40 | 0;
         $77 = HEAP32[$76 >> 2] | 0;
         $78 = $10;
         $79 = $78 + 4 | 0;
         $80 = HEAP32[$79 >> 2] | 0;
         $81 = $10;
         $82 = $81 + 2 | 0;
         $83 = HEAP16[$82 >> 1] | 0;
         $84 = $83 & 65535;
         _mp_emit_bc_load_local($77, $80, $84, 0);
         $85 = $8;
         $86 = $85 + 1 | 0;
         $8 = $86;
        }
       }
       $87 = $11;
       $88 = $87 + 1 | 0;
       $11 = $88;
      }
     }
    } while (0);
    $89 = $9;
    $90 = $89 + 1 | 0;
    $9 = $90;
   }
  }
 } while (0);
 $91 = $8;
 $92 = ($91 | 0) == 0;
 $93 = $4;
 $94 = $93 + 40 | 0;
 $95 = HEAP32[$94 >> 2] | 0;
 $96 = $5;
 if ($92) {
  $97 = $6;
  $98 = $7;
  _mp_emit_bc_make_function($95, $96, $97, $98);
  STACKTOP = sp;
  return;
 } else {
  $99 = $8;
  $100 = $6;
  $101 = $7;
  _mp_emit_bc_make_closure($95, $96, $99, $100, $101);
  STACKTOP = sp;
  return;
 }
}

function _uni_print_quoted($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $9 = 0, $or$cond = 0, $vararg_buffer = 0, $vararg_buffer11 = 0, $vararg_buffer14 = 0, $vararg_buffer17 = 0, $vararg_buffer2 = 0, $vararg_buffer5 = 0, $vararg_buffer8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(96 | 0);
 $vararg_buffer17 = sp + 48 | 0;
 $vararg_buffer14 = sp + 40 | 0;
 $vararg_buffer11 = sp + 32 | 0;
 $vararg_buffer8 = sp + 24 | 0;
 $vararg_buffer5 = sp + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = 0;
 $7 = 0;
 $14 = $4;
 $8 = $14;
 $15 = $4;
 $16 = $5;
 $17 = $15 + $16 | 0;
 $9 = $17;
 while (1) {
  $18 = $7;
  $19 = $18 & 1;
  if ($19) {
   break;
  }
  $20 = $8;
  $21 = $9;
  $22 = $20 >>> 0 < $21 >>> 0;
  if (!$22) {
   break;
  }
  $23 = $8;
  $24 = HEAP8[$23 >> 0] | 0;
  $25 = $24 & 255;
  $26 = ($25 | 0) == 39;
  if ($26) {
   $6 = 1;
  } else {
   $27 = $8;
   $28 = HEAP8[$27 >> 0] | 0;
   $29 = $28 & 255;
   $30 = ($29 | 0) == 34;
   if ($30) {
    $7 = 1;
   }
  }
  $31 = $8;
  $32 = $31 + 1 | 0;
  $8 = $32;
 }
 $10 = 39;
 $33 = $6;
 $34 = $33 & 1;
 if ($34) {
  $35 = $7;
  $36 = $35 & 1;
  if (!$36) {
   $10 = 34;
  }
 }
 $37 = $3;
 $38 = $10;
 HEAP32[$vararg_buffer >> 2] = $38;
 _mp_printf($37, 32828, $vararg_buffer) | 0;
 $39 = $4;
 $11 = $39;
 $40 = $4;
 $41 = $5;
 $42 = $40 + $41 | 0;
 $12 = $42;
 while (1) {
  $43 = $11;
  $44 = $12;
  $45 = $43 >>> 0 < $44 >>> 0;
  if (!$45) {
   break;
  }
  $46 = $11;
  $47 = _utf8_get_char($46) | 0;
  $13 = $47;
  $48 = $11;
  $49 = _utf8_next_char($48) | 0;
  $11 = $49;
  $50 = $13;
  $51 = $10;
  $52 = ($50 | 0) == ($51 | 0);
  do {
   if ($52) {
    $53 = $3;
    $54 = $10;
    HEAP32[$vararg_buffer2 >> 2] = $54;
    _mp_printf($53, 32831, $vararg_buffer2) | 0;
   } else {
    $55 = $13;
    $56 = ($55 | 0) == 92;
    if ($56) {
     $57 = $3;
     _mp_print_str($57, 32835) | 0;
     break;
    }
    $58 = $13;
    $59 = 32 <= $58 >>> 0;
    $60 = $13;
    $61 = $60 >>> 0 <= 126;
    $or$cond = $59 & $61;
    if ($or$cond) {
     $62 = $3;
     $63 = $13;
     HEAP32[$vararg_buffer5 >> 2] = $63;
     _mp_printf($62, 32828, $vararg_buffer5) | 0;
     break;
    }
    $64 = $13;
    $65 = ($64 | 0) == 10;
    if ($65) {
     $66 = $3;
     _mp_print_str($66, 32838) | 0;
     break;
    }
    $67 = $13;
    $68 = ($67 | 0) == 13;
    if ($68) {
     $69 = $3;
     _mp_print_str($69, 32841) | 0;
     break;
    }
    $70 = $13;
    $71 = ($70 | 0) == 9;
    if ($71) {
     $72 = $3;
     _mp_print_str($72, 32844) | 0;
     break;
    }
    $73 = $13;
    $74 = $73 >>> 0 < 256;
    if ($74) {
     $75 = $3;
     $76 = $13;
     HEAP32[$vararg_buffer8 >> 2] = $76;
     _mp_printf($75, 32847, $vararg_buffer8) | 0;
     break;
    }
    $77 = $13;
    $78 = $77 >>> 0 < 65536;
    $79 = $3;
    $80 = $13;
    if ($78) {
     HEAP32[$vararg_buffer11 >> 2] = $80;
     _mp_printf($79, 32854, $vararg_buffer11) | 0;
     break;
    } else {
     HEAP32[$vararg_buffer14 >> 2] = $80;
     _mp_printf($79, 32861, $vararg_buffer14) | 0;
     break;
    }
   }
  } while (0);
 }
 $81 = $3;
 $82 = $10;
 HEAP32[$vararg_buffer17 >> 2] = $82;
 _mp_printf($81, 32828, $vararg_buffer17) | 0;
 STACKTOP = sp;
 return;
}

function _compile_funcdef_lambdef_param($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, $or$cond3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $9 = $3;
 $10 = $9 & 15;
 $11 = ($10 | 0) == 2;
 if ($11) {
  $4 = -1;
 } else {
  $12 = $3;
  $13 = $12;
  $14 = $13 + 4 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $15 & 255;
  $4 = $16;
 }
 $17 = $4;
 $18 = ($17 | 0) == 70;
 $19 = $4;
 $20 = ($19 | 0) == 78;
 $or$cond = $18 | $20;
 if ($or$cond) {
  $21 = $2;
  $22 = $21 + 6 | 0;
  HEAP8[$22 >> 0] = 1;
  STACKTOP = sp;
  return;
 }
 $23 = $4;
 $24 = ($23 | 0) == 71;
 $25 = $4;
 $26 = ($25 | 0) == 79;
 $or$cond3 = $24 | $26;
 if ($or$cond3) {
  STACKTOP = sp;
  return;
 }
 $27 = $4;
 $28 = ($27 | 0) == -1;
 do {
  if ($28) {
   $29 = $3;
   $5 = $29;
   $6 = 0;
  } else {
   $30 = $4;
   $31 = ($30 | 0) == 69;
   $32 = $3;
   $33 = $32;
   if ($31) {
    $7 = $33;
    $34 = $7;
    $35 = $34 + 8 | 0;
    $36 = HEAP32[$35 >> 2] | 0;
    $5 = $36;
    $37 = $7;
    $38 = $37 + 8 | 0;
    $39 = $38 + 8 | 0;
    $40 = HEAP32[$39 >> 2] | 0;
    $6 = $40;
    break;
   } else {
    $8 = $33;
    $41 = $8;
    $42 = $41 + 8 | 0;
    $43 = HEAP32[$42 >> 2] | 0;
    $5 = $43;
    $44 = $8;
    $45 = $44 + 8 | 0;
    $46 = $45 + 4 | 0;
    $47 = HEAP32[$46 >> 2] | 0;
    $6 = $47;
    break;
   }
  }
 } while (0);
 $48 = $6;
 $49 = ($48 | 0) == 0;
 $50 = $2;
 $51 = $50 + 6 | 0;
 $52 = HEAP8[$51 >> 0] | 0;
 $53 = $52 << 24 >> 24 != 0;
 if ($49) {
  if ($53) {
   STACKTOP = sp;
   return;
  }
  $54 = $2;
  $55 = $54 + 22 | 0;
  $56 = HEAP16[$55 >> 1] | 0;
  $57 = $56 & 65535;
  $58 = ($57 | 0) != 0;
  if (!$58) {
   STACKTOP = sp;
   return;
  }
  $59 = $2;
  $60 = $3;
  _compile_syntax_error($59, $60, 29127);
  STACKTOP = sp;
  return;
 }
 $61 = $2;
 if (!$53) {
  $97 = $61 + 22 | 0;
  $98 = HEAP16[$97 >> 1] | 0;
  $99 = $98 & 65535;
  $100 = $99 + 1 | 0;
  $101 = $100 & 65535;
  HEAP16[$97 >> 1] = $101;
  $102 = $2;
  $103 = $6;
  _compile_node($102, $103);
  STACKTOP = sp;
  return;
 }
 $62 = $61 + 20 | 0;
 $63 = HEAP16[$62 >> 1] | 0;
 $64 = $63 & 65535;
 $65 = $64 + 1 | 0;
 $66 = $65 & 65535;
 HEAP16[$62 >> 1] = $66;
 $67 = $2;
 $68 = $67 + 20 | 0;
 $69 = HEAP16[$68 >> 1] | 0;
 $70 = $69 & 65535;
 $71 = ($70 | 0) == 1;
 if ($71) {
  $72 = $2;
  $73 = $72 + 22 | 0;
  $74 = HEAP16[$73 >> 1] | 0;
  $75 = $74 & 65535;
  $76 = ($75 | 0) > 0;
  $77 = $2;
  $78 = $77 + 40 | 0;
  $79 = HEAP32[$78 >> 2] | 0;
  if ($76) {
   $80 = $2;
   $81 = $80 + 22 | 0;
   $82 = HEAP16[$81 >> 1] | 0;
   $83 = $82 & 65535;
   _mp_emit_bc_build($79, $83, 0);
  } else {
   _mp_emit_bc_load_null($79);
  }
  $84 = $2;
  $85 = $84 + 40 | 0;
  $86 = HEAP32[$85 >> 2] | 0;
  _mp_emit_bc_build($86, 0, 3);
 }
 $87 = $2;
 $88 = $6;
 _compile_node($87, $88);
 $89 = $2;
 $90 = $89 + 40 | 0;
 $91 = HEAP32[$90 >> 2] | 0;
 $92 = $5;
 $93 = $92 >>> 4;
 _mp_emit_bc_load_const_str($91, $93);
 $94 = $2;
 $95 = $94 + 40 | 0;
 $96 = HEAP32[$95 >> 2] | 0;
 _mp_emit_bc_store_map($96);
 STACKTOP = sp;
 return;
}

function _it_iternext($0) {
 $0 = $0 | 0;
 var $$0 = 0, $$reg2mem15$0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, $cond17 = 0, $cond18 = 0, $cond19 = 0, $or$cond = 0, _setjmpTable = 0, _setjmpTableSize = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 176 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(176 | 0);
 _setjmpTableSize = 4;
 _setjmpTable = _malloc(40) | 0;
 HEAP32[_setjmpTable >> 2] = 0;
 $1 = sp;
 __THREW__ = 0;
 invoke_ii(496, $1 | 0) | 0;
 $2 = __THREW__;
 __THREW__ = 0;
 if (($2 | 0) != 0 & (threwValue | 0) != 0) {
  $3 = _testSetjmp(HEAP32[$2 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  if (($3 | 0) == 0) {
   _longjmp($2 | 0, threwValue | 0);
  }
  setTempRet0(threwValue | 0);
 } else {
  $3 = -1;
 }
 $4 = getTempRet0() | 0;
 $cond = ($3 | 0) == 1;
 if ($cond) {
  $$reg2mem15$0 = $4;
 } else {
  $5 = $1 + 8 | 0;
  _setjmpTable = _saveSetjmp($5, 1, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  _setjmpTableSize = getTempRet0() | 0;
  __THREW__ = 0;
  $6 = __THREW__;
  __THREW__ = 0;
  if (($6 | 0) != 0 & (threwValue | 0) != 0) {
   $7 = _testSetjmp(HEAP32[$6 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($7 | 0) == 0) {
    _longjmp($6 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $7 = -1;
  }
  $8 = getTempRet0() | 0;
  $cond17 = ($7 | 0) == 1;
  if ($cond17) {
   $$reg2mem15$0 = $8;
  } else {
   $$reg2mem15$0 = 0;
  }
 }
 while (1) {
  $9 = ($$reg2mem15$0 | 0) == 0;
  if ($9) {
   $10 = $0 + 4 | 0;
   __THREW__ = 0;
   $11 = invoke_iiii(497, 1, 0, $10 | 0) | 0;
   $12 = __THREW__;
   __THREW__ = 0;
   if (($12 | 0) != 0 & (threwValue | 0) != 0) {
    $13 = _testSetjmp(HEAP32[$12 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($13 | 0) == 0) {
     _longjmp($12 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $13 = -1;
   }
   $14 = getTempRet0() | 0;
   $cond18 = ($13 | 0) == 1;
   if ($cond18) {
    $$reg2mem15$0 = $14;
    continue;
   }
   $15 = $0 + 4 | 0;
   $16 = $15 + 8 | 0;
   $17 = HEAP32[$16 >> 2] | 0;
   $18 = $17;
   $19 = $18 >> 1;
   $20 = $19 + 1 | 0;
   $21 = $20 << 1;
   $22 = $21 | 1;
   $23 = $22;
   $24 = $0 + 4 | 0;
   $25 = $24 + 8 | 0;
   HEAP32[$25 >> 2] = $23;
   __THREW__ = 0;
   invoke_v(498);
   $26 = __THREW__;
   __THREW__ = 0;
   if (($26 | 0) != 0 & (threwValue | 0) != 0) {
    $27 = _testSetjmp(HEAP32[$26 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($27 | 0) == 0) {
     _longjmp($26 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $27 = -1;
   }
   $28 = getTempRet0() | 0;
   $cond19 = ($27 | 0) == 1;
   if ($cond19) {
    $$reg2mem15$0 = $28;
    continue;
   } else {
    label = 7;
    break;
   }
  } else {
   $29 = $1 + 4 | 0;
   $30 = HEAP32[$29 >> 2] | 0;
   $31 = HEAP32[$30 >> 2] | 0;
   $32 = ($31 | 0) == (14676 | 0);
   $33 = ($31 | 0) == (15532 | 0);
   $or$cond = $32 | $33;
   if ($or$cond) {
    label = 9;
    break;
   }
   $34 = $1 + 4 | 0;
   $35 = HEAP32[$34 >> 2] | 0;
   __THREW__ = 0;
   invoke_vi(500, $35 | 0);
   $36 = __THREW__;
   __THREW__ = 0;
   if (($36 | 0) != 0 & (threwValue | 0) != 0) {
    $37 = _testSetjmp(HEAP32[$36 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($37 | 0) == 0) {
     _longjmp($36 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $37 = -1;
   }
   $38 = getTempRet0() | 0;
   $$reg2mem15$0 = $38;
   continue;
  }
 }
 if ((label | 0) == 7) {
  $$0 = $11;
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$0 | 0;
 } else if ((label | 0) == 9) {
  $$0 = 0;
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$0 | 0;
 }
 return 0 | 0;
}

function _fold_logical_constants($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$expand_i1_val4 = 0, $$expand_i1_val6 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = sp + 29 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $12 = $5;
 $13 = $12 & 255;
 $14 = ($13 | 0) == 29;
 if (!$14) {
  $15 = $5;
  $16 = $15 & 255;
  $17 = ($16 | 0) == 30;
  if (!$17) {
   $68 = $5;
   $69 = $68 & 255;
   $70 = ($69 | 0) == 31;
   if (!$70) {
    $$expand_i1_val6 = 0;
    HEAP8[$3 >> 0] = $$expand_i1_val6;
    $$pre_trunc = HEAP8[$3 >> 0] | 0;
    $82 = $$pre_trunc & 1;
    STACKTOP = sp;
    return $82 | 0;
   }
   $71 = $4;
   $72 = _peek_result($71, 0) | 0;
   $11 = $72;
   $73 = $11;
   $74 = _mp_parse_node_is_const_false($73) | 0;
   do {
    if ($74) {
     $75 = _mp_parse_node_new_leaf(14, 15) | 0;
     $11 = $75;
    } else {
     $76 = $11;
     $77 = _mp_parse_node_is_const_true($76) | 0;
     if ($77) {
      $78 = _mp_parse_node_new_leaf(14, 13) | 0;
      $11 = $78;
      break;
     }
     $$expand_i1_val2 = 0;
     HEAP8[$3 >> 0] = $$expand_i1_val2;
     $$pre_trunc = HEAP8[$3 >> 0] | 0;
     $82 = $$pre_trunc & 1;
     STACKTOP = sp;
     return $82 | 0;
    }
   } while (0);
   $79 = $4;
   _pop_result($79) | 0;
   $80 = $4;
   $81 = $11;
   _push_result_node($80, $81);
   $$expand_i1_val4 = 1;
   HEAP8[$3 >> 0] = $$expand_i1_val4;
   $$pre_trunc = HEAP8[$3 >> 0] | 0;
   $82 = $$pre_trunc & 1;
   STACKTOP = sp;
   return $82 | 0;
  }
 }
 $18 = $6;
 $19 = HEAP32[$18 >> 2] | 0;
 $7 = $19;
 $20 = $7;
 $8 = $20;
 while (1) {
  $21 = $8;
  $22 = $21 >>> 0 > 0;
  if (!$22) {
   break;
  }
  $23 = $4;
  $24 = $8;
  $25 = $24 + -1 | 0;
  $8 = $25;
  $26 = _peek_result($23, $25) | 0;
  $9 = $26;
  $27 = $9;
  $28 = $4;
  $29 = $28 + 20 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = $4;
  $32 = $31 + 16 | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = $7;
  $35 = $33 - $34 | 0;
  $36 = $30 + ($35 << 2) | 0;
  HEAP32[$36 >> 2] = $27;
  $37 = $8;
  $38 = ($37 | 0) == 0;
  if ($38) {
   break;
  }
  $39 = $5;
  $40 = $39 & 255;
  $41 = ($40 | 0) == 29;
  $42 = $9;
  if ($41) {
   $43 = _mp_parse_node_is_const_true($42) | 0;
   if ($43) {
    break;
   }
   $44 = $9;
   $45 = _mp_parse_node_is_const_false($44) | 0;
   if (!$45) {
    $46 = $7;
    $47 = $46 - 1 | 0;
    $7 = $47;
   }
  } else {
   $48 = _mp_parse_node_is_const_false($42) | 0;
   if ($48) {
    break;
   }
   $49 = $9;
   $50 = _mp_parse_node_is_const_true($49) | 0;
   if (!$50) {
    $51 = $7;
    $52 = $51 - 1 | 0;
    $7 = $52;
   }
  }
 }
 $53 = $7;
 $54 = $53 - 1 | 0;
 $7 = $54;
 $10 = 0;
 while (1) {
  $55 = $10;
  $56 = $7;
  $57 = $55 >>> 0 < $56 >>> 0;
  if (!$57) {
   break;
  }
  $58 = $4;
  _pop_result($58) | 0;
  $59 = $10;
  $60 = $59 + 1 | 0;
  $10 = $60;
 }
 $61 = $7;
 $62 = $6;
 $63 = HEAP32[$62 >> 2] | 0;
 $64 = $63 - $61 | 0;
 HEAP32[$62 >> 2] = $64;
 $65 = $6;
 $66 = HEAP32[$65 >> 2] | 0;
 $67 = ($66 | 0) == 1;
 $$expand_i1_val = $67 & 1;
 HEAP8[$3 >> 0] = $$expand_i1_val;
 $$pre_trunc = HEAP8[$3 >> 0] | 0;
 $82 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $82 | 0;
}

function _str_subscr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $9 = sp + 28 | 0;
 $10 = sp + 24 | 0;
 $11 = sp + 20 | 0;
 $12 = sp + 16 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $18 = $4;
 $19 = _mp_obj_get_type($18) | 0;
 $7 = $19;
 $20 = $4;
 $21 = _mp_obj_is_qstr_1200($20) | 0;
 $22 = $4;
 if ($21) {
  $23 = $22;
  $24 = $23 >>> 2;
  $25 = _qstr_data($24, $9) | 0;
  $8 = $25;
 } else {
  $26 = $22 + 8 | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  HEAP32[$9 >> 2] = $27;
  $28 = $4;
  $29 = $28 + 12 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $8 = $30;
 }
 $31 = $6;
 $32 = ($31 | 0) == (4 | 0);
 if (!$32) {
  $3 = 0;
  $98 = $3;
  STACKTOP = sp;
  return $98 | 0;
 }
 $33 = $5;
 $34 = _mp_obj_is_obj_1201($33) | 0;
 if ($34) {
  $35 = $5;
  $36 = HEAP32[$35 >> 2] | 0;
  $37 = ($36 | 0) == (18228 | 0);
  if ($37) {
   $38 = $5;
   _mp_obj_slice_get($38, $10, $11, $12);
   $39 = HEAP32[$12 >> 2] | 0;
   $40 = ($39 | 0) != (17668 | 0);
   $41 = HEAP32[$12 >> 2] | 0;
   $42 = ($41 | 0) != (3 | 0);
   $or$cond = $40 & $42;
   if ($or$cond) {
    _mp_raise_NotImplementedError(32934);
   }
   $43 = HEAP32[$10 >> 2] | 0;
   $44 = ($43 | 0) != (17668 | 0);
   if ($44) {
    $45 = $7;
    $46 = $8;
    $47 = HEAP32[$9 >> 2] | 0;
    $48 = HEAP32[$10 >> 2] | 0;
    $49 = _str_index_to_ptr($45, $46, $47, $48, 1) | 0;
    $13 = $49;
   } else {
    $50 = $8;
    $13 = $50;
   }
   $51 = HEAP32[$11 >> 2] | 0;
   $52 = ($51 | 0) != (17668 | 0);
   if ($52) {
    $53 = $7;
    $54 = $8;
    $55 = HEAP32[$9 >> 2] | 0;
    $56 = HEAP32[$11 >> 2] | 0;
    $57 = _str_index_to_ptr($53, $54, $55, $56, 1) | 0;
    $14 = $57;
   } else {
    $58 = $8;
    $59 = HEAP32[$9 >> 2] | 0;
    $60 = $58 + $59 | 0;
    $14 = $60;
   }
   $61 = $14;
   $62 = $13;
   $63 = $61 >>> 0 < $62 >>> 0;
   if ($63) {
    $3 = 6;
    $98 = $3;
    STACKTOP = sp;
    return $98 | 0;
   } else {
    $64 = $7;
    $65 = $13;
    $66 = $14;
    $67 = $13;
    $68 = $66;
    $69 = $67;
    $70 = $68 - $69 | 0;
    $71 = _mp_obj_new_str_of_type($64, $65, $70) | 0;
    $3 = $71;
    $98 = $3;
    STACKTOP = sp;
    return $98 | 0;
   }
  }
 }
 $72 = $7;
 $73 = $8;
 $74 = HEAP32[$9 >> 2] | 0;
 $75 = $5;
 $76 = _str_index_to_ptr($72, $73, $74, $75, 0) | 0;
 $15 = $76;
 $16 = 1;
 $77 = $15;
 $78 = HEAP8[$77 >> 0] | 0;
 $79 = $78 & 255;
 $80 = $79 & 128;
 $81 = ($80 | 0) != 0;
 L29 : do {
  if ($81) {
   $17 = 64;
   while (1) {
    $82 = $15;
    $83 = HEAP8[$82 >> 0] | 0;
    $84 = $83 & 255;
    $85 = $17;
    $86 = $85 << 24 >> 24;
    $87 = $84 & $86;
    $88 = ($87 | 0) != 0;
    if (!$88) {
     break L29;
    }
    $89 = $16;
    $90 = $89 + 1 | 0;
    $16 = $90;
    $91 = $17;
    $92 = $91 << 24 >> 24;
    $93 = $92 >> 1;
    $94 = $93 & 255;
    $17 = $94;
   }
  }
 } while (0);
 $95 = $15;
 $96 = $16;
 $97 = _mp_obj_new_str_via_qstr($95, $96) | 0;
 $3 = $97;
 $98 = $3;
 STACKTOP = sp;
 return $98 | 0;
}

function _compile_subscript($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $6 = $5 + 4 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $7 & 255;
 $9 = ($8 | 0) == 51;
 $10 = $2;
 if ($9) {
  $11 = $3;
  $12 = $11 + 8 | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  _compile_node($10, $13);
  $14 = $3;
  $15 = $14 + 8 | 0;
  $16 = $15 + 4 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = $17;
  $3 = $18;
 } else {
  $19 = $10 + 40 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  _mp_emit_bc_load_const_tok($20, 14);
 }
 $21 = $3;
 $22 = $21 + 8 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $4 = $23;
 $24 = $4;
 $25 = ($24 | 0) == 0;
 if ($25) {
  $26 = $2;
  $27 = $26 + 40 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  _mp_emit_bc_load_const_tok($28, 14);
  $29 = $2;
  $30 = $29 + 40 | 0;
  $31 = HEAP32[$30 >> 2] | 0;
  _mp_emit_bc_build($31, 2, 8);
  STACKTOP = sp;
  return;
 }
 $32 = $4;
 $33 = ($32 | 0) != 0;
 if ($33) {
  $34 = $4;
  $35 = $34 & 3;
  $36 = ($35 | 0) == 0;
  if ($36) {
   $37 = $4;
   $38 = $37;
   $3 = $38;
   $39 = $3;
   $40 = $39 + 4 | 0;
   $41 = HEAP32[$40 >> 2] | 0;
   $42 = $41 & 255;
   $43 = ($42 | 0) == 152;
   if ($43) {
    $44 = $2;
    $45 = $44 + 40 | 0;
    $46 = HEAP32[$45 >> 2] | 0;
    _mp_emit_bc_load_const_tok($46, 14);
    $47 = $3;
    $48 = $47 + 8 | 0;
    $49 = HEAP32[$48 >> 2] | 0;
    $4 = $49;
    $50 = $4;
    $51 = ($50 | 0) == 0;
    $52 = $2;
    if ($51) {
     $53 = $52 + 40 | 0;
     $54 = HEAP32[$53 >> 2] | 0;
     _mp_emit_bc_build($54, 2, 8);
     STACKTOP = sp;
     return;
    } else {
     $55 = $4;
     _compile_node($52, $55);
     $56 = $2;
     $57 = $56 + 40 | 0;
     $58 = HEAP32[$57 >> 2] | 0;
     _mp_emit_bc_build($58, 3, 8);
     STACKTOP = sp;
     return;
    }
   }
   $59 = $3;
   $60 = $59 + 4 | 0;
   $61 = HEAP32[$60 >> 2] | 0;
   $62 = $61 & 255;
   $63 = ($62 | 0) == 153;
   $64 = $2;
   if (!$63) {
    $86 = $4;
    _compile_node($64, $86);
    $87 = $2;
    $88 = $87 + 40 | 0;
    $89 = HEAP32[$88 >> 2] | 0;
    _mp_emit_bc_build($89, 2, 8);
    STACKTOP = sp;
    return;
   }
   $65 = $3;
   $66 = $65 + 8 | 0;
   $67 = HEAP32[$66 >> 2] | 0;
   _compile_node($64, $67);
   $68 = $3;
   $69 = $68 + 8 | 0;
   $70 = $69 + 4 | 0;
   $71 = HEAP32[$70 >> 2] | 0;
   $72 = $71;
   $3 = $72;
   $73 = $3;
   $74 = $73 + 8 | 0;
   $75 = HEAP32[$74 >> 2] | 0;
   $76 = ($75 | 0) == 0;
   $77 = $2;
   if ($76) {
    $78 = $77 + 40 | 0;
    $79 = HEAP32[$78 >> 2] | 0;
    _mp_emit_bc_build($79, 2, 8);
    STACKTOP = sp;
    return;
   } else {
    $80 = $3;
    $81 = $80 + 8 | 0;
    $82 = HEAP32[$81 >> 2] | 0;
    _compile_node($77, $82);
    $83 = $2;
    $84 = $83 + 40 | 0;
    $85 = HEAP32[$84 >> 2] | 0;
    _mp_emit_bc_build($85, 3, 8);
    STACKTOP = sp;
    return;
   }
  }
 }
 $90 = $2;
 $91 = $4;
 _compile_node($90, $91);
 $92 = $2;
 $93 = $92 + 40 | 0;
 $94 = HEAP32[$93 >> 2] | 0;
 _mp_emit_bc_build($94, 2, 8);
 STACKTOP = sp;
 return;
}

function _mp_binary_set_val($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $105 = 0, $106 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0.0, $44 = Math_fround(0), $45 = 0, $46 = 0, $47 = 0.0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $9 = sp + 28 | 0;
 $12 = sp + 16 | 0;
 $13 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $16 = $7;
 $17 = HEAP32[$16 >> 2] | 0;
 $8 = $17;
 $18 = $4;
 $19 = $5;
 $20 = _mp_binary_get_size($18, $19, $9) | 0;
 $10 = $20;
 $21 = $4;
 $22 = $21 << 24 >> 24;
 $23 = ($22 | 0) == 64;
 if ($23) {
  $24 = $8;
  $25 = $24;
  $26 = HEAP32[$9 >> 2] | 0;
  $27 = $26 - 1 | 0;
  $28 = $25 + $27 | 0;
  $29 = HEAP32[$9 >> 2] | 0;
  $30 = $29 - 1 | 0;
  $31 = $30 ^ -1;
  $32 = $28 & $31;
  $33 = $32;
  $8 = $33;
  $4 = 60;
 }
 $34 = $8;
 $35 = $10;
 $36 = $34 + $35 | 0;
 $37 = $7;
 HEAP32[$37 >> 2] = $36;
 $38 = $5;
 $39 = $38 << 24 >> 24;
 switch ($39 | 0) {
 case 79:
  {
   $40 = $6;
   $41 = $40;
   $11 = $41;
   break;
  }
 case 102:
  {
   $42 = $6;
   $43 = +_mp_obj_get_float($42);
   $44 = Math_fround($43);
   HEAPF32[$12 >> 2] = $44;
   $45 = HEAP32[$12 >> 2] | 0;
   $11 = $45;
   break;
  }
 case 100:
  {
   $46 = $6;
   $47 = +_mp_obj_get_float($46);
   HEAPF64[$13 >> 3] = $47;
   $48 = $4;
   $49 = $48 << 24 >> 24;
   $50 = ($49 | 0) == 62;
   $51 = $50 & 1;
   $14 = $51;
   $52 = $14;
   $53 = ($52 | 0) != 0;
   $54 = $8;
   $55 = $14;
   $56 = 0 ^ $55;
   $57 = $13 + ($56 << 2) | 0;
   $58 = HEAP32[$57 >> 2] | 0;
   _mp_binary_set_int(4, $53, $54, $58);
   $59 = $8;
   $60 = $59 + 4 | 0;
   $8 = $60;
   $61 = $14;
   $62 = 1 ^ $61;
   $63 = $13 + ($62 << 2) | 0;
   $64 = HEAP32[$63 >> 2] | 0;
   $11 = $64;
   break;
  }
 default:
  {
   $65 = $6;
   $66 = _mp_obj_is_obj_1345($65) | 0;
   if ($66) {
    $67 = $6;
    $68 = HEAP32[$67 >> 2] | 0;
    $69 = ($68 | 0) == (16904 | 0);
    if ($69) {
     $70 = $6;
     $71 = $4;
     $72 = $71 << 24 >> 24;
     $73 = ($72 | 0) == 62;
     $74 = $10;
     $75 = $8;
     _mp_obj_int_to_bytes_impl($70, $73, $74, $75);
     STACKTOP = sp;
     return;
    }
   }
   $76 = $6;
   $77 = _mp_obj_get_int($76) | 0;
   $11 = $77;
   $78 = $10;
   $79 = $78 >>> 0 > 4;
   if ($79) {
    $80 = $5;
    $81 = $80 << 24 >> 24;
    $82 = ($81 | 0) > 90;
    $83 = $11;
    $84 = ($83 | 0) < 0;
    $85 = $82 ? $84 : 0;
    $86 = $85 ? 255 : 0;
    $15 = $86;
    $87 = $8;
    $88 = $15;
    $89 = $88 & 255;
    $90 = $10;
    _memset($87 | 0, $89 | 0, $90 | 0) | 0;
    $91 = $4;
    $92 = $91 << 24 >> 24;
    $93 = ($92 | 0) == 62;
    if ($93) {
     $94 = $10;
     $95 = $94 - 4 | 0;
     $96 = $8;
     $97 = $96 + $95 | 0;
     $8 = $97;
    }
   }
  }
 }
 $98 = $10;
 $99 = $98 >>> 0 < 4;
 $100 = $10;
 $101 = $99 ? $100 : 4;
 $102 = $4;
 $103 = $102 << 24 >> 24;
 $104 = ($103 | 0) == 62;
 $105 = $8;
 $106 = $11;
 _mp_binary_set_int($101, $104, $105, $106);
 STACKTOP = sp;
 return;
}

function _tinf_decode_trees($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 384 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(384 | 0);
 $7 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $20 = $4;
 $21 = _tinf_read_bits($20, 5, 257) | 0;
 $8 = $21;
 $22 = $4;
 $23 = _tinf_read_bits($22, 5, 1) | 0;
 $9 = $23;
 $24 = $4;
 $25 = _tinf_read_bits($24, 4, 4) | 0;
 $10 = $25;
 $12 = 0;
 while (1) {
  $26 = $12;
  $27 = $26 >>> 0 < 19;
  if (!$27) {
   break;
  }
  $28 = $12;
  $29 = $7 + $28 | 0;
  HEAP8[$29 >> 0] = 0;
  $30 = $12;
  $31 = $30 + 1 | 0;
  $12 = $31;
 }
 $12 = 0;
 while (1) {
  $32 = $12;
  $33 = $10;
  $34 = $32 >>> 0 < $33 >>> 0;
  if (!$34) {
   break;
  }
  $35 = $4;
  $36 = _tinf_read_bits($35, 3, 0) | 0;
  $15 = $36;
  $37 = $15;
  $38 = $37 & 255;
  $39 = $12;
  $40 = 7856 + $39 | 0;
  $41 = HEAP8[$40 >> 0] | 0;
  $42 = $41 & 255;
  $43 = $7 + $42 | 0;
  HEAP8[$43 >> 0] = $38;
  $44 = $12;
  $45 = $44 + 1 | 0;
  $12 = $45;
 }
 $46 = $5;
 _tinf_build_tree($46, $7, 19);
 $47 = $8;
 $48 = $9;
 $49 = $47 + $48 | 0;
 $11 = $49;
 $13 = 0;
 L9 : while (1) {
  $50 = $13;
  $51 = $11;
  $52 = $50 >>> 0 < $51 >>> 0;
  if (!$52) {
   label = 24;
   break;
  }
  $53 = $4;
  $54 = $5;
  $55 = _tinf_decode_symbol($53, $54) | 0;
  $16 = $55;
  $17 = 0;
  $19 = 3;
  $56 = $16;
  $57 = ($56 | 0) < 0;
  $58 = $16;
  if ($57) {
   label = 10;
   break;
  }
  switch ($58 | 0) {
  case 16:
   {
    $59 = $13;
    $60 = ($59 | 0) == 0;
    if ($60) {
     label = 13;
     break L9;
    }
    $61 = $13;
    $62 = $61 - 1 | 0;
    $63 = $7 + $62 | 0;
    $64 = HEAP8[$63 >> 0] | 0;
    $17 = $64;
    $18 = 2;
    break;
   }
  case 17:
   {
    $18 = 3;
    break;
   }
  case 18:
   {
    $18 = 7;
    $19 = 11;
    break;
   }
  default:
   {
    $65 = $16;
    $66 = $65 & 255;
    $67 = $13;
    $68 = $67 + 1 | 0;
    $13 = $68;
    $69 = $7 + $67 | 0;
    HEAP8[$69 >> 0] = $66;
    continue L9;
   }
  }
  $70 = $4;
  $71 = $18;
  $72 = $19;
  $73 = _tinf_read_bits($70, $71, $72) | 0;
  $14 = $73;
  $74 = $13;
  $75 = $14;
  $76 = $74 + $75 | 0;
  $77 = $11;
  $78 = $76 >>> 0 > $77 >>> 0;
  if ($78) {
   label = 19;
   break;
  }
  while (1) {
   $79 = $14;
   $80 = ($79 | 0) != 0;
   if (!$80) {
    break;
   }
   $81 = $17;
   $82 = $13;
   $83 = $82 + 1 | 0;
   $13 = $83;
   $84 = $7 + $82 | 0;
   HEAP8[$84 >> 0] = $81;
   $85 = $14;
   $86 = $85 + -1 | 0;
   $14 = $86;
  }
 }
 if ((label | 0) == 10) {
  $3 = $58;
  $93 = $3;
  STACKTOP = sp;
  return $93 | 0;
 } else if ((label | 0) == 13) {
  $3 = -3;
  $93 = $3;
  STACKTOP = sp;
  return $93 | 0;
 } else if ((label | 0) == 19) {
  $3 = -3;
  $93 = $3;
  STACKTOP = sp;
  return $93 | 0;
 } else if ((label | 0) == 24) {
  $87 = $5;
  $88 = $8;
  _tinf_build_tree($87, $7, $88);
  $89 = $6;
  $90 = $8;
  $91 = $7 + $90 | 0;
  $92 = $9;
  _tinf_build_tree($89, $91, $92);
  $3 = 0;
  $93 = $3;
  STACKTOP = sp;
  return $93 | 0;
 }
 return 0 | 0;
}

function _mp_obj_exception_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $or$cond = 0, $or$cond3 = 0, $vararg_buffer = 0, $vararg_ptr4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $10 = $4;
 $6 = $10;
 $11 = $5;
 $12 = $11 & -129;
 $7 = $12;
 $13 = $5;
 $14 = $13 & 128;
 $15 = ($14 | 0) != 0;
 $16 = $15 & 1;
 $8 = $16;
 $17 = $8;
 $18 = $17 & 1;
 if (!$18) {
  $19 = $7;
  $20 = ($19 | 0) == 1;
  $21 = $7;
  $22 = ($21 | 0) == 2;
  $or$cond = $20 | $22;
  if ($or$cond) {
   $23 = $3;
   $24 = $6;
   $25 = HEAP32[$24 >> 2] | 0;
   $26 = $25 + 6 | 0;
   $27 = HEAP16[$26 >> 1] | 0;
   $28 = $27 & 65535;
   $29 = _qstr_str($28) | 0;
   _mp_print_str($23, $29) | 0;
  }
 }
 $30 = $7;
 $31 = ($30 | 0) == 2;
 if ($31) {
  $32 = $3;
  _mp_print_str($32, 31090) | 0;
 }
 $33 = $7;
 $34 = ($33 | 0) == 0;
 $35 = $7;
 $36 = ($35 | 0) == 2;
 $or$cond3 = $34 | $36;
 do {
  if ($or$cond3) {
   $37 = $6;
   $38 = $37 + 12 | 0;
   $39 = HEAP32[$38 >> 2] | 0;
   $40 = ($39 | 0) == (0 | 0);
   if (!$40) {
    $41 = $6;
    $42 = $41 + 12 | 0;
    $43 = HEAP32[$42 >> 2] | 0;
    $44 = $43 + 4 | 0;
    $45 = HEAP32[$44 >> 2] | 0;
    $46 = ($45 | 0) == 0;
    if (!$46) {
     $48 = $6;
     $49 = $48 + 12 | 0;
     $50 = HEAP32[$49 >> 2] | 0;
     $51 = $50 + 4 | 0;
     $52 = HEAP32[$51 >> 2] | 0;
     $53 = ($52 | 0) == 1;
     if (!$53) {
      break;
     }
     $54 = $6;
     $55 = HEAP32[$54 >> 2] | 0;
     $56 = ($55 | 0) == (14796 | 0);
     if ($56) {
      $57 = $6;
      $58 = $57 + 12 | 0;
      $59 = HEAP32[$58 >> 2] | 0;
      $60 = $59 + 8 | 0;
      $61 = HEAP32[$60 >> 2] | 0;
      $62 = _mp_obj_is_small_int_909($61) | 0;
      if ($62) {
       $63 = $6;
       $64 = $63 + 12 | 0;
       $65 = HEAP32[$64 >> 2] | 0;
       $66 = $65 + 8 | 0;
       $67 = HEAP32[$66 >> 2] | 0;
       $68 = _mp_errno_to_str($67) | 0;
       $9 = $68;
       $69 = $9;
       $70 = ($69 | 0) != 0;
       if ($70) {
        $71 = $3;
        $72 = $6;
        $73 = $72 + 12 | 0;
        $74 = HEAP32[$73 >> 2] | 0;
        $75 = $74 + 8 | 0;
        $76 = HEAP32[$75 >> 2] | 0;
        $77 = $76;
        $78 = $77 >> 1;
        $79 = $9;
        HEAP32[$vararg_buffer >> 2] = $78;
        $vararg_ptr4 = $vararg_buffer + 4 | 0;
        HEAP32[$vararg_ptr4 >> 2] = $79;
        _mp_printf($71, 31093, $vararg_buffer) | 0;
        STACKTOP = sp;
        return;
       }
      }
     }
     $80 = $3;
     $81 = $6;
     $82 = $81 + 12 | 0;
     $83 = HEAP32[$82 >> 2] | 0;
     $84 = $83 + 8 | 0;
     $85 = HEAP32[$84 >> 2] | 0;
     _mp_obj_print_helper($80, $85, 0);
     STACKTOP = sp;
     return;
    }
   }
   $47 = $3;
   _mp_print_str($47, 41653) | 0;
   STACKTOP = sp;
   return;
  }
 } while (0);
 $86 = $3;
 $87 = $6;
 $88 = $87 + 12 | 0;
 $89 = HEAP32[$88 >> 2] | 0;
 $90 = $5;
 _mp_obj_tuple_print($86, $89, $90);
 STACKTOP = sp;
 return;
}

function _mpz_shr_inpl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $8 = sp + 24 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $10 = $4;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = ($12 | 0) == 0;
 $14 = $5;
 $15 = ($14 | 0) == 0;
 $or$cond = $13 | $15;
 $16 = $3;
 $17 = $4;
 if ($or$cond) {
  _mpz_set($16, $17);
  STACKTOP = sp;
  return;
 }
 $18 = $17 + 4 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 _mpz_need_dig($16, $19);
 $20 = $3;
 $21 = $20 + 8 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = $4;
 $24 = $23 + 8 | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = $4;
 $27 = $26 + 4 | 0;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = $5;
 $30 = _mpn_shr($22, $25, $28, $29) | 0;
 $31 = $3;
 $32 = $31 + 4 | 0;
 HEAP32[$32 >> 2] = $30;
 $33 = $4;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = $34 & 1;
 $36 = $3;
 $37 = HEAP32[$36 >> 2] | 0;
 $38 = $35 & 1;
 $39 = $37 & -2;
 $40 = $39 | $38;
 HEAP32[$36 >> 2] = $40;
 $41 = $3;
 $42 = HEAP32[$41 >> 2] | 0;
 $43 = $42 & 1;
 $44 = ($43 | 0) != 0;
 if (!$44) {
  STACKTOP = sp;
  return;
 }
 $45 = $5;
 $46 = ($45 >>> 0) / 16 & -1;
 $6 = $46;
 $47 = $5;
 $48 = ($47 >>> 0) % 16 & -1;
 $7 = $48;
 HEAP16[$8 >> 1] = 0;
 $9 = 0;
 while (1) {
  $49 = $9;
  $50 = $4;
  $51 = $50 + 4 | 0;
  $52 = HEAP32[$51 >> 2] | 0;
  $53 = $49 >>> 0 < $52 >>> 0;
  if (!$53) {
   break;
  }
  $54 = $9;
  $55 = $6;
  $56 = $54 >>> 0 < $55 >>> 0;
  if (!$56) {
   break;
  }
  $57 = $4;
  $58 = $57 + 8 | 0;
  $59 = HEAP32[$58 >> 2] | 0;
  $60 = $9;
  $61 = $59 + ($60 << 1) | 0;
  $62 = HEAP16[$61 >> 1] | 0;
  $63 = $62 & 65535;
  $64 = ($63 | 0) != 0;
  if ($64) {
   label = 8;
   break;
  }
  $65 = $9;
  $66 = $65 + 1 | 0;
  $9 = $66;
 }
 if ((label | 0) == 8) {
  HEAP16[$8 >> 1] = 1;
 }
 $67 = $6;
 $68 = $4;
 $69 = $68 + 4 | 0;
 $70 = HEAP32[$69 >> 2] | 0;
 $71 = $67 >>> 0 < $70 >>> 0;
 if ($71) {
  $72 = $4;
  $73 = $72 + 8 | 0;
  $74 = HEAP32[$73 >> 2] | 0;
  $75 = $6;
  $76 = $74 + ($75 << 1) | 0;
  $77 = HEAP16[$76 >> 1] | 0;
  $78 = $77 & 65535;
  $79 = $7;
  $80 = 1 << $79;
  $81 = $80 - 1 | 0;
  $82 = $78 & $81;
  $83 = ($82 | 0) != 0;
  if ($83) {
   HEAP16[$8 >> 1] = 1;
  }
 }
 $84 = HEAP16[$8 >> 1] | 0;
 $85 = $84 << 16 >> 16 != 0;
 if (!$85) {
  STACKTOP = sp;
  return;
 }
 $86 = $3;
 $87 = $86 + 4 | 0;
 $88 = HEAP32[$87 >> 2] | 0;
 $89 = ($88 | 0) == 0;
 $90 = $3;
 $91 = $90 + 8 | 0;
 $92 = HEAP32[$91 >> 2] | 0;
 if ($89) {
  HEAP16[$92 >> 1] = 1;
  $93 = $3;
  $94 = $93 + 4 | 0;
  HEAP32[$94 >> 2] = 1;
  STACKTOP = sp;
  return;
 } else {
  $95 = $3;
  $96 = $95 + 8 | 0;
  $97 = HEAP32[$96 >> 2] | 0;
  $98 = $3;
  $99 = $98 + 4 | 0;
  $100 = HEAP32[$99 >> 2] | 0;
  $101 = _mpn_add($92, $97, $100, $8, 1) | 0;
  $102 = $3;
  $103 = $102 + 4 | 0;
  HEAP32[$103 >> 2] = $101;
  STACKTOP = sp;
  return;
 }
}

function _mp_quicksort($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $104 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 while (1) {
  $13 = $4;
  $14 = $5;
  $15 = $13 >>> 0 < $14 >>> 0;
  if (!$15) {
   break;
  }
  $16 = $4;
  $17 = $16 + -4 | 0;
  $8 = $17;
  $18 = $5;
  $9 = $18;
  $19 = $6;
  $20 = ($19 | 0) == (0 | 0);
  if ($20) {
   $21 = $5;
   $22 = HEAP32[$21 >> 2] | 0;
   $27 = $22;
  } else {
   $23 = $6;
   $24 = $5;
   $25 = HEAP32[$24 >> 2] | 0;
   $26 = _mp_call_function_1($23, $25) | 0;
   $27 = $26;
  }
  $10 = $27;
  while (1) {
   while (1) {
    $28 = $8;
    $29 = $28 + 4 | 0;
    $8 = $29;
    $30 = $8;
    $31 = $9;
    $32 = $30 >>> 0 < $31 >>> 0;
    if (!$32) {
     break;
    }
    $33 = $6;
    $34 = ($33 | 0) == (0 | 0);
    if ($34) {
     $35 = $8;
     $36 = HEAP32[$35 >> 2] | 0;
     $42 = $36;
    } else {
     $37 = $6;
     $38 = $8;
     $39 = HEAP32[$38 >> 2] | 0;
     $40 = _mp_call_function_1($37, $39) | 0;
     $42 = $40;
    }
    $41 = $10;
    $43 = _mp_binary_op(0, $42, $41) | 0;
    $44 = $7;
    $45 = ($43 | 0) == ($44 | 0);
    if (!$45) {
     break;
    }
   }
   while (1) {
    $46 = $9;
    $47 = $46 + -4 | 0;
    $9 = $47;
    $48 = $8;
    $49 = $9;
    $50 = $48 >>> 0 < $49 >>> 0;
    if (!$50) {
     break;
    }
    $51 = $10;
    $52 = $6;
    $53 = ($52 | 0) == (0 | 0);
    if ($53) {
     $54 = $9;
     $55 = HEAP32[$54 >> 2] | 0;
     $60 = $55;
    } else {
     $56 = $6;
     $57 = $9;
     $58 = HEAP32[$57 >> 2] | 0;
     $59 = _mp_call_function_1($56, $58) | 0;
     $60 = $59;
    }
    $61 = _mp_binary_op(0, $51, $60) | 0;
    $62 = $7;
    $63 = ($61 | 0) == ($62 | 0);
    if (!$63) {
     break;
    }
   }
   $64 = $8;
   $65 = $9;
   $66 = $64 >>> 0 >= $65 >>> 0;
   $67 = $8;
   $68 = HEAP32[$67 >> 2] | 0;
   if ($66) {
    break;
   }
   $11 = $68;
   $69 = $9;
   $70 = HEAP32[$69 >> 2] | 0;
   $71 = $8;
   HEAP32[$71 >> 2] = $70;
   $72 = $11;
   $73 = $9;
   HEAP32[$73 >> 2] = $72;
  }
  $12 = $68;
  $74 = $5;
  $75 = HEAP32[$74 >> 2] | 0;
  $76 = $8;
  HEAP32[$76 >> 2] = $75;
  $77 = $12;
  $78 = $5;
  HEAP32[$78 >> 2] = $77;
  $79 = $9;
  $80 = $4;
  $81 = $79;
  $82 = $80;
  $83 = $81 - $82 | 0;
  $84 = ($83 | 0) / 4 & -1;
  $85 = $5;
  $86 = $8;
  $87 = $85;
  $88 = $86;
  $89 = $87 - $88 | 0;
  $90 = ($89 | 0) / 4 & -1;
  $91 = $90 - 1 | 0;
  $92 = ($84 | 0) < ($91 | 0);
  if ($92) {
   $93 = $4;
   $94 = $9;
   $95 = $6;
   $96 = $7;
   _mp_quicksort($93, $94, $95, $96);
   $97 = $8;
   $98 = $97 + 4 | 0;
   $4 = $98;
  } else {
   $99 = $8;
   $100 = $99 + 4 | 0;
   $101 = $5;
   $102 = $6;
   $103 = $7;
   _mp_quicksort($100, $101, $102, $103);
   $104 = $9;
   $5 = $104;
  }
 }
 STACKTOP = sp;
 return;
}

function _gc_info($0) {
 $0 = $0 | 0;
 var $$0 = 0, $$05159 = 0, $$05258 = 0, $$05457 = 0, $$056 = 0, $$1 = 0, $$153 = 0, $$2 = 0, $$in = 0, $$pre = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond5 = 0, $trunc = 0, $trunc$clear = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = HEAP32[40756 >> 2] | 0;
 $2 = HEAP32[40752 >> 2] | 0;
 $3 = $1 - $2 | 0;
 HEAP32[$0 >> 2] = $3;
 $4 = $0 + 4 | 0;
 $5 = $0 + 8 | 0;
 $6 = $0 + 12 | 0;
 $7 = $0 + 16 | 0;
 $8 = $0 + 20 | 0;
 $9 = $0 + 24 | 0;
 HEAP32[$4 >> 2] = 0 | 0;
 HEAP32[$4 + 4 >> 2] = 0 | 0;
 HEAP32[$4 + 8 >> 2] = 0 | 0;
 HEAP32[$4 + 12 >> 2] = 0 | 0;
 HEAP32[$4 + 16 >> 2] = 0 | 0;
 HEAP32[$4 + 20 >> 2] = 0 | 0;
 $$pre = HEAP32[40744 >> 2] | 0;
 $$05159 = 0;
 $$05258 = 0;
 $$05457 = 0;
 $22 = 0;
 $25 = 0;
 $42 = 0;
 $44 = 0;
 $46 = 0;
 $48 = 0;
 while (1) {
  $14 = $$05457 >>> 2;
  $15 = $$pre + $14 | 0;
  $16 = HEAP8[$15 >> 0] | 0;
  $17 = $16 & 255;
  $18 = $$05457 << 1;
  $19 = $18 & 6;
  $20 = $17 >>> $19;
  $trunc = $20 & 255;
  $trunc$clear = $trunc & 3;
  switch ($trunc$clear << 24 >> 24) {
  case 0:
   {
    $21 = $22 + 1 | 0;
    HEAP32[$5 >> 2] = $21;
    $23 = $$05159 + 1 | 0;
    $$1 = $23;
    $$153 = 0;
    $11 = $25;
    $13 = $21;
    break;
   }
  case 1:
   {
    $24 = $25 + 1 | 0;
    HEAP32[$4 >> 2] = $24;
    $$1 = $$05159;
    $$153 = 1;
    $11 = $24;
    $13 = $22;
    break;
   }
  case 2:
   {
    $26 = $25 + 1 | 0;
    HEAP32[$4 >> 2] = $26;
    $27 = $$05258 + 1 | 0;
    $$1 = $$05159;
    $$153 = $27;
    $11 = $26;
    $13 = $22;
    break;
   }
  default:
   {
    $$1 = $$05159;
    $$153 = $$05258;
    $11 = $25;
    $13 = $22;
   }
  }
  $28 = $$05457 + 1 | 0;
  $29 = HEAP32[40748 >> 2] | 0;
  $30 = $29 << 2;
  $31 = ($28 | 0) == ($30 | 0);
  if ($31) {
   $$056 = $20 & 3;
   $$in = $$056;
   label = 10;
  } else {
   $32 = $28 << 1;
   $33 = $32 & 6;
   $34 = $28 >>> 2;
   $35 = $$pre + $34 | 0;
   $36 = HEAP8[$35 >> 0] | 0;
   $37 = $36 & 255;
   $38 = $37 >>> $33;
   $$0 = $38 & 3;
   $39 = $$0 >>> 0 < 2;
   if ($39) {
    $$in = $$0;
    label = 10;
   } else {
    $$2 = $$1;
    $49 = $48;
    $50 = $46;
    $51 = $42;
    $52 = $44;
   }
  }
  if ((label | 0) == 10) {
   label = 0;
   $40 = ($$in | 0) == 1;
   switch ($$153 | 0) {
   case 1:
    {
     $41 = $42 + 1 | 0;
     HEAP32[$7 >> 2] = $41;
     $53 = $41;
     $54 = $44;
     break;
    }
   case 2:
    {
     $43 = $44 + 1 | 0;
     HEAP32[$8 >> 2] = $43;
     $53 = $42;
     $54 = $43;
     break;
    }
   default:
    {
     $53 = $42;
     $54 = $44;
    }
   }
   $45 = $$153 >>> 0 > $46 >>> 0;
   if ($45) {
    HEAP32[$9 >> 2] = $$153;
    $55 = $$153;
   } else {
    $55 = $46;
   }
   $or$cond5 = $31 | $40;
   if ($or$cond5) {
    $47 = $$1 >>> 0 > $48 >>> 0;
    if ($47) {
     HEAP32[$6 >> 2] = $$1;
     $$2 = 0;
     $49 = $$1;
     $50 = $55;
     $51 = $53;
     $52 = $54;
    } else {
     $$2 = 0;
     $49 = $48;
     $50 = $55;
     $51 = $53;
     $52 = $54;
    }
   } else {
    $$2 = $$1;
    $49 = $48;
    $50 = $55;
    $51 = $53;
    $52 = $54;
   }
  }
  if ($31) {
   break;
  } else {
   $$05159 = $$2;
   $$05258 = $$153;
   $$05457 = $28;
   $22 = $13;
   $25 = $11;
   $42 = $51;
   $44 = $52;
   $46 = $50;
   $48 = $49;
  }
 }
 $10 = $11 << 4;
 HEAP32[$4 >> 2] = $10;
 $12 = $13 << 4;
 HEAP32[$5 >> 2] = $12;
 return;
}

function _mp_parse_num_base($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$old = 0, $$old1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $9 = 0, $or$cond = 0, $or$cond4 = 0, $or$cond7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $3;
 $6 = $8;
 $9 = $4;
 $10 = $9 >>> 0 <= 1;
 do {
  if ($10) {
   label = 23;
  } else {
   $11 = $6;
   $12 = $11 + 1 | 0;
   $6 = $12;
   $13 = HEAP8[$11 >> 0] | 0;
   $14 = $13 & 255;
   $7 = $14;
   $15 = $5;
   $16 = HEAP32[$15 >> 2] | 0;
   $17 = ($16 | 0) == 0;
   if ($17) {
    $$old = $7;
    $$old1 = ($$old | 0) == 48;
    if (!$$old1) {
     label = 16;
    }
   } else {
    $18 = $5;
    $19 = HEAP32[$18 >> 2] | 0;
    $20 = ($19 | 0) == 16;
    $21 = $7;
    $22 = ($21 | 0) == 48;
    $or$cond = $20 & $22;
    if (!$or$cond) {
     label = 16;
    }
   }
   if ((label | 0) == 16) {
    $50 = $5;
    $51 = HEAP32[$50 >> 2] | 0;
    $52 = ($51 | 0) == 8;
    $53 = $7;
    $54 = ($53 | 0) == 48;
    $or$cond4 = $52 & $54;
    if ($or$cond4) {
     $55 = $6;
     $56 = $55 + 1 | 0;
     $6 = $56;
     $57 = HEAP8[$55 >> 0] | 0;
     $58 = $57 & 255;
     $7 = $58;
     $59 = $7;
     $60 = $59 | 32;
     $61 = ($60 | 0) != 111;
     if (!$61) {
      break;
     }
     $62 = $6;
     $63 = $62 + -2 | 0;
     $6 = $63;
     break;
    }
    $64 = $5;
    $65 = HEAP32[$64 >> 2] | 0;
    $66 = ($65 | 0) == 2;
    $67 = $7;
    $68 = ($67 | 0) == 48;
    $or$cond7 = $66 & $68;
    $69 = $6;
    if (!$or$cond7) {
     $78 = $69 + -1 | 0;
     $6 = $78;
     label = 23;
     break;
    }
    $70 = $69 + 1 | 0;
    $6 = $70;
    $71 = HEAP8[$69 >> 0] | 0;
    $72 = $71 & 255;
    $7 = $72;
    $73 = $7;
    $74 = $73 | 32;
    $75 = ($74 | 0) != 98;
    if (!$75) {
     break;
    }
    $76 = $6;
    $77 = $76 + -2 | 0;
    $6 = $77;
    break;
   }
   $23 = $6;
   $24 = $23 + 1 | 0;
   $6 = $24;
   $25 = HEAP8[$23 >> 0] | 0;
   $26 = $25 & 255;
   $7 = $26;
   $27 = $7;
   $28 = $27 | 32;
   $29 = ($28 | 0) == 120;
   $30 = $5;
   if ($29) {
    HEAP32[$30 >> 2] = 16;
    break;
   }
   $31 = HEAP32[$30 >> 2] | 0;
   $32 = ($31 | 0) == 0;
   if ($32) {
    $33 = $7;
    $34 = $33 | 32;
    $35 = ($34 | 0) == 111;
    if ($35) {
     $36 = $5;
     HEAP32[$36 >> 2] = 8;
     break;
    }
   }
   $37 = $5;
   $38 = HEAP32[$37 >> 2] | 0;
   $39 = ($38 | 0) == 0;
   if ($39) {
    $40 = $7;
    $41 = $40 | 32;
    $42 = ($41 | 0) == 98;
    if ($42) {
     $43 = $5;
     HEAP32[$43 >> 2] = 2;
     break;
    }
   }
   $44 = $5;
   $45 = HEAP32[$44 >> 2] | 0;
   $46 = ($45 | 0) == 0;
   if ($46) {
    $47 = $5;
    HEAP32[$47 >> 2] = 10;
   }
   $48 = $6;
   $49 = $48 + -2 | 0;
   $6 = $49;
  }
 } while (0);
 if ((label | 0) == 23) {
  $79 = $5;
  $80 = HEAP32[$79 >> 2] | 0;
  $81 = ($80 | 0) == 0;
  if ($81) {
   $82 = $5;
   HEAP32[$82 >> 2] = 10;
  }
 }
 $83 = $6;
 $84 = $3;
 $85 = $83;
 $86 = $84;
 $87 = $85 - $86 | 0;
 STACKTOP = sp;
 return $87 | 0;
}

function _asin($0) {
 $0 = +$0;
 var $$057 = 0.0, $$1 = 0.0, $$off = 0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0, $13 = 0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0, $60 = 0.0, $61 = 0, $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0, $68 = 0, $69 = 0.0, $7 = 0, $70 = 0.0, $71 = 0.0, $72 = 0.0, $73 = 0.0, $74 = 0.0, $75 = 0.0, $76 = 0.0, $77 = 0.0, $78 = 0.0, $79 = 0.0, $8 = 0.0, $80 = 0.0, $81 = 0.0, $82 = 0.0, $83 = 0, $84 = 0.0, $9 = 0.0, $spec$select = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = $2 & 2147483647;
 $4 = $3 >>> 0 > 1072693247;
 if ($4) {
  $5 = $3 + -1072693248 | 0;
  $6 = $5 | $1;
  $7 = ($6 | 0) == 0;
  if ($7) {
   $8 = $0 * 1.5707963267948966;
   $9 = $8 + 7.52316384526264e-37;
   $$1 = $9;
   return +$$1;
  } else {
   $10 = $0 - $0;
   $11 = 0.0 / $10;
   $$1 = $11;
   return +$$1;
  }
 }
 $12 = $3 >>> 0 < 1071644672;
 if ($12) {
  $$off = $3 + -1048576 | 0;
  $13 = $$off >>> 0 < 1044381696;
  if ($13) {
   $$1 = $0;
   return +$$1;
  }
  $14 = $0 * $0;
  $15 = $14 * 3.479331075960212e-05;
  $16 = $15 + 7.915349942898145e-04;
  $17 = $14 * $16;
  $18 = $17 + -.04005553450067941;
  $19 = $14 * $18;
  $20 = $19 + .20121253213486293;
  $21 = $14 * $20;
  $22 = $21 + -.3255658186224009;
  $23 = $14 * $22;
  $24 = $23 + .16666666666666666;
  $25 = $14 * $24;
  $26 = $14 * .07703815055590194;
  $27 = $26 + -.6882839716054533;
  $28 = $14 * $27;
  $29 = $28 + 2.0209457602335057;
  $30 = $14 * $29;
  $31 = $30 + -2.403394911734414;
  $32 = $14 * $31;
  $33 = $32 + 1.0;
  $34 = $25 / $33;
  $35 = $34 * $0;
  $36 = $35 + $0;
  $$1 = $36;
  return +$$1;
 }
 $37 = +Math_abs(+$0);
 $38 = 1.0 - $37;
 $39 = $38 * .5;
 $40 = +Math_sqrt(+$39);
 $41 = $39 * 3.479331075960212e-05;
 $42 = $41 + 7.915349942898145e-04;
 $43 = $39 * $42;
 $44 = $43 + -.04005553450067941;
 $45 = $39 * $44;
 $46 = $45 + .20121253213486293;
 $47 = $39 * $46;
 $48 = $47 + -.3255658186224009;
 $49 = $39 * $48;
 $50 = $49 + .16666666666666666;
 $51 = $39 * $50;
 $52 = $39 * .07703815055590194;
 $53 = $52 + -.6882839716054533;
 $54 = $39 * $53;
 $55 = $54 + 2.0209457602335057;
 $56 = $39 * $55;
 $57 = $56 + -2.403394911734414;
 $58 = $39 * $57;
 $59 = $58 + 1.0;
 $60 = $51 / $59;
 $61 = $3 >>> 0 > 1072640818;
 if ($61) {
  $62 = $40 * $60;
  $63 = $40 + $62;
  $64 = $63 * 2.0;
  $65 = $64 + -6.123233995736766e-17;
  $66 = 1.5707963267948966 - $65;
  $$057 = $66;
  $83 = ($2 | 0) < 0;
  $84 = -$$057;
  $spec$select = $83 ? $84 : $$057;
  return +$spec$select;
 } else {
  HEAPF64[tempDoublePtr >> 3] = $40;
  $67 = HEAP32[tempDoublePtr >> 2] | 0;
  $68 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  HEAP32[tempDoublePtr >> 2] = 0;
  HEAP32[tempDoublePtr + 4 >> 2] = $68;
  $69 = +HEAPF64[tempDoublePtr >> 3];
  $70 = $69 * $69;
  $71 = $39 - $70;
  $72 = $40 + $69;
  $73 = $71 / $72;
  $74 = $40 * 2.0;
  $75 = $74 * $60;
  $76 = $73 * 2.0;
  $77 = 6.123233995736766e-17 - $76;
  $78 = $75 - $77;
  $79 = $69 * 2.0;
  $80 = .7853981633974483 - $79;
  $81 = $78 - $80;
  $82 = .7853981633974483 - $81;
  $$057 = $82;
  $83 = ($2 | 0) < 0;
  $84 = -$$057;
  $spec$select = $83 ? $84 : $$057;
  return +$spec$select;
 }
 return +(0.0);
}

function _mp_print_strn($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $10 = sp + 52 | 0;
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 HEAP8[$10 >> 0] = $4;
 $11 = $5;
 $12 = 0;
 $13 = 0;
 $20 = $11;
 $21 = $8;
 $22 = $20 - $21 | 0;
 $14 = $22;
 $16 = 0;
 $23 = HEAP8[$10 >> 0] | 0;
 $24 = $23 << 24 >> 24 != 0;
 do {
  if ($24) {
   $25 = HEAP8[$10 >> 0] | 0;
   $26 = $25 << 24 >> 24;
   $27 = ($26 | 0) == 32;
   if ($27) {
    label = 3;
   } else {
    $28 = HEAP8[$10 >> 0] | 0;
    $29 = $28 << 24 >> 24;
    $30 = ($29 | 0) == 48;
    if ($30) {
     $17 = 1056;
     $15 = 16;
     break;
    } else {
     $17 = $10;
     $15 = 1;
     break;
    }
   }
  } else {
   label = 3;
  }
 } while (0);
 if ((label | 0) == 3) {
  $17 = 1024;
  $15 = 16;
 }
 $31 = $9;
 $32 = $31 & 128;
 $33 = ($32 | 0) != 0;
 do {
  if ($33) {
   $34 = $14;
   $35 = ($34 | 0) / 2 & -1;
   $12 = $35;
   $36 = $14;
   $37 = $12;
   $38 = $36 - $37 | 0;
   $13 = $38;
  } else {
   $39 = $9;
   $40 = $39 & 1;
   $41 = ($40 | 0) != 0;
   $42 = $14;
   if ($41) {
    $13 = $42;
    break;
   } else {
    $12 = $42;
    break;
   }
  }
 } while (0);
 $43 = $12;
 $44 = ($43 | 0) > 0;
 L17 : do {
  if ($44) {
   $45 = $12;
   $46 = $16;
   $47 = $46 + $45 | 0;
   $16 = $47;
   while (1) {
    $48 = $12;
    $49 = ($48 | 0) > 0;
    if (!$49) {
     break L17;
    }
    $50 = $12;
    $18 = $50;
    $51 = $18;
    $52 = $15;
    $53 = ($51 | 0) > ($52 | 0);
    if ($53) {
     $54 = $15;
     $18 = $54;
    }
    $55 = $6;
    $56 = $55 + 4 | 0;
    $57 = HEAP32[$56 >> 2] | 0;
    $58 = $6;
    $59 = HEAP32[$58 >> 2] | 0;
    $60 = $17;
    $61 = $18;
    FUNCTION_TABLE_viii[$57 & 1023]($59, $60, $61);
    $62 = $18;
    $63 = $12;
    $64 = $63 - $62 | 0;
    $12 = $64;
   }
  }
 } while (0);
 $65 = $8;
 $66 = ($65 | 0) != 0;
 if ($66) {
  $67 = $6;
  $68 = $67 + 4 | 0;
  $69 = HEAP32[$68 >> 2] | 0;
  $70 = $6;
  $71 = HEAP32[$70 >> 2] | 0;
  $72 = $7;
  $73 = $8;
  FUNCTION_TABLE_viii[$69 & 1023]($71, $72, $73);
  $74 = $8;
  $75 = $16;
  $76 = $75 + $74 | 0;
  $16 = $76;
 }
 $77 = $13;
 $78 = ($77 | 0) > 0;
 if (!$78) {
  $99 = $16;
  STACKTOP = sp;
  return $99 | 0;
 }
 $79 = $13;
 $80 = $16;
 $81 = $80 + $79 | 0;
 $16 = $81;
 while (1) {
  $82 = $13;
  $83 = ($82 | 0) > 0;
  if (!$83) {
   break;
  }
  $84 = $13;
  $19 = $84;
  $85 = $19;
  $86 = $15;
  $87 = ($85 | 0) > ($86 | 0);
  if ($87) {
   $88 = $15;
   $19 = $88;
  }
  $89 = $6;
  $90 = $89 + 4 | 0;
  $91 = HEAP32[$90 >> 2] | 0;
  $92 = $6;
  $93 = HEAP32[$92 >> 2] | 0;
  $94 = $17;
  $95 = $19;
  FUNCTION_TABLE_viii[$91 & 1023]($93, $94, $95);
  $96 = $19;
  $97 = $13;
  $98 = $97 - $96 | 0;
  $13 = $98;
 }
 $99 = $16;
 STACKTOP = sp;
 return $99 | 0;
}

function _struct_unpack_from($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $4 = sp + 48 | 0;
 $5 = sp + 44 | 0;
 $9 = sp + 24 | 0;
 $10 = sp + 20 | 0;
 $2 = $0;
 $3 = $1;
 $16 = $3;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = _mp_obj_str_get_str($17) | 0;
 HEAP32[$4 >> 2] = $18;
 $19 = HEAP32[$4 >> 2] | 0;
 $20 = _calc_size_items($19, $5) | 0;
 $6 = $20;
 $21 = _get_fmt_type($4) | 0;
 $7 = $21;
 $22 = $6;
 $23 = _mp_obj_new_tuple($22, 0) | 0;
 $8 = $23;
 $24 = $3;
 $25 = $24 + 4 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 _mp_get_buffer_raise($26, $9, 1);
 $27 = HEAP32[$9 >> 2] | 0;
 HEAP32[$10 >> 2] = $27;
 $28 = HEAP32[$10 >> 2] | 0;
 $29 = $9 + 4 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = $28 + $30 | 0;
 $11 = $31;
 $12 = 0;
 $32 = $2;
 $33 = $32 >>> 0 > 2;
 if ($33) {
  $34 = $3;
  $35 = $34 + 8 | 0;
  $36 = HEAP32[$35 >> 2] | 0;
  $37 = _mp_obj_get_int($36) | 0;
  $12 = $37;
  $38 = $12;
  $39 = ($38 | 0) < 0;
  if ($39) {
   $40 = $9 + 4 | 0;
   $41 = HEAP32[$40 >> 2] | 0;
   $42 = $12;
   $43 = $41 + $42 | 0;
   $12 = $43;
   $44 = $12;
   $45 = ($44 | 0) < 0;
   if ($45) {
    _mp_raise_ValueError(33963);
   }
  }
  $46 = $12;
  $47 = HEAP32[$10 >> 2] | 0;
  $48 = $47 + $46 | 0;
  HEAP32[$10 >> 2] = $48;
 }
 $49 = HEAP32[$10 >> 2] | 0;
 $50 = HEAP32[$5 >> 2] | 0;
 $51 = $49 + $50 | 0;
 $52 = $11;
 $53 = $51 >>> 0 > $52 >>> 0;
 if ($53) {
  _mp_raise_ValueError(33963);
 }
 $13 = 0;
 while (1) {
  $54 = $13;
  $55 = $6;
  $56 = $54 >>> 0 < $55 >>> 0;
  if (!$56) {
   break;
  }
  $14 = 1;
  $57 = HEAP32[$4 >> 2] | 0;
  $58 = HEAP8[$57 >> 0] | 0;
  $59 = $58 << 24 >> 24;
  $60 = _unichar_isdigit($59) | 0;
  if ($60) {
   $61 = _get_fmt_num($4) | 0;
   $14 = $61;
  }
  $62 = HEAP32[$4 >> 2] | 0;
  $63 = HEAP8[$62 >> 0] | 0;
  $64 = $63 << 24 >> 24;
  $65 = ($64 | 0) == 115;
  L17 : do {
   if ($65) {
    $66 = HEAP32[$10 >> 2] | 0;
    $67 = $14;
    $68 = _mp_obj_new_bytes($66, $67) | 0;
    $15 = $68;
    $69 = $14;
    $70 = HEAP32[$10 >> 2] | 0;
    $71 = $70 + $69 | 0;
    HEAP32[$10 >> 2] = $71;
    $72 = $15;
    $73 = $8;
    $74 = $73 + 8 | 0;
    $75 = $13;
    $76 = $75 + 1 | 0;
    $13 = $76;
    $77 = $74 + ($75 << 2) | 0;
    HEAP32[$77 >> 2] = $72;
   } else {
    while (1) {
     $78 = $14;
     $79 = $78 + -1 | 0;
     $14 = $79;
     $80 = ($78 | 0) != 0;
     if (!$80) {
      break L17;
     }
     $81 = $7;
     $82 = HEAP32[$4 >> 2] | 0;
     $83 = HEAP8[$82 >> 0] | 0;
     $84 = _mp_binary_get_val($81, $83, $10) | 0;
     $15 = $84;
     $85 = $15;
     $86 = $8;
     $87 = $86 + 8 | 0;
     $88 = $13;
     $89 = $88 + 1 | 0;
     $13 = $89;
     $90 = $87 + ($88 << 2) | 0;
     HEAP32[$90 >> 2] = $85;
    }
   }
  } while (0);
  $91 = HEAP32[$4 >> 2] | 0;
  $92 = $91 + 1 | 0;
  HEAP32[$4 >> 2] = $92;
 }
 $93 = $8;
 STACKTOP = sp;
 return $93 | 0;
}

function _mp_binary_set_val_array_from_int($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = Math_fround(0), $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0.0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $8 = $4;
 $9 = $8 << 24 >> 24;
 do {
  switch ($9 | 0) {
  case 98:
   {
    $10 = $7;
    $11 = $10 & 255;
    $12 = $5;
    $13 = $6;
    $14 = $12 + $13 | 0;
    HEAP8[$14 >> 0] = $11;
    STACKTOP = sp;
    return;
    break;
   }
  case 66:
  case 1:
   {
    $15 = $7;
    $16 = $15 & 255;
    $17 = $5;
    $18 = $6;
    $19 = $17 + $18 | 0;
    HEAP8[$19 >> 0] = $16;
    STACKTOP = sp;
    return;
    break;
   }
  case 104:
   {
    $20 = $7;
    $21 = $20 & 65535;
    $22 = $5;
    $23 = $6;
    $24 = $22 + ($23 << 1) | 0;
    HEAP16[$24 >> 1] = $21;
    STACKTOP = sp;
    return;
    break;
   }
  case 72:
   {
    $25 = $7;
    $26 = $25 & 65535;
    $27 = $5;
    $28 = $6;
    $29 = $27 + ($28 << 1) | 0;
    HEAP16[$29 >> 1] = $26;
    STACKTOP = sp;
    return;
    break;
   }
  case 105:
   {
    $30 = $7;
    $31 = $5;
    $32 = $6;
    $33 = $31 + ($32 << 2) | 0;
    HEAP32[$33 >> 2] = $30;
    STACKTOP = sp;
    return;
    break;
   }
  case 73:
   {
    $34 = $7;
    $35 = $5;
    $36 = $6;
    $37 = $35 + ($36 << 2) | 0;
    HEAP32[$37 >> 2] = $34;
    STACKTOP = sp;
    return;
    break;
   }
  case 108:
   {
    $38 = $7;
    $39 = $5;
    $40 = $6;
    $41 = $39 + ($40 << 2) | 0;
    HEAP32[$41 >> 2] = $38;
    STACKTOP = sp;
    return;
    break;
   }
  case 76:
   {
    $42 = $7;
    $43 = $5;
    $44 = $6;
    $45 = $43 + ($44 << 2) | 0;
    HEAP32[$45 >> 2] = $42;
    STACKTOP = sp;
    return;
    break;
   }
  case 113:
   {
    $46 = $7;
    $47 = ($46 | 0) < 0;
    $48 = $47 << 31 >> 31;
    $49 = $5;
    $50 = $6;
    $51 = $49 + ($50 << 3) | 0;
    $52 = $51;
    $53 = $52;
    HEAP32[$53 >> 2] = $46;
    $54 = $52 + 4 | 0;
    $55 = $54;
    HEAP32[$55 >> 2] = $48;
    STACKTOP = sp;
    return;
    break;
   }
  case 81:
   {
    $56 = $7;
    $57 = ($56 | 0) < 0;
    $58 = $57 << 31 >> 31;
    $59 = $5;
    $60 = $6;
    $61 = $59 + ($60 << 3) | 0;
    $62 = $61;
    $63 = $62;
    HEAP32[$63 >> 2] = $56;
    $64 = $62 + 4 | 0;
    $65 = $64;
    HEAP32[$65 >> 2] = $58;
    STACKTOP = sp;
    return;
    break;
   }
  case 102:
   {
    $66 = $7;
    $67 = Math_fround($66 | 0);
    $68 = $5;
    $69 = $6;
    $70 = $68 + ($69 << 2) | 0;
    HEAPF32[$70 >> 2] = $67;
    STACKTOP = sp;
    return;
    break;
   }
  case 100:
   {
    $71 = $7;
    $72 = +($71 | 0);
    $73 = $5;
    $74 = $6;
    $75 = $73 + ($74 << 3) | 0;
    HEAPF64[$75 >> 3] = $72;
    STACKTOP = sp;
    return;
    break;
   }
  case 80:
   {
    $76 = $7;
    $77 = $76;
    $78 = $5;
    $79 = $6;
    $80 = $78 + ($79 << 2) | 0;
    HEAP32[$80 >> 2] = $77;
    STACKTOP = sp;
    return;
    break;
   }
  default:
   {
    STACKTOP = sp;
    return;
   }
  }
 } while (0);
}

function _mp_convert_member_lookup($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $9 = 0, $or$cond = 0, $or$cond3 = 0, $or$cond5 = 0, $or$cond7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $6;
 $10 = _mp_obj_is_obj_729($9) | 0;
 if ($10) {
  $11 = $6;
  $12 = HEAP32[$11 >> 2] | 0;
  $13 = ($12 | 0) == (19120 | 0);
  if ($13) {
   $14 = $6;
   $15 = $14 + 4 | 0;
   $16 = HEAP32[$15 >> 2] | 0;
   $17 = $7;
   HEAP32[$17 >> 2] = $16;
   STACKTOP = sp;
   return;
  }
 }
 $18 = $6;
 $19 = _mp_obj_is_obj_729($18) | 0;
 if ($19) {
  $20 = $6;
  $21 = HEAP32[$20 >> 2] | 0;
  $22 = ($21 | 0) == (19256 | 0);
  if ($22) {
   $23 = $4;
   $24 = ($23 | 0) != (0 | 0);
   if ($24) {
    $25 = $4;
    $26 = _mp_obj_get_type($25) | 0;
    $5 = $26;
   }
   $27 = $6;
   $28 = $27 + 4 | 0;
   $29 = HEAP32[$28 >> 2] | 0;
   $30 = $7;
   HEAP32[$30 >> 2] = $29;
   $31 = $5;
   $32 = $7;
   $33 = $32 + 4 | 0;
   HEAP32[$33 >> 2] = $31;
   STACKTOP = sp;
   return;
  }
 }
 $34 = $6;
 $35 = _mp_obj_is_obj_729($34) | 0;
 if ($35) {
  $36 = $6;
  $37 = HEAP32[$36 >> 2] | 0;
  $38 = ($37 | 0) == (19048 | 0);
  if ($38) {
   $39 = $6;
   $40 = $7;
   HEAP32[$40 >> 2] = $39;
   STACKTOP = sp;
   return;
  }
 }
 $41 = $6;
 $42 = _mp_obj_is_obj_729($41) | 0;
 if ($42) {
  $43 = $6;
  $44 = HEAP32[$43 >> 2] | 0;
  $45 = $44 + 6 | 0;
  $46 = HEAP16[$45 >> 1] | 0;
  $47 = $46 & 65535;
  $48 = ($47 | 0) == 365;
  if (!$48) {
   label = 14;
  }
 } else {
  label = 14;
 }
 do {
  if ((label | 0) == 14) {
   $49 = $6;
   $50 = _mp_obj_is_obj_729($49) | 0;
   if ($50) {
    $51 = $6;
    $52 = HEAP32[$51 >> 2] | 0;
    $53 = $52 + 6 | 0;
    $54 = HEAP16[$53 >> 1] | 0;
    $55 = $54 & 65535;
    $56 = ($55 | 0) == 316;
    if ($56) {
     break;
    }
    $57 = $6;
    $58 = HEAP32[$57 >> 2] | 0;
    $59 = $58 + 6 | 0;
    $60 = HEAP16[$59 >> 1] | 0;
    $61 = $60 & 65535;
    $62 = ($61 | 0) == 368;
    if ($62) {
     break;
    }
   }
   $86 = $6;
   $87 = $7;
   HEAP32[$87 >> 2] = $86;
   STACKTOP = sp;
   return;
  }
 } while (0);
 $63 = $6;
 $64 = HEAP32[$63 >> 2] | 0;
 $8 = $64;
 $65 = $4;
 $66 = ($65 | 0) == (0 | 0);
 if ($66) {
  $67 = $8;
  $68 = ($67 | 0) == (16312 | 0);
  $69 = $8;
  $70 = ($69 | 0) == (16372 | 0);
  $or$cond = $68 | $70;
  $71 = $8;
  $72 = ($71 | 0) == (16432 | 0);
  $or$cond3 = $or$cond | $72;
  $73 = $8;
  $74 = ($73 | 0) == (16492 | 0);
  $or$cond5 = $or$cond3 | $74;
  $75 = $8;
  $76 = ($75 | 0) == (16552 | 0);
  $or$cond7 = $or$cond5 | $76;
  if ($or$cond7) {
   $77 = $5;
   $78 = $6;
   $79 = _mp_obj_new_checked_fun($77, $78) | 0;
   $80 = $7;
   HEAP32[$80 >> 2] = $79;
   STACKTOP = sp;
   return;
  }
 }
 $81 = $6;
 $82 = $7;
 HEAP32[$82 >> 2] = $81;
 $83 = $4;
 $84 = $7;
 $85 = $84 + 4 | 0;
 HEAP32[$85 >> 2] = $83;
 STACKTOP = sp;
 return;
}

function _mod_uzlib_decompress($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $5 = sp + 28 | 0;
 $2 = $0;
 $3 = $1;
 $14 = $3;
 $15 = HEAP32[$14 >> 2] | 0;
 $4 = $15;
 $16 = $4;
 _mp_get_buffer_raise($16, $5, 1);
 $17 = _m_malloc(1284) | 0;
 $6 = $17;
 $18 = $6;
 _memset($18 | 0, 0, 1284) | 0;
 $19 = $6;
 _uzlib_uncompress_init($19, 0, 0);
 $20 = $5 + 4 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $21 + 15 | 0;
 $23 = $22 & -16;
 $7 = $23;
 $24 = $7;
 $25 = $24;
 $26 = _m_malloc($25) | 0;
 $8 = $26;
 $27 = $8;
 $28 = $6;
 $29 = $28 + 24 | 0;
 HEAP32[$29 >> 2] = $27;
 $30 = $8;
 $31 = $7;
 $32 = $30 + $31 | 0;
 $33 = $6;
 $34 = $33 + 28 | 0;
 HEAP32[$34 >> 2] = $32;
 $35 = HEAP32[$5 >> 2] | 0;
 $36 = $6;
 HEAP32[$36 >> 2] = $35;
 $37 = HEAP32[$5 >> 2] | 0;
 $38 = $5 + 4 | 0;
 $39 = HEAP32[$38 >> 2] | 0;
 $40 = $37 + $39 | 0;
 $41 = $6;
 $42 = $41 + 4 | 0;
 HEAP32[$42 >> 2] = $40;
 $10 = 1;
 $43 = $2;
 $44 = $43 >>> 0 > 1;
 if ($44) {
  $45 = $3;
  $46 = $45 + 4 | 0;
  $47 = HEAP32[$46 >> 2] | 0;
  $48 = $47;
  $49 = $48 >> 1;
  $50 = ($49 | 0) < 0;
  if ($50) {
   $10 = 0;
  }
 }
 $51 = $10;
 $52 = $51 & 1;
 if ($52) {
  $53 = $6;
  $54 = _uzlib_zlib_parse_header($53) | 0;
  $9 = $54;
  $55 = $9;
  $56 = ($55 | 0) < 0;
  if ($56) {
   $97 = $9;
   $98 = $97 << 1;
   $99 = $98 | 1;
   $100 = $99;
   $101 = _mp_obj_new_exception_arg1(16072, $100) | 0;
   _nlr_jump($101);
  }
 }
 while (1) {
  $57 = $6;
  $58 = _uzlib_uncompress_chksum($57) | 0;
  $9 = $58;
  $59 = $9;
  $60 = ($59 | 0) < 0;
  if ($60) {
   label = 11;
   break;
  }
  $61 = $9;
  $62 = ($61 | 0) == 1;
  $63 = $6;
  $64 = $63 + 24 | 0;
  $65 = HEAP32[$64 >> 2] | 0;
  $66 = $8;
  $67 = $65;
  $68 = $66;
  $69 = $67 - $68 | 0;
  if ($62) {
   label = 10;
   break;
  }
  $11 = $69;
  $70 = $8;
  $71 = $7;
  $72 = $71 + 256 | 0;
  $73 = $72;
  $74 = _m_realloc($70, $73) | 0;
  $8 = $74;
  $75 = $7;
  $76 = $75 + 256 | 0;
  $7 = $76;
  $77 = $8;
  $78 = $11;
  $79 = $77 + $78 | 0;
  $80 = $6;
  $81 = $80 + 24 | 0;
  HEAP32[$81 >> 2] = $79;
  $82 = $6;
  $83 = $82 + 24 | 0;
  $84 = HEAP32[$83 >> 2] | 0;
  $85 = $84 + 256 | 0;
  $86 = $6;
  $87 = $86 + 28 | 0;
  HEAP32[$87 >> 2] = $85;
 }
 if ((label | 0) == 10) {
  $12 = $69;
  $88 = $8;
  $89 = $12;
  $90 = $89;
  $91 = _m_realloc($88, $90) | 0;
  $8 = $91;
  $92 = $12;
  $93 = $8;
  $94 = _mp_obj_new_bytearray_by_ref($92, $93) | 0;
  $13 = $94;
  $95 = $6;
  _m_free($95);
  $96 = $13;
  STACKTOP = sp;
  return $96 | 0;
 } else if ((label | 0) == 11) {
  $97 = $9;
  $98 = $97 << 1;
  $99 = $98 | 1;
  $100 = $99;
  $101 = _mp_obj_new_exception_arg1(16072, $100) | 0;
  _nlr_jump($101);
 }
 return 0 | 0;
}

function _mp_builtin_min_max($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 96 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(96 | 0);
 $12 = sp + 40 | 0;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $22 = $7;
 $23 = _mp_map_lookup($22, 422, 0) | 0;
 $9 = $23;
 $24 = $9;
 $25 = ($24 | 0) == (0 | 0);
 if ($25) {
  $29 = 0;
 } else {
  $26 = $9;
  $27 = $26 + 4 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = $28;
 }
 $11 = $29;
 $30 = $5;
 $31 = ($30 | 0) == 1;
 if (!$31) {
  $18 = 0;
  $19 = 0;
  $20 = 0;
  while (1) {
   $64 = $20;
   $65 = $5;
   $66 = $64 >>> 0 < $65 >>> 0;
   if (!$66) {
    break;
   }
   $67 = $11;
   $68 = ($67 | 0) == (0 | 0);
   if ($68) {
    $69 = $6;
    $70 = $20;
    $71 = $69 + ($70 << 2) | 0;
    $72 = HEAP32[$71 >> 2] | 0;
    $79 = $72;
   } else {
    $73 = $11;
    $74 = $6;
    $75 = $20;
    $76 = $74 + ($75 << 2) | 0;
    $77 = HEAP32[$76 >> 2] | 0;
    $78 = _mp_call_function_1($73, $77) | 0;
    $79 = $78;
   }
   $21 = $79;
   $80 = $19;
   $81 = ($80 | 0) == (0 | 0);
   if ($81) {
    label = 25;
   } else {
    $82 = $8;
    $83 = $21;
    $84 = $18;
    $85 = _mp_binary_op($82, $83, $84) | 0;
    $86 = ($85 | 0) == (13864 | 0);
    if ($86) {
     label = 25;
    }
   }
   if ((label | 0) == 25) {
    label = 0;
    $87 = $21;
    $18 = $87;
    $88 = $6;
    $89 = $20;
    $90 = $88 + ($89 << 2) | 0;
    $91 = HEAP32[$90 >> 2] | 0;
    $19 = $91;
   }
   $92 = $20;
   $93 = $92 + 1 | 0;
   $20 = $93;
  }
  $94 = $19;
  $4 = $94;
  $95 = $4;
  STACKTOP = sp;
  return $95 | 0;
 }
 $32 = $6;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = _mp_getiter($33, $12) | 0;
 $13 = $34;
 $14 = 0;
 $15 = 0;
 while (1) {
  $35 = $13;
  $36 = _mp_iternext($35) | 0;
  $16 = $36;
  $37 = ($36 | 0) != (0 | 0);
  if (!$37) {
   break;
  }
  $38 = $11;
  $39 = ($38 | 0) == (0 | 0);
  if ($39) {
   $40 = $16;
   $44 = $40;
  } else {
   $41 = $11;
   $42 = $16;
   $43 = _mp_call_function_1($41, $42) | 0;
   $44 = $43;
  }
  $17 = $44;
  $45 = $15;
  $46 = ($45 | 0) == (0 | 0);
  if ($46) {
   label = 11;
  } else {
   $47 = $8;
   $48 = $17;
   $49 = $14;
   $50 = _mp_binary_op($47, $48, $49) | 0;
   $51 = ($50 | 0) == (13864 | 0);
   if ($51) {
    label = 11;
   }
  }
  if ((label | 0) == 11) {
   label = 0;
   $52 = $17;
   $14 = $52;
   $53 = $16;
   $15 = $53;
  }
 }
 $54 = $15;
 $55 = ($54 | 0) == (0 | 0);
 do {
  if ($55) {
   $56 = $7;
   $57 = _mp_map_lookup($56, 1314, 0) | 0;
   $10 = $57;
   $58 = $10;
   $59 = ($58 | 0) != (0 | 0);
   if ($59) {
    $60 = $10;
    $61 = $60 + 4 | 0;
    $62 = HEAP32[$61 >> 2] | 0;
    $15 = $62;
    break;
   } else {
    _mp_raise_ValueError(33701);
   }
  }
 } while (0);
 $63 = $15;
 $4 = $63;
 $95 = $4;
 STACKTOP = sp;
 return $95 | 0;
}

function _re1_5_compilecode($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $3;
 $6 = $5 + 4 | 0;
 HEAP32[$6 >> 2] = 0;
 $7 = $3;
 HEAP32[$7 >> 2] = 0;
 $8 = $3;
 $9 = $8 + 8 | 0;
 HEAP32[$9 >> 2] = 0;
 $10 = $3;
 $11 = $10 + 12 | 0;
 $12 = $3;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $13 + 1 | 0;
 HEAP32[$12 >> 2] = $14;
 $15 = $11 + $13 | 0;
 HEAP8[$15 >> 0] = 98;
 $16 = $3;
 $17 = $16 + 12 | 0;
 $18 = $3;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $19 + 1 | 0;
 HEAP32[$18 >> 2] = $20;
 $21 = $17 + $19 | 0;
 HEAP8[$21 >> 0] = 3;
 $22 = $3;
 $23 = $22 + 12 | 0;
 $24 = $3;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = $25 + 1 | 0;
 HEAP32[$24 >> 2] = $26;
 $27 = $23 + $25 | 0;
 HEAP8[$27 >> 0] = 2;
 $28 = $3;
 $29 = $28 + 12 | 0;
 $30 = $3;
 $31 = HEAP32[$30 >> 2] | 0;
 $32 = $31 + 1 | 0;
 HEAP32[$30 >> 2] = $32;
 $33 = $29 + $31 | 0;
 HEAP8[$33 >> 0] = 96;
 $34 = $3;
 $35 = $34 + 12 | 0;
 $36 = $3;
 $37 = HEAP32[$36 >> 2] | 0;
 $38 = $37 + 1 | 0;
 HEAP32[$36 >> 2] = $38;
 $39 = $35 + $37 | 0;
 HEAP8[$39 >> 0] = -5;
 $40 = $3;
 $41 = $40 + 4 | 0;
 $42 = HEAP32[$41 >> 2] | 0;
 $43 = $42 + 3 | 0;
 HEAP32[$41 >> 2] = $43;
 $44 = $3;
 $45 = $44 + 12 | 0;
 $46 = $3;
 $47 = HEAP32[$46 >> 2] | 0;
 $48 = $47 + 1 | 0;
 HEAP32[$46 >> 2] = $48;
 $49 = $45 + $47 | 0;
 HEAP8[$49 >> 0] = 126;
 $50 = $3;
 $51 = $50 + 12 | 0;
 $52 = $3;
 $53 = HEAP32[$52 >> 2] | 0;
 $54 = $53 + 1 | 0;
 HEAP32[$52 >> 2] = $54;
 $55 = $51 + $53 | 0;
 HEAP8[$55 >> 0] = 0;
 $56 = $3;
 $57 = $56 + 4 | 0;
 $58 = HEAP32[$57 >> 2] | 0;
 $59 = $58 + 1 | 0;
 HEAP32[$57 >> 2] = $59;
 $60 = $4;
 $61 = $3;
 $62 = __compilecode($60, $61, 0) | 0;
 $4 = $62;
 $63 = $4;
 $64 = ($63 | 0) == (0 | 0);
 if (!$64) {
  $65 = $4;
  $66 = HEAP8[$65 >> 0] | 0;
  $67 = $66 << 24 >> 24;
  $68 = ($67 | 0) != 0;
  if (!$68) {
   $69 = $3;
   $70 = $69 + 12 | 0;
   $71 = $3;
   $72 = HEAP32[$71 >> 2] | 0;
   $73 = $72 + 1 | 0;
   HEAP32[$71 >> 2] = $73;
   $74 = $70 + $72 | 0;
   HEAP8[$74 >> 0] = 126;
   $75 = $3;
   $76 = $75 + 12 | 0;
   $77 = $3;
   $78 = HEAP32[$77 >> 2] | 0;
   $79 = $78 + 1 | 0;
   HEAP32[$77 >> 2] = $79;
   $80 = $76 + $78 | 0;
   HEAP8[$80 >> 0] = 1;
   $81 = $3;
   $82 = $81 + 4 | 0;
   $83 = HEAP32[$82 >> 2] | 0;
   $84 = $83 + 1 | 0;
   HEAP32[$82 >> 2] = $84;
   $85 = $3;
   $86 = $85 + 12 | 0;
   $87 = $3;
   $88 = HEAP32[$87 >> 2] | 0;
   $89 = $88 + 1 | 0;
   HEAP32[$87 >> 2] = $89;
   $90 = $86 + $88 | 0;
   HEAP8[$90 >> 0] = 127;
   $91 = $3;
   $92 = $91 + 4 | 0;
   $93 = HEAP32[$92 >> 2] | 0;
   $94 = $93 + 1 | 0;
   HEAP32[$92 >> 2] = $94;
   $2 = 0;
   $95 = $2;
   STACKTOP = sp;
   return $95 | 0;
  }
 }
 $2 = 1;
 $95 = $2;
 STACKTOP = sp;
 return $95 | 0;
}

function _mp_obj_exception_add_traceback($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $11 = $4;
 $12 = _mp_obj_get_type($11) | 0;
 $13 = $12 + 12 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = ($14 | 0) == (108 | 0);
 $16 = $4;
 if ($15) {
  $8 = $16;
 } else {
  $17 = $16 + 16 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $8 = $18;
 }
 $19 = $8;
 $20 = $19 + 8 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = ($21 | 0) == (0 | 0);
 do {
  if ($22) {
   $23 = _m_malloc_maybe(12) | 0;
   $24 = $8;
   $25 = $24 + 8 | 0;
   HEAP32[$25 >> 2] = $23;
   $26 = $8;
   $27 = $26 + 8 | 0;
   $28 = HEAP32[$27 >> 2] | 0;
   $29 = ($28 | 0) == (0 | 0);
   if ($29) {
    STACKTOP = sp;
    return;
   } else {
    $30 = $8;
    $31 = $30 + 4 | 0;
    $32 = HEAP32[$31 >> 2] | 0;
    $33 = $32 & -65536;
    $34 = $33 | 3;
    HEAP32[$31 >> 2] = $34;
    $35 = $8;
    $36 = $35 + 4 | 0;
    $37 = HEAP32[$36 >> 2] | 0;
    $38 = $37 & 65535;
    HEAP32[$36 >> 2] = $38;
    break;
   }
  } else {
   $39 = $8;
   $40 = $39 + 4 | 0;
   $41 = HEAP32[$40 >> 2] | 0;
   $42 = $41 >>> 16;
   $43 = $42 + 3 | 0;
   $44 = $8;
   $45 = $44 + 4 | 0;
   $46 = HEAP32[$45 >> 2] | 0;
   $47 = $46 & 65535;
   $48 = ($43 | 0) > ($47 | 0);
   if ($48) {
    $49 = $8;
    $50 = $49 + 8 | 0;
    $51 = HEAP32[$50 >> 2] | 0;
    $52 = $8;
    $53 = $52 + 4 | 0;
    $54 = HEAP32[$53 >> 2] | 0;
    $55 = $54 & 65535;
    $56 = $55 + 3 | 0;
    $57 = $56 << 2;
    $58 = _m_realloc_maybe($51, $57, 1) | 0;
    $9 = $58;
    $59 = $9;
    $60 = ($59 | 0) == (0 | 0);
    if ($60) {
     STACKTOP = sp;
     return;
    } else {
     $61 = $9;
     $62 = $8;
     $63 = $62 + 8 | 0;
     HEAP32[$63 >> 2] = $61;
     $64 = $8;
     $65 = $64 + 4 | 0;
     $66 = HEAP32[$65 >> 2] | 0;
     $67 = $66 & 65535;
     $68 = $67 + 3 | 0;
     $69 = HEAP32[$65 >> 2] | 0;
     $70 = $68 & 65535;
     $71 = $69 & -65536;
     $72 = $71 | $70;
     HEAP32[$65 >> 2] = $72;
     break;
    }
   }
  }
 } while (0);
 $73 = $8;
 $74 = $73 + 8 | 0;
 $75 = HEAP32[$74 >> 2] | 0;
 $76 = $8;
 $77 = $76 + 4 | 0;
 $78 = HEAP32[$77 >> 2] | 0;
 $79 = $78 >>> 16;
 $80 = $75 + ($79 << 2) | 0;
 $10 = $80;
 $81 = $8;
 $82 = $81 + 4 | 0;
 $83 = HEAP32[$82 >> 2] | 0;
 $84 = $83 >>> 16;
 $85 = $84 + 3 | 0;
 $86 = HEAP32[$82 >> 2] | 0;
 $87 = $85 & 65535;
 $88 = $87 << 16;
 $89 = $86 & 65535;
 $90 = $89 | $88;
 HEAP32[$82 >> 2] = $90;
 $91 = $5;
 $92 = $10;
 HEAP32[$92 >> 2] = $91;
 $93 = $6;
 $94 = $10;
 $95 = $94 + 4 | 0;
 HEAP32[$95 >> 2] = $93;
 $96 = $7;
 $97 = $10;
 $98 = $97 + 8 | 0;
 HEAP32[$98 >> 2] = $96;
 STACKTOP = sp;
 return;
}
function _re_split($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $5 = sp + 40 | 0;
 $6 = sp + 32 | 0;
 $2 = $0;
 $3 = $1;
 $15 = $3;
 $16 = HEAP32[$15 >> 2] | 0;
 $4 = $16;
 $17 = $3;
 $18 = $17 + 4 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = _mp_obj_get_type($19) | 0;
 $7 = $20;
 $21 = $3;
 $22 = $21 + 4 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = _mp_obj_str_get_data($23, $6) | 0;
 HEAP32[$5 >> 2] = $24;
 $25 = HEAP32[$5 >> 2] | 0;
 $26 = HEAP32[$6 >> 2] | 0;
 $27 = $25 + $26 | 0;
 $28 = $5 + 4 | 0;
 HEAP32[$28 >> 2] = $27;
 $29 = $4;
 $30 = $29 + 4 | 0;
 $31 = $30 + 8 | 0;
 $32 = HEAP32[$31 >> 2] | 0;
 $33 = $32 + 1 | 0;
 $34 = $33 << 1;
 $8 = $34;
 $9 = 0;
 $35 = $2;
 $36 = $35 >>> 0 > 2;
 if ($36) {
  $37 = $3;
  $38 = $37 + 8 | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  $40 = _mp_obj_get_int($39) | 0;
  $9 = $40;
 }
 $41 = _mp_obj_new_list(0, 0) | 0;
 $10 = $41;
 $42 = $8;
 $43 = $42 << 2;
 $44 = _mp_local_alloc_1491($43) | 0;
 $11 = $44;
 while (1) {
  $45 = $11;
  $46 = $8;
  $47 = $46 << 2;
  _memset($45 | 0, 0, $47 | 0) | 0;
  $48 = $4;
  $49 = $48 + 4 | 0;
  $50 = $11;
  $51 = $8;
  $52 = _re1_5_recursiveloopprog($49, $5, $50, $51, 0) | 0;
  $12 = $52;
  $53 = $12;
  $54 = ($53 | 0) != 0;
  if (!$54) {
   label = 11;
   break;
  }
  $55 = $11;
  $56 = HEAP32[$55 >> 2] | 0;
  $57 = $11;
  $58 = $57 + 4 | 0;
  $59 = HEAP32[$58 >> 2] | 0;
  $60 = ($56 | 0) == ($59 | 0);
  if ($60) {
   label = 11;
   break;
  }
  $61 = $7;
  $62 = HEAP32[$5 >> 2] | 0;
  $63 = $11;
  $64 = HEAP32[$63 >> 2] | 0;
  $65 = HEAP32[$5 >> 2] | 0;
  $66 = $64;
  $67 = $65;
  $68 = $66 - $67 | 0;
  $69 = _mp_obj_new_str_of_type($61, $62, $68) | 0;
  $13 = $69;
  $70 = $10;
  $71 = $13;
  _mp_obj_list_append($70, $71) | 0;
  $72 = $4;
  $73 = $72 + 4 | 0;
  $74 = $73 + 8 | 0;
  $75 = HEAP32[$74 >> 2] | 0;
  $76 = ($75 | 0) > 0;
  if ($76) {
   label = 7;
   break;
  }
  $77 = $11;
  $78 = $77 + 4 | 0;
  $79 = HEAP32[$78 >> 2] | 0;
  HEAP32[$5 >> 2] = $79;
  $80 = $9;
  $81 = ($80 | 0) > 0;
  if ($81) {
   $82 = $9;
   $83 = $82 + -1 | 0;
   $9 = $83;
   $84 = ($83 | 0) == 0;
   if ($84) {
    label = 11;
    break;
   }
  }
 }
 if ((label | 0) == 7) {
  _mp_raise_NotImplementedError(34675);
 } else if ((label | 0) == 11) {
  $85 = $11;
  _mp_local_free_1493($85);
  $86 = $7;
  $87 = HEAP32[$5 >> 2] | 0;
  $88 = $5 + 4 | 0;
  $89 = HEAP32[$88 >> 2] | 0;
  $90 = HEAP32[$5 >> 2] | 0;
  $91 = $89;
  $92 = $90;
  $93 = $91 - $92 | 0;
  $94 = _mp_obj_new_str_of_type($86, $87, $93) | 0;
  $14 = $94;
  $95 = $10;
  $96 = $14;
  _mp_obj_list_append($95, $96) | 0;
  $97 = $10;
  STACKTOP = sp;
  return $97 | 0;
 }
 return 0 | 0;
}

function _type_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $7 = sp + 12 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $11 = $3;
 $6 = $11;
 $12 = $5;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = ($13 | 0) == (0 | 0);
 if ($14) {
  $15 = $4;
  $16 = ($15 | 0) == 23;
  if ($16) {
   $17 = $6;
   $18 = $17 + 6 | 0;
   $19 = HEAP16[$18 >> 1] | 0;
   $20 = $19 & 65535;
   $21 = $20 << 2;
   $22 = $21 | 2;
   $23 = $22;
   $24 = $5;
   HEAP32[$24 >> 2] = $23;
   STACKTOP = sp;
   return;
  } else {
   $25 = $6;
   HEAP32[$7 >> 2] = $25;
   $26 = $7 + 4 | 0;
   $27 = $4;
   HEAP32[$26 >> 2] = $27;
   $28 = $7 + 8 | 0;
   HEAP32[$28 >> 2] = 0;
   $29 = $7 + 12 | 0;
   $30 = $5;
   HEAP32[$29 >> 2] = $30;
   $31 = $7 + 16 | 0;
   HEAP8[$31 >> 0] = 1;
   $32 = $6;
   _mp_obj_class_lookup($7, $32);
   STACKTOP = sp;
   return;
  }
 }
 $33 = $6;
 $34 = $33 + 56 | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 $36 = ($35 | 0) != (0 | 0);
 if (!$36) {
  STACKTOP = sp;
  return;
 }
 $37 = $6;
 $38 = $37 + 56 | 0;
 $39 = HEAP32[$38 >> 2] | 0;
 $40 = $39 + 4 | 0;
 $8 = $40;
 $41 = $8;
 $42 = HEAP32[$41 >> 2] | 0;
 $43 = $42 >>> 1;
 $44 = $43 & 1;
 $45 = ($44 | 0) != 0;
 if ($45) {
  STACKTOP = sp;
  return;
 }
 $46 = $5;
 $47 = $46 + 4 | 0;
 $48 = HEAP32[$47 >> 2] | 0;
 $49 = ($48 | 0) == (0 | 0);
 if ($49) {
  $50 = $8;
  $51 = $4;
  $52 = $51 << 2;
  $53 = $52 | 2;
  $54 = $53;
  $55 = _mp_map_lookup($50, $54, 2) | 0;
  $9 = $55;
  $56 = $9;
  $57 = ($56 | 0) != (0 | 0);
  if (!$57) {
   STACKTOP = sp;
   return;
  }
  $58 = $5;
  HEAP32[$58 >> 2] = 0;
  STACKTOP = sp;
  return;
 }
 $59 = $6;
 $60 = $59 + 4 | 0;
 $61 = HEAP16[$60 >> 1] | 0;
 $62 = $61 & 65535;
 $63 = $62 & 2;
 $64 = ($63 | 0) != 0;
 do {
  if (!$64) {
   $65 = $4;
   $66 = $65 << 2;
   $67 = $66 | 2;
   $68 = $67;
   $69 = $5;
   $70 = $69 + 4 | 0;
   $71 = HEAP32[$70 >> 2] | 0;
   $72 = _check_for_special_accessors($68, $71) | 0;
   if ($72) {
    $73 = $6;
    $74 = $73 + 4 | 0;
    $75 = HEAP16[$74 >> 1] | 0;
    $76 = $75 & 65535;
    $77 = $76 & 1;
    $78 = ($77 | 0) != 0;
    if ($78) {
     _mp_raise_msg(15292, 33003);
    } else {
     $79 = $6;
     $80 = $79 + 4 | 0;
     $81 = HEAP16[$80 >> 1] | 0;
     $82 = $81 & 65535;
     $83 = $82 | 2;
     $84 = $83 & 65535;
     HEAP16[$80 >> 1] = $84;
     break;
    }
   }
  }
 } while (0);
 $85 = $8;
 $86 = $4;
 $87 = $86 << 2;
 $88 = $87 | 2;
 $89 = $88;
 $90 = _mp_map_lookup($85, $89, 1) | 0;
 $10 = $90;
 $91 = $5;
 $92 = $91 + 4 | 0;
 $93 = HEAP32[$92 >> 2] | 0;
 $94 = $10;
 $95 = $94 + 4 | 0;
 HEAP32[$95 >> 2] = $93;
 $96 = $5;
 HEAP32[$96 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _qstr_from_strn($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $9 = 0, $spec$store$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $10 = $2;
 $11 = $3;
 $12 = _qstr_find_strn($10, $11) | 0;
 $4 = $12;
 $13 = $4;
 $14 = ($13 | 0) == 0;
 if (!$14) {
  $88 = $4;
  STACKTOP = sp;
  return $88 | 0;
 }
 $15 = $3;
 $16 = 3 + $15 | 0;
 $17 = $16 + 1 | 0;
 $5 = $17;
 $18 = HEAP32[40724 >> 2] | 0;
 $19 = ($18 | 0) != (0 | 0);
 do {
  if ($19) {
   $20 = HEAP32[40732 >> 2] | 0;
   $21 = $5;
   $22 = $20 + $21 | 0;
   $23 = HEAP32[40728 >> 2] | 0;
   $24 = $22 >>> 0 > $23 >>> 0;
   if ($24) {
    $25 = HEAP32[40724 >> 2] | 0;
    $26 = HEAP32[40728 >> 2] | 0;
    $27 = $5;
    $28 = $26 + $27 | 0;
    $29 = $28;
    $30 = _m_realloc_maybe($25, $29, 0) | 0;
    $6 = $30;
    $31 = $6;
    $32 = ($31 | 0) == (0 | 0);
    if ($32) {
     $33 = HEAP32[40724 >> 2] | 0;
     $34 = HEAP32[40732 >> 2] | 0;
     $35 = $34;
     _m_realloc_maybe($33, $35, 0) | 0;
     HEAP32[40724 >> 2] = 0;
     break;
    } else {
     $36 = $5;
     $37 = HEAP32[40728 >> 2] | 0;
     $38 = $37 + $36 | 0;
     HEAP32[40728 >> 2] = $38;
     break;
    }
   }
  }
 } while (0);
 $39 = HEAP32[40724 >> 2] | 0;
 $40 = ($39 | 0) == (0 | 0);
 if ($40) {
  $41 = $5;
  $7 = $41;
  $42 = $7;
  $43 = $42 >>> 0 < 128;
  $spec$store$select = $43 ? 128 : $41;
  $7 = $spec$store$select;
  $44 = $7;
  $45 = $44;
  $46 = _m_malloc_maybe($45) | 0;
  HEAP32[40724 >> 2] = $46;
  $47 = HEAP32[40724 >> 2] | 0;
  $48 = ($47 | 0) == (0 | 0);
  do {
   if ($48) {
    $49 = $5;
    $50 = $49;
    $51 = _m_malloc_maybe($50) | 0;
    HEAP32[40724 >> 2] = $51;
    $52 = HEAP32[40724 >> 2] | 0;
    $53 = ($52 | 0) == (0 | 0);
    $54 = $5;
    if ($53) {
     _m_malloc_fail($54);
    } else {
     $7 = $54;
     break;
    }
   }
  } while (0);
  $55 = $7;
  HEAP32[40728 >> 2] = $55;
  HEAP32[40732 >> 2] = 0;
 }
 $56 = HEAP32[40724 >> 2] | 0;
 $57 = HEAP32[40732 >> 2] | 0;
 $58 = $56 + $57 | 0;
 $8 = $58;
 $59 = $5;
 $60 = HEAP32[40732 >> 2] | 0;
 $61 = $60 + $59 | 0;
 HEAP32[40732 >> 2] = $61;
 $62 = $2;
 $63 = $3;
 $64 = _qstr_compute_hash($62, $63) | 0;
 $9 = $64;
 $65 = $9;
 $66 = $65 & 255;
 $67 = $8;
 HEAP8[$67 >> 0] = $66;
 $68 = $9;
 $69 = $68 >>> 8;
 $70 = $69 & 255;
 $71 = $8;
 $72 = $71 + 1 | 0;
 HEAP8[$72 >> 0] = $70;
 $73 = $3;
 $74 = $73 & 255;
 $75 = $8;
 $76 = $75 + 2 | 0;
 HEAP8[$76 >> 0] = $74;
 $77 = $8;
 $78 = $77 + 2 | 0;
 $79 = $78 + 1 | 0;
 $80 = $2;
 $81 = $3;
 _memcpy($79 | 0, $80 | 0, $81 | 0) | 0;
 $82 = $8;
 $83 = $3;
 $84 = 3 + $83 | 0;
 $85 = $82 + $84 | 0;
 HEAP8[$85 >> 0] = 0;
 $86 = $8;
 $87 = _qstr_add($86) | 0;
 $4 = $87;
 $88 = $4;
 STACKTOP = sp;
 return $88 | 0;
}

function _mp_seq_cmp_objs($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val11 = 0, $$expand_i1_val3 = 0, $$expand_i1_val5 = 0, $$expand_i1_val7 = 0, $$expand_i1_val9 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = sp + 36 | 0;
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $15 = $6;
 $16 = ($15 | 0) == 2;
 if ($16) {
  $17 = $8;
  $18 = $10;
  $19 = ($17 | 0) != ($18 | 0);
  if ($19) {
   $$expand_i1_val = 0;
   HEAP8[$5 >> 0] = $$expand_i1_val;
  } else {
   label = 4;
  }
 } else {
  label = 4;
 }
 do {
  if ((label | 0) == 4) {
   $20 = $6;
   $21 = ($20 | 0) == 0;
   $22 = $6;
   $23 = ($22 | 0) == 3;
   $or$cond = $21 | $23;
   do {
    if ($or$cond) {
     $24 = $9;
     $11 = $24;
     $25 = $7;
     $9 = $25;
     $26 = $11;
     $7 = $26;
     $27 = $10;
     $12 = $27;
     $28 = $8;
     $10 = $28;
     $29 = $12;
     $8 = $29;
     $30 = $6;
     $31 = ($30 | 0) == 0;
     if ($31) {
      $6 = 1;
      break;
     } else {
      $6 = 4;
      break;
     }
    }
   } while (0);
   $32 = $8;
   $33 = $10;
   $34 = $32 >>> 0 < $33 >>> 0;
   $35 = $8;
   $36 = $10;
   $37 = $34 ? $35 : $36;
   $13 = $37;
   $14 = 0;
   while (1) {
    $38 = $14;
    $39 = $13;
    $40 = $38 >>> 0 < $39 >>> 0;
    if (!$40) {
     break;
    }
    $41 = $7;
    $42 = $14;
    $43 = $41 + ($42 << 2) | 0;
    $44 = HEAP32[$43 >> 2] | 0;
    $45 = $9;
    $46 = $14;
    $47 = $45 + ($46 << 2) | 0;
    $48 = HEAP32[$47 >> 2] | 0;
    $49 = _mp_obj_equal($44, $48) | 0;
    if (!$49) {
     label = 11;
     break;
    }
    $63 = $14;
    $64 = $63 + 1 | 0;
    $14 = $64;
   }
   if ((label | 0) == 11) {
    $50 = $6;
    $51 = ($50 | 0) == 2;
    if ($51) {
     $$expand_i1_val3 = 0;
     HEAP8[$5 >> 0] = $$expand_i1_val3;
     break;
    } else {
     $52 = $6;
     $53 = $7;
     $54 = $14;
     $55 = $53 + ($54 << 2) | 0;
     $56 = HEAP32[$55 >> 2] | 0;
     $57 = $9;
     $58 = $14;
     $59 = $57 + ($58 << 2) | 0;
     $60 = HEAP32[$59 >> 2] | 0;
     $61 = _mp_binary_op($52, $56, $60) | 0;
     $62 = ($61 | 0) == (13864 | 0);
     $$expand_i1_val5 = $62 & 1;
     HEAP8[$5 >> 0] = $$expand_i1_val5;
     break;
    }
   }
   $65 = $8;
   $66 = $10;
   $67 = ($65 | 0) != ($66 | 0);
   if ($67) {
    $68 = $8;
    $69 = $10;
    $70 = $68 >>> 0 < $69 >>> 0;
    if ($70) {
     $$expand_i1_val7 = 0;
     HEAP8[$5 >> 0] = $$expand_i1_val7;
     break;
    }
   } else {
    $71 = $6;
    $72 = ($71 | 0) == 1;
    if ($72) {
     $$expand_i1_val9 = 0;
     HEAP8[$5 >> 0] = $$expand_i1_val9;
     break;
    }
   }
   $$expand_i1_val11 = 1;
   HEAP8[$5 >> 0] = $$expand_i1_val11;
  }
 } while (0);
 $$pre_trunc = HEAP8[$5 >> 0] | 0;
 $73 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $73 | 0;
}

function _compile_scope_comp_iter($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $13 = $4;
 $14 = _comp_next_label($13) | 0;
 $8 = $14;
 $15 = $4;
 $16 = _comp_next_label($15) | 0;
 $9 = $16;
 $17 = $4;
 $18 = $17 + 40 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $8;
 _mp_emit_bc_label_assign($19, $20);
 $21 = $4;
 $22 = $21 + 40 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $9;
 _mp_emit_bc_for_iter($23, $24);
 $25 = $4;
 $26 = $5;
 $27 = $26 + 8 | 0;
 $28 = HEAP32[$27 >> 2] | 0;
 _c_assign($25, $28, 0);
 $29 = $5;
 $30 = $29 + 8 | 0;
 $31 = $30 + 8 | 0;
 $32 = HEAP32[$31 >> 2] | 0;
 $10 = $32;
 while (1) {
  $33 = $10;
  $34 = ($33 | 0) == 0;
  if ($34) {
   label = 3;
   break;
  }
  $55 = $10;
  $56 = $55;
  $57 = $56 + 4 | 0;
  $58 = HEAP32[$57 >> 2] | 0;
  $59 = $58 & 255;
  $60 = ($59 | 0) == 172;
  $61 = $10;
  $62 = $61;
  if (!$60) {
   label = 8;
   break;
  }
  $11 = $62;
  $63 = $4;
  $64 = $11;
  $65 = $64 + 8 | 0;
  $66 = HEAP32[$65 >> 2] | 0;
  $67 = $8;
  _c_if_cond($63, $66, 0, $67);
  $68 = $11;
  $69 = $68 + 8 | 0;
  $70 = $69 + 4 | 0;
  $71 = HEAP32[$70 >> 2] | 0;
  $10 = $71;
 }
 do {
  if ((label | 0) == 3) {
   $35 = $4;
   $36 = $6;
   _compile_node($35, $36);
   $37 = $4;
   $38 = $37 + 36 | 0;
   $39 = HEAP32[$38 >> 2] | 0;
   $40 = HEAP32[$39 >> 2] | 0;
   $41 = ($40 | 0) == 6;
   $42 = $4;
   $43 = $42 + 40 | 0;
   $44 = HEAP32[$43 >> 2] | 0;
   if ($41) {
    _mp_emit_bc_yield($44, 0);
    $45 = $4;
    $46 = $45 + 40 | 0;
    $47 = HEAP32[$46 >> 2] | 0;
    _mp_emit_bc_pop_top($47);
    break;
   } else {
    $48 = $4;
    $49 = $48 + 36 | 0;
    $50 = HEAP32[$49 >> 2] | 0;
    $51 = HEAP32[$50 >> 2] | 0;
    $52 = $7;
    $53 = $52 << 2;
    $54 = $53 + 5 | 0;
    _mp_emit_bc_store_comp($44, $51, $54);
    break;
   }
  } else if ((label | 0) == 8) {
   $12 = $62;
   $72 = $4;
   $73 = $12;
   $74 = $73 + 8 | 0;
   $75 = $74 + 4 | 0;
   $76 = HEAP32[$75 >> 2] | 0;
   _compile_node($72, $76);
   $77 = $4;
   $78 = $77 + 40 | 0;
   $79 = HEAP32[$78 >> 2] | 0;
   _mp_emit_bc_get_iter($79, 1);
   $80 = $4;
   $81 = $12;
   $82 = $6;
   $83 = $7;
   $84 = $83 + 1 | 0;
   _compile_scope_comp_iter($80, $81, $82, $84);
  }
 } while (0);
 $85 = $4;
 $86 = $85 + 40 | 0;
 $87 = HEAP32[$86 >> 2] | 0;
 $88 = $8;
 _mp_emit_bc_jump($87, $88);
 $89 = $4;
 $90 = $89 + 40 | 0;
 $91 = HEAP32[$90 >> 2] | 0;
 $92 = $9;
 _mp_emit_bc_label_assign($91, $92);
 $93 = $4;
 $94 = $93 + 40 | 0;
 $95 = HEAP32[$94 >> 2] | 0;
 _mp_emit_bc_for_iter_end($95);
 STACKTOP = sp;
 return;
}

function _str_index_to_ptr($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer = sp;
 $12 = sp + 12 | 0;
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $15 = $4 & 1;
 $10 = $15;
 $16 = $6;
 $17 = ($16 | 0) == (18304 | 0);
 if ($17) {
  $18 = $6;
  $19 = $8;
  $20 = $9;
  $21 = $10;
  $22 = $21 & 1;
  $23 = _mp_get_index($18, $19, $20, $22) | 0;
  $11 = $23;
  $24 = $7;
  $25 = $11;
  $26 = $24 + $25 | 0;
  $5 = $26;
  $81 = $5;
  STACKTOP = sp;
  return $81 | 0;
 }
 $27 = $9;
 $28 = _mp_obj_is_small_int_1205($27) | 0;
 $29 = $9;
 if ($28) {
  $30 = $29;
  $31 = $30 >> 1;
  HEAP32[$12 >> 2] = $31;
 } else {
  $32 = _mp_obj_get_int_maybe($29, $12) | 0;
  if (!$32) {
   $33 = $9;
   $34 = _mp_obj_get_type_str($33) | 0;
   HEAP32[$vararg_buffer >> 2] = $34;
   $35 = _mp_obj_new_exception_msg_varg(16012, 32757, $vararg_buffer) | 0;
   _nlr_jump($35);
  }
 }
 $36 = $7;
 $37 = $8;
 $38 = $36 + $37 | 0;
 $14 = $38;
 $39 = HEAP32[$12 >> 2] | 0;
 $40 = ($39 | 0) < 0;
 L10 : do {
  if ($40) {
   $41 = $14;
   $42 = $41 + -1 | 0;
   $13 = $42;
   while (1) {
    $43 = HEAP32[$12 >> 2] | 0;
    $44 = ($43 | 0) != 0;
    $45 = $13;
    if (!$44) {
     label = 17;
     break;
    }
    $46 = $7;
    $47 = $45 >>> 0 < $46 >>> 0;
    if ($47) {
     break;
    }
    $51 = $13;
    $52 = HEAP8[$51 >> 0] | 0;
    $53 = $52 & 255;
    $54 = $53 & 192;
    $55 = ($54 | 0) == 128;
    if (!$55) {
     $56 = HEAP32[$12 >> 2] | 0;
     $57 = $56 + 1 | 0;
     HEAP32[$12 >> 2] = $57;
    }
    $58 = $13;
    $59 = $58 + -1 | 0;
    $13 = $59;
   }
   if ((label | 0) == 17) {
    $60 = $45 + 1 | 0;
    $13 = $60;
    break;
   }
   $48 = $10;
   $49 = $48 & 1;
   if (!$49) {
    _mp_raise_msg(15532, 32797);
   }
   $50 = $7;
   $5 = $50;
   $81 = $5;
   STACKTOP = sp;
   return $81 | 0;
  } else {
   $61 = $7;
   $13 = $61;
   while (1) {
    $62 = $13;
    $63 = $14;
    $64 = $62 >>> 0 >= $63 >>> 0;
    if ($64) {
     break;
    }
    $68 = HEAP32[$12 >> 2] | 0;
    $69 = $68 + -1 | 0;
    HEAP32[$12 >> 2] = $69;
    $70 = ($68 | 0) == 0;
    if ($70) {
     break L10;
    }
    $71 = $13;
    $72 = $71 + 1 | 0;
    $13 = $72;
    while (1) {
     $73 = $13;
     $74 = HEAP8[$73 >> 0] | 0;
     $75 = $74 & 255;
     $76 = $75 & 192;
     $77 = ($76 | 0) == 128;
     if (!$77) {
      break;
     }
     $78 = $13;
     $79 = $78 + 1 | 0;
     $13 = $79;
    }
   }
   $65 = $10;
   $66 = $65 & 1;
   if (!$66) {
    _mp_raise_msg(15532, 32797);
   }
   $67 = $14;
   $5 = $67;
   $81 = $5;
   STACKTOP = sp;
   return $81 | 0;
  }
 } while (0);
 $80 = $13;
 $5 = $80;
 $81 = $5;
 STACKTOP = sp;
 return $81 | 0;
}

function _mp_obj_int_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0.0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $9 = sp + 12 | 0;
 $11 = sp + 4 | 0;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $13 = $6;
 $14 = $7;
 _mp_arg_check_num_1013($13, $14, 0, 2, 0);
 $15 = $6;
 switch ($15 | 0) {
 case 0:
  {
   $4 = 1;
   $70 = $4;
   STACKTOP = sp;
   return $70 | 0;
   break;
  }
 case 1:
  {
   $16 = $8;
   $17 = HEAP32[$16 >> 2] | 0;
   $18 = _mp_obj_is_small_int_1012($17) | 0;
   do {
    if (!$18) {
     $19 = $8;
     $20 = HEAP32[$19 >> 2] | 0;
     $21 = _mp_obj_is_obj_1014($20) | 0;
     if ($21) {
      $22 = $8;
      $23 = HEAP32[$22 >> 2] | 0;
      $24 = HEAP32[$23 >> 2] | 0;
      $25 = ($24 | 0) == (16904 | 0);
      if ($25) {
       break;
      }
     }
     $28 = $8;
     $29 = HEAP32[$28 >> 2] | 0;
     $30 = _mp_obj_is_qstr_1015($29) | 0;
     do {
      if (!$30) {
       $31 = $8;
       $32 = HEAP32[$31 >> 2] | 0;
       $33 = _mp_obj_is_obj_1014($32) | 0;
       if ($33) {
        $34 = $8;
        $35 = HEAP32[$34 >> 2] | 0;
        $36 = HEAP32[$35 >> 2] | 0;
        $37 = $36 + 24 | 0;
        $38 = HEAP32[$37 >> 2] | 0;
        $39 = ($38 | 0) == (206 | 0);
        if ($39) {
         break;
        }
       }
       $46 = $8;
       $47 = HEAP32[$46 >> 2] | 0;
       $48 = _mp_obj_is_obj_1014($47) | 0;
       if ($48) {
        $49 = $8;
        $50 = HEAP32[$49 >> 2] | 0;
        $51 = HEAP32[$50 >> 2] | 0;
        $52 = ($51 | 0) == (16252 | 0);
        if ($52) {
         $53 = $8;
         $54 = HEAP32[$53 >> 2] | 0;
         $55 = +_mp_obj_float_get($54);
         $56 = _mp_obj_new_int_from_float($55) | 0;
         $4 = $56;
         $70 = $4;
         STACKTOP = sp;
         return $70 | 0;
        }
       }
       $57 = $8;
       $58 = HEAP32[$57 >> 2] | 0;
       $59 = _mp_unary_op(8, $58) | 0;
       $4 = $59;
       $70 = $4;
       STACKTOP = sp;
       return $70 | 0;
      }
     } while (0);
     $40 = $8;
     $41 = HEAP32[$40 >> 2] | 0;
     $42 = _mp_obj_str_get_data($41, $9) | 0;
     $10 = $42;
     $43 = $10;
     $44 = HEAP32[$9 >> 2] | 0;
     $45 = _mp_parse_num_integer($43, $44, 0, 0) | 0;
     $4 = $45;
     $70 = $4;
     STACKTOP = sp;
     return $70 | 0;
    }
   } while (0);
   $26 = $8;
   $27 = HEAP32[$26 >> 2] | 0;
   $4 = $27;
   $70 = $4;
   STACKTOP = sp;
   return $70 | 0;
   break;
  }
 default:
  {
   $60 = $8;
   $61 = HEAP32[$60 >> 2] | 0;
   $62 = _mp_obj_str_get_data($61, $11) | 0;
   $12 = $62;
   $63 = $12;
   $64 = HEAP32[$11 >> 2] | 0;
   $65 = $8;
   $66 = $65 + 4 | 0;
   $67 = HEAP32[$66 >> 2] | 0;
   $68 = _mp_obj_get_int($67) | 0;
   $69 = _mp_parse_num_integer($63, $64, $68, 0) | 0;
   $4 = $69;
   $70 = $4;
   STACKTOP = sp;
   return $70 | 0;
  }
 }
 return 0 | 0;
}

function _stringio_write($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $100 = 0, $101 = 0, $102 = 0, $103 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $12 = $5;
 $9 = $12;
 $13 = $9;
 _check_stringio_is_open($13);
 $14 = $9;
 $15 = $14 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $16 + 12 | 0;
 $18 = HEAP8[$17 >> 0] | 0;
 $19 = $18 & 1;
 $20 = $19 & 1;
 if ($20) {
  $21 = $9;
  _stringio_copy_on_write($21);
 }
 $22 = $9;
 $23 = $22 + 8 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $7;
 $26 = $24 + $25 | 0;
 $10 = $26;
 $27 = $10;
 $28 = $7;
 $29 = $27 >>> 0 < $28 >>> 0;
 if ($29) {
  $30 = $8;
  HEAP32[$30 >> 2] = 27;
  $4 = -1;
  $103 = $4;
  STACKTOP = sp;
  return $103 | 0;
 }
 $31 = $9;
 $32 = $31 + 4 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = $33 + 4 | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 $11 = $35;
 $36 = $10;
 $37 = $9;
 $38 = $37 + 4 | 0;
 $39 = HEAP32[$38 >> 2] | 0;
 $40 = HEAP32[$39 >> 2] | 0;
 $41 = $36 >>> 0 > $40 >>> 0;
 if ($41) {
  $42 = $9;
  $43 = $42 + 4 | 0;
  $44 = HEAP32[$43 >> 2] | 0;
  $45 = HEAP32[$44 >> 2] | 0;
  $46 = $9;
  $47 = $46 + 4 | 0;
  $48 = HEAP32[$47 >> 2] | 0;
  $49 = $48 + 4 | 0;
  HEAP32[$49 >> 2] = $45;
  $50 = $9;
  $51 = $50 + 4 | 0;
  $52 = HEAP32[$51 >> 2] | 0;
  $53 = $10;
  $54 = $9;
  $55 = $54 + 4 | 0;
  $56 = HEAP32[$55 >> 2] | 0;
  $57 = HEAP32[$56 >> 2] | 0;
  $58 = $53 - $57 | 0;
  _vstr_add_len($52, $58) | 0;
 }
 $59 = $9;
 $60 = $59 + 8 | 0;
 $61 = HEAP32[$60 >> 2] | 0;
 $62 = $11;
 $63 = $61 >>> 0 > $62 >>> 0;
 if ($63) {
  $64 = $9;
  $65 = $64 + 4 | 0;
  $66 = HEAP32[$65 >> 2] | 0;
  $67 = $66 + 8 | 0;
  $68 = HEAP32[$67 >> 2] | 0;
  $69 = $11;
  $70 = $68 + $69 | 0;
  $71 = $9;
  $72 = $71 + 8 | 0;
  $73 = HEAP32[$72 >> 2] | 0;
  $74 = $11;
  $75 = $73 - $74 | 0;
  _memset($70 | 0, 0, $75 | 0) | 0;
 }
 $76 = $9;
 $77 = $76 + 4 | 0;
 $78 = HEAP32[$77 >> 2] | 0;
 $79 = $78 + 8 | 0;
 $80 = HEAP32[$79 >> 2] | 0;
 $81 = $9;
 $82 = $81 + 8 | 0;
 $83 = HEAP32[$82 >> 2] | 0;
 $84 = $80 + $83 | 0;
 $85 = $6;
 $86 = $7;
 _memcpy($84 | 0, $85 | 0, $86 | 0) | 0;
 $87 = $10;
 $88 = $9;
 $89 = $88 + 8 | 0;
 HEAP32[$89 >> 2] = $87;
 $90 = $10;
 $91 = $9;
 $92 = $91 + 4 | 0;
 $93 = HEAP32[$92 >> 2] | 0;
 $94 = $93 + 4 | 0;
 $95 = HEAP32[$94 >> 2] | 0;
 $96 = $90 >>> 0 > $95 >>> 0;
 if ($96) {
  $97 = $10;
  $98 = $9;
  $99 = $98 + 4 | 0;
  $100 = HEAP32[$99 >> 2] | 0;
  $101 = $100 + 4 | 0;
  HEAP32[$101 >> 2] = $97;
 }
 $102 = $7;
 $4 = $102;
 $103 = $4;
 STACKTOP = sp;
 return $103 | 0;
}

function _framebuf_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $9 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $5;
 $11 = $6;
 _mp_arg_check_num_1541($10, $11, 4, 5, 0);
 $12 = _m_malloc(20) | 0;
 $8 = $12;
 $13 = $4;
 $14 = $8;
 HEAP32[$14 >> 2] = $13;
 $15 = $7;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $8;
 $18 = $17 + 4 | 0;
 HEAP32[$18 >> 2] = $16;
 $19 = $7;
 $20 = HEAP32[$19 >> 2] | 0;
 _mp_get_buffer_raise($20, $9, 2);
 $21 = HEAP32[$9 >> 2] | 0;
 $22 = $8;
 $23 = $22 + 8 | 0;
 HEAP32[$23 >> 2] = $21;
 $24 = $7;
 $25 = $24 + 4 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = _mp_obj_get_int($26) | 0;
 $28 = $27 & 65535;
 $29 = $8;
 $30 = $29 + 12 | 0;
 HEAP16[$30 >> 1] = $28;
 $31 = $7;
 $32 = $31 + 8 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = _mp_obj_get_int($33) | 0;
 $35 = $34 & 65535;
 $36 = $8;
 $37 = $36 + 14 | 0;
 HEAP16[$37 >> 1] = $35;
 $38 = $7;
 $39 = $38 + 12 | 0;
 $40 = HEAP32[$39 >> 2] | 0;
 $41 = _mp_obj_get_int($40) | 0;
 $42 = $41 & 255;
 $43 = $8;
 $44 = $43 + 18 | 0;
 HEAP8[$44 >> 0] = $42;
 $45 = $5;
 $46 = $45 >>> 0 >= 5;
 if ($46) {
  $47 = $7;
  $48 = $47 + 16 | 0;
  $49 = HEAP32[$48 >> 2] | 0;
  $50 = _mp_obj_get_int($49) | 0;
  $51 = $50 & 65535;
  $52 = $8;
  $53 = $52 + 16 | 0;
  HEAP16[$53 >> 1] = $51;
 } else {
  $54 = $8;
  $55 = $54 + 12 | 0;
  $56 = HEAP16[$55 >> 1] | 0;
  $57 = $8;
  $58 = $57 + 16 | 0;
  HEAP16[$58 >> 1] = $56;
 }
 $59 = $8;
 $60 = $59 + 18 | 0;
 $61 = HEAP8[$60 >> 0] | 0;
 $62 = $61 & 255;
 switch ($62 | 0) {
 case 4:
 case 3:
  {
   $63 = $8;
   $64 = $63 + 16 | 0;
   $65 = HEAP16[$64 >> 1] | 0;
   $66 = $65 & 65535;
   $67 = $66 + 7 | 0;
   $68 = $67 & -8;
   $69 = $68 & 65535;
   $70 = $8;
   $71 = $70 + 16 | 0;
   HEAP16[$71 >> 1] = $69;
   $90 = $8;
   STACKTOP = sp;
   return $90 | 0;
   break;
  }
 case 5:
  {
   $72 = $8;
   $73 = $72 + 16 | 0;
   $74 = HEAP16[$73 >> 1] | 0;
   $75 = $74 & 65535;
   $76 = $75 + 3 | 0;
   $77 = $76 & -4;
   $78 = $77 & 65535;
   $79 = $8;
   $80 = $79 + 16 | 0;
   HEAP16[$80 >> 1] = $78;
   $90 = $8;
   STACKTOP = sp;
   return $90 | 0;
   break;
  }
 case 2:
  {
   $81 = $8;
   $82 = $81 + 16 | 0;
   $83 = HEAP16[$82 >> 1] | 0;
   $84 = $83 & 65535;
   $85 = $84 + 1 | 0;
   $86 = $85 & -2;
   $87 = $86 & 65535;
   $88 = $8;
   $89 = $88 + 16 | 0;
   HEAP16[$89 >> 1] = $87;
   $90 = $8;
   STACKTOP = sp;
   return $90 | 0;
   break;
  }
 case 6:
 case 1:
 case 0:
  {
   $90 = $8;
   STACKTOP = sp;
   return $90 | 0;
   break;
  }
 default:
  {
   _mp_raise_ValueError(35005);
  }
 }
 return 0 | 0;
}

function _framebuf_text($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $or$cond = 0, $or$cond3 = 0, $spec$store$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $2 = $0;
 $3 = $1;
 $14 = $3;
 $15 = HEAP32[$14 >> 2] | 0;
 $4 = $15;
 $16 = $3;
 $17 = $16 + 4 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = _mp_obj_str_get_str($18) | 0;
 $5 = $19;
 $20 = $3;
 $21 = $20 + 8 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = _mp_obj_get_int($22) | 0;
 $6 = $23;
 $24 = $3;
 $25 = $24 + 12 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = _mp_obj_get_int($26) | 0;
 $7 = $27;
 $8 = 1;
 $28 = $2;
 $29 = $28 >>> 0 >= 5;
 if ($29) {
  $30 = $3;
  $31 = $30 + 16 | 0;
  $32 = HEAP32[$31 >> 2] | 0;
  $33 = _mp_obj_get_int($32) | 0;
  $8 = $33;
 }
 while (1) {
  $34 = $5;
  $35 = HEAP8[$34 >> 0] | 0;
  $36 = $35 << 24 >> 24 != 0;
  if (!$36) {
   break;
  }
  $37 = $5;
  $38 = HEAP8[$37 >> 0] | 0;
  $39 = $38 & 255;
  $9 = $39;
  $40 = $9;
  $41 = ($40 | 0) < 32;
  $42 = $9;
  $43 = ($42 | 0) > 127;
  $or$cond = $41 | $43;
  $spec$store$select = $or$cond ? 127 : $39;
  $9 = $spec$store$select;
  $44 = $9;
  $45 = $44 - 32 | 0;
  $46 = $45 << 3;
  $47 = 8608 + $46 | 0;
  $10 = $47;
  $11 = 0;
  while (1) {
   $48 = $11;
   $49 = ($48 | 0) < 8;
   if (!$49) {
    break;
   }
   $50 = $6;
   $51 = 0 <= ($50 | 0);
   L10 : do {
    if ($51) {
     $52 = $6;
     $53 = $4;
     $54 = $53 + 12 | 0;
     $55 = HEAP16[$54 >> 1] | 0;
     $56 = $55 & 65535;
     $57 = ($52 | 0) < ($56 | 0);
     if ($57) {
      $58 = $10;
      $59 = $11;
      $60 = $58 + $59 | 0;
      $61 = HEAP8[$60 >> 0] | 0;
      $62 = $61 & 255;
      $12 = $62;
      $63 = $7;
      $13 = $63;
      while (1) {
       $64 = $12;
       $65 = ($64 | 0) != 0;
       if (!$65) {
        break L10;
       }
       $66 = $12;
       $67 = $66 & 1;
       $68 = ($67 | 0) != 0;
       $69 = $13;
       $70 = 0 <= ($69 | 0);
       $or$cond3 = $68 & $70;
       if ($or$cond3) {
        $71 = $13;
        $72 = $4;
        $73 = $72 + 14 | 0;
        $74 = HEAP16[$73 >> 1] | 0;
        $75 = $74 & 65535;
        $76 = ($71 | 0) < ($75 | 0);
        if ($76) {
         $77 = $4;
         $78 = $6;
         $79 = $13;
         $80 = $8;
         _setpixel($77, $78, $79, $80);
        }
       }
       $81 = $12;
       $82 = $81 >>> 1;
       $12 = $82;
       $83 = $13;
       $84 = $83 + 1 | 0;
       $13 = $84;
      }
     }
    }
   } while (0);
   $85 = $11;
   $86 = $85 + 1 | 0;
   $11 = $86;
   $87 = $6;
   $88 = $87 + 1 | 0;
   $6 = $88;
  }
  $89 = $5;
  $90 = $89 + 1 | 0;
  $5 = $90;
 }
 STACKTOP = sp;
 return 17668 | 0;
}

function _log10($0) {
 $0 = +$0;
 var $$0 = 0, $$0100 = 0, $$0101 = 0.0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0.0, $29 = 0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0, $52 = 0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0, $60 = 0.0, $61 = 0.0, $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0.0, $71 = 0.0, $72 = 0.0, $8 = 0, $9 = 0.0, $or$cond = 0, $or$cond105 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = $2 >>> 0 < 1048576;
 $4 = ($2 | 0) < 0;
 $or$cond = $4 | $3;
 do {
  if ($or$cond) {
   $5 = $2 & 2147483647;
   $6 = ($1 | 0) == 0;
   $7 = ($5 | 0) == 0;
   $8 = $6 & $7;
   if ($8) {
    $9 = $0 * $0;
    $10 = -1.0 / $9;
    $$0101 = $10;
    break;
   }
   if ($4) {
    $11 = $0 - $0;
    $12 = $11 / 0.0;
    $$0101 = $12;
    break;
   } else {
    $13 = $0 * 18014398509481984.0;
    HEAPF64[tempDoublePtr >> 3] = $13;
    $14 = HEAP32[tempDoublePtr >> 2] | 0;
    $15 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
    $$0 = -1077;
    $$0100 = $15;
    $27 = 0;
    $29 = $14;
    label = 9;
    break;
   }
  } else {
   $16 = $2 >>> 0 > 2146435071;
   if ($16) {
    $$0101 = $0;
   } else {
    $17 = ($2 | 0) == 1072693248;
    $18 = ($1 | 0) == 0;
    $19 = 0 == 0;
    $20 = $18 & $19;
    $or$cond105 = $20 & $17;
    if ($or$cond105) {
     $$0101 = 0.0;
    } else {
     $$0 = -1023;
     $$0100 = $2;
     $27 = 0;
     $29 = $1;
     label = 9;
    }
   }
  }
 } while (0);
 if ((label | 0) == 9) {
  $21 = $$0100 + 614242 | 0;
  $22 = $21 >>> 20;
  $23 = $$0 + $22 | 0;
  $24 = $21 & 1048575;
  $25 = $24 + 1072079006 | 0;
  $26 = $25 | $27;
  HEAP32[tempDoublePtr >> 2] = $29;
  HEAP32[tempDoublePtr + 4 >> 2] = $26;
  $28 = +HEAPF64[tempDoublePtr >> 3];
  $30 = $28 + -1.0;
  $31 = $30 * .5;
  $32 = $30 * $31;
  $33 = $30 + 2.0;
  $34 = $30 / $33;
  $35 = $34 * $34;
  $36 = $35 * $35;
  $37 = $36 * .15313837699209373;
  $38 = $37 + .22222198432149784;
  $39 = $36 * $38;
  $40 = $39 + .3999999999940942;
  $41 = $36 * $40;
  $42 = $36 * .14798198605116586;
  $43 = $42 + .1818357216161805;
  $44 = $36 * $43;
  $45 = $44 + .2857142874366239;
  $46 = $36 * $45;
  $47 = $46 + .6666666666666735;
  $48 = $35 * $47;
  $49 = $41 + $48;
  $50 = $30 - $32;
  HEAPF64[tempDoublePtr >> 3] = $50;
  $51 = HEAP32[tempDoublePtr >> 2] | 0;
  $52 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  HEAP32[tempDoublePtr >> 2] = 0;
  HEAP32[tempDoublePtr + 4 >> 2] = $52;
  $53 = +HEAPF64[tempDoublePtr >> 3];
  $54 = $30 - $53;
  $55 = $54 - $32;
  $56 = $32 + $49;
  $57 = $34 * $56;
  $58 = $55 + $57;
  $59 = $53 * .4342944818781689;
  $60 = +($23 | 0);
  $61 = $60 * .30102999566361177;
  $62 = $60 * 3.694239077158931e-13;
  $63 = $58 + $53;
  $64 = $63 * 2.5082946711645275e-11;
  $65 = $62 + $64;
  $66 = $58 * .4342944818781689;
  $67 = $66 + $65;
  $68 = $61 + $59;
  $69 = $61 - $68;
  $70 = $59 + $69;
  $71 = $70 + $67;
  $72 = $68 + $71;
  $$0101 = $72;
 }
 return +$$0101;
}

function _memchr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$0$lcssa = 0, $$035$lcssa = 0, $$035$lcssa65 = 0, $$03555 = 0, $$036$lcssa = 0, $$036$lcssa64 = 0, $$03654 = 0, $$046 = 0, $$137$lcssa = 0, $$137$lcssa66 = 0, $$13745 = 0, $$140 = 0, $$23839 = 0, $$in = 0, $$lcssa = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond53 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $3 = $1 & 255;
 $4 = $0;
 $5 = $4 & 3;
 $6 = ($5 | 0) != 0;
 $7 = ($2 | 0) != 0;
 $or$cond53 = $7 & $6;
 L1 : do {
  if ($or$cond53) {
   $8 = $1 & 255;
   $$03555 = $0;
   $$03654 = $2;
   while (1) {
    $9 = HEAP8[$$03555 >> 0] | 0;
    $10 = $9 << 24 >> 24 == $8 << 24 >> 24;
    if ($10) {
     $$035$lcssa65 = $$03555;
     $$036$lcssa64 = $$03654;
     label = 6;
     break L1;
    }
    $11 = $$03555 + 1 | 0;
    $12 = $$03654 + -1 | 0;
    $13 = $11;
    $14 = $13 & 3;
    $15 = ($14 | 0) != 0;
    $16 = ($12 | 0) != 0;
    $or$cond = $16 & $15;
    if ($or$cond) {
     $$03555 = $11;
     $$03654 = $12;
    } else {
     $$035$lcssa = $11;
     $$036$lcssa = $12;
     $$lcssa = $16;
     label = 5;
     break;
    }
   }
  } else {
   $$035$lcssa = $0;
   $$036$lcssa = $2;
   $$lcssa = $7;
   label = 5;
  }
 } while (0);
 if ((label | 0) == 5) {
  if ($$lcssa) {
   $$035$lcssa65 = $$035$lcssa;
   $$036$lcssa64 = $$036$lcssa;
   label = 6;
  } else {
   label = 16;
  }
 }
 L8 : do {
  if ((label | 0) == 6) {
   $17 = HEAP8[$$035$lcssa65 >> 0] | 0;
   $18 = $1 & 255;
   $19 = $17 << 24 >> 24 == $18 << 24 >> 24;
   if ($19) {
    $38 = ($$036$lcssa64 | 0) == 0;
    if ($38) {
     label = 16;
     break;
    } else {
     $39 = $$035$lcssa65;
     break;
    }
   }
   $20 = Math_imul($3, 16843009) | 0;
   $21 = $$036$lcssa64 >>> 0 > 3;
   L13 : do {
    if ($21) {
     $$046 = $$035$lcssa65;
     $$13745 = $$036$lcssa64;
     while (1) {
      $22 = HEAP32[$$046 >> 2] | 0;
      $23 = $22 ^ $20;
      $24 = $23 + -16843009 | 0;
      $25 = $23 & -2139062144;
      $26 = $25 ^ -2139062144;
      $27 = $26 & $24;
      $28 = ($27 | 0) == 0;
      if (!$28) {
       $$137$lcssa66 = $$13745;
       $$in = $$046;
       break L13;
      }
      $29 = $$046 + 4 | 0;
      $30 = $$13745 + -4 | 0;
      $31 = $30 >>> 0 > 3;
      if ($31) {
       $$046 = $29;
       $$13745 = $30;
      } else {
       $$0$lcssa = $29;
       $$137$lcssa = $30;
       label = 11;
       break;
      }
     }
    } else {
     $$0$lcssa = $$035$lcssa65;
     $$137$lcssa = $$036$lcssa64;
     label = 11;
    }
   } while (0);
   if ((label | 0) == 11) {
    $32 = ($$137$lcssa | 0) == 0;
    if ($32) {
     label = 16;
     break;
    } else {
     $$137$lcssa66 = $$137$lcssa;
     $$in = $$0$lcssa;
    }
   }
   $$140 = $$in;
   $$23839 = $$137$lcssa66;
   while (1) {
    $33 = HEAP8[$$140 >> 0] | 0;
    $34 = $33 << 24 >> 24 == $18 << 24 >> 24;
    if ($34) {
     $39 = $$140;
     break L8;
    }
    $35 = $$140 + 1 | 0;
    $36 = $$23839 + -1 | 0;
    $37 = ($36 | 0) == 0;
    if ($37) {
     label = 16;
     break;
    } else {
     $$140 = $35;
     $$23839 = $36;
    }
   }
  }
 } while (0);
 if ((label | 0) == 16) {
  $39 = 0;
 }
 return $39 | 0;
}

function _mp_call_function_1_protected($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$0 = 0, $$reg2mem14$0 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, $cond16 = 0, $cond17 = 0, $cond18 = 0, $cond19 = 0, _setjmpTable = 0, _setjmpTableSize = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 176 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(176 | 0);
 _setjmpTableSize = 4;
 _setjmpTable = _malloc(40) | 0;
 HEAP32[_setjmpTable >> 2] = 0;
 $2 = sp;
 __THREW__ = 0;
 invoke_ii(496, $2 | 0) | 0;
 $3 = __THREW__;
 __THREW__ = 0;
 if (($3 | 0) != 0 & (threwValue | 0) != 0) {
  $4 = _testSetjmp(HEAP32[$3 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  if (($4 | 0) == 0) {
   _longjmp($3 | 0, threwValue | 0);
  }
  setTempRet0(threwValue | 0);
 } else {
  $4 = -1;
 }
 $5 = getTempRet0() | 0;
 $cond = ($4 | 0) == 1;
 if ($cond) {
  $$reg2mem14$0 = $5;
 } else {
  $6 = $2 + 8 | 0;
  _setjmpTable = _saveSetjmp($6, 1, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  _setjmpTableSize = getTempRet0() | 0;
  __THREW__ = 0;
  $7 = __THREW__;
  __THREW__ = 0;
  if (($7 | 0) != 0 & (threwValue | 0) != 0) {
   $8 = _testSetjmp(HEAP32[$7 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($8 | 0) == 0) {
    _longjmp($7 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $8 = -1;
  }
  $9 = getTempRet0() | 0;
  $cond16 = ($8 | 0) == 1;
  if ($cond16) {
   $$reg2mem14$0 = $9;
  } else {
   $$reg2mem14$0 = 0;
  }
 }
 while (1) {
  $10 = ($$reg2mem14$0 | 0) == 0;
  if (!$10) {
   $18 = $2 + 4 | 0;
   $19 = HEAP32[$18 >> 2] | 0;
   __THREW__ = 0;
   invoke_vii(511, 13344 | 0, $19 | 0);
   $20 = __THREW__;
   __THREW__ = 0;
   if (($20 | 0) != 0 & (threwValue | 0) != 0) {
    $21 = _testSetjmp(HEAP32[$20 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($21 | 0) == 0) {
     _longjmp($20 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $21 = -1;
   }
   $22 = getTempRet0() | 0;
   $cond17 = ($21 | 0) == 1;
   if ($cond17) {
    $$reg2mem14$0 = $22;
    continue;
   } else {
    label = 9;
    break;
   }
  }
  __THREW__ = 0;
  $11 = invoke_iii(510, $0 | 0, $1 | 0) | 0;
  $12 = __THREW__;
  __THREW__ = 0;
  if (($12 | 0) != 0 & (threwValue | 0) != 0) {
   $13 = _testSetjmp(HEAP32[$12 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($13 | 0) == 0) {
    _longjmp($12 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $13 = -1;
  }
  $14 = getTempRet0() | 0;
  $cond18 = ($13 | 0) == 1;
  if ($cond18) {
   $$reg2mem14$0 = $14;
   continue;
  }
  __THREW__ = 0;
  invoke_v(498);
  $15 = __THREW__;
  __THREW__ = 0;
  if (($15 | 0) != 0 & (threwValue | 0) != 0) {
   $16 = _testSetjmp(HEAP32[$15 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($16 | 0) == 0) {
    _longjmp($15 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $16 = -1;
  }
  $17 = getTempRet0() | 0;
  $cond19 = ($16 | 0) == 1;
  if ($cond19) {
   $$reg2mem14$0 = $17;
  } else {
   label = 7;
   break;
  }
 }
 if ((label | 0) == 7) {
  $$0 = $11;
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$0 | 0;
 } else if ((label | 0) == 9) {
  $$0 = 0;
  _free(_setjmpTable | 0);
  STACKTOP = sp;
  return $$0 | 0;
 }
 return 0 | 0;
}

function ___tan($0, $1, $2) {
 $0 = +$0;
 $1 = +$1;
 $2 = $2 | 0;
 var $$0 = 0.0, $$087 = 0.0, $$088 = 0.0, $$090 = 0, $$1 = 0.0, $$189 = 0.0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0, $52 = 0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0, $60 = 0.0, $61 = 0, $62 = 0.0, $63 = 0.0, $64 = 0, $65 = 0, $66 = 0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0, $70 = 0.0, $71 = 0, $72 = 0, $73 = 0.0, $74 = 0.0, $75 = 0.0, $76 = 0.0, $77 = 0.0, $78 = 0.0, $79 = 0.0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $3 = HEAP32[tempDoublePtr >> 2] | 0;
 $4 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $5 = $4 & 2147483640;
 $6 = $5 >>> 0 > 1072010279;
 $7 = 0 > 0;
 $8 = ($5 | 0) == 1072010279;
 $9 = $8 & $7;
 $10 = $6 | $9;
 if ($10) {
  $11 = _bitshift64Lshr($3 | 0, $4 | 0, 63) | 0;
  $12 = getTempRet0() | 0;
  $13 = ($11 | 0) == 0;
  $14 = -$0;
  $15 = -$1;
  $$088 = $13 ? $1 : $15;
  $$087 = $13 ? $0 : $14;
  $16 = .7853981633974483 - $$087;
  $17 = 3.061616997868383e-17 - $$088;
  $18 = $16 + $17;
  $$090 = $11;
  $$1 = $18;
  $$189 = 0.0;
 } else {
  $$090 = 0;
  $$1 = $0;
  $$189 = $1;
 }
 $19 = $$1 * $$1;
 $20 = $19 * $19;
 $21 = $20 * 1.8558637485527546e-05;
 $22 = 7.817944429395571e-05 - $21;
 $23 = $20 * $22;
 $24 = $23 + 5.880412408202641e-04;
 $25 = $20 * $24;
 $26 = $25 + 3.5920791075913124e-03;
 $27 = $20 * $26;
 $28 = $27 + .021869488294859542;
 $29 = $20 * $28;
 $30 = $29 + .13333333333320124;
 $31 = $20 * 2.590730518636337e-05;
 $32 = $31 + 7.140724913826082e-05;
 $33 = $20 * $32;
 $34 = $33 + 2.464631348184699e-04;
 $35 = $20 * $34;
 $36 = $35 + 1.4562094543252903e-03;
 $37 = $20 * $36;
 $38 = $37 + .0088632398235993;
 $39 = $20 * $38;
 $40 = $39 + .05396825397622605;
 $41 = $19 * $40;
 $42 = $$1 * $19;
 $43 = $30 + $41;
 $44 = $42 * $43;
 $45 = $$189 + $44;
 $46 = $19 * $45;
 $47 = $$189 + $46;
 $48 = $42 * .3333333333333341;
 $49 = $48 + $47;
 $50 = $$1 + $49;
 if ($10) {
  $51 = $2 << 1;
  $52 = 1 - $51 | 0;
  $53 = +($52 | 0);
  $54 = $50 * $50;
  $55 = $50 + $53;
  $56 = $54 / $55;
  $57 = $49 - $56;
  $58 = $$1 + $57;
  $59 = $58 * 2.0;
  $60 = $53 - $59;
  $61 = ($$090 | 0) == 0;
  $62 = -$60;
  $63 = $61 ? $60 : $62;
  $$0 = $63;
 } else {
  $64 = ($2 | 0) == 0;
  if ($64) {
   $$0 = $50;
  } else {
   HEAPF64[tempDoublePtr >> 3] = $50;
   $65 = HEAP32[tempDoublePtr >> 2] | 0;
   $66 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
   HEAP32[tempDoublePtr >> 2] = 0;
   HEAP32[tempDoublePtr + 4 >> 2] = $66;
   $67 = +HEAPF64[tempDoublePtr >> 3];
   $68 = $67 - $$1;
   $69 = $49 - $68;
   $70 = -1.0 / $50;
   HEAPF64[tempDoublePtr >> 3] = $70;
   $71 = HEAP32[tempDoublePtr >> 2] | 0;
   $72 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
   HEAP32[tempDoublePtr >> 2] = 0;
   HEAP32[tempDoublePtr + 4 >> 2] = $72;
   $73 = +HEAPF64[tempDoublePtr >> 3];
   $74 = $67 * $73;
   $75 = $74 + 1.0;
   $76 = $69 * $73;
   $77 = $75 + $76;
   $78 = $70 * $77;
   $79 = $78 + $73;
   $$0 = $79;
  }
 }
 return +$$0;
}

function _list_extend($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = _mp_obj_is_obj_1061($6) | 0;
 if ($7) {
  $8 = $3;
  $9 = HEAP32[$8 >> 2] | 0;
  $10 = ($9 | 0) == (17028 | 0);
  if ($10) {
   $11 = $2;
   $4 = $11;
   $12 = $3;
   $5 = $12;
   $13 = $4;
   $14 = $13 + 8 | 0;
   $15 = HEAP32[$14 >> 2] | 0;
   $16 = $5;
   $17 = $16 + 8 | 0;
   $18 = HEAP32[$17 >> 2] | 0;
   $19 = $15 + $18 | 0;
   $20 = $4;
   $21 = $20 + 4 | 0;
   $22 = HEAP32[$21 >> 2] | 0;
   $23 = $19 >>> 0 > $22 >>> 0;
   if ($23) {
    $24 = $4;
    $25 = $24 + 12 | 0;
    $26 = HEAP32[$25 >> 2] | 0;
    $27 = $4;
    $28 = $27 + 8 | 0;
    $29 = HEAP32[$28 >> 2] | 0;
    $30 = $5;
    $31 = $30 + 8 | 0;
    $32 = HEAP32[$31 >> 2] | 0;
    $33 = $29 + $32 | 0;
    $34 = $33 + 4 | 0;
    $35 = $34 << 2;
    $36 = _m_realloc($26, $35) | 0;
    $37 = $4;
    $38 = $37 + 12 | 0;
    HEAP32[$38 >> 2] = $36;
    $39 = $4;
    $40 = $39 + 8 | 0;
    $41 = HEAP32[$40 >> 2] | 0;
    $42 = $5;
    $43 = $42 + 8 | 0;
    $44 = HEAP32[$43 >> 2] | 0;
    $45 = $41 + $44 | 0;
    $46 = $45 + 4 | 0;
    $47 = $4;
    $48 = $47 + 4 | 0;
    HEAP32[$48 >> 2] = $46;
    $49 = $4;
    $50 = $49 + 12 | 0;
    $51 = HEAP32[$50 >> 2] | 0;
    $52 = $4;
    $53 = $52 + 8 | 0;
    $54 = HEAP32[$53 >> 2] | 0;
    $55 = $5;
    $56 = $55 + 8 | 0;
    $57 = HEAP32[$56 >> 2] | 0;
    $58 = $54 + $57 | 0;
    $59 = $58 << 2;
    $60 = $51 + $59 | 0;
    $61 = $4;
    $62 = $61 + 4 | 0;
    $63 = HEAP32[$62 >> 2] | 0;
    $64 = $4;
    $65 = $64 + 8 | 0;
    $66 = HEAP32[$65 >> 2] | 0;
    $67 = $5;
    $68 = $67 + 8 | 0;
    $69 = HEAP32[$68 >> 2] | 0;
    $70 = $66 + $69 | 0;
    $71 = $63 - $70 | 0;
    $72 = $71 << 2;
    _memset($60 | 0, 0, $72 | 0) | 0;
   }
   $73 = $4;
   $74 = $73 + 12 | 0;
   $75 = HEAP32[$74 >> 2] | 0;
   $76 = $4;
   $77 = $76 + 8 | 0;
   $78 = HEAP32[$77 >> 2] | 0;
   $79 = $75 + ($78 << 2) | 0;
   $80 = $5;
   $81 = $80 + 12 | 0;
   $82 = HEAP32[$81 >> 2] | 0;
   $83 = $5;
   $84 = $83 + 8 | 0;
   $85 = HEAP32[$84 >> 2] | 0;
   $86 = $85 << 2;
   _memcpy($79 | 0, $82 | 0, $86 | 0) | 0;
   $87 = $5;
   $88 = $87 + 8 | 0;
   $89 = HEAP32[$88 >> 2] | 0;
   $90 = $4;
   $91 = $90 + 8 | 0;
   $92 = HEAP32[$91 >> 2] | 0;
   $93 = $92 + $89 | 0;
   HEAP32[$91 >> 2] = $93;
   STACKTOP = sp;
   return 17668 | 0;
  }
 }
 $94 = $2;
 $95 = $3;
 _list_extend_from_iter($94, $95) | 0;
 STACKTOP = sp;
 return 17668 | 0;
}

function ___stdio_write($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$0 = 0, $$04756 = 0, $$04855 = 0, $$04954 = 0, $$051 = 0, $$1 = 0, $$150 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer3 = 0, $vararg_ptr1 = 0, $vararg_ptr2 = 0, $vararg_ptr6 = 0, $vararg_ptr7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer3 = sp + 32 | 0;
 $vararg_buffer = sp + 16 | 0;
 $3 = sp;
 $4 = $0 + 28 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 HEAP32[$3 >> 2] = $5;
 $6 = $3 + 4 | 0;
 $7 = $0 + 20 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $8 - $5 | 0;
 HEAP32[$6 >> 2] = $9;
 $10 = $3 + 8 | 0;
 HEAP32[$10 >> 2] = $1;
 $11 = $3 + 12 | 0;
 HEAP32[$11 >> 2] = $2;
 $12 = $9 + $2 | 0;
 $13 = $0 + 60 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $3;
 HEAP32[$vararg_buffer >> 2] = $14;
 $vararg_ptr1 = $vararg_buffer + 4 | 0;
 HEAP32[$vararg_ptr1 >> 2] = $15;
 $vararg_ptr2 = $vararg_buffer + 8 | 0;
 HEAP32[$vararg_ptr2 >> 2] = 2;
 $16 = ___syscall146(146, $vararg_buffer | 0) | 0;
 $17 = ___syscall_ret($16) | 0;
 $18 = ($12 | 0) == ($17 | 0);
 L1 : do {
  if ($18) {
   label = 3;
  } else {
   $$04756 = 2;
   $$04855 = $12;
   $$04954 = $3;
   $26 = $17;
   while (1) {
    $27 = ($26 | 0) < 0;
    if ($27) {
     break;
    }
    $35 = $$04855 - $26 | 0;
    $36 = $$04954 + 4 | 0;
    $37 = HEAP32[$36 >> 2] | 0;
    $38 = $26 >>> 0 > $37 >>> 0;
    $39 = $$04954 + 8 | 0;
    $$150 = $38 ? $39 : $$04954;
    $40 = $38 << 31 >> 31;
    $$1 = $$04756 + $40 | 0;
    $41 = $38 ? $37 : 0;
    $$0 = $26 - $41 | 0;
    $42 = HEAP32[$$150 >> 2] | 0;
    $43 = $42 + $$0 | 0;
    HEAP32[$$150 >> 2] = $43;
    $44 = $$150 + 4 | 0;
    $45 = HEAP32[$44 >> 2] | 0;
    $46 = $45 - $$0 | 0;
    HEAP32[$44 >> 2] = $46;
    $47 = HEAP32[$13 >> 2] | 0;
    $48 = $$150;
    HEAP32[$vararg_buffer3 >> 2] = $47;
    $vararg_ptr6 = $vararg_buffer3 + 4 | 0;
    HEAP32[$vararg_ptr6 >> 2] = $48;
    $vararg_ptr7 = $vararg_buffer3 + 8 | 0;
    HEAP32[$vararg_ptr7 >> 2] = $$1;
    $49 = ___syscall146(146, $vararg_buffer3 | 0) | 0;
    $50 = ___syscall_ret($49) | 0;
    $51 = ($35 | 0) == ($50 | 0);
    if ($51) {
     label = 3;
     break L1;
    } else {
     $$04756 = $$1;
     $$04855 = $35;
     $$04954 = $$150;
     $26 = $50;
    }
   }
   $28 = $0 + 16 | 0;
   HEAP32[$28 >> 2] = 0;
   HEAP32[$4 >> 2] = 0;
   HEAP32[$7 >> 2] = 0;
   $29 = HEAP32[$0 >> 2] | 0;
   $30 = $29 | 32;
   HEAP32[$0 >> 2] = $30;
   $31 = ($$04756 | 0) == 2;
   if ($31) {
    $$051 = 0;
   } else {
    $32 = $$04954 + 4 | 0;
    $33 = HEAP32[$32 >> 2] | 0;
    $34 = $2 - $33 | 0;
    $$051 = $34;
   }
  }
 } while (0);
 if ((label | 0) == 3) {
  $19 = $0 + 44 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = $0 + 48 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $20 + $22 | 0;
  $24 = $0 + 16 | 0;
  HEAP32[$24 >> 2] = $23;
  $25 = $20;
  HEAP32[$4 >> 2] = $25;
  HEAP32[$7 >> 2] = $25;
  $$051 = $2;
 }
 STACKTOP = sp;
 return $$051 | 0;
}

function _stringio_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $11 = sp + 4 | 0;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $9 = 16;
 $10 = 0;
 $13 = $5;
 $14 = _stringio_new($13) | 0;
 $12 = $14;
 $15 = $6;
 $16 = $15 >>> 0 > 0;
 L1 : do {
  if ($16) {
   $17 = $8;
   $18 = HEAP32[$17 >> 2] | 0;
   $19 = _mp_obj_is_small_int_1220($18) | 0;
   do {
    if (!$19) {
     $20 = $8;
     $21 = HEAP32[$20 >> 2] | 0;
     $22 = _mp_obj_is_obj_1221($21) | 0;
     if ($22) {
      $23 = $8;
      $24 = HEAP32[$23 >> 2] | 0;
      $25 = HEAP32[$24 >> 2] | 0;
      $26 = ($25 | 0) == (16904 | 0);
      if ($26) {
       break;
      }
     }
     $30 = $8;
     $31 = HEAP32[$30 >> 2] | 0;
     _mp_get_buffer_raise($31, $11, 1);
     $32 = $8;
     $33 = HEAP32[$32 >> 2] | 0;
     $34 = _mp_obj_is_qstr_1222($33) | 0;
     do {
      if (!$34) {
       $35 = $8;
       $36 = HEAP32[$35 >> 2] | 0;
       $37 = _mp_obj_is_obj_1221($36) | 0;
       if ($37) {
        $38 = $8;
        $39 = HEAP32[$38 >> 2] | 0;
        $40 = HEAP32[$39 >> 2] | 0;
        $41 = $40 + 24 | 0;
        $42 = HEAP32[$41 >> 2] | 0;
        $43 = ($42 | 0) == (206 | 0);
        if ($43) {
         break;
        }
       }
       $64 = $11 + 4 | 0;
       $65 = HEAP32[$64 >> 2] | 0;
       $9 = $65;
       $10 = 1;
       break L1;
      }
     } while (0);
     $44 = _m_malloc(16) | 0;
     $45 = $12;
     $46 = $45 + 4 | 0;
     HEAP32[$46 >> 2] = $44;
     $47 = $12;
     $48 = $47 + 4 | 0;
     $49 = HEAP32[$48 >> 2] | 0;
     $50 = $11 + 4 | 0;
     $51 = HEAP32[$50 >> 2] | 0;
     $52 = HEAP32[$11 >> 2] | 0;
     _vstr_init_fixed_buf($49, $51, $52);
     $53 = $11 + 4 | 0;
     $54 = HEAP32[$53 >> 2] | 0;
     $55 = $12;
     $56 = $55 + 4 | 0;
     $57 = HEAP32[$56 >> 2] | 0;
     $58 = $57 + 4 | 0;
     HEAP32[$58 >> 2] = $54;
     $59 = $8;
     $60 = HEAP32[$59 >> 2] | 0;
     $61 = $12;
     $62 = $61 + 12 | 0;
     HEAP32[$62 >> 2] = $60;
     $63 = $12;
     $4 = $63;
     $79 = $4;
     STACKTOP = sp;
     return $79 | 0;
    }
   } while (0);
   $27 = $8;
   $28 = HEAP32[$27 >> 2] | 0;
   $29 = _mp_obj_get_int($28) | 0;
   $9 = $29;
  }
 } while (0);
 $66 = $9;
 $67 = _vstr_new($66) | 0;
 $68 = $12;
 $69 = $68 + 4 | 0;
 HEAP32[$69 >> 2] = $67;
 $70 = $10;
 $71 = $70 & 1;
 if ($71) {
  $72 = $12;
  $73 = HEAP32[$11 >> 2] | 0;
  $74 = $11 + 4 | 0;
  $75 = HEAP32[$74 >> 2] | 0;
  _stringio_write($72, $73, $75, 0) | 0;
  $76 = $12;
  $77 = $76 + 8 | 0;
  HEAP32[$77 >> 2] = 0;
 }
 $78 = $12;
 $4 = $78;
 $79 = $4;
 STACKTOP = sp;
 return $79 | 0;
}

function _mp_unpack_sequence($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $6 = sp + 48 | 0;
 $7 = sp + 44 | 0;
 $9 = sp + 24 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $12 = $3;
 $13 = _mp_obj_is_obj_729($12) | 0;
 if ($13) {
  $14 = $3;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = ($15 | 0) == (18952 | 0);
  if (!$16) {
   label = 3;
  }
 } else {
  label = 3;
 }
 do {
  if ((label | 0) == 3) {
   $17 = $3;
   $18 = _mp_obj_is_obj_729($17) | 0;
   if ($18) {
    $19 = $3;
    $20 = HEAP32[$19 >> 2] | 0;
    $21 = ($20 | 0) == (17028 | 0);
    if ($21) {
     break;
    }
   }
   $44 = $3;
   $45 = _mp_getiter($44, $9) | 0;
   $10 = $45;
   HEAP32[$6 >> 2] = 0;
   while (1) {
    $46 = HEAP32[$6 >> 2] | 0;
    $47 = $4;
    $48 = $46 >>> 0 < $47 >>> 0;
    $49 = $10;
    $50 = _mp_iternext($49) | 0;
    if (!$48) {
     break;
    }
    $11 = $50;
    $51 = $11;
    $52 = ($51 | 0) == (0 | 0);
    if ($52) {
     label = 16;
     break;
    }
    $53 = $11;
    $54 = $5;
    $55 = $4;
    $56 = $55 - 1 | 0;
    $57 = HEAP32[$6 >> 2] | 0;
    $58 = $56 - $57 | 0;
    $59 = $54 + ($58 << 2) | 0;
    HEAP32[$59 >> 2] = $53;
    $60 = HEAP32[$6 >> 2] | 0;
    $61 = $60 + 1 | 0;
    HEAP32[$6 >> 2] = $61;
   }
   if ((label | 0) == 16) {
    $63 = HEAP32[$6 >> 2] | 0;
    HEAP32[$vararg_buffer >> 2] = $63;
    $64 = _mp_obj_new_exception_msg_varg(16072, 29829, $vararg_buffer) | 0;
    _nlr_jump($64);
   }
   $62 = ($50 | 0) != (0 | 0);
   if ($62) {
    $65 = $4;
    HEAP32[$vararg_buffer1 >> 2] = $65;
    $66 = _mp_obj_new_exception_msg_varg(16072, 29864, $vararg_buffer1) | 0;
    _nlr_jump($66);
   } else {
    STACKTOP = sp;
    return;
   }
  }
 } while (0);
 $22 = $3;
 _mp_obj_get_array($22, $6, $7);
 $23 = HEAP32[$6 >> 2] | 0;
 $24 = $4;
 $25 = $23 >>> 0 < $24 >>> 0;
 if ($25) {
  $63 = HEAP32[$6 >> 2] | 0;
  HEAP32[$vararg_buffer >> 2] = $63;
  $64 = _mp_obj_new_exception_msg_varg(16072, 29829, $vararg_buffer) | 0;
  _nlr_jump($64);
 }
 $26 = HEAP32[$6 >> 2] | 0;
 $27 = $4;
 $28 = $26 >>> 0 > $27 >>> 0;
 if ($28) {
  $65 = $4;
  HEAP32[$vararg_buffer1 >> 2] = $65;
  $66 = _mp_obj_new_exception_msg_varg(16072, 29864, $vararg_buffer1) | 0;
  _nlr_jump($66);
 }
 $8 = 0;
 while (1) {
  $29 = $8;
  $30 = $4;
  $31 = $29 >>> 0 < $30 >>> 0;
  if (!$31) {
   break;
  }
  $32 = HEAP32[$7 >> 2] | 0;
  $33 = $4;
  $34 = $33 - 1 | 0;
  $35 = $8;
  $36 = $34 - $35 | 0;
  $37 = $32 + ($36 << 2) | 0;
  $38 = HEAP32[$37 >> 2] | 0;
  $39 = $5;
  $40 = $8;
  $41 = $39 + ($40 << 2) | 0;
  HEAP32[$41 >> 2] = $38;
  $42 = $8;
  $43 = $42 + 1 | 0;
  $8 = $43;
 }
 STACKTOP = sp;
 return;
}

function _str_partitioner($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $8 = sp + 28 | 0;
 $10 = sp + 20 | 0;
 $11 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $14 = $3;
 $15 = _mp_obj_get_type($14) | 0;
 $6 = $15;
 $16 = $6;
 $17 = $4;
 $18 = _mp_obj_get_type($17) | 0;
 $19 = ($16 | 0) != ($18 | 0);
 if ($19) {
  $20 = $4;
  _bad_implicit_conversion($20);
 }
 $21 = $3;
 $22 = _mp_obj_is_qstr_1128($21) | 0;
 $23 = $3;
 if ($22) {
  $24 = $23;
  $25 = $24 >>> 2;
  $26 = _qstr_data($25, $8) | 0;
  $7 = $26;
 } else {
  $27 = $23 + 8 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  HEAP32[$8 >> 2] = $28;
  $29 = $3;
  $30 = $29 + 12 | 0;
  $31 = HEAP32[$30 >> 2] | 0;
  $7 = $31;
 }
 $32 = $4;
 $33 = _mp_obj_is_qstr_1128($32) | 0;
 $34 = $4;
 if ($33) {
  $35 = $34;
  $36 = $35 >>> 2;
  $37 = _qstr_data($36, $10) | 0;
  $9 = $37;
 } else {
  $38 = $34 + 8 | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  HEAP32[$10 >> 2] = $39;
  $40 = $4;
  $41 = $40 + 12 | 0;
  $42 = HEAP32[$41 >> 2] | 0;
  $9 = $42;
 }
 $43 = HEAP32[$10 >> 2] | 0;
 $44 = ($43 | 0) == 0;
 if ($44) {
  _mp_raise_ValueError(31716);
 }
 $45 = $6;
 $46 = ($45 | 0) == (18680 | 0);
 if ($46) {
  HEAP32[$11 >> 2] = 6;
  $47 = $11 + 4 | 0;
  HEAP32[$47 >> 2] = 6;
  $48 = $11 + 8 | 0;
  HEAP32[$48 >> 2] = 6;
 } else {
  HEAP32[$11 >> 2] = 18288;
  $49 = $11 + 4 | 0;
  HEAP32[$49 >> 2] = 18288;
  $50 = $11 + 8 | 0;
  HEAP32[$50 >> 2] = 18288;
 }
 $51 = $5;
 $52 = ($51 | 0) > 0;
 $53 = $3;
 if ($52) {
  HEAP32[$11 >> 2] = $53;
 } else {
  $54 = $11 + 8 | 0;
  HEAP32[$54 >> 2] = $53;
 }
 $55 = $7;
 $56 = HEAP32[$8 >> 2] | 0;
 $57 = $9;
 $58 = HEAP32[$10 >> 2] | 0;
 $59 = $5;
 $60 = _find_subbytes($55, $56, $57, $58, $59) | 0;
 $12 = $60;
 $61 = $12;
 $62 = ($61 | 0) != (0 | 0);
 if (!$62) {
  $87 = _mp_obj_new_tuple(3, $11) | 0;
  STACKTOP = sp;
  return $87 | 0;
 }
 $63 = $12;
 $64 = $7;
 $65 = $63;
 $66 = $64;
 $67 = $65 - $66 | 0;
 $13 = $67;
 $68 = $6;
 $69 = $7;
 $70 = $13;
 $71 = _mp_obj_new_str_of_type($68, $69, $70) | 0;
 HEAP32[$11 >> 2] = $71;
 $72 = $4;
 $73 = $11 + 4 | 0;
 HEAP32[$73 >> 2] = $72;
 $74 = $6;
 $75 = $7;
 $76 = $13;
 $77 = $75 + $76 | 0;
 $78 = HEAP32[$10 >> 2] | 0;
 $79 = $77 + $78 | 0;
 $80 = HEAP32[$8 >> 2] | 0;
 $81 = $13;
 $82 = $80 - $81 | 0;
 $83 = HEAP32[$10 >> 2] | 0;
 $84 = $82 - $83 | 0;
 $85 = _mp_obj_new_str_of_type($74, $79, $84) | 0;
 $86 = $11 + 8 | 0;
 HEAP32[$86 >> 2] = $85;
 $87 = _mp_obj_new_tuple(3, $11) | 0;
 STACKTOP = sp;
 return $87 | 0;
}

function _mp_print_int($0, $1, $2, $3, $4, $5, $6, $7) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 $7 = $7 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $16 = sp + 56 | 0;
 $17 = sp;
 $8 = $0;
 $9 = $1;
 $10 = $2;
 $11 = $3;
 $12 = $4;
 $13 = $5;
 $14 = $6;
 $15 = $7;
 HEAP8[$16 >> 0] = 0;
 $21 = $10;
 $22 = ($21 | 0) != 0;
 do {
  if ($22) {
   $23 = $9;
   $24 = ($23 | 0) < 0;
   if ($24) {
    HEAP8[$16 >> 0] = 45;
    $25 = $9;
    $26 = 0 - $25 | 0;
    $9 = $26;
    break;
   }
   $27 = $13;
   $28 = $27 & 2;
   $29 = ($28 | 0) != 0;
   if ($29) {
    HEAP8[$16 >> 0] = 43;
    break;
   }
   $30 = $13;
   $31 = $30 & 4;
   $32 = ($31 | 0) != 0;
   if ($32) {
    HEAP8[$16 >> 0] = 32;
   }
  }
 } while (0);
 $33 = $17 + 16 | 0;
 $18 = $33;
 $34 = $9;
 $35 = ($34 | 0) == 0;
 if ($35) {
  $36 = $18;
  $37 = $36 + -1 | 0;
  $18 = $37;
  HEAP8[$37 >> 0] = 48;
 } else {
  while (1) {
   $38 = $9;
   $39 = $11;
   $40 = ($38 >>> 0) % ($39 >>> 0) & -1;
   $19 = $40;
   $41 = $11;
   $42 = $9;
   $43 = ($42 >>> 0) / ($41 >>> 0) & -1;
   $9 = $43;
   $44 = $19;
   $45 = ($44 | 0) >= 10;
   if ($45) {
    $46 = $12;
    $47 = $46 - 10 | 0;
    $48 = $19;
    $49 = $48 + $47 | 0;
    $19 = $49;
   } else {
    $50 = $19;
    $51 = $50 + 48 | 0;
    $19 = $51;
   }
   $52 = $19;
   $53 = $52 & 255;
   $54 = $18;
   $55 = $54 + -1 | 0;
   $18 = $55;
   HEAP8[$55 >> 0] = $53;
   $56 = $18;
   $57 = $56 >>> 0 > $17 >>> 0;
   $58 = $9;
   $59 = ($58 | 0) != 0;
   $60 = $57 ? $59 : 0;
   if (!$60) {
    break;
   }
  }
 }
 $20 = 0;
 $61 = $13;
 $62 = $61 & 64;
 $63 = ($62 | 0) != 0;
 $64 = HEAP8[$16 >> 0] | 0;
 if ($63) {
  $65 = $64 << 24 >> 24 != 0;
  if ($65) {
   $66 = $8;
   $67 = $13;
   $68 = $14;
   $69 = _mp_print_strn($66, $16, 1, $67, $68, 1) | 0;
   $70 = $20;
   $71 = $70 + $69 | 0;
   $20 = $71;
   $72 = $15;
   $73 = $72 + -1 | 0;
   $15 = $73;
  }
 } else {
  $74 = $64 << 24 >> 24;
  $75 = ($74 | 0) != 0;
  if ($75) {
   $76 = $18;
   $77 = $76 >>> 0 > $17 >>> 0;
   if ($77) {
    $78 = HEAP8[$16 >> 0] | 0;
    $79 = $18;
    $80 = $79 + -1 | 0;
    $18 = $80;
    HEAP8[$80 >> 0] = $78;
   }
  }
 }
 $81 = $8;
 $82 = $18;
 $83 = $17 + 16 | 0;
 $84 = $18;
 $85 = $83;
 $86 = $84;
 $87 = $85 - $86 | 0;
 $88 = $13;
 $89 = $14;
 $90 = $15;
 $91 = _mp_print_strn($81, $82, $87, $88, $89, $90) | 0;
 $92 = $20;
 $93 = $92 + $91 | 0;
 $20 = $93;
 $94 = $20;
 STACKTOP = sp;
 return $94 | 0;
}

function _mp_obj_str_equal($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val3 = 0, $$expand_i1_val5 = 0, $$expand_i1_val7 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $2 = sp + 32 | 0;
 $8 = sp + 8 | 0;
 $10 = sp;
 $3 = $0;
 $4 = $1;
 $11 = $3;
 $12 = _mp_obj_is_qstr_1128($11) | 0;
 if ($12) {
  $13 = $4;
  $14 = _mp_obj_is_qstr_1128($13) | 0;
  if ($14) {
   $15 = $3;
   $16 = $4;
   $17 = ($15 | 0) == ($16 | 0);
   $$expand_i1_val = $17 & 1;
   HEAP8[$2 >> 0] = $$expand_i1_val;
   $$pre_trunc = HEAP8[$2 >> 0] | 0;
   $71 = $$pre_trunc & 1;
   STACKTOP = sp;
   return $71 | 0;
  }
 }
 $18 = $3;
 $19 = _mp_obj_is_qstr_1128($18) | 0;
 $20 = $3;
 if ($19) {
  $21 = $20;
  $22 = $21 >>> 2;
  $23 = _qstr_hash($22) | 0;
  $5 = $23;
 } else {
  $24 = $20 + 4 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $5 = $25;
 }
 $26 = $4;
 $27 = _mp_obj_is_qstr_1128($26) | 0;
 $28 = $4;
 if ($27) {
  $29 = $28;
  $30 = $29 >>> 2;
  $31 = _qstr_hash($30) | 0;
  $6 = $31;
 } else {
  $32 = $28 + 4 | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $6 = $33;
 }
 $34 = $5;
 $35 = ($34 | 0) != 0;
 $36 = $6;
 $37 = ($36 | 0) != 0;
 $or$cond = $35 & $37;
 if ($or$cond) {
  $38 = $5;
  $39 = $6;
  $40 = ($38 | 0) != ($39 | 0);
  if ($40) {
   $$expand_i1_val3 = 0;
   HEAP8[$2 >> 0] = $$expand_i1_val3;
   $$pre_trunc = HEAP8[$2 >> 0] | 0;
   $71 = $$pre_trunc & 1;
   STACKTOP = sp;
   return $71 | 0;
  }
 }
 $41 = $3;
 $42 = _mp_obj_is_qstr_1128($41) | 0;
 $43 = $3;
 if ($42) {
  $44 = $43;
  $45 = $44 >>> 2;
  $46 = _qstr_data($45, $8) | 0;
  $7 = $46;
 } else {
  $47 = $43 + 8 | 0;
  $48 = HEAP32[$47 >> 2] | 0;
  HEAP32[$8 >> 2] = $48;
  $49 = $3;
  $50 = $49 + 12 | 0;
  $51 = HEAP32[$50 >> 2] | 0;
  $7 = $51;
 }
 $52 = $4;
 $53 = _mp_obj_is_qstr_1128($52) | 0;
 $54 = $4;
 if ($53) {
  $55 = $54;
  $56 = $55 >>> 2;
  $57 = _qstr_data($56, $10) | 0;
  $9 = $57;
 } else {
  $58 = $54 + 8 | 0;
  $59 = HEAP32[$58 >> 2] | 0;
  HEAP32[$10 >> 2] = $59;
  $60 = $4;
  $61 = $60 + 12 | 0;
  $62 = HEAP32[$61 >> 2] | 0;
  $9 = $62;
 }
 $63 = HEAP32[$8 >> 2] | 0;
 $64 = HEAP32[$10 >> 2] | 0;
 $65 = ($63 | 0) != ($64 | 0);
 if ($65) {
  $$expand_i1_val5 = 0;
  HEAP8[$2 >> 0] = $$expand_i1_val5;
  $$pre_trunc = HEAP8[$2 >> 0] | 0;
  $71 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $71 | 0;
 } else {
  $66 = $7;
  $67 = $9;
  $68 = HEAP32[$8 >> 2] | 0;
  $69 = _memcmp($66, $67, $68) | 0;
  $70 = ($69 | 0) == 0;
  $$expand_i1_val7 = $70 & 1;
  HEAP8[$2 >> 0] = $$expand_i1_val7;
  $$pre_trunc = HEAP8[$2 >> 0] | 0;
  $71 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $71 | 0;
 }
 return 0 | 0;
}

function _log2($0) {
 $0 = +$0;
 var $$0 = 0, $$096 = 0, $$097 = 0.0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0.0, $29 = 0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0, $52 = 0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0, $60 = 0.0, $61 = 0.0, $62 = 0.0, $63 = 0.0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0.0, $69 = 0.0, $7 = 0, $8 = 0, $9 = 0.0, $or$cond = 0, $or$cond101 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = $2 >>> 0 < 1048576;
 $4 = ($2 | 0) < 0;
 $or$cond = $4 | $3;
 do {
  if ($or$cond) {
   $5 = $2 & 2147483647;
   $6 = ($1 | 0) == 0;
   $7 = ($5 | 0) == 0;
   $8 = $6 & $7;
   if ($8) {
    $9 = $0 * $0;
    $10 = -1.0 / $9;
    $$097 = $10;
    break;
   }
   if ($4) {
    $11 = $0 - $0;
    $12 = $11 / 0.0;
    $$097 = $12;
    break;
   } else {
    $13 = $0 * 18014398509481984.0;
    HEAPF64[tempDoublePtr >> 3] = $13;
    $14 = HEAP32[tempDoublePtr >> 2] | 0;
    $15 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
    $$0 = -1077;
    $$096 = $15;
    $27 = 0;
    $29 = $14;
    label = 9;
    break;
   }
  } else {
   $16 = $2 >>> 0 > 2146435071;
   if ($16) {
    $$097 = $0;
   } else {
    $17 = ($2 | 0) == 1072693248;
    $18 = ($1 | 0) == 0;
    $19 = 0 == 0;
    $20 = $18 & $19;
    $or$cond101 = $20 & $17;
    if ($or$cond101) {
     $$097 = 0.0;
    } else {
     $$0 = -1023;
     $$096 = $2;
     $27 = 0;
     $29 = $1;
     label = 9;
    }
   }
  }
 } while (0);
 if ((label | 0) == 9) {
  $21 = $$096 + 614242 | 0;
  $22 = $21 >>> 20;
  $23 = $$0 + $22 | 0;
  $24 = $21 & 1048575;
  $25 = $24 + 1072079006 | 0;
  $26 = $25 | $27;
  HEAP32[tempDoublePtr >> 2] = $29;
  HEAP32[tempDoublePtr + 4 >> 2] = $26;
  $28 = +HEAPF64[tempDoublePtr >> 3];
  $30 = $28 + -1.0;
  $31 = $30 * .5;
  $32 = $30 * $31;
  $33 = $30 + 2.0;
  $34 = $30 / $33;
  $35 = $34 * $34;
  $36 = $35 * $35;
  $37 = $36 * .15313837699209373;
  $38 = $37 + .22222198432149784;
  $39 = $36 * $38;
  $40 = $39 + .3999999999940942;
  $41 = $36 * $40;
  $42 = $36 * .14798198605116586;
  $43 = $42 + .1818357216161805;
  $44 = $36 * $43;
  $45 = $44 + .2857142874366239;
  $46 = $36 * $45;
  $47 = $46 + .6666666666666735;
  $48 = $35 * $47;
  $49 = $41 + $48;
  $50 = $30 - $32;
  HEAPF64[tempDoublePtr >> 3] = $50;
  $51 = HEAP32[tempDoublePtr >> 2] | 0;
  $52 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  HEAP32[tempDoublePtr >> 2] = 0;
  HEAP32[tempDoublePtr + 4 >> 2] = $52;
  $53 = +HEAPF64[tempDoublePtr >> 3];
  $54 = $30 - $53;
  $55 = $54 - $32;
  $56 = $32 + $49;
  $57 = $34 * $56;
  $58 = $55 + $57;
  $59 = $53 * 1.4426950407214463;
  $60 = $58 + $53;
  $61 = $60 * 1.6751713164886512e-10;
  $62 = $58 * 1.4426950407214463;
  $63 = $62 + $61;
  $64 = +($23 | 0);
  $65 = $59 + $64;
  $66 = $64 - $65;
  $67 = $59 + $66;
  $68 = $67 + $63;
  $69 = $65 + $68;
  $$097 = $69;
 }
 return +$$097;
}

function _namedtuple_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, $vararg_buffer5 = 0, $vararg_ptr1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $vararg_buffer5 = sp + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $14 = $4;
 $8 = $14;
 $15 = $8;
 $16 = $15 + 60 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $9 = $17;
 $18 = $5;
 $19 = $6;
 $20 = $18 + $19 | 0;
 $21 = $9;
 $22 = ($20 | 0) != ($21 | 0);
 $23 = $9;
 if ($22) {
  $24 = $5;
  $25 = $6;
  $26 = $24 + $25 | 0;
  HEAP32[$vararg_buffer >> 2] = $23;
  $vararg_ptr1 = $vararg_buffer + 4 | 0;
  HEAP32[$vararg_ptr1 >> 2] = $26;
  $27 = _mp_obj_new_exception_msg_varg(16012, 34348, $vararg_buffer) | 0;
  _nlr_jump($27);
 }
 $28 = _mp_obj_new_tuple($23, 0) | 0;
 $10 = $28;
 $29 = $4;
 $30 = $10;
 HEAP32[$30 >> 2] = $29;
 $31 = $10;
 $32 = $31 + 8 | 0;
 $33 = $7;
 $34 = $5;
 $35 = $34 << 2;
 _memcpy($32 | 0, $33 | 0, $35 | 0) | 0;
 $36 = $10;
 $37 = $36 + 8 | 0;
 $38 = $5;
 $39 = $37 + ($38 << 2) | 0;
 $40 = $6;
 $41 = $40 << 2;
 _memset($39 | 0, 0, $41 | 0) | 0;
 $42 = $5;
 $11 = $42;
 while (1) {
  $43 = $11;
  $44 = $5;
  $45 = $6;
  $46 = $45 << 1;
  $47 = $44 + $46 | 0;
  $48 = $43 >>> 0 < $47 >>> 0;
  if (!$48) {
   label = 10;
   break;
  }
  $49 = $7;
  $50 = $11;
  $51 = $49 + ($50 << 2) | 0;
  $52 = HEAP32[$51 >> 2] | 0;
  $53 = _mp_obj_str_get_qstr($52) | 0;
  $12 = $53;
  $54 = $8;
  $55 = $12;
  $56 = _mp_obj_namedtuple_find_field($54, $55) | 0;
  $13 = $56;
  $57 = $13;
  $58 = ($57 | 0) == -1;
  if ($58) {
   label = 6;
   break;
  }
  $61 = $10;
  $62 = $61 + 8 | 0;
  $63 = $13;
  $64 = $62 + ($63 << 2) | 0;
  $65 = HEAP32[$64 >> 2] | 0;
  $66 = ($65 | 0) != (0 | 0);
  if ($66) {
   label = 8;
   break;
  }
  $69 = $7;
  $70 = $11;
  $71 = $70 + 1 | 0;
  $72 = $69 + ($71 << 2) | 0;
  $73 = HEAP32[$72 >> 2] | 0;
  $74 = $10;
  $75 = $74 + 8 | 0;
  $76 = $13;
  $77 = $75 + ($76 << 2) | 0;
  HEAP32[$77 >> 2] = $73;
  $78 = $11;
  $79 = $78 + 2 | 0;
  $11 = $79;
 }
 if ((label | 0) == 6) {
  $59 = $12;
  HEAP32[$vararg_buffer2 >> 2] = $59;
  $60 = _mp_obj_new_exception_msg_varg(16012, 34178, $vararg_buffer2) | 0;
  _nlr_jump($60);
 } else if ((label | 0) == 8) {
  $67 = $12;
  HEAP32[$vararg_buffer5 >> 2] = $67;
  $68 = _mp_obj_new_exception_msg_varg(16012, 34131, $vararg_buffer5) | 0;
  _nlr_jump($68);
 } else if ((label | 0) == 10) {
  $80 = $10;
  STACKTOP = sp;
  return $80 | 0;
 }
 return 0 | 0;
}

function _super_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $8 = sp + 16 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $13 = $5;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = ($14 | 0) != (0 | 0);
 if ($15) {
  STACKTOP = sp;
  return;
 }
 $16 = $3;
 $6 = $16;
 $17 = $6;
 $18 = $17 + 4 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $7 = $19;
 $20 = $6;
 $21 = $20 + 8 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 HEAP32[$8 >> 2] = $22;
 $23 = $8 + 4 | 0;
 $24 = $4;
 HEAP32[$23 >> 2] = $24;
 $25 = $8 + 8 | 0;
 HEAP32[$25 >> 2] = 0;
 $26 = $8 + 12 | 0;
 $27 = $5;
 HEAP32[$26 >> 2] = $27;
 $28 = $8 + 16 | 0;
 HEAP8[$28 >> 0] = 0;
 $29 = $4;
 $30 = ($29 | 0) == 17;
 if ($30) {
  $31 = $8 + 8 | 0;
  HEAP32[$31 >> 2] = 12;
 }
 $32 = $7;
 $33 = $32 + 52 | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = ($34 | 0) == (0 | 0);
 L7 : do {
  if (!$35) {
   $36 = $7;
   $37 = $36 + 52 | 0;
   $38 = HEAP32[$37 >> 2] | 0;
   $39 = HEAP32[$38 >> 2] | 0;
   $40 = ($39 | 0) == (18952 | 0);
   $41 = $7;
   $42 = $41 + 52 | 0;
   $43 = HEAP32[$42 >> 2] | 0;
   if (!$40) {
    $66 = ($43 | 0) != (17348 | 0);
    if (!$66) {
     break;
    }
    $67 = $7;
    $68 = $67 + 52 | 0;
    $69 = HEAP32[$68 >> 2] | 0;
    _mp_obj_class_lookup($8, $69);
    break;
   }
   $9 = $43;
   $44 = $9;
   $45 = $44 + 4 | 0;
   $46 = HEAP32[$45 >> 2] | 0;
   $10 = $46;
   $47 = $9;
   $48 = $47 + 8 | 0;
   $11 = $48;
   $12 = 0;
   while (1) {
    $49 = $12;
    $50 = $10;
    $51 = $49 >>> 0 < $50 >>> 0;
    if (!$51) {
     break L7;
    }
    $52 = $11;
    $53 = $12;
    $54 = $52 + ($53 << 2) | 0;
    $55 = HEAP32[$54 >> 2] | 0;
    $56 = ($55 | 0) == (17348 | 0);
    if (!$56) {
     $57 = $11;
     $58 = $12;
     $59 = $57 + ($58 << 2) | 0;
     $60 = HEAP32[$59 >> 2] | 0;
     _mp_obj_class_lookup($8, $60);
     $61 = $5;
     $62 = HEAP32[$61 >> 2] | 0;
     $63 = ($62 | 0) != (0 | 0);
     if ($63) {
      break L7;
     }
    }
    $64 = $12;
    $65 = $64 + 1 | 0;
    $12 = $65;
   }
  }
 } while (0);
 $70 = $5;
 $71 = HEAP32[$70 >> 2] | 0;
 $72 = ($71 | 0) != (0 | 0);
 if (!$72) {
  $82 = $8 + 8 | 0;
  HEAP32[$82 >> 2] = 0;
  _mp_obj_class_lookup($8, 17348);
  STACKTOP = sp;
  return;
 }
 $73 = $5;
 $74 = HEAP32[$73 >> 2] | 0;
 $75 = ($74 | 0) == (4 | 0);
 if (!$75) {
  STACKTOP = sp;
  return;
 }
 $76 = $5;
 HEAP32[$76 >> 2] = 19108;
 $77 = $6;
 $78 = $77 + 8 | 0;
 $79 = HEAP32[$78 >> 2] | 0;
 $80 = $5;
 $81 = $80 + 4 | 0;
 HEAP32[$81 >> 2] = $79;
 STACKTOP = sp;
 return;
}

function _atan($0) {
 $0 = +$0;
 var $$0 = 0.0, $$064 = 0, $$065 = 0.0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0.0, $15 = 0, $16 = 0, $17 = 0.0, $18 = 0, $19 = 0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $55 = 0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0, $6 = 0, $60 = 0.0, $61 = 0.0, $62 = 0.0, $63 = 0, $64 = 0.0, $65 = 0.0, $66 = 0.0, $67 = 0.0, $68 = 0, $69 = 0.0, $7 = 0, $70 = 0.0, $8 = 0, $9 = 0, $spec$select = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = _bitshift64Lshr($1 | 0, $2 | 0, 63) | 0;
 $4 = getTempRet0() | 0;
 $5 = $2 & 2147483647;
 $6 = $5 >>> 0 > 1141899263;
 if ($6) {
  $7 = $2 & 2147483647;
  $8 = $7 >>> 0 > 2146435072;
  $9 = $1 >>> 0 > 0;
  $10 = ($7 | 0) == 2146435072;
  $11 = $10 & $9;
  $12 = $8 | $11;
  $13 = ($3 | 0) == 0;
  $14 = $13 ? 1.5707963267948966 : -1.5707963267948966;
  $spec$select = $12 ? $0 : $14;
  return +$spec$select;
 }
 $15 = $5 >>> 0 < 1071382528;
 do {
  if ($15) {
   $16 = $5 >>> 0 < 1044381696;
   if ($16) {
    $$0 = $0;
    return +$$0;
   } else {
    $$064 = -1;
    $$065 = $0;
   }
  } else {
   $17 = +Math_abs(+$0);
   $18 = $5 >>> 0 < 1072889856;
   if ($18) {
    $19 = $5 >>> 0 < 1072037888;
    if ($19) {
     $20 = $17 * 2.0;
     $21 = $20 + -1.0;
     $22 = $17 + 2.0;
     $23 = $21 / $22;
     $$064 = 0;
     $$065 = $23;
     break;
    } else {
     $24 = $17 + -1.0;
     $25 = $17 + 1.0;
     $26 = $24 / $25;
     $$064 = 1;
     $$065 = $26;
     break;
    }
   } else {
    $27 = $5 >>> 0 < 1073971200;
    if ($27) {
     $28 = $17 + -1.5;
     $29 = $17 * 1.5;
     $30 = $29 + 1.0;
     $31 = $28 / $30;
     $$064 = 2;
     $$065 = $31;
     break;
    } else {
     $32 = -1.0 / $17;
     $$064 = 3;
     $$065 = $32;
     break;
    }
   }
  }
 } while (0);
 $33 = $$065 * $$065;
 $34 = $33 * $33;
 $35 = $34 * .016285820115365782;
 $36 = $35 + .049768779946159324;
 $37 = $34 * $36;
 $38 = $37 + .06661073137387531;
 $39 = $34 * $38;
 $40 = $39 + .09090887133436507;
 $41 = $34 * $40;
 $42 = $41 + .14285714272503466;
 $43 = $34 * $42;
 $44 = $43 + .3333333333333293;
 $45 = $33 * $44;
 $46 = $34 * .036531572744216916;
 $47 = -.058335701337905735 - $46;
 $48 = $34 * $47;
 $49 = $48 + -.0769187620504483;
 $50 = $34 * $49;
 $51 = $50 + -.11111110405462356;
 $52 = $34 * $51;
 $53 = $52 + -.19999999999876483;
 $54 = $34 * $53;
 $55 = ($$064 | 0) < 0;
 if ($55) {
  $56 = $54 + $45;
  $57 = $$065 * $56;
  $58 = $$065 - $57;
  $$0 = $58;
  return +$$0;
 } else {
  $59 = 10832 + ($$064 << 3) | 0;
  $60 = +HEAPF64[$59 >> 3];
  $61 = $54 + $45;
  $62 = $$065 * $61;
  $63 = 10864 + ($$064 << 3) | 0;
  $64 = +HEAPF64[$63 >> 3];
  $65 = $62 - $64;
  $66 = $65 - $$065;
  $67 = $60 - $66;
  $68 = ($3 | 0) == 0;
  $69 = -$67;
  $70 = $68 ? $67 : $69;
  $$0 = $70;
  return +$$0;
 }
 return +(0.0);
}

function _parser_alloc($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $8 = $2;
 $9 = $8 + 36 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $4 = $10;
 $11 = $4;
 $12 = ($11 | 0) != (0 | 0);
 do {
  if ($12) {
   $13 = $4;
   $14 = $13 + 4 | 0;
   $15 = HEAP32[$14 >> 2] | 0;
   $16 = $3;
   $17 = $15 + $16 | 0;
   $18 = $4;
   $19 = HEAP32[$18 >> 2] | 0;
   $20 = $17 >>> 0 > $19 >>> 0;
   if ($20) {
    $21 = $4;
    $22 = $4;
    $23 = HEAP32[$22 >> 2] | 0;
    $24 = 8 + $23 | 0;
    $25 = $3;
    $26 = $24 + $25 | 0;
    $27 = $26;
    $28 = _m_realloc_maybe($21, $27, 0) | 0;
    $5 = $28;
    $29 = $5;
    $30 = ($29 | 0) == (0 | 0);
    if ($30) {
     $31 = $4;
     $32 = $4;
     $33 = $32 + 4 | 0;
     $34 = HEAP32[$33 >> 2] | 0;
     $35 = 8 + $34 | 0;
     $36 = $35;
     _m_realloc_maybe($31, $36, 0) | 0;
     $37 = $4;
     $38 = $37 + 4 | 0;
     $39 = HEAP32[$38 >> 2] | 0;
     $40 = $4;
     HEAP32[$40 >> 2] = $39;
     $41 = $2;
     $42 = $41 + 28 | 0;
     $43 = $42 + 4 | 0;
     $44 = HEAP32[$43 >> 2] | 0;
     $45 = $4;
     $46 = $45 + 4 | 0;
     HEAP32[$46 >> 2] = $44;
     $47 = $4;
     $48 = $2;
     $49 = $48 + 28 | 0;
     $50 = $49 + 4 | 0;
     HEAP32[$50 >> 2] = $47;
     $4 = 0;
     break;
    } else {
     $51 = $3;
     $52 = $4;
     $53 = HEAP32[$52 >> 2] | 0;
     $54 = $53 + $51 | 0;
     HEAP32[$52 >> 2] = $54;
     break;
    }
   }
  }
 } while (0);
 $55 = $4;
 $56 = ($55 | 0) == (0 | 0);
 if (!$56) {
  $72 = $4;
  $73 = $72 + 8 | 0;
  $74 = $4;
  $75 = $74 + 4 | 0;
  $76 = HEAP32[$75 >> 2] | 0;
  $77 = $73 + $76 | 0;
  $7 = $77;
  $78 = $3;
  $79 = $4;
  $80 = $79 + 4 | 0;
  $81 = HEAP32[$80 >> 2] | 0;
  $82 = $81 + $78 | 0;
  HEAP32[$80 >> 2] = $82;
  $83 = $7;
  STACKTOP = sp;
  return $83 | 0;
 }
 $6 = 16;
 $57 = $6;
 $58 = $3;
 $59 = $57 >>> 0 < $58 >>> 0;
 if ($59) {
  $60 = $3;
  $6 = $60;
 }
 $61 = $6;
 $62 = 8 + $61 | 0;
 $63 = $62;
 $64 = _m_malloc($63) | 0;
 $4 = $64;
 $65 = $6;
 $66 = $4;
 HEAP32[$66 >> 2] = $65;
 $67 = $4;
 $68 = $67 + 4 | 0;
 HEAP32[$68 >> 2] = 0;
 $69 = $4;
 $70 = $2;
 $71 = $70 + 36 | 0;
 HEAP32[$71 >> 2] = $69;
 $72 = $4;
 $73 = $72 + 8 | 0;
 $74 = $4;
 $75 = $74 + 4 | 0;
 $76 = HEAP32[$75 >> 2] | 0;
 $77 = $73 + $76 | 0;
 $7 = $77;
 $78 = $3;
 $79 = $4;
 $80 = $79 + 4 | 0;
 $81 = HEAP32[$80 >> 2] | 0;
 $82 = $81 + $78 | 0;
 HEAP32[$80 >> 2] = $82;
 $83 = $7;
 STACKTOP = sp;
 return $83 | 0;
}

function _get_aligned($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = Math_fround(0), $74 = 0.0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0.0, $8 = 0, $80 = 0, $81 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $4;
 do {
  switch ($7 | 0) {
  case 0:
   {
    $8 = $5;
    $9 = $6;
    $10 = $8 + $9 | 0;
    $11 = HEAP8[$10 >> 0] | 0;
    $12 = $11 & 255;
    $13 = $12 << 1;
    $14 = $13 | 1;
    $15 = $14;
    $3 = $15;
    break;
   }
  case 1:
   {
    $16 = $5;
    $17 = $6;
    $18 = $16 + $17 | 0;
    $19 = HEAP8[$18 >> 0] | 0;
    $20 = $19 << 24 >> 24;
    $21 = $20 << 1;
    $22 = $21 | 1;
    $23 = $22;
    $3 = $23;
    break;
   }
  case 2:
   {
    $24 = $5;
    $25 = $6;
    $26 = $24 + ($25 << 1) | 0;
    $27 = HEAP16[$26 >> 1] | 0;
    $28 = $27 & 65535;
    $29 = $28 << 1;
    $30 = $29 | 1;
    $31 = $30;
    $3 = $31;
    break;
   }
  case 3:
   {
    $32 = $5;
    $33 = $6;
    $34 = $32 + ($33 << 1) | 0;
    $35 = HEAP16[$34 >> 1] | 0;
    $36 = $35 << 16 >> 16;
    $37 = $36 << 1;
    $38 = $37 | 1;
    $39 = $38;
    $3 = $39;
    break;
   }
  case 4:
   {
    $40 = $5;
    $41 = $6;
    $42 = $40 + ($41 << 2) | 0;
    $43 = HEAP32[$42 >> 2] | 0;
    $44 = _mp_obj_new_int_from_uint($43) | 0;
    $3 = $44;
    break;
   }
  case 5:
   {
    $45 = $5;
    $46 = $6;
    $47 = $45 + ($46 << 2) | 0;
    $48 = HEAP32[$47 >> 2] | 0;
    $49 = _mp_obj_new_int($48) | 0;
    $3 = $49;
    break;
   }
  case 6:
   {
    $50 = $5;
    $51 = $6;
    $52 = $50 + ($51 << 3) | 0;
    $53 = $52;
    $54 = $53;
    $55 = HEAP32[$54 >> 2] | 0;
    $56 = $53 + 4 | 0;
    $57 = $56;
    $58 = HEAP32[$57 >> 2] | 0;
    $59 = _mp_obj_new_int_from_ull($55, $58) | 0;
    $3 = $59;
    break;
   }
  case 7:
   {
    $60 = $5;
    $61 = $6;
    $62 = $60 + ($61 << 3) | 0;
    $63 = $62;
    $64 = $63;
    $65 = HEAP32[$64 >> 2] | 0;
    $66 = $63 + 4 | 0;
    $67 = $66;
    $68 = HEAP32[$67 >> 2] | 0;
    $69 = _mp_obj_new_int_from_ll($65, $68) | 0;
    $3 = $69;
    break;
   }
  case 14:
   {
    $70 = $5;
    $71 = $6;
    $72 = $70 + ($71 << 2) | 0;
    $73 = Math_fround(HEAPF32[$72 >> 2]);
    $74 = +$73;
    $75 = _mp_obj_new_float($74) | 0;
    $3 = $75;
    break;
   }
  case 15:
   {
    $76 = $5;
    $77 = $6;
    $78 = $76 + ($77 << 3) | 0;
    $79 = +HEAPF64[$78 >> 3];
    $80 = _mp_obj_new_float($79) | 0;
    $3 = $80;
    break;
   }
  default:
   {
    $3 = 0;
   }
  }
 } while (0);
 $81 = $3;
 STACKTOP = sp;
 return $81 | 0;
}

function _mp_resume($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $11 = sp;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $12 = $5;
 $13 = _mp_obj_get_type($12) | 0;
 $9 = $13;
 $14 = $9;
 $15 = ($14 | 0) == (16732 | 0);
 if ($15) {
  $16 = $5;
  $17 = $6;
  $18 = $7;
  $19 = $8;
  $20 = _mp_obj_gen_resume($16, $17, $18, $19) | 0;
  $4 = $20;
  $67 = $4;
  STACKTOP = sp;
  return $67 | 0;
 }
 $21 = $9;
 $22 = $21 + 40 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = ($23 | 0) != (0 | 0);
 $25 = $6;
 $26 = ($25 | 0) == (17668 | 0);
 $or$cond = $24 & $26;
 if ($or$cond) {
  $27 = $9;
  $28 = $27 + 40 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  $30 = $5;
  $31 = FUNCTION_TABLE_ii[$29 & 1023]($30) | 0;
  $10 = $31;
  $32 = $10;
  $33 = $8;
  HEAP32[$33 >> 2] = $32;
  $34 = $10;
  $35 = ($34 | 0) != (0 | 0);
  if ($35) {
   $4 = 1;
   $67 = $4;
   STACKTOP = sp;
   return $67 | 0;
  } else {
   $4 = 0;
   $67 = $4;
   STACKTOP = sp;
   return $67 | 0;
  }
 }
 $36 = $6;
 $37 = ($36 | 0) == (17668 | 0);
 if ($37) {
  $38 = $5;
  _mp_load_method_maybe($38, 25, $11);
  $39 = HEAP32[$11 >> 2] | 0;
  $40 = ($39 | 0) != (0 | 0);
  if ($40) {
   $41 = _mp_call_method_n_kw(0, 0, $11) | 0;
   $42 = $8;
   HEAP32[$42 >> 2] = $41;
   $4 = 1;
   $67 = $4;
   STACKTOP = sp;
   return $67 | 0;
  }
 }
 $43 = $6;
 $44 = ($43 | 0) != (0 | 0);
 if ($44) {
  $45 = $5;
  _mp_load_method($45, 138, $11);
  $46 = $6;
  $47 = $11 + 8 | 0;
  HEAP32[$47 >> 2] = $46;
  $48 = _mp_call_method_n_kw(1, 0, $11) | 0;
  $49 = $8;
  HEAP32[$49 >> 2] = $48;
  $4 = 1;
  $67 = $4;
  STACKTOP = sp;
  return $67 | 0;
 }
 $50 = $7;
 $51 = _mp_obj_get_type($50) | 0;
 $52 = _mp_obj_is_subclass_fast($51, 14556) | 0;
 $53 = $5;
 if ($52) {
  _mp_load_method_maybe($53, 71, $11);
  $54 = HEAP32[$11 >> 2] | 0;
  $55 = ($54 | 0) != (0 | 0);
  if ($55) {
   $56 = _mp_call_method_n_kw(0, 0, $11) | 0;
   $57 = $8;
   HEAP32[$57 >> 2] = $56;
   $4 = 0;
   $67 = $4;
   STACKTOP = sp;
   return $67 | 0;
  }
 } else {
  _mp_load_method_maybe($53, 155, $11);
  $58 = HEAP32[$11 >> 2] | 0;
  $59 = ($58 | 0) != (0 | 0);
  if ($59) {
   $60 = $7;
   $61 = $11 + 8 | 0;
   HEAP32[$61 >> 2] = $60;
   $62 = _mp_call_method_n_kw(1, 0, $11) | 0;
   $63 = $8;
   HEAP32[$63 >> 2] = $62;
   $4 = 1;
   $67 = $4;
   STACKTOP = sp;
   return $67 | 0;
  }
 }
 $64 = $7;
 $65 = _mp_make_raise_obj($64) | 0;
 $66 = $8;
 HEAP32[$66 >> 2] = $65;
 $4 = 2;
 $67 = $4;
 STACKTOP = sp;
 return $67 | 0;
}

function _mpz_pow3_inpl($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $10 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $11 = $5;
 $12 = $11 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = ($13 | 0) == 0;
 do {
  if (!$14) {
   $15 = $6;
   $16 = HEAP32[$15 >> 2] | 0;
   $17 = $16 & 1;
   $18 = ($17 | 0) != 0;
   if (!$18) {
    $19 = $7;
    $20 = $19 + 4 | 0;
    $21 = HEAP32[$20 >> 2] | 0;
    $22 = ($21 | 0) == 1;
    if ($22) {
     $23 = $7;
     $24 = $23 + 8 | 0;
     $25 = HEAP32[$24 >> 2] | 0;
     $26 = HEAP16[$25 >> 1] | 0;
     $27 = $26 & 65535;
     $28 = ($27 | 0) == 1;
     if ($28) {
      break;
     }
    }
    $30 = $4;
    _mpz_set_from_int($30, 1);
    $31 = $6;
    $32 = $31 + 4 | 0;
    $33 = HEAP32[$32 >> 2] | 0;
    $34 = ($33 | 0) == 0;
    if ($34) {
     STACKTOP = sp;
     return;
    }
    $35 = $5;
    $36 = _mpz_clone($35) | 0;
    $8 = $36;
    $37 = $6;
    $38 = _mpz_clone($37) | 0;
    $9 = $38;
    _mpz_init_zero($10);
    while (1) {
     $39 = $9;
     $40 = $39 + 4 | 0;
     $41 = HEAP32[$40 >> 2] | 0;
     $42 = $41 >>> 0 > 0;
     if (!$42) {
      break;
     }
     $43 = $9;
     $44 = $43 + 8 | 0;
     $45 = HEAP32[$44 >> 2] | 0;
     $46 = HEAP16[$45 >> 1] | 0;
     $47 = $46 & 65535;
     $48 = $47 & 1;
     $49 = ($48 | 0) != 0;
     if ($49) {
      $50 = $4;
      $51 = $4;
      $52 = $8;
      _mpz_mul_inpl($50, $51, $52);
      $53 = $4;
      $54 = $4;
      $55 = $7;
      _mpz_divmod_inpl($10, $53, $54, $55);
     }
     $56 = $9;
     $57 = $56 + 8 | 0;
     $58 = HEAP32[$57 >> 2] | 0;
     $59 = $9;
     $60 = $59 + 8 | 0;
     $61 = HEAP32[$60 >> 2] | 0;
     $62 = $9;
     $63 = $62 + 4 | 0;
     $64 = HEAP32[$63 >> 2] | 0;
     $65 = _mpn_shr($58, $61, $64, 1) | 0;
     $66 = $9;
     $67 = $66 + 4 | 0;
     HEAP32[$67 >> 2] = $65;
     $68 = $9;
     $69 = $68 + 4 | 0;
     $70 = HEAP32[$69 >> 2] | 0;
     $71 = ($70 | 0) == 0;
     if ($71) {
      break;
     }
     $72 = $8;
     $73 = $8;
     $74 = $8;
     _mpz_mul_inpl($72, $73, $74);
     $75 = $8;
     $76 = $8;
     $77 = $7;
     _mpz_divmod_inpl($10, $75, $76, $77);
    }
    _mpz_deinit($10);
    $78 = $8;
    _mpz_free($78);
    $79 = $9;
    _mpz_free($79);
    STACKTOP = sp;
    return;
   }
  }
 } while (0);
 $29 = $4;
 _mpz_set_from_int($29, 0);
 STACKTOP = sp;
 return;
}

function _gc_collect_end() {
 var $$01214$i = 0, $$015$i = 0, $$06$i = 0, $$113$i = 0, $$2$i = 0, $$mask$i = 0, $$mask$i1 = 0, $$pn$i = 0, $$pn$in$i = 0, $$pre = 0, $$pre10$i = 0, $$pre11$i = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $trunc$i = 0, $trunc$i$clear = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP32[40760 >> 2] | 0;
 $1 = ($0 | 0) == 0;
 $$pre = HEAP32[40748 >> 2] | 0;
 L1 : do {
  if ($1) {
   $19 = $$pre;
  } else {
   $2 = $$pre;
   while (1) {
    HEAP32[40760 >> 2] = 0;
    $$mask$i = $2 & 1073741823;
    $3 = ($$mask$i | 0) == 0;
    if ($3) {
     $19 = $2;
     break L1;
    }
    $$06$i = 0;
    $42 = $2;
    while (1) {
     $5 = HEAP32[40744 >> 2] | 0;
     $6 = $$06$i >>> 2;
     $7 = $5 + $6 | 0;
     $8 = HEAP8[$7 >> 0] | 0;
     $9 = $8 & 255;
     $10 = $$06$i << 1;
     $11 = $10 & 6;
     $12 = $9 >>> $11;
     $13 = $12 & 3;
     $14 = ($13 | 0) == 3;
     if ($14) {
      _gc_mark_subtree($$06$i);
      $$pre10$i = HEAP32[40748 >> 2] | 0;
      $17 = $$pre10$i;
     } else {
      $17 = $42;
     }
     $15 = $$06$i + 1 | 0;
     $16 = $17 << 2;
     $18 = $15 >>> 0 < $16 >>> 0;
     if ($18) {
      $$06$i = $15;
      $42 = $17;
     } else {
      break;
     }
    }
    $$pre11$i = HEAP32[40760 >> 2] | 0;
    $4 = ($$pre11$i | 0) == 0;
    if ($4) {
     $19 = $17;
     break;
    } else {
     $2 = $17;
    }
   }
  }
 } while (0);
 $$mask$i1 = $19 & 1073741823;
 $20 = ($$mask$i1 | 0) == 0;
 if ($20) {
  HEAP32[41032 >> 2] = 0;
  $40 = HEAP16[41020 >> 1] | 0;
  $41 = $40 + -1 << 16 >> 16;
  HEAP16[41020 >> 1] = $41;
  return;
 }
 $$01214$i = 0;
 $$015$i = 0;
 while (1) {
  $21 = HEAP32[40744 >> 2] | 0;
  $22 = $$015$i >>> 2;
  $23 = $21 + $22 | 0;
  $24 = HEAP8[$23 >> 0] | 0;
  $25 = $24 & 255;
  $26 = $$015$i << 1;
  $27 = $26 & 6;
  $28 = $25 >>> $27;
  $trunc$i = $28 & 255;
  $trunc$i$clear = $trunc$i & 3;
  switch ($trunc$i$clear << 24 >> 24) {
  case 1:
   {
    $$113$i = 1;
    label = 13;
    break;
   }
  case 2:
   {
    $29 = ($$01214$i | 0) == 0;
    if ($29) {
     $$2$i = 0;
    } else {
     $$113$i = $$01214$i;
     label = 13;
    }
    break;
   }
  case 3:
   {
    $32 = 2 << $27;
    $33 = $32 ^ 255;
    $34 = $33 & $25;
    $35 = $34 & 255;
    HEAP8[$23 >> 0] = $35;
    $$2$i = 0;
    break;
   }
  default:
   {
    $$2$i = $$01214$i;
   }
  }
  if ((label | 0) == 13) {
   label = 0;
   $$pn$in$i = 3 << $27;
   $$pn$i = $$pn$in$i ^ 255;
   $30 = $$pn$i & $25;
   $31 = $30 & 255;
   HEAP8[$23 >> 0] = $31;
   $$2$i = $$113$i;
  }
  $36 = $$015$i + 1 | 0;
  $37 = HEAP32[40748 >> 2] | 0;
  $38 = $37 << 2;
  $39 = $36 >>> 0 < $38 >>> 0;
  if ($39) {
   $$01214$i = $$2$i;
   $$015$i = $36;
  } else {
   break;
  }
 }
 HEAP32[41032 >> 2] = 0;
 $40 = HEAP16[41020 >> 1] | 0;
 $41 = $40 + -1 << 16 >> 16;
 HEAP16[41020 >> 1] = $41;
 return;
}

function _erfc2($0, $1) {
 $0 = $0 | 0;
 $1 = +$1;
 var $$0 = 0.0, $$047 = 0.0, $$047$in = 0.0, $$048 = 0.0, $$sink49 = 0.0, $$sink51 = 0.0, $$sink53 = 0.0, $$sink55 = 0.0, $$sink57 = 0.0, $$sink58 = 0.0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $29 = 0.0, $3 = 0.0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0.0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0.0, $50 = 0, $51 = 0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0.0, $60 = 0.0, $61 = 0.0, $62 = 0.0, $63 = 0.0, $7 = 0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = $0 >>> 0 < 1072955392;
 if ($2) {
  $3 = +_erfc1($1);
  $$0 = $3;
 } else {
  $4 = +Math_abs(+$1);
  $5 = $4 * $4;
  $6 = 1.0 / $5;
  $7 = $0 >>> 0 < 1074191213;
  if ($7) {
   $8 = $6 * 9.814329344169145;
   $9 = -81.2874355063066 - $8;
   $10 = $6 * $9;
   $11 = $10 + -184.60509290671104;
   $12 = $6 * $11;
   $13 = $12 + -162.39666946257347;
   $14 = $6 * $13;
   $15 = $14 + -62.375332450326006;
   $16 = $6 * $15;
   $17 = $16 + -10.558626225323291;
   $18 = $6 * $17;
   $19 = $18 + -.6938585727071818;
   $20 = $6 * $19;
   $21 = $20 + -.009864944034847148;
   $22 = $6 * .0604244152148581;
   $23 = 6.570249770319282 - $22;
   $24 = $6 * $23;
   $25 = $24 + 108.63500554177944;
   $$048 = $21;
   $$sink49 = 19.651271667439257;
   $$sink51 = 137.65775414351904;
   $$sink53 = 434.56587747522923;
   $$sink55 = 645.3872717332679;
   $$sink57 = 429.00814002756783;
   $$sink58 = $25;
  } else {
   $26 = $6 * 483.5191916086514;
   $27 = -1025.0951316110772 - $26;
   $28 = $6 * $27;
   $29 = $28 + -637.5664433683896;
   $30 = $6 * $29;
   $31 = $30 + -160.63638485582192;
   $32 = $6 * $31;
   $33 = $32 + -17.757954917754752;
   $34 = $6 * $33;
   $35 = $34 + -.799283237680523;
   $36 = $6 * $35;
   $37 = $36 + -.0098649429247001;
   $38 = $6 * 22.44095244658582;
   $39 = 474.52854120695537 - $38;
   $$048 = $37;
   $$sink49 = 30.33806074348246;
   $$sink51 = 325.7925129965739;
   $$sink53 = 1536.729586084437;
   $$sink55 = 3199.8582195085955;
   $$sink57 = 2553.0504064331644;
   $$sink58 = $39;
  }
  $40 = $6 * $$sink58;
  $41 = $40 + $$sink57;
  $42 = $6 * $41;
  $43 = $42 + $$sink55;
  $44 = $6 * $43;
  $45 = $44 + $$sink53;
  $46 = $6 * $45;
  $47 = $46 + $$sink51;
  $48 = $6 * $47;
  $49 = $48 + $$sink49;
  $$047$in = $6 * $49;
  $$047 = $$047$in + 1.0;
  HEAPF64[tempDoublePtr >> 3] = $4;
  $50 = HEAP32[tempDoublePtr >> 2] | 0;
  $51 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  HEAP32[tempDoublePtr >> 2] = 0;
  HEAP32[tempDoublePtr + 4 >> 2] = $51;
  $52 = +HEAPF64[tempDoublePtr >> 3];
  $53 = $52 * $52;
  $54 = -.5625 - $53;
  $55 = +_exp($54);
  $56 = $52 - $4;
  $57 = $4 + $52;
  $58 = $56 * $57;
  $59 = $$048 / $$047;
  $60 = $58 + $59;
  $61 = +_exp($60);
  $62 = $55 * $61;
  $63 = $62 / $4;
  $$0 = $63;
 }
 return +$$0;
}

function _gc_collect() {
 var $$reg2mem12$0 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, $cond14 = 0, $cond15 = 0, $cond16 = 0, _setjmpTable = 0, _setjmpTableSize = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(160 | 0);
 _setjmpTableSize = 4;
 _setjmpTable = _malloc(40) | 0;
 HEAP32[_setjmpTable >> 2] = 0;
 $0 = sp;
 _setjmpTable = _saveSetjmp($0, 1, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
 _setjmpTableSize = getTempRet0() | 0;
 __THREW__ = 0;
 $1 = __THREW__;
 __THREW__ = 0;
 if (($1 | 0) != 0 & (threwValue | 0) != 0) {
  $2 = _testSetjmp(HEAP32[$1 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
  if (($2 | 0) == 0) {
   _longjmp($1 | 0, threwValue | 0);
  }
  setTempRet0(threwValue | 0);
 } else {
  $2 = -1;
 }
 $3 = getTempRet0() | 0;
 $cond = ($2 | 0) == 1;
 if ($cond) {
  $$reg2mem12$0 = $3;
 } else {
  $$reg2mem12$0 = 0;
 }
 while (1) {
  $4 = ($$reg2mem12$0 | 0) == 0;
  if ($4) {
   __THREW__ = 0;
   invoke_vii(627, $0 | 0, 1);
   $5 = __THREW__;
   __THREW__ = 0;
   if (($5 | 0) != 0 & (threwValue | 0) != 0) {
    $6 = _testSetjmp(HEAP32[$5 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
    if (($6 | 0) == 0) {
     _longjmp($5 | 0, threwValue | 0);
    }
    setTempRet0(threwValue | 0);
   } else {
    $6 = -1;
   }
   $7 = getTempRet0() | 0;
   $$reg2mem12$0 = $7;
   continue;
  }
  __THREW__ = 0;
  invoke_v(628);
  $8 = __THREW__;
  __THREW__ = 0;
  if (($8 | 0) != 0 & (threwValue | 0) != 0) {
   $9 = _testSetjmp(HEAP32[$8 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($9 | 0) == 0) {
    _longjmp($8 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $9 = -1;
  }
  $10 = getTempRet0() | 0;
  $cond14 = ($9 | 0) == 1;
  if ($cond14) {
   $$reg2mem12$0 = $10;
   continue;
  }
  $11 = HEAP32[10259] | 0;
  $12 = $0 + 156 | 0;
  $13 = $12;
  $14 = HEAP32[10259] | 0;
  $15 = $14;
  $16 = $13 - $15 | 0;
  $17 = ($16 >>> 0) / 4 & -1;
  __THREW__ = 0;
  invoke_vii(629, $11 | 0, $17 | 0);
  $18 = __THREW__;
  __THREW__ = 0;
  if (($18 | 0) != 0 & (threwValue | 0) != 0) {
   $19 = _testSetjmp(HEAP32[$18 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($19 | 0) == 0) {
    _longjmp($18 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $19 = -1;
  }
  $20 = getTempRet0() | 0;
  $cond15 = ($19 | 0) == 1;
  if ($cond15) {
   $$reg2mem12$0 = $20;
   continue;
  }
  __THREW__ = 0;
  invoke_v(630);
  $21 = __THREW__;
  __THREW__ = 0;
  if (($21 | 0) != 0 & (threwValue | 0) != 0) {
   $22 = _testSetjmp(HEAP32[$21 >> 2] | 0, _setjmpTable | 0, _setjmpTableSize | 0) | 0;
   if (($22 | 0) == 0) {
    _longjmp($21 | 0, threwValue | 0);
   }
   setTempRet0(threwValue | 0);
  } else {
   $22 = -1;
  }
  $23 = getTempRet0() | 0;
  $cond16 = ($22 | 0) == 1;
  if ($cond16) {
   $$reg2mem12$0 = $23;
  } else {
   break;
  }
 }
 _free(_setjmpTable | 0);
 STACKTOP = sp;
 return;
}

function _uzlib_uncompress($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 L1 : while (1) {
  $4 = $2;
  $5 = $4 + 40 | 0;
  $6 = HEAP32[$5 >> 2] | 0;
  $7 = ($6 | 0) == -1;
  if ($7) {
   label = 4;
  }
  while (1) {
   if ((label | 0) == 4) {
    label = 0;
    $8 = $2;
    $9 = _tinf_getbit($8) | 0;
    $10 = $2;
    $11 = $10 + 44 | 0;
    HEAP32[$11 >> 2] = $9;
    $12 = $2;
    $13 = _tinf_read_bits($12, 2, 0) | 0;
    $14 = $2;
    $15 = $14 + 40 | 0;
    HEAP32[$15 >> 2] = $13;
    $16 = $2;
    $17 = $16 + 40 | 0;
    $18 = HEAP32[$17 >> 2] | 0;
    $19 = ($18 | 0) == 1;
    $20 = $2;
    if ($19) {
     $21 = $20 + 68 | 0;
     $22 = $2;
     $23 = $22 + 676 | 0;
     _tinf_build_fixed_trees($21, $23);
     continue;
    }
    $24 = $20 + 40 | 0;
    $25 = HEAP32[$24 >> 2] | 0;
    $26 = ($25 | 0) == 2;
    if (!$26) {
     continue;
    }
    $27 = $2;
    $28 = $2;
    $29 = $28 + 68 | 0;
    $30 = $2;
    $31 = $30 + 676 | 0;
    $32 = _tinf_decode_trees($27, $29, $31) | 0;
    $3 = $32;
    $33 = $3;
    $34 = ($33 | 0) != 0;
    if ($34) {
     label = 8;
     break L1;
    }
   }
   $36 = $2;
   $37 = $36 + 40 | 0;
   $38 = HEAP32[$37 >> 2] | 0;
   switch ($38 | 0) {
   case 0:
    {
     $39 = $2;
     $40 = _tinf_inflate_uncompressed_block($39) | 0;
     $3 = $40;
     break;
    }
   case 2:
   case 1:
    {
     $41 = $2;
     $42 = $2;
     $43 = $42 + 68 | 0;
     $44 = $2;
     $45 = $44 + 676 | 0;
     $46 = _tinf_inflate_block_data($41, $43, $45) | 0;
     $3 = $46;
     break;
    }
   default:
    {
     label = 12;
     break L1;
    }
   }
   $47 = $3;
   $48 = ($47 | 0) == 1;
   if (!$48) {
    break;
   }
   $49 = $2;
   $50 = $49 + 44 | 0;
   $51 = HEAP32[$50 >> 2] | 0;
   $52 = ($51 | 0) != 0;
   if ($52) {
    break;
   }
   label = 4;
  }
  $53 = $3;
  $54 = ($53 | 0) != 0;
  if ($54) {
   label = 17;
   break;
  }
  $56 = $2;
  $57 = $56 + 24 | 0;
  $58 = HEAP32[$57 >> 2] | 0;
  $59 = $2;
  $60 = $59 + 28 | 0;
  $61 = HEAP32[$60 >> 2] | 0;
  $62 = $58 >>> 0 < $61 >>> 0;
  if (!$62) {
   label = 19;
   break;
  }
 }
 if ((label | 0) == 8) {
  $35 = $3;
  $1 = $35;
  $63 = $1;
  STACKTOP = sp;
  return $63 | 0;
 } else if ((label | 0) == 12) {
  $1 = -3;
  $63 = $1;
  STACKTOP = sp;
  return $63 | 0;
 } else if ((label | 0) == 17) {
  $55 = $3;
  $1 = $55;
  $63 = $1;
  STACKTOP = sp;
  return $63 | 0;
 } else if ((label | 0) == 19) {
  $1 = 0;
  $63 = $1;
  STACKTOP = sp;
  return $63 | 0;
 }
 return 0 | 0;
}

function _mod_binascii_hexlify($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $6 = sp + 32 | 0;
 $7 = sp + 16 | 0;
 $3 = $0;
 $4 = $1;
 $5 = 0;
 $13 = $4;
 $14 = HEAP32[$13 >> 2] | 0;
 _mp_get_buffer_raise($14, $6, 1);
 $15 = $6 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($16 | 0) == 0;
 if ($17) {
  $2 = 18288;
  $87 = $2;
  STACKTOP = sp;
  return $87 | 0;
 }
 $18 = $6 + 4 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $19 << 1;
 $8 = $20;
 $21 = $3;
 $22 = $21 >>> 0 > 1;
 if ($22) {
  $23 = $6 + 4 | 0;
  $24 = HEAP32[$23 >> 2] | 0;
  $25 = $24 - 1 | 0;
  $26 = $8;
  $27 = $26 + $25 | 0;
  $8 = $27;
  $28 = $4;
  $29 = $28 + 4 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = _mp_obj_str_get_str($30) | 0;
  $5 = $31;
 }
 $32 = $8;
 _vstr_init_len($7, $32);
 $33 = HEAP32[$6 >> 2] | 0;
 $9 = $33;
 $34 = $7 + 8 | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 $10 = $35;
 $36 = $6 + 4 | 0;
 $37 = HEAP32[$36 >> 2] | 0;
 $11 = $37;
 while (1) {
  $38 = $11;
  $39 = $38 + -1 | 0;
  $11 = $39;
  $40 = ($38 | 0) != 0;
  if (!$40) {
   break;
  }
  $41 = $9;
  $42 = HEAP8[$41 >> 0] | 0;
  $43 = $42 & 255;
  $44 = $43 >> 4;
  $45 = $44 & 255;
  $12 = $45;
  $46 = $12;
  $47 = $46 & 255;
  $48 = ($47 | 0) > 9;
  if ($48) {
   $49 = $12;
   $50 = $49 & 255;
   $51 = $50 + 39 | 0;
   $52 = $51 & 255;
   $12 = $52;
  }
  $53 = $12;
  $54 = $53 & 255;
  $55 = $54 + 48 | 0;
  $56 = $55 & 255;
  $57 = $10;
  $58 = $57 + 1 | 0;
  $10 = $58;
  HEAP8[$57 >> 0] = $56;
  $59 = $9;
  $60 = $59 + 1 | 0;
  $9 = $60;
  $61 = HEAP8[$59 >> 0] | 0;
  $62 = $61 & 255;
  $63 = $62 & 15;
  $64 = $63 & 255;
  $12 = $64;
  $65 = $12;
  $66 = $65 & 255;
  $67 = ($66 | 0) > 9;
  if ($67) {
   $68 = $12;
   $69 = $68 & 255;
   $70 = $69 + 39 | 0;
   $71 = $70 & 255;
   $12 = $71;
  }
  $72 = $12;
  $73 = $72 & 255;
  $74 = $73 + 48 | 0;
  $75 = $74 & 255;
  $76 = $10;
  $77 = $76 + 1 | 0;
  $10 = $77;
  HEAP8[$76 >> 0] = $75;
  $78 = $5;
  $79 = ($78 | 0) != (0 | 0);
  $80 = $11;
  $81 = ($80 | 0) != 0;
  $or$cond = $79 & $81;
  if ($or$cond) {
   $82 = $5;
   $83 = HEAP8[$82 >> 0] | 0;
   $84 = $10;
   $85 = $84 + 1 | 0;
   $10 = $85;
   HEAP8[$84 >> 0] = $83;
  }
 }
 $86 = _mp_obj_new_str_from_vstr(18304, $7) | 0;
 $2 = $86;
 $87 = $2;
 STACKTOP = sp;
 return $87 | 0;
}

function _mp_obj_tuple_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $10 = sp + 4 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $12 = $5;
 $7 = $12;
 $13 = $4;
 switch ($13 | 0) {
 case 14:
 case 26:
  {
   $14 = $6;
   $15 = _mp_obj_get_type($14) | 0;
   $16 = _mp_obj_is_subclass_fast($15, 18952) | 0;
   if ($16) {
    $17 = $6;
    $8 = $17;
    $18 = $7;
    $19 = $18 + 4 | 0;
    $20 = HEAP32[$19 >> 2] | 0;
    $21 = $8;
    $22 = $21 + 4 | 0;
    $23 = HEAP32[$22 >> 2] | 0;
    $24 = $20 + $23 | 0;
    $25 = _mp_obj_new_tuple($24, 0) | 0;
    $9 = $25;
    $26 = $9;
    $27 = $26 + 8 | 0;
    $28 = $7;
    $29 = $28 + 8 | 0;
    $30 = $7;
    $31 = $30 + 4 | 0;
    $32 = HEAP32[$31 >> 2] | 0;
    $33 = $32 << 2;
    _memcpy($27 | 0, $29 | 0, $33 | 0) | 0;
    $34 = $9;
    $35 = $34 + 8 | 0;
    $36 = $7;
    $37 = $36 + 4 | 0;
    $38 = HEAP32[$37 >> 2] | 0;
    $39 = $35 + ($38 << 2) | 0;
    $40 = $8;
    $41 = $40 + 8 | 0;
    $42 = $8;
    $43 = $42 + 4 | 0;
    $44 = HEAP32[$43 >> 2] | 0;
    $45 = $44 << 2;
    _memcpy($39 | 0, $41 | 0, $45 | 0) | 0;
    $46 = $9;
    $3 = $46;
    $70 = $3;
    STACKTOP = sp;
    return $70 | 0;
   } else {
    $3 = 0;
    $70 = $3;
    STACKTOP = sp;
    return $70 | 0;
   }
   break;
  }
 case 16:
 case 28:
  {
   $47 = $6;
   $48 = _mp_obj_get_int_maybe($47, $10) | 0;
   if (!$48) {
    $3 = 0;
    $70 = $3;
    STACKTOP = sp;
    return $70 | 0;
   }
   $49 = HEAP32[$10 >> 2] | 0;
   $50 = ($49 | 0) <= 0;
   if ($50) {
    $3 = 18944;
    $70 = $3;
    STACKTOP = sp;
    return $70 | 0;
   } else {
    $51 = $7;
    $52 = $51 + 4 | 0;
    $53 = HEAP32[$52 >> 2] | 0;
    $54 = HEAP32[$10 >> 2] | 0;
    $55 = Math_imul($53, $54) | 0;
    $56 = _mp_obj_new_tuple($55, 0) | 0;
    $11 = $56;
    $57 = $7;
    $58 = $57 + 8 | 0;
    $59 = $7;
    $60 = $59 + 4 | 0;
    $61 = HEAP32[$60 >> 2] | 0;
    $62 = HEAP32[$10 >> 2] | 0;
    $63 = $11;
    $64 = $63 + 8 | 0;
    _mp_seq_multiply($58, 4, $61, $62, $64);
    $65 = $11;
    $3 = $65;
    $70 = $3;
    STACKTOP = sp;
    return $70 | 0;
   }
   break;
  }
 case 4:
 case 1:
 case 3:
 case 0:
 case 2:
  {
   $66 = $4;
   $67 = $5;
   $68 = $6;
   $69 = _tuple_cmp_helper($66, $67, $68) | 0;
   $3 = $69;
   $70 = $3;
   STACKTOP = sp;
   return $70 | 0;
   break;
  }
 default:
  {
   $3 = 0;
   $70 = $3;
   STACKTOP = sp;
   return $70 | 0;
  }
 }
 return 0 | 0;
}

function _mpz_set_from_ll($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp + 8 | 0;
 $7 = sp;
 $4 = $0;
 $8 = $5;
 $9 = $8;
 HEAP32[$9 >> 2] = $1;
 $10 = $8 + 4 | 0;
 $11 = $10;
 HEAP32[$11 >> 2] = $2;
 $12 = $3 & 1;
 $6 = $12;
 $13 = $4;
 _mpz_need_dig($13, 4);
 $14 = $6;
 $15 = $14 & 1;
 $16 = $5;
 $17 = $16;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $16 + 4 | 0;
 $20 = $19;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = ($21 | 0) < 0;
 $or$cond = $15 & $22;
 $23 = $4;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $24 & -2;
 if ($or$cond) {
  $26 = $25 | 1;
  HEAP32[$23 >> 2] = $26;
  $27 = $5;
  $28 = $27;
  $29 = HEAP32[$28 >> 2] | 0;
  $30 = $27 + 4 | 0;
  $31 = $30;
  $32 = HEAP32[$31 >> 2] | 0;
  $33 = _i64Subtract(0, 0, $29 | 0, $32 | 0) | 0;
  $34 = getTempRet0() | 0;
  $35 = $7;
  $36 = $35;
  HEAP32[$36 >> 2] = $33;
  $37 = $35 + 4 | 0;
  $38 = $37;
  HEAP32[$38 >> 2] = $34;
 } else {
  HEAP32[$23 >> 2] = $25;
  $39 = $5;
  $40 = $39;
  $41 = HEAP32[$40 >> 2] | 0;
  $42 = $39 + 4 | 0;
  $43 = $42;
  $44 = HEAP32[$43 >> 2] | 0;
  $45 = $7;
  $46 = $45;
  HEAP32[$46 >> 2] = $41;
  $47 = $45 + 4 | 0;
  $48 = $47;
  HEAP32[$48 >> 2] = $44;
 }
 $49 = $4;
 $50 = $49 + 4 | 0;
 HEAP32[$50 >> 2] = 0;
 while (1) {
  $51 = $7;
  $52 = $51;
  $53 = HEAP32[$52 >> 2] | 0;
  $54 = $51 + 4 | 0;
  $55 = $54;
  $56 = HEAP32[$55 >> 2] | 0;
  $57 = $56 >>> 0 > 0;
  $58 = $53 >>> 0 > 0;
  $59 = ($56 | 0) == 0;
  $60 = $59 & $58;
  $61 = $57 | $60;
  if (!$61) {
   break;
  }
  $62 = $7;
  $63 = $62;
  $64 = HEAP32[$63 >> 2] | 0;
  $65 = $62 + 4 | 0;
  $66 = $65;
  $67 = HEAP32[$66 >> 2] | 0;
  $68 = $64 & 65535;
  $69 = $68 & 65535;
  $70 = $4;
  $71 = $70 + 8 | 0;
  $72 = HEAP32[$71 >> 2] | 0;
  $73 = $4;
  $74 = $73 + 4 | 0;
  $75 = HEAP32[$74 >> 2] | 0;
  $76 = $75 + 1 | 0;
  HEAP32[$74 >> 2] = $76;
  $77 = $72 + ($75 << 1) | 0;
  HEAP16[$77 >> 1] = $69;
  $78 = $7;
  $79 = $78;
  $80 = HEAP32[$79 >> 2] | 0;
  $81 = $78 + 4 | 0;
  $82 = $81;
  $83 = HEAP32[$82 >> 2] | 0;
  $84 = _bitshift64Lshr($80 | 0, $83 | 0, 16) | 0;
  $85 = getTempRet0() | 0;
  $86 = $7;
  $87 = $86;
  HEAP32[$87 >> 2] = $84;
  $88 = $86 + 4 | 0;
  $89 = $88;
  HEAP32[$89 >> 2] = $85;
 }
 STACKTOP = sp;
 return;
}

function _struct_pack_into_internal($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = sp + 36 | 0;
 $8 = sp + 24 | 0;
 $12 = sp + 4 | 0;
 $4 = $0;
 HEAP32[$5 >> 2] = $1;
 $6 = $2;
 $7 = $3;
 $14 = $4;
 $15 = _mp_obj_str_get_str($14) | 0;
 HEAP32[$8 >> 2] = $15;
 $16 = _get_fmt_type($8) | 0;
 $9 = $16;
 $10 = 0;
 while (1) {
  $17 = $10;
  $18 = $6;
  $19 = $17 >>> 0 < $18 >>> 0;
  if (!$19) {
   label = 15;
   break;
  }
  $11 = 1;
  $20 = HEAP32[$8 >> 2] | 0;
  $21 = HEAP8[$20 >> 0] | 0;
  $22 = $21 << 24 >> 24;
  $23 = ($22 | 0) == 0;
  if ($23) {
   label = 15;
   break;
  }
  $24 = HEAP32[$8 >> 2] | 0;
  $25 = HEAP8[$24 >> 0] | 0;
  $26 = $25 << 24 >> 24;
  $27 = _unichar_isdigit($26) | 0;
  if ($27) {
   $28 = _get_fmt_num($8) | 0;
   $11 = $28;
  }
  $29 = HEAP32[$8 >> 2] | 0;
  $30 = HEAP8[$29 >> 0] | 0;
  $31 = $30 << 24 >> 24;
  $32 = ($31 | 0) == 115;
  L8 : do {
   if ($32) {
    $33 = $7;
    $34 = $10;
    $35 = $34 + 1 | 0;
    $10 = $35;
    $36 = $33 + ($34 << 2) | 0;
    $37 = HEAP32[$36 >> 2] | 0;
    _mp_get_buffer_raise($37, $12, 1);
    $38 = $11;
    $13 = $38;
    $39 = $12 + 4 | 0;
    $40 = HEAP32[$39 >> 2] | 0;
    $41 = $13;
    $42 = $40 >>> 0 < $41 >>> 0;
    if ($42) {
     $43 = $12 + 4 | 0;
     $44 = HEAP32[$43 >> 2] | 0;
     $13 = $44;
    }
    $45 = HEAP32[$5 >> 2] | 0;
    $46 = HEAP32[$12 >> 2] | 0;
    $47 = $13;
    _memcpy($45 | 0, $46 | 0, $47 | 0) | 0;
    $48 = HEAP32[$5 >> 2] | 0;
    $49 = $13;
    $50 = $48 + $49 | 0;
    $51 = $11;
    $52 = $13;
    $53 = $51 - $52 | 0;
    _memset($50 | 0, 0, $53 | 0) | 0;
    $54 = $11;
    $55 = HEAP32[$5 >> 2] | 0;
    $56 = $55 + $54 | 0;
    HEAP32[$5 >> 2] = $56;
   } else {
    while (1) {
     $57 = $11;
     $58 = $57 + -1 | 0;
     $11 = $58;
     $59 = ($57 | 0) != 0;
     if (!$59) {
      break L8;
     }
     $60 = $10;
     $61 = $6;
     $62 = $60 >>> 0 < $61 >>> 0;
     if (!$62) {
      break L8;
     }
     $63 = $9;
     $64 = HEAP32[$8 >> 2] | 0;
     $65 = HEAP8[$64 >> 0] | 0;
     $66 = $7;
     $67 = $10;
     $68 = $67 + 1 | 0;
     $10 = $68;
     $69 = $66 + ($67 << 2) | 0;
     $70 = HEAP32[$69 >> 2] | 0;
     _mp_binary_set_val($63, $65, $70, $5);
    }
   }
  } while (0);
  $71 = HEAP32[$8 >> 2] | 0;
  $72 = $71 + 1 | 0;
  HEAP32[$8 >> 2] = $72;
 }
 if ((label | 0) == 15) {
  STACKTOP = sp;
  return;
 }
}

function _gs4_hmsb_fill_rect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $100 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $95 = 0, $96 = 0, $97 = 0, $98 = 0, $99 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 $18 = $11;
 $19 = $18 & 15;
 $11 = $19;
 $20 = $6;
 $21 = $20 + 8 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = $7;
 $24 = $8;
 $25 = $6;
 $26 = $25 + 16 | 0;
 $27 = HEAP16[$26 >> 1] | 0;
 $28 = $27 & 65535;
 $29 = Math_imul($24, $28) | 0;
 $30 = $23 + $29 | 0;
 $31 = $30 >> 1;
 $32 = $22 + $31 | 0;
 $12 = $32;
 $33 = $11;
 $34 = $33 << 4;
 $35 = $34 & 255;
 $13 = $35;
 $36 = $13;
 $37 = $36 & 255;
 $38 = $11;
 $39 = $37 | $38;
 $40 = $39 & 255;
 $14 = $40;
 $41 = $6;
 $42 = $41 + 16 | 0;
 $43 = HEAP16[$42 >> 1] | 0;
 $44 = $43 & 65535;
 $45 = $9;
 $46 = $44 - $45 | 0;
 $47 = $46 >> 1;
 $15 = $47;
 $48 = $7;
 $49 = ($48 | 0) % 2 & -1;
 $50 = ($49 | 0) == 1;
 $51 = $50 & 1;
 $16 = $51;
 while (1) {
  $52 = $10;
  $53 = $52 + -1 | 0;
  $10 = $53;
  $54 = ($52 | 0) != 0;
  if (!$54) {
   break;
  }
  $55 = $9;
  $17 = $55;
  $56 = $16;
  $57 = $56 & 1;
  $58 = $17;
  $59 = ($58 | 0) > 0;
  $or$cond = $57 & $59;
  if ($or$cond) {
   $60 = $12;
   $61 = HEAP8[$60 >> 0] | 0;
   $62 = $61 & 255;
   $63 = $62 & 240;
   $64 = $11;
   $65 = $63 | $64;
   $66 = $65 & 255;
   $67 = $12;
   HEAP8[$67 >> 0] = $66;
   $68 = $12;
   $69 = $68 + 1 | 0;
   $12 = $69;
   $70 = $17;
   $71 = $70 + -1 | 0;
   $17 = $71;
  }
  $72 = $12;
  $73 = $14;
  $74 = $73 & 255;
  $75 = $74 & 255;
  $76 = $17;
  $77 = $76 >> 1;
  _memset($72 | 0, $75 | 0, $77 | 0) | 0;
  $78 = $17;
  $79 = $78 >> 1;
  $80 = $12;
  $81 = $80 + $79 | 0;
  $12 = $81;
  $82 = $17;
  $83 = ($82 | 0) % 2 & -1;
  $84 = ($83 | 0) != 0;
  if ($84) {
   $85 = $13;
   $86 = $85 & 255;
   $87 = $12;
   $88 = HEAP8[$87 >> 0] | 0;
   $89 = $88 & 255;
   $90 = $89 & 15;
   $91 = $86 | $90;
   $92 = $91 & 255;
   $93 = $12;
   HEAP8[$93 >> 0] = $92;
   $94 = $16;
   $95 = $94 & 1;
   if (!$95) {
    $96 = $12;
    $97 = $96 + 1 | 0;
    $12 = $97;
   }
  }
  $98 = $15;
  $99 = $12;
  $100 = $99 + $98 | 0;
  $12 = $100;
 }
 STACKTOP = sp;
 return;
}

function _log1p($0) {
 $0 = +$0;
 var $$081 = 0.0, $$1 = 0.0, $$183 = 0.0, $$185 = 0.0, $$2 = 0.0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0.0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0, $29 = 0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $59 = 0.0, $6 = 0, $7 = 0.0, $8 = 0.0, $9 = 0, $or$cond = 0, $phitmp = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = $2 >>> 0 < 1071284858;
 $4 = ($2 | 0) < 0;
 $or$cond = $4 | $3;
 do {
  if ($or$cond) {
   $5 = $2 >>> 0 > 3220176895;
   if ($5) {
    $6 = $0 == -1.0;
    if ($6) {
     $$081 = -inf;
     break;
    }
    $7 = $0 - $0;
    $8 = $7 / 0.0;
    $$081 = $8;
    break;
   } else {
    $9 = _bitshift64Shl($2 | 0, 0, 1) | 0;
    $10 = getTempRet0() | 0;
    $11 = $9 >>> 0 < 2034237440;
    if ($11) {
     $$081 = $0;
     break;
    }
    $12 = $2 >>> 0 < 3218259653;
    if ($12) {
     $$1 = 0.0;
     $$183 = $0;
     $$2 = 0.0;
     label = 11;
     break;
    } else {
     label = 8;
     break;
    }
   }
  } else {
   $13 = $2 >>> 0 > 2146435071;
   if ($13) {
    $$081 = $0;
   } else {
    label = 8;
   }
  }
 } while (0);
 if ((label | 0) == 8) {
  $14 = $0 + 1.0;
  HEAPF64[tempDoublePtr >> 3] = $14;
  $15 = HEAP32[tempDoublePtr >> 2] | 0;
  $16 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
  $17 = $16 + 614242 | 0;
  $18 = $17 >>> 20;
  $19 = $18 + -1023 | 0;
  $20 = $17 >>> 0 < 1129316352;
  if ($20) {
   $21 = $17 >>> 0 > 1074790399;
   $22 = $14 - $0;
   $23 = 1.0 - $22;
   $24 = $14 + -1.0;
   $25 = $0 - $24;
   $26 = $21 ? $23 : $25;
   $27 = $26 / $14;
   $$185 = $27;
  } else {
   $$185 = 0.0;
  }
  $28 = $17 & 1048575;
  $29 = $28 + 1072079006 | 0;
  HEAP32[tempDoublePtr >> 2] = $15;
  HEAP32[tempDoublePtr + 4 >> 2] = $29;
  $30 = +HEAPF64[tempDoublePtr >> 3];
  $31 = $30 + -1.0;
  $phitmp = +($19 | 0);
  $$1 = $phitmp;
  $$183 = $31;
  $$2 = $$185;
  label = 11;
 }
 if ((label | 0) == 11) {
  $32 = $$183 * .5;
  $33 = $$183 * $32;
  $34 = $$183 + 2.0;
  $35 = $$183 / $34;
  $36 = $35 * $35;
  $37 = $36 * $36;
  $38 = $37 * .15313837699209373;
  $39 = $38 + .22222198432149784;
  $40 = $37 * $39;
  $41 = $40 + .3999999999940942;
  $42 = $37 * $41;
  $43 = $37 * .14798198605116586;
  $44 = $43 + .1818357216161805;
  $45 = $37 * $44;
  $46 = $45 + .2857142874366239;
  $47 = $37 * $46;
  $48 = $47 + .6666666666666735;
  $49 = $36 * $48;
  $50 = $42 + $49;
  $51 = $33 + $50;
  $52 = $35 * $51;
  $53 = $$1 * 1.9082149292705877e-10;
  $54 = $$2 + $53;
  $55 = $54 + $52;
  $56 = $55 - $33;
  $57 = $$183 + $56;
  $58 = $$1 * .6931471803691238;
  $59 = $58 + $57;
  $$081 = $59;
 }
 return +$$081;
}

function _next_char($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 16 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = ($4 | 0) == 10;
 $6 = $1;
 do {
  if ($5) {
   $7 = $6 + 28 | 0;
   $8 = HEAP32[$7 >> 2] | 0;
   $9 = $8 + 1 | 0;
   HEAP32[$7 >> 2] = $9;
   $10 = $1;
   $11 = $10 + 32 | 0;
   HEAP32[$11 >> 2] = 1;
  } else {
   $12 = $6 + 16 | 0;
   $13 = HEAP32[$12 >> 2] | 0;
   $14 = ($13 | 0) == 9;
   $15 = $1;
   $16 = $15 + 32 | 0;
   $17 = HEAP32[$16 >> 2] | 0;
   if ($14) {
    $18 = $17 - 1 | 0;
    $19 = $18 + 8 | 0;
    $20 = ($19 >>> 0) / 8 & -1;
    $21 = $20 << 3;
    $22 = $21 + 1 | 0;
    $23 = $1;
    $24 = $23 + 32 | 0;
    HEAP32[$24 >> 2] = $22;
    break;
   } else {
    $25 = $17 + 1 | 0;
    HEAP32[$16 >> 2] = $25;
    break;
   }
  }
 } while (0);
 $26 = $1;
 $27 = $26 + 20 | 0;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = $1;
 $30 = $29 + 16 | 0;
 HEAP32[$30 >> 2] = $28;
 $31 = $1;
 $32 = $31 + 24 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = $1;
 $35 = $34 + 20 | 0;
 HEAP32[$35 >> 2] = $33;
 $36 = $1;
 $37 = $36 + 4 | 0;
 $38 = $37 + 4 | 0;
 $39 = HEAP32[$38 >> 2] | 0;
 $40 = $1;
 $41 = $40 + 4 | 0;
 $42 = HEAP32[$41 >> 2] | 0;
 $43 = FUNCTION_TABLE_ii[$39 & 1023]($42) | 0;
 $44 = $1;
 $45 = $44 + 24 | 0;
 HEAP32[$45 >> 2] = $43;
 $46 = $1;
 $47 = $46 + 20 | 0;
 $48 = HEAP32[$47 >> 2] | 0;
 $49 = ($48 | 0) == 13;
 if ($49) {
  $50 = $1;
  $51 = $50 + 20 | 0;
  HEAP32[$51 >> 2] = 10;
  $52 = $1;
  $53 = $52 + 24 | 0;
  $54 = HEAP32[$53 >> 2] | 0;
  $55 = ($54 | 0) == 10;
  if ($55) {
   $56 = $1;
   $57 = $56 + 4 | 0;
   $58 = $57 + 4 | 0;
   $59 = HEAP32[$58 >> 2] | 0;
   $60 = $1;
   $61 = $60 + 4 | 0;
   $62 = HEAP32[$61 >> 2] | 0;
   $63 = FUNCTION_TABLE_ii[$59 & 1023]($62) | 0;
   $64 = $1;
   $65 = $64 + 24 | 0;
   HEAP32[$65 >> 2] = $63;
  }
 }
 $66 = $1;
 $67 = $66 + 24 | 0;
 $68 = HEAP32[$67 >> 2] | 0;
 $69 = ($68 | 0) == -1;
 if (!$69) {
  STACKTOP = sp;
  return;
 }
 $70 = $1;
 $71 = $70 + 20 | 0;
 $72 = HEAP32[$71 >> 2] | 0;
 $73 = ($72 | 0) != -1;
 if (!$73) {
  STACKTOP = sp;
  return;
 }
 $74 = $1;
 $75 = $74 + 20 | 0;
 $76 = HEAP32[$75 >> 2] | 0;
 $77 = ($76 | 0) != 10;
 if (!$77) {
  STACKTOP = sp;
  return;
 }
 $78 = $1;
 $79 = $78 + 24 | 0;
 HEAP32[$79 >> 2] = 10;
 STACKTOP = sp;
 return;
}

function _range_subscr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $9 = sp + 8 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $12 = $6;
 $13 = ($12 | 0) == (4 | 0);
 if (!$13) {
  $3 = 0;
  $85 = $3;
  STACKTOP = sp;
  return $85 | 0;
 }
 $14 = $4;
 $7 = $14;
 $15 = $7;
 $16 = _range_len($15) | 0;
 $8 = $16;
 $17 = $5;
 $18 = _mp_obj_is_obj_1095($17) | 0;
 if ($18) {
  $19 = $5;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = ($20 | 0) == (18228 | 0);
  if ($21) {
   $22 = $8;
   $23 = $5;
   _mp_seq_get_fast_slice_indexes($22, $23, $9) | 0;
   $24 = _m_malloc(16) | 0;
   $10 = $24;
   $25 = $10;
   HEAP32[$25 >> 2] = 17680;
   $26 = $7;
   $27 = $26 + 4 | 0;
   $28 = HEAP32[$27 >> 2] | 0;
   $29 = HEAP32[$9 >> 2] | 0;
   $30 = $7;
   $31 = $30 + 12 | 0;
   $32 = HEAP32[$31 >> 2] | 0;
   $33 = Math_imul($29, $32) | 0;
   $34 = $28 + $33 | 0;
   $35 = $10;
   $36 = $35 + 4 | 0;
   HEAP32[$36 >> 2] = $34;
   $37 = $7;
   $38 = $37 + 4 | 0;
   $39 = HEAP32[$38 >> 2] | 0;
   $40 = $9 + 4 | 0;
   $41 = HEAP32[$40 >> 2] | 0;
   $42 = $7;
   $43 = $42 + 12 | 0;
   $44 = HEAP32[$43 >> 2] | 0;
   $45 = Math_imul($41, $44) | 0;
   $46 = $39 + $45 | 0;
   $47 = $10;
   $48 = $47 + 8 | 0;
   HEAP32[$48 >> 2] = $46;
   $49 = $9 + 8 | 0;
   $50 = HEAP32[$49 >> 2] | 0;
   $51 = $7;
   $52 = $51 + 12 | 0;
   $53 = HEAP32[$52 >> 2] | 0;
   $54 = Math_imul($50, $53) | 0;
   $55 = $10;
   $56 = $55 + 12 | 0;
   HEAP32[$56 >> 2] = $54;
   $57 = $9 + 8 | 0;
   $58 = HEAP32[$57 >> 2] | 0;
   $59 = ($58 | 0) < 0;
   if ($59) {
    $60 = $7;
    $61 = $60 + 12 | 0;
    $62 = HEAP32[$61 >> 2] | 0;
    $63 = $10;
    $64 = $63 + 8 | 0;
    $65 = HEAP32[$64 >> 2] | 0;
    $66 = $65 - $62 | 0;
    HEAP32[$64 >> 2] = $66;
   }
   $67 = $10;
   $3 = $67;
   $85 = $3;
   STACKTOP = sp;
   return $85 | 0;
  }
 }
 $68 = $7;
 $69 = HEAP32[$68 >> 2] | 0;
 $70 = $8;
 $71 = $5;
 $72 = _mp_get_index($69, $70, $71, 0) | 0;
 $11 = $72;
 $73 = $7;
 $74 = $73 + 4 | 0;
 $75 = HEAP32[$74 >> 2] | 0;
 $76 = $11;
 $77 = $7;
 $78 = $77 + 12 | 0;
 $79 = HEAP32[$78 >> 2] | 0;
 $80 = Math_imul($76, $79) | 0;
 $81 = $75 + $80 | 0;
 $82 = $81 << 1;
 $83 = $82 | 1;
 $84 = $83;
 $3 = $84;
 $85 = $3;
 STACKTOP = sp;
 return $85 | 0;
}

function _fill_rect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, $92 = 0, $93 = 0, $94 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 $14 = $10;
 $15 = ($14 | 0) < 1;
 $16 = $9;
 $17 = ($16 | 0) < 1;
 $or$cond = $15 | $17;
 if ($or$cond) {
  STACKTOP = sp;
  return;
 }
 $18 = $7;
 $19 = $9;
 $20 = $18 + $19 | 0;
 $21 = ($20 | 0) <= 0;
 if ($21) {
  STACKTOP = sp;
  return;
 }
 $22 = $8;
 $23 = $10;
 $24 = $22 + $23 | 0;
 $25 = ($24 | 0) <= 0;
 if ($25) {
  STACKTOP = sp;
  return;
 }
 $26 = $8;
 $27 = $6;
 $28 = $27 + 14 | 0;
 $29 = HEAP16[$28 >> 1] | 0;
 $30 = $29 & 65535;
 $31 = ($26 | 0) >= ($30 | 0);
 if ($31) {
  STACKTOP = sp;
  return;
 }
 $32 = $7;
 $33 = $6;
 $34 = $33 + 12 | 0;
 $35 = HEAP16[$34 >> 1] | 0;
 $36 = $35 & 65535;
 $37 = ($32 | 0) >= ($36 | 0);
 if ($37) {
  STACKTOP = sp;
  return;
 }
 $38 = $6;
 $39 = $38 + 12 | 0;
 $40 = HEAP16[$39 >> 1] | 0;
 $41 = $40 & 65535;
 $42 = $7;
 $43 = $9;
 $44 = $42 + $43 | 0;
 $45 = ($41 | 0) < ($44 | 0);
 if ($45) {
  $46 = $6;
  $47 = $46 + 12 | 0;
  $48 = HEAP16[$47 >> 1] | 0;
  $49 = $48 & 65535;
  $53 = $49;
 } else {
  $50 = $7;
  $51 = $9;
  $52 = $50 + $51 | 0;
  $53 = $52;
 }
 $12 = $53;
 $54 = $6;
 $55 = $54 + 14 | 0;
 $56 = HEAP16[$55 >> 1] | 0;
 $57 = $56 & 65535;
 $58 = $8;
 $59 = $10;
 $60 = $58 + $59 | 0;
 $61 = ($57 | 0) < ($60 | 0);
 if ($61) {
  $62 = $6;
  $63 = $62 + 14 | 0;
  $64 = HEAP16[$63 >> 1] | 0;
  $65 = $64 & 65535;
  $69 = $65;
 } else {
  $66 = $8;
  $67 = $10;
  $68 = $66 + $67 | 0;
  $69 = $68;
 }
 $13 = $69;
 $70 = $7;
 $71 = ($70 | 0) > 0;
 $72 = $7;
 $73 = $71 ? $72 : 0;
 $7 = $73;
 $74 = $8;
 $75 = ($74 | 0) > 0;
 $76 = $8;
 $77 = $75 ? $76 : 0;
 $8 = $77;
 $78 = $6;
 $79 = $78 + 18 | 0;
 $80 = HEAP8[$79 >> 0] | 0;
 $81 = $80 & 255;
 $82 = 9376 + ($81 * 12 | 0) | 0;
 $83 = $82 + 8 | 0;
 $84 = HEAP32[$83 >> 2] | 0;
 $85 = $6;
 $86 = $7;
 $87 = $8;
 $88 = $12;
 $89 = $7;
 $90 = $88 - $89 | 0;
 $91 = $13;
 $92 = $8;
 $93 = $91 - $92 | 0;
 $94 = $11;
 FUNCTION_TABLE_viiiiii[$84 & 511]($85, $86, $87, $90, $93, $94);
 STACKTOP = sp;
 return;
}

function _instance_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $8 = 0, $9 = 0, $or$cond = 0, $vararg_buffer = 0, $vararg_ptr2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $vararg_buffer = sp;
 $8 = sp + 32 | 0;
 $9 = sp + 12 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $11 = $4;
 $6 = $11;
 $12 = $5;
 $13 = ($12 | 0) == 0;
 $14 = $13 ? 29 : 27;
 $7 = $14;
 HEAP32[$8 >> 2] = 0 | 0;
 HEAP32[$8 + 4 >> 2] = 0 | 0;
 $15 = $6;
 HEAP32[$9 >> 2] = $15;
 $16 = $9 + 4 | 0;
 $17 = $7;
 HEAP32[$16 >> 2] = $17;
 $18 = $9 + 8 | 0;
 HEAP32[$18 >> 2] = 8;
 $19 = $9 + 12 | 0;
 HEAP32[$19 >> 2] = $8;
 $20 = $9 + 16 | 0;
 HEAP8[$20 >> 0] = 0;
 $21 = $6;
 $22 = HEAP32[$21 >> 2] | 0;
 _mp_obj_class_lookup($9, $22);
 $23 = HEAP32[$8 >> 2] | 0;
 $24 = ($23 | 0) == (0 | 0);
 $25 = $5;
 $26 = ($25 | 0) == 0;
 $or$cond = $24 & $26;
 if ($or$cond) {
  $27 = $9 + 4 | 0;
  HEAP32[$27 >> 2] = 27;
  $28 = $9 + 8 | 0;
  HEAP32[$28 >> 2] = 0;
  $29 = $6;
  $30 = HEAP32[$29 >> 2] | 0;
  _mp_obj_class_lookup($9, $30);
 }
 $31 = HEAP32[$8 >> 2] | 0;
 $32 = ($31 | 0) == (4 | 0);
 if (!$32) {
  $60 = HEAP32[$8 >> 2] | 0;
  $61 = ($60 | 0) != (0 | 0);
  if ($61) {
   $62 = HEAP32[$8 >> 2] | 0;
   $63 = $4;
   $64 = _mp_call_function_1($62, $63) | 0;
   $10 = $64;
   $65 = $3;
   $66 = $10;
   _mp_obj_print_helper($65, $66, 0);
   STACKTOP = sp;
   return;
  } else {
   $67 = $3;
   $68 = $4;
   $69 = _mp_obj_get_type_str($68) | 0;
   $70 = $6;
   HEAP32[$vararg_buffer >> 2] = $69;
   $vararg_ptr2 = $vararg_buffer + 4 | 0;
   HEAP32[$vararg_ptr2 >> 2] = $70;
   _mp_printf($67, 33287, $vararg_buffer) | 0;
   STACKTOP = sp;
   return;
  }
 }
 $33 = $6;
 $34 = $33 + 16 | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 $36 = _mp_obj_get_type($35) | 0;
 $37 = $36 + 12 | 0;
 $38 = HEAP32[$37 >> 2] | 0;
 $39 = ($38 | 0) == (108 | 0);
 if (!$39) {
  $55 = $3;
  $56 = $6;
  $57 = $56 + 16 | 0;
  $58 = HEAP32[$57 >> 2] | 0;
  $59 = $5;
  _mp_obj_print_helper($55, $58, $59);
  STACKTOP = sp;
  return;
 }
 $40 = $5;
 $41 = ($40 | 0) != 0;
 if ($41) {
  $42 = $3;
  $43 = $6;
  $44 = HEAP32[$43 >> 2] | 0;
  $45 = $44 + 6 | 0;
  $46 = HEAP16[$45 >> 1] | 0;
  $47 = $46 & 65535;
  $48 = _qstr_str($47) | 0;
  _mp_print_str($42, $48) | 0;
 }
 $49 = $3;
 $50 = $6;
 $51 = $50 + 16 | 0;
 $52 = HEAP32[$51 >> 2] | 0;
 $53 = $5;
 $54 = $53 | 128;
 _mp_obj_print_helper($49, $52, $54);
 STACKTOP = sp;
 return;
}

function _tinf_build_fixed_trees($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = 0;
 while (1) {
  $5 = $4;
  $6 = ($5 | 0) < 7;
  $7 = $2;
  if (!$6) {
   break;
  }
  $8 = $4;
  $9 = $7 + ($8 << 1) | 0;
  HEAP16[$9 >> 1] = 0;
  $10 = $4;
  $11 = $10 + 1 | 0;
  $4 = $11;
 }
 $12 = $7 + 14 | 0;
 HEAP16[$12 >> 1] = 24;
 $13 = $2;
 $14 = $13 + 16 | 0;
 HEAP16[$14 >> 1] = 152;
 $15 = $2;
 $16 = $15 + 18 | 0;
 HEAP16[$16 >> 1] = 112;
 $4 = 0;
 while (1) {
  $17 = $4;
  $18 = ($17 | 0) < 24;
  if (!$18) {
   break;
  }
  $19 = $4;
  $20 = 256 + $19 | 0;
  $21 = $20 & 65535;
  $22 = $2;
  $23 = $22 + 32 | 0;
  $24 = $4;
  $25 = $23 + ($24 << 1) | 0;
  HEAP16[$25 >> 1] = $21;
  $26 = $4;
  $27 = $26 + 1 | 0;
  $4 = $27;
 }
 $4 = 0;
 while (1) {
  $28 = $4;
  $29 = ($28 | 0) < 144;
  if (!$29) {
   break;
  }
  $30 = $4;
  $31 = $30 & 65535;
  $32 = $2;
  $33 = $32 + 32 | 0;
  $34 = $4;
  $35 = 24 + $34 | 0;
  $36 = $33 + ($35 << 1) | 0;
  HEAP16[$36 >> 1] = $31;
  $37 = $4;
  $38 = $37 + 1 | 0;
  $4 = $38;
 }
 $4 = 0;
 while (1) {
  $39 = $4;
  $40 = ($39 | 0) < 8;
  if (!$40) {
   break;
  }
  $41 = $4;
  $42 = 280 + $41 | 0;
  $43 = $42 & 65535;
  $44 = $2;
  $45 = $44 + 32 | 0;
  $46 = $4;
  $47 = 168 + $46 | 0;
  $48 = $45 + ($47 << 1) | 0;
  HEAP16[$48 >> 1] = $43;
  $49 = $4;
  $50 = $49 + 1 | 0;
  $4 = $50;
 }
 $4 = 0;
 while (1) {
  $51 = $4;
  $52 = ($51 | 0) < 112;
  if (!$52) {
   break;
  }
  $53 = $4;
  $54 = 144 + $53 | 0;
  $55 = $54 & 65535;
  $56 = $2;
  $57 = $56 + 32 | 0;
  $58 = $4;
  $59 = 176 + $58 | 0;
  $60 = $57 + ($59 << 1) | 0;
  HEAP16[$60 >> 1] = $55;
  $61 = $4;
  $62 = $61 + 1 | 0;
  $4 = $62;
 }
 $4 = 0;
 while (1) {
  $63 = $4;
  $64 = ($63 | 0) < 5;
  $65 = $3;
  if (!$64) {
   break;
  }
  $66 = $4;
  $67 = $65 + ($66 << 1) | 0;
  HEAP16[$67 >> 1] = 0;
  $68 = $4;
  $69 = $68 + 1 | 0;
  $4 = $69;
 }
 $70 = $65 + 10 | 0;
 HEAP16[$70 >> 1] = 32;
 $4 = 0;
 while (1) {
  $71 = $4;
  $72 = ($71 | 0) < 32;
  if (!$72) {
   break;
  }
  $73 = $4;
  $74 = $73 & 65535;
  $75 = $3;
  $76 = $75 + 32 | 0;
  $77 = $4;
  $78 = $76 + ($77 << 1) | 0;
  HEAP16[$78 >> 1] = $74;
  $79 = $4;
  $80 = $79 + 1 | 0;
  $4 = $80;
 }
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_end_pass($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 5 | 0;
 $4 = HEAPU8[$3 >> 0] | HEAPU8[$3 + 1 >> 0] << 8;
 $5 = $4 & 255;
 $6 = $5 & 65535;
 $7 = ($6 | 0) == 1;
 if ($7) {
  STACKTOP = sp;
  return;
 }
 $8 = $1;
 _emit_write_code_info_byte($8, 0);
 $9 = $1;
 $10 = $9 + 5 | 0;
 $11 = HEAPU8[$10 >> 0] | HEAPU8[$10 + 1 >> 0] << 8;
 $12 = $11 & 255;
 $13 = $12 & 65535;
 $14 = ($13 | 0) == 3;
 $15 = $1;
 if ($14) {
  $16 = $15 + 32 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = $17 + 3 | 0;
  $19 = $18 & -4;
  $20 = $19;
  $21 = $20;
  $22 = $1;
  $23 = $22 + 32 | 0;
  HEAP32[$23 >> 2] = $21;
  $24 = $1;
  $25 = $24 + 32 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $1;
  $28 = $27 + 36 | 0;
  HEAP32[$28 >> 2] = $26;
  $29 = $1;
  $30 = $29 + 40 | 0;
  $31 = HEAP32[$30 >> 2] | 0;
  $32 = $1;
  $33 = $32 + 44 | 0;
  HEAP32[$33 >> 2] = $31;
  $34 = $1;
  $35 = $34 + 36 | 0;
  $36 = HEAP32[$35 >> 2] | 0;
  $37 = $1;
  $38 = $37 + 44 | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  $40 = $36 + $39 | 0;
  $41 = $40;
  $42 = _m_malloc0($41) | 0;
  $43 = $1;
  $44 = $43 + 48 | 0;
  HEAP32[$44 >> 2] = $42;
  $45 = $1;
  $46 = $45 + 12 | 0;
  $47 = HEAP32[$46 >> 2] | 0;
  $48 = $47 + 28 | 0;
  $49 = HEAP16[$48 >> 1] | 0;
  $50 = $49 & 65535;
  $51 = $1;
  $52 = $51 + 12 | 0;
  $53 = HEAP32[$52 >> 2] | 0;
  $54 = $53 + 30 | 0;
  $55 = HEAP16[$54 >> 1] | 0;
  $56 = $55 & 65535;
  $57 = $50 + $56 | 0;
  $58 = $57 << 2;
  $59 = _m_malloc0($58) | 0;
  $60 = $1;
  $61 = $60 + 52 | 0;
  HEAP32[$61 >> 2] = $59;
  STACKTOP = sp;
  return;
 }
 $62 = $15 + 5 | 0;
 $63 = HEAPU8[$62 >> 0] | HEAPU8[$62 + 1 >> 0] << 8;
 $64 = $63 & 255;
 $65 = $64 & 65535;
 $66 = ($65 | 0) == 4;
 if (!$66) {
  STACKTOP = sp;
  return;
 }
 $67 = $1;
 $68 = $67 + 12 | 0;
 $69 = HEAP32[$68 >> 2] | 0;
 $70 = $69 + 16 | 0;
 $71 = HEAP32[$70 >> 2] | 0;
 $72 = $1;
 $73 = $72 + 48 | 0;
 $74 = HEAP32[$73 >> 2] | 0;
 $75 = $1;
 $76 = $75 + 52 | 0;
 $77 = HEAP32[$76 >> 2] | 0;
 $78 = $1;
 $79 = $78 + 12 | 0;
 $80 = HEAP32[$79 >> 2] | 0;
 $81 = $80 + 24 | 0;
 $82 = HEAP16[$81 >> 1] | 0;
 $83 = $82 & 65535;
 _mp_emit_glue_assign_bytecode($71, $74, $77, $83);
 STACKTOP = sp;
 return;
}

function _list_pop($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $7 = $3;
 $8 = HEAP32[$7 >> 2] | 0;
 $4 = $8;
 $9 = $4;
 $10 = $9 + 8 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = ($11 | 0) == 0;
 if ($12) {
  _mp_raise_msg(15532, 31507);
 }
 $13 = $4;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $4;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $2;
 $19 = ($18 | 0) == 1;
 if ($19) {
  $23 = -1;
 } else {
  $20 = $3;
  $21 = $20 + 4 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $22;
 }
 $24 = _mp_get_index($14, $17, $23, 0) | 0;
 $5 = $24;
 $25 = $4;
 $26 = $25 + 12 | 0;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = $5;
 $29 = $27 + ($28 << 2) | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $6 = $30;
 $31 = $4;
 $32 = $31 + 8 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = $33 - 1 | 0;
 HEAP32[$32 >> 2] = $34;
 $35 = $4;
 $36 = $35 + 12 | 0;
 $37 = HEAP32[$36 >> 2] | 0;
 $38 = $5;
 $39 = $37 + ($38 << 2) | 0;
 $40 = $4;
 $41 = $40 + 12 | 0;
 $42 = HEAP32[$41 >> 2] | 0;
 $43 = $5;
 $44 = $42 + ($43 << 2) | 0;
 $45 = $44 + 4 | 0;
 $46 = $4;
 $47 = $46 + 8 | 0;
 $48 = HEAP32[$47 >> 2] | 0;
 $49 = $5;
 $50 = $48 - $49 | 0;
 $51 = $50 << 2;
 _memmove($39 | 0, $45 | 0, $51 | 0) | 0;
 $52 = $4;
 $53 = $52 + 12 | 0;
 $54 = HEAP32[$53 >> 2] | 0;
 $55 = $4;
 $56 = $55 + 8 | 0;
 $57 = HEAP32[$56 >> 2] | 0;
 $58 = $54 + ($57 << 2) | 0;
 HEAP32[$58 >> 2] = 0;
 $59 = $4;
 $60 = $59 + 4 | 0;
 $61 = HEAP32[$60 >> 2] | 0;
 $62 = $61 >>> 0 > 4;
 if (!$62) {
  $86 = $6;
  STACKTOP = sp;
  return $86 | 0;
 }
 $63 = $4;
 $64 = $63 + 4 | 0;
 $65 = HEAP32[$64 >> 2] | 0;
 $66 = $4;
 $67 = $66 + 8 | 0;
 $68 = HEAP32[$67 >> 2] | 0;
 $69 = $68 << 1;
 $70 = $65 >>> 0 > $69 >>> 0;
 if (!$70) {
  $86 = $6;
  STACKTOP = sp;
  return $86 | 0;
 }
 $71 = $4;
 $72 = $71 + 12 | 0;
 $73 = HEAP32[$72 >> 2] | 0;
 $74 = $4;
 $75 = $74 + 4 | 0;
 $76 = HEAP32[$75 >> 2] | 0;
 $77 = ($76 >>> 0) / 2 & -1;
 $78 = $77 << 2;
 $79 = _m_realloc($73, $78) | 0;
 $80 = $4;
 $81 = $80 + 12 | 0;
 HEAP32[$81 >> 2] = $79;
 $82 = $4;
 $83 = $82 + 4 | 0;
 $84 = HEAP32[$83 >> 2] | 0;
 $85 = ($84 >>> 0) / 2 & -1;
 HEAP32[$83 >> 2] = $85;
 $86 = $6;
 STACKTOP = sp;
 return $86 | 0;
}

function _array_append($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $4 = $6;
 $7 = $4;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 >>> 8;
 $11 = ($10 | 0) == 0;
 if ($11) {
  $12 = $4;
  $13 = $12 + 4 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = $14 & 255;
  $16 = $15 & 255;
  $17 = _mp_binary_get_size(64, $16, 0) | 0;
  $5 = $17;
  $18 = $4;
  $19 = $18 + 4 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = $20 & 255;
  $22 = $21 | 2048;
  HEAP32[$19 >> 2] = $22;
  $23 = $4;
  $24 = $23 + 12 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = $5;
  $27 = $4;
  $28 = $27 + 8 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  $30 = $4;
  $31 = $30 + 4 | 0;
  $32 = HEAP32[$31 >> 2] | 0;
  $33 = $32 >>> 8;
  $34 = $29 + $33 | 0;
  $35 = Math_imul($26, $34) | 0;
  $36 = $35;
  $37 = _m_realloc($25, $36) | 0;
  $38 = $4;
  $39 = $38 + 12 | 0;
  HEAP32[$39 >> 2] = $37;
  $40 = $4;
  $41 = $40 + 12 | 0;
  $42 = HEAP32[$41 >> 2] | 0;
  $43 = $4;
  $44 = $43 + 8 | 0;
  $45 = HEAP32[$44 >> 2] | 0;
  $46 = $45 + 1 | 0;
  $47 = $5;
  $48 = Math_imul($46, $47) | 0;
  $49 = $42 + $48 | 0;
  $50 = $4;
  $51 = $50 + 8 | 0;
  $52 = HEAP32[$51 >> 2] | 0;
  $53 = $4;
  $54 = $53 + 4 | 0;
  $55 = HEAP32[$54 >> 2] | 0;
  $56 = $55 >>> 8;
  $57 = $52 + $56 | 0;
  $58 = $4;
  $59 = $58 + 8 | 0;
  $60 = HEAP32[$59 >> 2] | 0;
  $61 = $60 + 1 | 0;
  $62 = $57 - $61 | 0;
  $63 = $5;
  $64 = Math_imul($62, $63) | 0;
  _memset($49 | 0, 0, $64 | 0) | 0;
 }
 $65 = $4;
 $66 = $65 + 4 | 0;
 $67 = HEAP32[$66 >> 2] | 0;
 $68 = $67 & 255;
 $69 = $68 & 255;
 $70 = $4;
 $71 = $70 + 12 | 0;
 $72 = HEAP32[$71 >> 2] | 0;
 $73 = $4;
 $74 = $73 + 8 | 0;
 $75 = HEAP32[$74 >> 2] | 0;
 $76 = $3;
 _mp_binary_set_val_array($69, $72, $75, $76);
 $77 = $4;
 $78 = $77 + 8 | 0;
 $79 = HEAP32[$78 >> 2] | 0;
 $80 = $79 + 1 | 0;
 HEAP32[$78 >> 2] = $80;
 $81 = $4;
 $82 = $81 + 4 | 0;
 $83 = HEAP32[$82 >> 2] | 0;
 $84 = $83 >>> 8;
 $85 = $84 + -1 | 0;
 $86 = HEAP32[$82 >> 2] | 0;
 $87 = $85 & 16777215;
 $88 = $87 << 8;
 $89 = $86 & 255;
 $90 = $89 | $88;
 HEAP32[$82 >> 2] = $90;
 STACKTOP = sp;
 return 17668 | 0;
}

function _str_splitlines($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $6 = sp + 32 | 0;
 $10 = sp + 16 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $15 = $3;
 $16 = $15 - 1 | 0;
 $17 = $4;
 $18 = $17 + 4 | 0;
 $19 = $5;
 _mp_arg_parse_all($16, $18, $19, 1, 18660, $6);
 $20 = $4;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = _mp_obj_get_type($21) | 0;
 $7 = $22;
 $23 = _mp_obj_new_list(0, 0) | 0;
 $8 = $23;
 $24 = $4;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = _mp_obj_is_qstr_1128($25) | 0;
 $27 = $4;
 $28 = HEAP32[$27 >> 2] | 0;
 if ($26) {
  $29 = $28;
  $30 = $29 >>> 2;
  $31 = _qstr_data($30, $10) | 0;
  $9 = $31;
 } else {
  $32 = $28 + 8 | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  HEAP32[$10 >> 2] = $33;
  $34 = $4;
  $35 = HEAP32[$34 >> 2] | 0;
  $36 = $35 + 12 | 0;
  $37 = HEAP32[$36 >> 2] | 0;
  $9 = $37;
 }
 $38 = $9;
 $39 = HEAP32[$10 >> 2] | 0;
 $40 = $38 + $39 | 0;
 $11 = $40;
 while (1) {
  $41 = $9;
  $42 = $11;
  $43 = $41 >>> 0 < $42 >>> 0;
  if (!$43) {
   break;
  }
  $44 = $9;
  $12 = $44;
  $13 = 0;
  while (1) {
   $45 = $9;
   $46 = $11;
   $47 = $45 >>> 0 < $46 >>> 0;
   if (!$47) {
    break;
   }
   $48 = $9;
   $49 = HEAP8[$48 >> 0] | 0;
   $50 = $49 & 255;
   $51 = ($50 | 0) == 10;
   if ($51) {
    label = 9;
    break;
   }
   $52 = $9;
   $53 = HEAP8[$52 >> 0] | 0;
   $54 = $53 & 255;
   $55 = ($54 | 0) == 13;
   $56 = $9;
   $57 = $56 + 1 | 0;
   if ($55) {
    label = 11;
    break;
   }
   $9 = $57;
  }
  do {
   if ((label | 0) == 9) {
    label = 0;
    $13 = 1;
   } else if ((label | 0) == 11) {
    label = 0;
    $58 = HEAP8[$57 >> 0] | 0;
    $59 = $58 & 255;
    $60 = ($59 | 0) == 10;
    if ($60) {
     $13 = 2;
     break;
    } else {
     $13 = 1;
     break;
    }
   }
  } while (0);
  $61 = $9;
  $62 = $12;
  $63 = $61;
  $64 = $62;
  $65 = $63 - $64 | 0;
  $14 = $65;
  $66 = HEAP8[$6 >> 0] | 0;
  $67 = $66 & 1;
  if ($67) {
   $68 = $13;
   $69 = $14;
   $70 = $69 + $68 | 0;
   $14 = $70;
  }
  $71 = $8;
  $72 = $7;
  $73 = $12;
  $74 = $14;
  $75 = _mp_obj_new_str_of_type($72, $73, $74) | 0;
  _mp_obj_list_append($71, $75) | 0;
  $76 = $13;
  $77 = $9;
  $78 = $77 + $76 | 0;
  $9 = $78;
 }
 $79 = $8;
 STACKTOP = sp;
 return $79 | 0;
}

function _compile_node($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = sp + 12 | 0;
 $2 = $0;
 $3 = $1;
 $10 = $3;
 $11 = ($10 | 0) == 0;
 if ($11) {
  STACKTOP = sp;
  return;
 }
 $12 = $3;
 $13 = $12 & 1;
 $14 = ($13 | 0) == 1;
 $15 = $3;
 if ($14) {
  $16 = $15 >> 1;
  $4 = $16;
  $17 = $2;
  $18 = $17 + 40 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = $4;
  _mp_emit_bc_load_const_small_int($19, $20);
  STACKTOP = sp;
  return;
 }
 $21 = $15 & 3;
 $22 = ($21 | 0) != 0;
 $23 = $3;
 if (!$22) {
  $59 = $23;
  $8 = $59;
  $60 = $2;
  $61 = $60 + 40 | 0;
  $62 = HEAP32[$61 >> 2] | 0;
  $63 = $8;
  $64 = HEAP32[$63 >> 2] | 0;
  _mp_emit_bc_set_source_line($62, $64);
  $65 = $8;
  $66 = $65 + 4 | 0;
  $67 = HEAP32[$66 >> 2] | 0;
  $68 = $67 & 255;
  $69 = 2656 + ($68 << 2) | 0;
  $70 = HEAP32[$69 >> 2] | 0;
  $9 = $70;
  $71 = $9;
  $72 = $2;
  $73 = $8;
  FUNCTION_TABLE_vii[$71 & 1023]($72, $73);
  STACKTOP = sp;
  return;
 }
 $24 = $23 >>> 4;
 $5 = $24;
 $25 = $3;
 $26 = $25 & 15;
 $27 = $26 - 2 | 0;
 $28 = $27 >>> 2;
 $29 = $27 << 30;
 $30 = $28 | $29;
 switch ($30 | 0) {
 case 0:
  {
   $31 = $2;
   $32 = $5;
   _compile_load_id($31, $32);
   STACKTOP = sp;
   return;
   break;
  }
 case 1:
  {
   $33 = $2;
   $34 = $33 + 40 | 0;
   $35 = HEAP32[$34 >> 2] | 0;
   $36 = $5;
   _mp_emit_bc_load_const_str($35, $36);
   STACKTOP = sp;
   return;
   break;
  }
 case 2:
  {
   $37 = $2;
   $38 = $37 + 5 | 0;
   $39 = HEAP8[$38 >> 0] | 0;
   $40 = $39 & 255;
   $41 = ($40 | 0) != 4;
   if ($41) {
    $42 = $2;
    $43 = $42 + 40 | 0;
    $44 = HEAP32[$43 >> 2] | 0;
    _mp_emit_bc_load_const_obj($44, 17668);
    STACKTOP = sp;
    return;
   } else {
    $45 = $5;
    $46 = _qstr_data($45, $6) | 0;
    $7 = $46;
    $47 = $2;
    $48 = $47 + 40 | 0;
    $49 = HEAP32[$48 >> 2] | 0;
    $50 = $7;
    $51 = HEAP32[$6 >> 2] | 0;
    $52 = _mp_obj_new_bytes($50, $51) | 0;
    _mp_emit_bc_load_const_obj($49, $52);
    STACKTOP = sp;
    return;
   }
   break;
  }
 default:
  {
   $53 = $5;
   $54 = ($53 | 0) == 4;
   if ($54) {
    STACKTOP = sp;
    return;
   }
   $55 = $2;
   $56 = $55 + 40 | 0;
   $57 = HEAP32[$56 >> 2] | 0;
   $58 = $5;
   _mp_emit_bc_load_const_tok($57, $58);
   STACKTOP = sp;
   return;
  }
 }
}

function _mpz_sub_inpl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = 0;
 $8 = $4;
 $9 = $8 + 8 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $4;
 $12 = $11 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $5;
 $15 = $14 + 8 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $5;
 $18 = $17 + 4 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = _mpn_cmp($10, $13, $16, $19) | 0;
 $21 = ($20 | 0) < 0;
 if ($21) {
  $22 = $4;
  $7 = $22;
  $23 = $5;
  $4 = $23;
  $24 = $7;
  $5 = $24;
  $6 = 1;
 }
 $25 = $4;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = $26 & 1;
 $28 = $5;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = $29 & 1;
 $31 = ($27 | 0) != ($30 | 0);
 $32 = $3;
 $33 = $4;
 $34 = $33 + 4 | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 if ($31) {
  $36 = $35 + 1 | 0;
  _mpz_need_dig($32, $36);
  $37 = $3;
  $38 = $37 + 8 | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  $40 = $4;
  $41 = $40 + 8 | 0;
  $42 = HEAP32[$41 >> 2] | 0;
  $43 = $4;
  $44 = $43 + 4 | 0;
  $45 = HEAP32[$44 >> 2] | 0;
  $46 = $5;
  $47 = $46 + 8 | 0;
  $48 = HEAP32[$47 >> 2] | 0;
  $49 = $5;
  $50 = $49 + 4 | 0;
  $51 = HEAP32[$50 >> 2] | 0;
  $52 = _mpn_add($39, $42, $45, $48, $51) | 0;
  $53 = $3;
  $54 = $53 + 4 | 0;
  HEAP32[$54 >> 2] = $52;
 } else {
  _mpz_need_dig($32, $35);
  $55 = $3;
  $56 = $55 + 8 | 0;
  $57 = HEAP32[$56 >> 2] | 0;
  $58 = $4;
  $59 = $58 + 8 | 0;
  $60 = HEAP32[$59 >> 2] | 0;
  $61 = $4;
  $62 = $61 + 4 | 0;
  $63 = HEAP32[$62 >> 2] | 0;
  $64 = $5;
  $65 = $64 + 8 | 0;
  $66 = HEAP32[$65 >> 2] | 0;
  $67 = $5;
  $68 = $67 + 4 | 0;
  $69 = HEAP32[$68 >> 2] | 0;
  $70 = _mpn_sub($57, $60, $63, $66, $69) | 0;
  $71 = $3;
  $72 = $71 + 4 | 0;
  HEAP32[$72 >> 2] = $70;
 }
 $73 = $6;
 $74 = $73 & 1;
 $75 = $4;
 $76 = HEAP32[$75 >> 2] | 0;
 $77 = $76 & 1;
 if ($74) {
  $78 = 1 - $77 | 0;
  $79 = $3;
  $80 = HEAP32[$79 >> 2] | 0;
  $81 = $78 & 1;
  $82 = $80 & -2;
  $83 = $82 | $81;
  HEAP32[$79 >> 2] = $83;
  STACKTOP = sp;
  return;
 } else {
  $84 = $3;
  $85 = HEAP32[$84 >> 2] | 0;
  $86 = $77 & 1;
  $87 = $85 & -2;
  $88 = $87 | $86;
  HEAP32[$84 >> 2] = $88;
  STACKTOP = sp;
  return;
 }
}

function _mpn_and_neg($0, $1, $2, $3, $4, $5, $6, $7) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 $7 = $7 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $86 = 0, $87 = 0, $88 = 0, $89 = 0, $9 = 0, $90 = 0, $91 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $8 = $0;
 $9 = $1;
 $10 = $2;
 $11 = $3;
 $12 = $4;
 $13 = $5;
 $14 = $6;
 $15 = $7;
 $20 = $8;
 $16 = $20;
 $21 = $13;
 $22 = 0 == ($21 | 0);
 $23 = $22 ? 0 : 65535;
 $24 = $23 & 65535;
 $17 = $24;
 $25 = $14;
 $26 = 0 == ($25 | 0);
 $27 = $26 ? 0 : 65535;
 $28 = $27 & 65535;
 $18 = $28;
 $29 = $15;
 $30 = 0 == ($29 | 0);
 $31 = $30 ? 0 : 65535;
 $32 = $31 & 65535;
 $19 = $32;
 while (1) {
  $33 = $10;
  $34 = $33 >>> 0 > 0;
  if (!$34) {
   break;
  }
  $35 = $9;
  $36 = HEAP16[$35 >> 1] | 0;
  $37 = $36 & 65535;
  $38 = $18;
  $39 = $38 & 65535;
  $40 = $37 ^ $39;
  $41 = $14;
  $42 = $41 + $40 | 0;
  $14 = $42;
  $43 = $12;
  $44 = $43 + -1 | 0;
  $12 = $44;
  $45 = $10;
  $46 = $45 + -1 | 0;
  $10 = $46;
  $47 = $44 >>> 0 <= $46 >>> 0;
  if ($47) {
   $48 = $11;
   $49 = $48 + 2 | 0;
   $11 = $49;
   $50 = HEAP16[$48 >> 1] | 0;
   $51 = $50 & 65535;
   $52 = $19;
   $53 = $52 & 65535;
   $54 = $51 ^ $53;
   $59 = $54;
  } else {
   $55 = $19;
   $56 = $55 & 65535;
   $59 = $56;
  }
  $57 = $15;
  $58 = $57 + $59 | 0;
  $15 = $58;
  $60 = $14;
  $61 = $15;
  $62 = $60 & $61;
  $63 = $17;
  $64 = $63 & 65535;
  $65 = $62 ^ $64;
  $66 = $65 & 65535;
  $67 = $13;
  $68 = $67 + $66 | 0;
  $13 = $68;
  $69 = $13;
  $70 = $69 & 65535;
  $71 = $70 & 65535;
  $72 = $8;
  HEAP16[$72 >> 1] = $71;
  $73 = $15;
  $74 = $73 >>> 16;
  $15 = $74;
  $75 = $14;
  $76 = $75 >>> 16;
  $14 = $76;
  $77 = $13;
  $78 = $77 >>> 16;
  $13 = $78;
  $79 = $8;
  $80 = $79 + 2 | 0;
  $8 = $80;
  $81 = $9;
  $82 = $81 + 2 | 0;
  $9 = $82;
 }
 $83 = $13;
 $84 = 0 != ($83 | 0);
 if (!$84) {
  $89 = $16;
  $90 = $8;
  $91 = _mpn_remove_trailing_zeros($89, $90) | 0;
  STACKTOP = sp;
  return $91 | 0;
 }
 $85 = $13;
 $86 = $85 & 65535;
 $87 = $8;
 $88 = $87 + 2 | 0;
 $8 = $88;
 HEAP16[$87 >> 1] = $86;
 $89 = $16;
 $90 = $8;
 $91 = _mpn_remove_trailing_zeros($89, $90) | 0;
 STACKTOP = sp;
 return $91 | 0;
}

function _gc_mark_subtree($0) {
 $0 = $0 | 0;
 var $$035 = 0, $$036 = 0, $$03845 = 0, $$03944 = 0, $$040 = 0, $$137$lcssa = 0, $$13746 = 0, $$3 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $$035 = $0;
 $$036 = 0;
 while (1) {
  $1 = HEAP32[40744 >> 2] | 0;
  $$040 = 0;
  while (1) {
   $2 = $$040 + 1 | 0;
   $3 = $2 + $$035 | 0;
   $4 = $3 >>> 2;
   $5 = $1 + $4 | 0;
   $6 = HEAP8[$5 >> 0] | 0;
   $7 = $6 & 255;
   $8 = $3 << 1;
   $9 = $8 & 6;
   $10 = $7 >>> $9;
   $11 = $10 & 3;
   $12 = ($11 | 0) == 2;
   if ($12) {
    $$040 = $2;
   } else {
    break;
   }
  }
  $13 = $2 << 2;
  $14 = $13 & 1073741820;
  $15 = ($14 | 0) == 0;
  if ($15) {
   $$137$lcssa = $$036;
  } else {
   $16 = HEAP32[40752 >> 2] | 0;
   $17 = $$035 << 4;
   $18 = $16 + $17 | 0;
   $19 = $18;
   $$03845 = $14;
   $$03944 = $19;
   $$13746 = $$036;
   while (1) {
    $22 = HEAP32[$$03944 >> 2] | 0;
    $23 = $22;
    $24 = $23 & 15;
    $25 = ($24 | 0) == 0;
    do {
     if ($25) {
      $26 = HEAP32[40752 >> 2] | 0;
      $27 = $22 >>> 0 >= $26 >>> 0;
      $28 = HEAP32[40756 >> 2] | 0;
      $29 = $22 >>> 0 < $28 >>> 0;
      $or$cond = $27 & $29;
      if ($or$cond) {
       $30 = $26;
       $31 = $23 - $30 | 0;
       $32 = $31 >>> 4;
       $33 = HEAP32[40744 >> 2] | 0;
       $34 = $31 >>> 6;
       $35 = $33 + $34 | 0;
       $36 = HEAP8[$35 >> 0] | 0;
       $37 = $36 & 255;
       $38 = $32 << 1;
       $39 = $38 & 6;
       $40 = $37 >>> $39;
       $41 = $40 & 3;
       $42 = ($41 | 0) == 1;
       if ($42) {
        $43 = 3 << $39;
        $44 = $43 | $37;
        $45 = $44 & 255;
        HEAP8[$35 >> 0] = $45;
        $46 = $$13746 >>> 0 < 64;
        if ($46) {
         $47 = $$13746 + 1 | 0;
         $48 = 40764 + ($$13746 << 2) | 0;
         HEAP32[$48 >> 2] = $32;
         $$3 = $47;
         break;
        } else {
         HEAP32[40760 >> 2] = 1;
         $$3 = $$13746;
         break;
        }
       } else {
        $$3 = $$13746;
       }
      } else {
       $$3 = $$13746;
      }
     } else {
      $$3 = $$13746;
     }
    } while (0);
    $49 = $$03845 + -1 | 0;
    $50 = $$03944 + 4 | 0;
    $51 = ($49 | 0) == 0;
    if ($51) {
     $$137$lcssa = $$3;
     break;
    } else {
     $$03845 = $49;
     $$03944 = $50;
     $$13746 = $$3;
    }
   }
  }
  $20 = ($$137$lcssa | 0) == 0;
  $21 = $$137$lcssa + -1 | 0;
  if ($20) {
   break;
  }
  $52 = 40764 + ($21 << 2) | 0;
  $53 = HEAP32[$52 >> 2] | 0;
  $$035 = $53;
  $$036 = $21;
 }
 return;
}

function _eval_exec_helper($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $10 = sp + 8 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $13 = _mp_globals_get_1364() | 0;
 $7 = $13;
 $14 = _mp_locals_get_1365() | 0;
 $8 = $14;
 $9 = 1;
 while (1) {
  $15 = $9;
  $16 = $15 >>> 0 < 3;
  if ($16) {
   $17 = $9;
   $18 = $4;
   $19 = $17 >>> 0 < $18 >>> 0;
   $71 = $19;
  } else {
   $71 = 0;
  }
  $20 = $5;
  if (!$71) {
   label = 12;
   break;
  }
  $21 = $9;
  $22 = $20 + ($21 << 2) | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = ($23 | 0) != (17668 | 0);
  if ($24) {
   $25 = $5;
   $26 = $9;
   $27 = $25 + ($26 << 2) | 0;
   $28 = HEAP32[$27 >> 2] | 0;
   $29 = _mp_obj_is_obj_1366($28) | 0;
   if (!$29) {
    label = 8;
    break;
   }
   $30 = $5;
   $31 = $9;
   $32 = $30 + ($31 << 2) | 0;
   $33 = HEAP32[$32 >> 2] | 0;
   $34 = HEAP32[$33 >> 2] | 0;
   $35 = ($34 | 0) == (14112 | 0);
   if (!$35) {
    label = 8;
    break;
   }
   $36 = $5;
   $37 = $9;
   $38 = $36 + ($37 << 2) | 0;
   $39 = HEAP32[$38 >> 2] | 0;
   $8 = $39;
   $40 = $9;
   $41 = ($40 | 0) == 1;
   if ($41) {
    $42 = $8;
    $7 = $42;
   }
  }
  $43 = $9;
  $44 = $43 + 1 | 0;
  $9 = $44;
 }
 if ((label | 0) == 8) {
  _mp_raise_TypeError(0);
 } else if ((label | 0) == 12) {
  $45 = HEAP32[$20 >> 2] | 0;
  $46 = _mp_obj_is_obj_1366($45) | 0;
  if ($46) {
   $47 = $5;
   $48 = HEAP32[$47 >> 2] | 0;
   $49 = HEAP32[$48 >> 2] | 0;
   $50 = ($49 | 0) == (19508 | 0);
   if ($50) {
    $51 = $5;
    $52 = HEAP32[$51 >> 2] | 0;
    $53 = $7;
    $54 = $8;
    $55 = _code_execute($52, $53, $54) | 0;
    $3 = $55;
    $70 = $3;
    STACKTOP = sp;
    return $70 | 0;
   }
  }
  $56 = $5;
  $57 = HEAP32[$56 >> 2] | 0;
  $58 = _mp_obj_str_get_data($57, $10) | 0;
  $11 = $58;
  $59 = $6;
  $60 = ($59 | 0) == 0;
  $61 = $11;
  if ($60) {
   $62 = _mp_lexer_new_from_file($61) | 0;
   $12 = $62;
   $6 = 1;
  } else {
   $63 = HEAP32[$10 >> 2] | 0;
   $64 = _mp_lexer_new_from_str_len(214, $61, $63, 0) | 0;
   $12 = $64;
  }
  $65 = $12;
  $66 = $6;
  $67 = $7;
  $68 = $8;
  $69 = _mp_parse_compile_execute($65, $66, $67, $68) | 0;
  $3 = $69;
  $70 = $3;
  STACKTOP = sp;
  return $70 | 0;
 }
 return 0 | 0;
}

function _compile_while_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $10 = $2;
 $11 = $10 + 24 | 0;
 $12 = HEAP16[$11 >> 1] | 0;
 $4 = $12;
 $13 = $2;
 $14 = $13 + 26 | 0;
 $15 = HEAP16[$14 >> 1] | 0;
 $5 = $15;
 $16 = $2;
 $17 = $16 + 30 | 0;
 $18 = HEAP16[$17 >> 1] | 0;
 $6 = $18;
 $19 = $2;
 $20 = _comp_next_label($19) | 0;
 $7 = $20;
 $21 = $2;
 $22 = _comp_next_label($21) | 0;
 $8 = $22;
 $23 = $7;
 $24 = $23 & 65535;
 $25 = $2;
 $26 = $25 + 24 | 0;
 HEAP16[$26 >> 1] = $24;
 $27 = $8;
 $28 = $27 & 65535;
 $29 = $2;
 $30 = $29 + 26 | 0;
 HEAP16[$30 >> 1] = $28;
 $31 = $2;
 $32 = $31 + 28 | 0;
 $33 = HEAP16[$32 >> 1] | 0;
 $34 = $2;
 $35 = $34 + 30 | 0;
 HEAP16[$35 >> 1] = $33;
 $36 = $3;
 $37 = $36 + 8 | 0;
 $38 = HEAP32[$37 >> 2] | 0;
 $39 = _mp_parse_node_is_const_false($38) | 0;
 if (!$39) {
  $40 = $2;
  $41 = _comp_next_label($40) | 0;
  $9 = $41;
  $42 = $3;
  $43 = $42 + 8 | 0;
  $44 = HEAP32[$43 >> 2] | 0;
  $45 = _mp_parse_node_is_const_true($44) | 0;
  if (!$45) {
   $46 = $2;
   $47 = $46 + 40 | 0;
   $48 = HEAP32[$47 >> 2] | 0;
   $49 = $8;
   _mp_emit_bc_jump($48, $49);
  }
  $50 = $2;
  $51 = $50 + 40 | 0;
  $52 = HEAP32[$51 >> 2] | 0;
  $53 = $9;
  _mp_emit_bc_label_assign($52, $53);
  $54 = $2;
  $55 = $3;
  $56 = $55 + 8 | 0;
  $57 = $56 + 4 | 0;
  $58 = HEAP32[$57 >> 2] | 0;
  _compile_node($54, $58);
  $59 = $2;
  $60 = $59 + 40 | 0;
  $61 = HEAP32[$60 >> 2] | 0;
  $62 = $8;
  _mp_emit_bc_label_assign($61, $62);
  $63 = $2;
  $64 = $3;
  $65 = $64 + 8 | 0;
  $66 = HEAP32[$65 >> 2] | 0;
  $67 = $9;
  _c_if_cond($63, $66, 1, $67);
 }
 $68 = $4;
 $69 = $2;
 $70 = $69 + 24 | 0;
 HEAP16[$70 >> 1] = $68;
 $71 = $5;
 $72 = $2;
 $73 = $72 + 26 | 0;
 HEAP16[$73 >> 1] = $71;
 $74 = $6;
 $75 = $2;
 $76 = $75 + 30 | 0;
 HEAP16[$76 >> 1] = $74;
 $77 = $2;
 $78 = $3;
 $79 = $78 + 8 | 0;
 $80 = $79 + 8 | 0;
 $81 = HEAP32[$80 >> 2] | 0;
 _compile_node($77, $81);
 $82 = $2;
 $83 = $82 + 40 | 0;
 $84 = HEAP32[$83 >> 2] | 0;
 $85 = $7;
 _mp_emit_bc_label_assign($84, $85);
 STACKTOP = sp;
 return;
}

function _mp_seq_cmp_bytes($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val11 = 0, $$expand_i1_val13 = 0, $$expand_i1_val3 = 0, $$expand_i1_val5 = 0, $$expand_i1_val7 = 0, $$expand_i1_val9 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = sp + 36 | 0;
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $15 = $6;
 $16 = ($15 | 0) == 2;
 if ($16) {
  $17 = $8;
  $18 = $10;
  $19 = ($17 | 0) != ($18 | 0);
  if ($19) {
   $$expand_i1_val = 0;
   HEAP8[$5 >> 0] = $$expand_i1_val;
  } else {
   label = 4;
  }
 } else {
  label = 4;
 }
 do {
  if ((label | 0) == 4) {
   $20 = $6;
   $21 = ($20 | 0) == 0;
   $22 = $6;
   $23 = ($22 | 0) == 3;
   $or$cond = $21 | $23;
   do {
    if ($or$cond) {
     $24 = $9;
     $11 = $24;
     $25 = $7;
     $9 = $25;
     $26 = $11;
     $7 = $26;
     $27 = $10;
     $12 = $27;
     $28 = $8;
     $10 = $28;
     $29 = $12;
     $8 = $29;
     $30 = $6;
     $31 = ($30 | 0) == 0;
     if ($31) {
      $6 = 1;
      break;
     } else {
      $6 = 4;
      break;
     }
    }
   } while (0);
   $32 = $8;
   $33 = $10;
   $34 = $32 >>> 0 < $33 >>> 0;
   $35 = $8;
   $36 = $10;
   $37 = $34 ? $35 : $36;
   $13 = $37;
   $38 = $7;
   $39 = $9;
   $40 = $13;
   $41 = _memcmp($38, $39, $40) | 0;
   $14 = $41;
   $42 = $6;
   $43 = ($42 | 0) == 2;
   $44 = $14;
   if ($43) {
    $45 = ($44 | 0) == 0;
    $$expand_i1_val3 = $45 & 1;
    HEAP8[$5 >> 0] = $$expand_i1_val3;
    break;
   }
   $46 = ($44 | 0) < 0;
   if ($46) {
    $$expand_i1_val5 = 0;
    HEAP8[$5 >> 0] = $$expand_i1_val5;
    break;
   }
   $47 = $14;
   $48 = ($47 | 0) > 0;
   if ($48) {
    $$expand_i1_val7 = 1;
    HEAP8[$5 >> 0] = $$expand_i1_val7;
    break;
   }
   $49 = $8;
   $50 = $10;
   $51 = ($49 | 0) != ($50 | 0);
   if ($51) {
    $52 = $8;
    $53 = $10;
    $54 = $52 >>> 0 < $53 >>> 0;
    if ($54) {
     $$expand_i1_val9 = 0;
     HEAP8[$5 >> 0] = $$expand_i1_val9;
     break;
    }
   } else {
    $55 = $6;
    $56 = ($55 | 0) == 1;
    if ($56) {
     $$expand_i1_val11 = 0;
     HEAP8[$5 >> 0] = $$expand_i1_val11;
     break;
    }
   }
   $$expand_i1_val13 = 1;
   HEAP8[$5 >> 0] = $$expand_i1_val13;
  }
 } while (0);
 $$pre_trunc = HEAP8[$5 >> 0] | 0;
 $57 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $57 | 0;
}

function _uzlib_uncompress_chksum($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $6 = $2;
 $7 = $6 + 24 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $4 = $8;
 $9 = $2;
 $10 = _uzlib_uncompress($9) | 0;
 $3 = $10;
 $11 = $3;
 $12 = ($11 | 0) < 0;
 if ($12) {
  $13 = $3;
  $1 = $13;
  $70 = $1;
  STACKTOP = sp;
  return $70 | 0;
 }
 $14 = $2;
 $15 = $14 + 36 | 0;
 $16 = HEAP8[$15 >> 0] | 0;
 $17 = $16 << 24 >> 24;
 switch ($17 | 0) {
 case 1:
  {
   $18 = $4;
   $19 = $2;
   $20 = $19 + 24 | 0;
   $21 = HEAP32[$20 >> 2] | 0;
   $22 = $4;
   $23 = $21;
   $24 = $22;
   $25 = $23 - $24 | 0;
   $26 = $2;
   $27 = $26 + 32 | 0;
   $28 = HEAP32[$27 >> 2] | 0;
   $29 = _uzlib_adler32($18, $25, $28) | 0;
   $30 = $2;
   $31 = $30 + 32 | 0;
   HEAP32[$31 >> 2] = $29;
   break;
  }
 case 2:
  {
   $32 = $4;
   $33 = $2;
   $34 = $33 + 24 | 0;
   $35 = HEAP32[$34 >> 2] | 0;
   $36 = $4;
   $37 = $35;
   $38 = $36;
   $39 = $37 - $38 | 0;
   $40 = $2;
   $41 = $40 + 32 | 0;
   $42 = HEAP32[$41 >> 2] | 0;
   $43 = _uzlib_crc32($32, $39, $42) | 0;
   $44 = $2;
   $45 = $44 + 32 | 0;
   HEAP32[$45 >> 2] = $43;
   break;
  }
 default:
  {}
 }
 $46 = $3;
 $47 = ($46 | 0) == 1;
 L9 : do {
  if ($47) {
   $48 = $2;
   $49 = $48 + 36 | 0;
   $50 = HEAP8[$49 >> 0] | 0;
   $51 = $50 << 24 >> 24;
   switch ($51 | 0) {
   case 1:
    {
     $52 = $2;
     $53 = _tinf_get_be_uint32($52) | 0;
     $5 = $53;
     $54 = $2;
     $55 = $54 + 32 | 0;
     $56 = HEAP32[$55 >> 2] | 0;
     $57 = $5;
     $58 = ($56 | 0) != ($57 | 0);
     if (!$58) {
      break L9;
     }
     $1 = -4;
     $70 = $1;
     STACKTOP = sp;
     return $70 | 0;
     break;
    }
   case 2:
    {
     break;
    }
   default:
    {
     break L9;
    }
   }
   $59 = $2;
   $60 = _tinf_get_le_uint32($59) | 0;
   $5 = $60;
   $61 = $2;
   $62 = $61 + 32 | 0;
   $63 = HEAP32[$62 >> 2] | 0;
   $64 = $63 ^ -1;
   $65 = $5;
   $66 = ($64 | 0) != ($65 | 0);
   if (!$66) {
    $67 = $2;
    $68 = _tinf_get_le_uint32($67) | 0;
    $5 = $68;
    break;
   }
   $1 = -4;
   $70 = $1;
   STACKTOP = sp;
   return $70 | 0;
  }
 } while (0);
 $69 = $3;
 $1 = $69;
 $70 = $1;
 STACKTOP = sp;
 return $70 | 0;
}

function _mpz_add_inpl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $8 = $7 + 8 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $4;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $5;
 $14 = $13 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $5;
 $17 = $16 + 4 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = _mpn_cmp($9, $12, $15, $18) | 0;
 $20 = ($19 | 0) < 0;
 if ($20) {
  $21 = $4;
  $6 = $21;
  $22 = $5;
  $4 = $22;
  $23 = $6;
  $5 = $23;
 }
 $24 = $4;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = $25 & 1;
 $27 = $5;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = $28 & 1;
 $30 = ($26 | 0) == ($29 | 0);
 $31 = $3;
 $32 = $4;
 $33 = $32 + 4 | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 if ($30) {
  $35 = $34 + 1 | 0;
  _mpz_need_dig($31, $35);
  $36 = $3;
  $37 = $36 + 8 | 0;
  $38 = HEAP32[$37 >> 2] | 0;
  $39 = $4;
  $40 = $39 + 8 | 0;
  $41 = HEAP32[$40 >> 2] | 0;
  $42 = $4;
  $43 = $42 + 4 | 0;
  $44 = HEAP32[$43 >> 2] | 0;
  $45 = $5;
  $46 = $45 + 8 | 0;
  $47 = HEAP32[$46 >> 2] | 0;
  $48 = $5;
  $49 = $48 + 4 | 0;
  $50 = HEAP32[$49 >> 2] | 0;
  $51 = _mpn_add($38, $41, $44, $47, $50) | 0;
  $52 = $3;
  $53 = $52 + 4 | 0;
  HEAP32[$53 >> 2] = $51;
  $72 = $4;
  $73 = HEAP32[$72 >> 2] | 0;
  $74 = $73 & 1;
  $75 = $3;
  $76 = HEAP32[$75 >> 2] | 0;
  $77 = $74 & 1;
  $78 = $76 & -2;
  $79 = $78 | $77;
  HEAP32[$75 >> 2] = $79;
  STACKTOP = sp;
  return;
 } else {
  _mpz_need_dig($31, $34);
  $54 = $3;
  $55 = $54 + 8 | 0;
  $56 = HEAP32[$55 >> 2] | 0;
  $57 = $4;
  $58 = $57 + 8 | 0;
  $59 = HEAP32[$58 >> 2] | 0;
  $60 = $4;
  $61 = $60 + 4 | 0;
  $62 = HEAP32[$61 >> 2] | 0;
  $63 = $5;
  $64 = $63 + 8 | 0;
  $65 = HEAP32[$64 >> 2] | 0;
  $66 = $5;
  $67 = $66 + 4 | 0;
  $68 = HEAP32[$67 >> 2] | 0;
  $69 = _mpn_sub($56, $59, $62, $65, $68) | 0;
  $70 = $3;
  $71 = $70 + 4 | 0;
  HEAP32[$71 >> 2] = $69;
  $72 = $4;
  $73 = HEAP32[$72 >> 2] | 0;
  $74 = $73 & 1;
  $75 = $3;
  $76 = HEAP32[$75 >> 2] | 0;
  $77 = $74 & 1;
  $78 = $76 & -2;
  $79 = $78 | $77;
  HEAP32[$75 >> 2] = $79;
  STACKTOP = sp;
  return;
 }
}

function _array_construct($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $5 = sp + 36 | 0;
 $3 = $0;
 $4 = $1;
 $15 = $3;
 $16 = $15 << 24 >> 24;
 $17 = ($16 | 0) == 1;
 do {
  if ($17) {
   label = 6;
  } else {
   $18 = $4;
   $19 = _mp_obj_is_obj_817($18) | 0;
   if ($19) {
    $20 = $4;
    $21 = HEAP32[$20 >> 2] | 0;
    $22 = ($21 | 0) == (18304 | 0);
    if ($22) {
     label = 6;
     break;
    }
   }
   $23 = $4;
   $24 = _mp_obj_is_obj_817($23) | 0;
   if ($24) {
    $25 = $4;
    $26 = HEAP32[$25 >> 2] | 0;
    $27 = ($26 | 0) == (13584 | 0);
    if ($27) {
     label = 6;
    }
   }
  }
 } while (0);
 if ((label | 0) == 6) {
  $28 = $4;
  $29 = _mp_get_buffer($28, $5, 1) | 0;
  if ($29) {
   $30 = $3;
   $31 = _mp_binary_get_size(64, $30, 0) | 0;
   $6 = $31;
   $32 = $5 + 4 | 0;
   $33 = HEAP32[$32 >> 2] | 0;
   $34 = $6;
   $35 = ($33 >>> 0) / ($34 >>> 0) & -1;
   $7 = $35;
   $36 = $3;
   $37 = $7;
   $38 = _array_new($36, $37) | 0;
   $8 = $38;
   $39 = $8;
   $40 = $39 + 12 | 0;
   $41 = HEAP32[$40 >> 2] | 0;
   $42 = HEAP32[$5 >> 2] | 0;
   $43 = $7;
   $44 = $6;
   $45 = Math_imul($43, $44) | 0;
   _memcpy($41 | 0, $42 | 0, $45 | 0) | 0;
   $46 = $8;
   $2 = $46;
   $74 = $2;
   STACKTOP = sp;
   return $74 | 0;
  }
 }
 $47 = $4;
 $48 = _mp_obj_len_maybe($47) | 0;
 $10 = $48;
 $49 = $10;
 $50 = ($49 | 0) == (0 | 0);
 if ($50) {
  $9 = 0;
 } else {
  $51 = $10;
  $52 = $51;
  $53 = $52 >> 1;
  $9 = $53;
 }
 $54 = $3;
 $55 = $9;
 $56 = _array_new($54, $55) | 0;
 $11 = $56;
 $57 = $4;
 $58 = _mp_getiter($57, 0) | 0;
 $12 = $58;
 $14 = 0;
 while (1) {
  $59 = $12;
  $60 = _mp_iternext($59) | 0;
  $13 = $60;
  $61 = ($60 | 0) != (0 | 0);
  if (!$61) {
   break;
  }
  $62 = $9;
  $63 = ($62 | 0) == 0;
  if ($63) {
   $64 = $11;
   $65 = $13;
   _array_append($64, $65) | 0;
  } else {
   $66 = $3;
   $67 = $11;
   $68 = $67 + 12 | 0;
   $69 = HEAP32[$68 >> 2] | 0;
   $70 = $14;
   $71 = $70 + 1 | 0;
   $14 = $71;
   $72 = $13;
   _mp_binary_set_val_array($66, $69, $70, $72);
  }
 }
 $73 = $11;
 $2 = $73;
 $74 = $2;
 STACKTOP = sp;
 return $74 | 0;
}

function __re1_5_namedclassmatch($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 << 24 >> 24;
 $8 = $7 >> 5;
 $9 = $8 & 1;
 $4 = $9;
 $10 = $2;
 $11 = HEAP8[$10 >> 0] | 0;
 $12 = $11 << 24 >> 24;
 $13 = $12 | 32;
 $14 = ($13 | 0) == 100;
 do {
  if ($14) {
   $15 = $3;
   $16 = HEAP8[$15 >> 0] | 0;
   $17 = $16 << 24 >> 24;
   $18 = ($17 | 0) >= 48;
   if ($18) {
    $19 = $3;
    $20 = HEAP8[$19 >> 0] | 0;
    $21 = $20 << 24 >> 24;
    $22 = ($21 | 0) <= 57;
    if ($22) {
     break;
    }
   }
   $23 = $4;
   $24 = $23 ^ 1;
   $4 = $24;
  } else {
   $25 = $2;
   $26 = HEAP8[$25 >> 0] | 0;
   $27 = $26 << 24 >> 24;
   $28 = $27 | 32;
   $29 = ($28 | 0) == 115;
   $30 = $3;
   $31 = HEAP8[$30 >> 0] | 0;
   $32 = $31 << 24 >> 24;
   if ($29) {
    $33 = ($32 | 0) == 32;
    if ($33) {
     break;
    }
    $34 = $3;
    $35 = HEAP8[$34 >> 0] | 0;
    $36 = $35 << 24 >> 24;
    $37 = ($36 | 0) >= 9;
    if ($37) {
     $38 = $3;
     $39 = HEAP8[$38 >> 0] | 0;
     $40 = $39 << 24 >> 24;
     $41 = ($40 | 0) <= 13;
     if ($41) {
      break;
     }
    }
    $42 = $4;
    $43 = $42 ^ 1;
    $4 = $43;
    break;
   }
   $44 = ($32 | 0) >= 65;
   if ($44) {
    $45 = $3;
    $46 = HEAP8[$45 >> 0] | 0;
    $47 = $46 << 24 >> 24;
    $48 = ($47 | 0) <= 90;
    if ($48) {
     break;
    }
   }
   $49 = $3;
   $50 = HEAP8[$49 >> 0] | 0;
   $51 = $50 << 24 >> 24;
   $52 = ($51 | 0) >= 97;
   if ($52) {
    $53 = $3;
    $54 = HEAP8[$53 >> 0] | 0;
    $55 = $54 << 24 >> 24;
    $56 = ($55 | 0) <= 122;
    if ($56) {
     break;
    }
   }
   $57 = $3;
   $58 = HEAP8[$57 >> 0] | 0;
   $59 = $58 << 24 >> 24;
   $60 = ($59 | 0) >= 48;
   if ($60) {
    $61 = $3;
    $62 = HEAP8[$61 >> 0] | 0;
    $63 = $62 << 24 >> 24;
    $64 = ($63 | 0) <= 57;
    if ($64) {
     break;
    }
   }
   $65 = $3;
   $66 = HEAP8[$65 >> 0] | 0;
   $67 = $66 << 24 >> 24;
   $68 = ($67 | 0) == 95;
   if (!$68) {
    $69 = $4;
    $70 = $69 ^ 1;
    $4 = $70;
   }
  }
 } while (0);
 $71 = $4;
 STACKTOP = sp;
 return $71 | 0;
}

function _mpz_set_from_str($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond3 = 0, $or$cond5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $13 = $3 & 1;
 $8 = $13;
 $9 = $4;
 $14 = $6;
 $10 = $14;
 $15 = $6;
 $16 = $7;
 $17 = $15 + $16 | 0;
 $11 = $17;
 $18 = $5;
 $19 = $7;
 $20 = $19 << 3;
 $21 = ($20 >>> 0) / 16 & -1;
 $22 = $21 + 1 | 0;
 _mpz_need_dig($18, $22);
 $23 = $8;
 $24 = $23 & 1;
 $25 = $5;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = $26 & -2;
 if ($24) {
  $28 = $27 | 1;
  HEAP32[$25 >> 2] = $28;
 } else {
  HEAP32[$25 >> 2] = $27;
 }
 $29 = $5;
 $30 = $29 + 4 | 0;
 HEAP32[$30 >> 2] = 0;
 L5 : while (1) {
  $31 = $10;
  $32 = $11;
  $33 = $31 >>> 0 < $32 >>> 0;
  if (!$33) {
   label = 14;
   break;
  }
  $34 = $10;
  $35 = HEAP8[$34 >> 0] | 0;
  $36 = $35 << 24 >> 24;
  $12 = $36;
  $37 = $12;
  $38 = 48 <= $37 >>> 0;
  $39 = $12;
  $40 = $39 >>> 0 <= 57;
  $or$cond = $38 & $40;
  $41 = $12;
  do {
   if ($or$cond) {
    $42 = $41 - 48 | 0;
    $12 = $42;
   } else {
    $43 = 65 <= $41 >>> 0;
    $44 = $12;
    $45 = $44 >>> 0 <= 90;
    $or$cond3 = $43 & $45;
    $46 = $12;
    if ($or$cond3) {
     $47 = $46 - 55 | 0;
     $12 = $47;
     break;
    }
    $48 = 97 <= $46 >>> 0;
    $49 = $12;
    $50 = $49 >>> 0 <= 122;
    $or$cond5 = $48 & $50;
    if (!$or$cond5) {
     label = 14;
     break L5;
    }
    $51 = $12;
    $52 = $51 - 87 | 0;
    $12 = $52;
   }
  } while (0);
  $53 = $12;
  $54 = $9;
  $55 = $53 >>> 0 >= $54 >>> 0;
  if ($55) {
   label = 14;
   break;
  }
  $56 = $5;
  $57 = $56 + 8 | 0;
  $58 = HEAP32[$57 >> 2] | 0;
  $59 = $5;
  $60 = $59 + 4 | 0;
  $61 = HEAP32[$60 >> 2] | 0;
  $62 = $9;
  $63 = $62 & 65535;
  $64 = $12;
  $65 = $64 & 65535;
  $66 = _mpn_mul_dig_add_dig($58, $61, $63, $65) | 0;
  $67 = $5;
  $68 = $67 + 4 | 0;
  HEAP32[$68 >> 2] = $66;
  $69 = $10;
  $70 = $69 + 1 | 0;
  $10 = $70;
 }
 if ((label | 0) == 14) {
  $71 = $10;
  $72 = $6;
  $73 = $71;
  $74 = $72;
  $75 = $73 - $74 | 0;
  STACKTOP = sp;
  return $75 | 0;
 }
 return 0 | 0;
}

function _gc_collect_start() {
 var $$019$i = 0, $$019$i9 = 0, $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $exitcond$i = 0, $exitcond$i11 = 0, $or$cond$i = 0, $or$cond$i10 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP16[41020 >> 1] | 0;
 $1 = $0 + 1 << 16 >> 16;
 HEAP16[41020 >> 1] = $1;
 HEAP32[41024 >> 2] = 0;
 HEAP32[40760 >> 2] = 0;
 $$019$i = 0;
 while (1) {
  $2 = 40560 + ($$019$i << 2) | 0;
  $3 = HEAP32[$2 >> 2] | 0;
  $4 = $3;
  $5 = $4 & 15;
  $6 = ($5 | 0) == 0;
  if ($6) {
   $7 = HEAP32[40752 >> 2] | 0;
   $8 = $3 >>> 0 >= $7 >>> 0;
   $9 = HEAP32[40756 >> 2] | 0;
   $10 = $3 >>> 0 < $9 >>> 0;
   $or$cond$i = $8 & $10;
   if ($or$cond$i) {
    $11 = $7;
    $12 = $4 - $11 | 0;
    $13 = $12 >>> 4;
    $14 = HEAP32[40744 >> 2] | 0;
    $15 = $12 >>> 6;
    $16 = $14 + $15 | 0;
    $17 = HEAP8[$16 >> 0] | 0;
    $18 = $17 & 255;
    $19 = $13 << 1;
    $20 = $19 & 6;
    $21 = $18 >>> $20;
    $22 = $21 & 3;
    $23 = ($22 | 0) == 1;
    if ($23) {
     $24 = 3 << $20;
     $25 = $24 | $18;
     $26 = $25 & 255;
     HEAP8[$16 >> 0] = $26;
     _gc_mark_subtree($13);
    }
   }
  }
  $27 = $$019$i + 1 | 0;
  $exitcond$i = ($27 | 0) == 41;
  if ($exitcond$i) {
   break;
  } else {
   $$019$i = $27;
  }
 }
 $28 = HEAP32[40548 >> 2] | 0;
 $29 = HEAP32[40556 >> 2] | 0;
 $30 = $28;
 $31 = $29 - $30 | 0;
 $32 = $31 >>> 2;
 $33 = ($32 | 0) == 0;
 if ($33) {
  return;
 }
 $$019$i9 = 0;
 while (1) {
  $34 = $28 + ($$019$i9 << 2) | 0;
  $35 = HEAP32[$34 >> 2] | 0;
  $36 = $35;
  $37 = $36 & 15;
  $38 = ($37 | 0) == 0;
  if ($38) {
   $39 = HEAP32[40752 >> 2] | 0;
   $40 = $35 >>> 0 >= $39 >>> 0;
   $41 = HEAP32[40756 >> 2] | 0;
   $42 = $35 >>> 0 < $41 >>> 0;
   $or$cond$i10 = $40 & $42;
   if ($or$cond$i10) {
    $43 = $39;
    $44 = $36 - $43 | 0;
    $45 = $44 >>> 4;
    $46 = HEAP32[40744 >> 2] | 0;
    $47 = $44 >>> 6;
    $48 = $46 + $47 | 0;
    $49 = HEAP8[$48 >> 0] | 0;
    $50 = $49 & 255;
    $51 = $45 << 1;
    $52 = $51 & 6;
    $53 = $50 >>> $52;
    $54 = $53 & 3;
    $55 = ($54 | 0) == 1;
    if ($55) {
     $56 = 3 << $52;
     $57 = $56 | $50;
     $58 = $57 & 255;
     HEAP8[$48 >> 0] = $58;
     _gc_mark_subtree($45);
    }
   }
  }
  $59 = $$019$i9 + 1 | 0;
  $exitcond$i11 = ($59 | 0) == ($32 | 0);
  if ($exitcond$i11) {
   break;
  } else {
   $$019$i9 = $59;
  }
 }
 return;
}

function _exp($0) {
 $0 = +$0;
 var $$0 = 0.0, $$055 = 0.0, $$056 = 0, $$057 = 0.0, $$058 = 0.0, $$1 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0.0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0.0, $2 = 0, $20 = 0, $21 = 0.0, $22 = 0.0, $23 = 0, $24 = 0, $25 = 0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0, $51 = 0.0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = _bitshift64Lshr($1 | 0, $2 | 0, 63) | 0;
 $4 = getTempRet0() | 0;
 $5 = $2 & 2147483647;
 $6 = $5 >>> 0 > 1082532650;
 do {
  if ($6) {
   $7 = $2 & 2147483647;
   $8 = $7 >>> 0 > 2146435072;
   $9 = $1 >>> 0 > 0;
   $10 = ($7 | 0) == 2146435072;
   $11 = $10 & $9;
   $12 = $8 | $11;
   if ($12) {
    $$0 = $0;
    return +$$0;
   }
   $13 = $0 > 709.782712893384;
   if ($13) {
    $14 = $0 * 8988465674311579538646525.0e283;
    $$0 = $14;
    return +$$0;
   } else {
    $15 = $0 < -708.3964185322641;
    $16 = $0 < -745.1332191019411;
    $or$cond = $15 & $16;
    if ($or$cond) {
     $$0 = 0.0;
    } else {
     label = 8;
     break;
    }
    return +$$0;
   }
  } else {
   $17 = $5 >>> 0 > 1071001154;
   if ($17) {
    $18 = $5 >>> 0 > 1072734897;
    if ($18) {
     label = 8;
     break;
    }
    $24 = $3 ^ 1;
    $25 = $24 - $3 | 0;
    $$056 = $25;
    label = 10;
    break;
   }
   $31 = $5 >>> 0 > 1043333120;
   if ($31) {
    $$055 = $0;
    $$057 = $0;
    $$058 = 0.0;
    $$1 = 0;
   } else {
    $32 = $0 + 1.0;
    $$0 = $32;
    return +$$0;
   }
  }
 } while (0);
 if ((label | 0) == 8) {
  $19 = $0 * 1.4426950408889634;
  $20 = 10896 + ($3 << 3) | 0;
  $21 = +HEAPF64[$20 >> 3];
  $22 = $19 + $21;
  $23 = ~~$22;
  $$056 = $23;
  label = 10;
 }
 if ((label | 0) == 10) {
  $26 = +($$056 | 0);
  $27 = $26 * .6931471803691238;
  $28 = $0 - $27;
  $29 = $26 * 1.9082149292705877e-10;
  $30 = $28 - $29;
  $$055 = $30;
  $$057 = $28;
  $$058 = $29;
  $$1 = $$056;
 }
 $33 = $$055 * $$055;
 $34 = $33 * 4.1381367970572385e-08;
 $35 = $34 + -1.6533902205465252e-06;
 $36 = $33 * $35;
 $37 = $36 + 6.613756321437934e-05;
 $38 = $33 * $37;
 $39 = $38 + -2.7777777777015593e-03;
 $40 = $33 * $39;
 $41 = $40 + .16666666666666602;
 $42 = $33 * $41;
 $43 = $$055 - $42;
 $44 = $$055 * $43;
 $45 = 2.0 - $43;
 $46 = $44 / $45;
 $47 = $46 - $$058;
 $48 = $$057 + $47;
 $49 = $48 + 1.0;
 $50 = ($$1 | 0) == 0;
 if ($50) {
  $$0 = $49;
  return +$$0;
 }
 $51 = +_scalbn($49, $$1);
 $$0 = $51;
 return +$$0;
}

function _mpz_mul_inpl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) == 0;
 if (!$10) {
  $11 = $5;
  $12 = $11 + 4 | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = ($13 | 0) == 0;
  if (!$14) {
   $6 = 0;
   $16 = $4;
   $17 = $3;
   $18 = ($16 | 0) == ($17 | 0);
   if ($18) {
    $19 = $4;
    $20 = _mpz_clone($19) | 0;
    $6 = $20;
    $4 = $20;
    $21 = $5;
    $22 = $3;
    $23 = ($21 | 0) == ($22 | 0);
    if ($23) {
     $24 = $4;
     $5 = $24;
    }
   } else {
    $25 = $5;
    $26 = $3;
    $27 = ($25 | 0) == ($26 | 0);
    if ($27) {
     $28 = $5;
     $29 = _mpz_clone($28) | 0;
     $6 = $29;
     $5 = $29;
    }
   }
   $30 = $3;
   $31 = $4;
   $32 = $31 + 4 | 0;
   $33 = HEAP32[$32 >> 2] | 0;
   $34 = $5;
   $35 = $34 + 4 | 0;
   $36 = HEAP32[$35 >> 2] | 0;
   $37 = $33 + $36 | 0;
   _mpz_need_dig($30, $37);
   $38 = $3;
   $39 = $38 + 8 | 0;
   $40 = HEAP32[$39 >> 2] | 0;
   $41 = $3;
   $42 = HEAP32[$41 >> 2] | 0;
   $43 = $42 >>> 2;
   $44 = $43 << 1;
   _memset($40 | 0, 0, $44 | 0) | 0;
   $45 = $3;
   $46 = $45 + 8 | 0;
   $47 = HEAP32[$46 >> 2] | 0;
   $48 = $4;
   $49 = $48 + 8 | 0;
   $50 = HEAP32[$49 >> 2] | 0;
   $51 = $4;
   $52 = $51 + 4 | 0;
   $53 = HEAP32[$52 >> 2] | 0;
   $54 = $5;
   $55 = $54 + 8 | 0;
   $56 = HEAP32[$55 >> 2] | 0;
   $57 = $5;
   $58 = $57 + 4 | 0;
   $59 = HEAP32[$58 >> 2] | 0;
   $60 = _mpn_mul($47, $50, $53, $56, $59) | 0;
   $61 = $3;
   $62 = $61 + 4 | 0;
   HEAP32[$62 >> 2] = $60;
   $63 = $4;
   $64 = HEAP32[$63 >> 2] | 0;
   $65 = $64 & 1;
   $66 = $5;
   $67 = HEAP32[$66 >> 2] | 0;
   $68 = $67 & 1;
   $69 = ($65 | 0) == ($68 | 0);
   $70 = $3;
   $71 = HEAP32[$70 >> 2] | 0;
   $72 = $71 & -2;
   if ($69) {
    HEAP32[$70 >> 2] = $72;
   } else {
    $73 = $72 | 1;
    HEAP32[$70 >> 2] = $73;
   }
   $74 = $6;
   _mpz_free($74);
   STACKTOP = sp;
   return;
  }
 }
 $15 = $3;
 _mpz_set_from_int($15, 0);
 STACKTOP = sp;
 return;
}

function _tinf_inflate_uncompressed_block($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $6 = $2;
 $7 = $6 + 48 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) == 0;
 do {
  if ($9) {
   $10 = $2;
   $11 = _uzlib_get_byte($10) | 0;
   $12 = $11 & 255;
   $3 = $12;
   $13 = $2;
   $14 = _uzlib_get_byte($13) | 0;
   $15 = $14 & 255;
   $16 = $15 << 8;
   $17 = $3;
   $18 = $17 + $16 | 0;
   $3 = $18;
   $19 = $2;
   $20 = _uzlib_get_byte($19) | 0;
   $21 = $20 & 255;
   $4 = $21;
   $22 = $2;
   $23 = _uzlib_get_byte($22) | 0;
   $24 = $23 & 255;
   $25 = $24 << 8;
   $26 = $4;
   $27 = $26 + $25 | 0;
   $4 = $27;
   $28 = $3;
   $29 = $4;
   $30 = $29 ^ -1;
   $31 = $30 & 65535;
   $32 = ($28 | 0) != ($31 | 0);
   if (!$32) {
    $33 = $3;
    $34 = $33 + 1 | 0;
    $35 = $2;
    $36 = $35 + 48 | 0;
    HEAP32[$36 >> 2] = $34;
    $37 = $2;
    $38 = $37 + 16 | 0;
    HEAP32[$38 >> 2] = 0;
    break;
   }
   $1 = -3;
   $73 = $1;
   STACKTOP = sp;
   return $73 | 0;
  }
 } while (0);
 $39 = $2;
 $40 = $39 + 48 | 0;
 $41 = HEAP32[$40 >> 2] | 0;
 $42 = $41 + -1 | 0;
 HEAP32[$40 >> 2] = $42;
 $43 = ($42 | 0) == 0;
 if ($43) {
  $1 = 1;
  $73 = $1;
  STACKTOP = sp;
  return $73 | 0;
 }
 $44 = $2;
 $45 = _uzlib_get_byte($44) | 0;
 $5 = $45;
 $46 = $5;
 $47 = $2;
 $48 = $47 + 24 | 0;
 $49 = HEAP32[$48 >> 2] | 0;
 $50 = $49 + 1 | 0;
 HEAP32[$48 >> 2] = $50;
 HEAP8[$49 >> 0] = $46;
 $51 = $2;
 $52 = $51 + 56 | 0;
 $53 = HEAP32[$52 >> 2] | 0;
 $54 = ($53 | 0) != (0 | 0);
 if ($54) {
  $55 = $5;
  $56 = $2;
  $57 = $56 + 56 | 0;
  $58 = HEAP32[$57 >> 2] | 0;
  $59 = $2;
  $60 = $59 + 64 | 0;
  $61 = HEAP32[$60 >> 2] | 0;
  $62 = $61 + 1 | 0;
  HEAP32[$60 >> 2] = $62;
  $63 = $58 + $61 | 0;
  HEAP8[$63 >> 0] = $55;
  $64 = $2;
  $65 = $64 + 64 | 0;
  $66 = HEAP32[$65 >> 2] | 0;
  $67 = $2;
  $68 = $67 + 60 | 0;
  $69 = HEAP32[$68 >> 2] | 0;
  $70 = ($66 | 0) == ($69 | 0);
  if ($70) {
   $71 = $2;
   $72 = $71 + 64 | 0;
   HEAP32[$72 >> 2] = 0;
  }
 }
 $1 = 0;
 $73 = $1;
 STACKTOP = sp;
 return $73 | 0;
}

function _closure_call($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $11 = sp;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $14 = $5;
 $9 = $14;
 $15 = $9;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $6;
 $19 = $17 + $18 | 0;
 $20 = $7;
 $21 = $20 << 1;
 $22 = $19 + $21 | 0;
 $10 = $22;
 $23 = $10;
 $24 = $23 >>> 0 <= 5;
 if ($24) {
  $25 = $9;
  $26 = $25 + 12 | 0;
  $27 = $9;
  $28 = $27 + 8 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  $30 = $29 << 2;
  _memcpy($11 | 0, $26 | 0, $30 | 0) | 0;
  $31 = $9;
  $32 = $31 + 8 | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = $11 + ($33 << 2) | 0;
  $35 = $8;
  $36 = $6;
  $37 = $7;
  $38 = $37 << 1;
  $39 = $36 + $38 | 0;
  $40 = $39 << 2;
  _memcpy($34 | 0, $35 | 0, $40 | 0) | 0;
  $41 = $9;
  $42 = $41 + 4 | 0;
  $43 = HEAP32[$42 >> 2] | 0;
  $44 = $9;
  $45 = $44 + 8 | 0;
  $46 = HEAP32[$45 >> 2] | 0;
  $47 = $6;
  $48 = $46 + $47 | 0;
  $49 = $7;
  $50 = _mp_call_function_n_kw($43, $48, $49, $11) | 0;
  $4 = $50;
  $85 = $4;
  STACKTOP = sp;
  return $85 | 0;
 } else {
  $51 = $10;
  $52 = $51 << 2;
  $53 = _m_malloc($52) | 0;
  $12 = $53;
  $54 = $12;
  $55 = $9;
  $56 = $55 + 12 | 0;
  $57 = $9;
  $58 = $57 + 8 | 0;
  $59 = HEAP32[$58 >> 2] | 0;
  $60 = $59 << 2;
  _memcpy($54 | 0, $56 | 0, $60 | 0) | 0;
  $61 = $12;
  $62 = $9;
  $63 = $62 + 8 | 0;
  $64 = HEAP32[$63 >> 2] | 0;
  $65 = $61 + ($64 << 2) | 0;
  $66 = $8;
  $67 = $6;
  $68 = $7;
  $69 = $68 << 1;
  $70 = $67 + $69 | 0;
  $71 = $70 << 2;
  _memcpy($65 | 0, $66 | 0, $71 | 0) | 0;
  $72 = $9;
  $73 = $72 + 4 | 0;
  $74 = HEAP32[$73 >> 2] | 0;
  $75 = $9;
  $76 = $75 + 8 | 0;
  $77 = HEAP32[$76 >> 2] | 0;
  $78 = $6;
  $79 = $77 + $78 | 0;
  $80 = $7;
  $81 = $12;
  $82 = _mp_call_function_n_kw($74, $79, $80, $81) | 0;
  $13 = $82;
  $83 = $12;
  _m_free($83);
  $84 = $13;
  $4 = $84;
  $85 = $4;
  STACKTOP = sp;
  return $85 | 0;
 }
 return 0 | 0;
}

function _mp_str_print_json($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $3;
 _mp_print_str($8, 32755) | 0;
 $9 = $4;
 $6 = $9;
 $10 = $4;
 $11 = $5;
 $12 = $10 + $11 | 0;
 $7 = $12;
 while (1) {
  $13 = $6;
  $14 = $7;
  $15 = $13 >>> 0 < $14 >>> 0;
  if (!$15) {
   break;
  }
  $16 = $6;
  $17 = HEAP8[$16 >> 0] | 0;
  $18 = $17 & 255;
  $19 = ($18 | 0) == 34;
  do {
   if ($19) {
    label = 5;
   } else {
    $20 = $6;
    $21 = HEAP8[$20 >> 0] | 0;
    $22 = $21 & 255;
    $23 = ($22 | 0) == 92;
    if ($23) {
     label = 5;
    } else {
     $28 = $6;
     $29 = HEAP8[$28 >> 0] | 0;
     $30 = $29 & 255;
     $31 = ($30 | 0) >= 32;
     if ($31) {
      $32 = $3;
      $33 = $6;
      $34 = HEAP8[$33 >> 0] | 0;
      $35 = $34 & 255;
      HEAP32[$vararg_buffer1 >> 2] = $35;
      _mp_printf($32, 32828, $vararg_buffer1) | 0;
      break;
     }
     $36 = $6;
     $37 = HEAP8[$36 >> 0] | 0;
     $38 = $37 & 255;
     $39 = ($38 | 0) == 10;
     if ($39) {
      $40 = $3;
      _mp_print_str($40, 32838) | 0;
      break;
     }
     $41 = $6;
     $42 = HEAP8[$41 >> 0] | 0;
     $43 = $42 & 255;
     $44 = ($43 | 0) == 13;
     if ($44) {
      $45 = $3;
      _mp_print_str($45, 32841) | 0;
      break;
     }
     $46 = $6;
     $47 = HEAP8[$46 >> 0] | 0;
     $48 = $47 & 255;
     $49 = ($48 | 0) == 9;
     $50 = $3;
     if ($49) {
      _mp_print_str($50, 32844) | 0;
      break;
     } else {
      $51 = $6;
      $52 = HEAP8[$51 >> 0] | 0;
      $53 = $52 & 255;
      HEAP32[$vararg_buffer4 >> 2] = $53;
      _mp_printf($50, 32854, $vararg_buffer4) | 0;
      break;
     }
    }
   }
  } while (0);
  if ((label | 0) == 5) {
   label = 0;
   $24 = $3;
   $25 = $6;
   $26 = HEAP8[$25 >> 0] | 0;
   $27 = $26 & 255;
   HEAP32[$vararg_buffer >> 2] = $27;
   _mp_printf($24, 32831, $vararg_buffer) | 0;
  }
  $54 = $6;
  $55 = $54 + 1 | 0;
  $6 = $55;
 }
 $56 = $3;
 _mp_print_str($56, 32755) | 0;
 STACKTOP = sp;
 return;
}

function _mpn_shl($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $9 = 0, $spec$store$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $12 = $7;
 $13 = $12 + 16 | 0;
 $14 = $13 - 1 | 0;
 $15 = ($14 >>> 0) / 16 & -1;
 $8 = $15;
 $16 = $7;
 $17 = ($16 >>> 0) % 16 & -1;
 $9 = $17;
 $18 = $9;
 $19 = ($18 | 0) == 0;
 $spec$store$select = $19 ? 16 : $17;
 $9 = $spec$store$select;
 $20 = $6;
 $21 = $8;
 $22 = $20 + $21 | 0;
 $23 = $22 - 1 | 0;
 $24 = $4;
 $25 = $24 + ($23 << 1) | 0;
 $4 = $25;
 $26 = $6;
 $27 = $26 - 1 | 0;
 $28 = $5;
 $29 = $28 + ($27 << 1) | 0;
 $5 = $29;
 $10 = 0;
 $30 = $6;
 $11 = $30;
 while (1) {
  $31 = $11;
  $32 = $31 >>> 0 > 0;
  if (!$32) {
   break;
  }
  $33 = $5;
  $34 = HEAP16[$33 >> 1] | 0;
  $35 = $34 & 65535;
  $36 = $10;
  $37 = $36 | $35;
  $10 = $37;
  $38 = $10;
  $39 = $9;
  $40 = 16 - $39 | 0;
  $41 = $38 >>> $40;
  $42 = $41 & 65535;
  $43 = $42 & 65535;
  $44 = $4;
  HEAP16[$44 >> 1] = $43;
  $45 = $10;
  $46 = $45 << 16;
  $10 = $46;
  $47 = $11;
  $48 = $47 + -1 | 0;
  $11 = $48;
  $49 = $4;
  $50 = $49 + -2 | 0;
  $4 = $50;
  $51 = $5;
  $52 = $51 + -2 | 0;
  $5 = $52;
 }
 $53 = $10;
 $54 = $9;
 $55 = 16 - $54 | 0;
 $56 = $53 >>> $55;
 $57 = $56 & 65535;
 $58 = $57 & 65535;
 $59 = $4;
 HEAP16[$59 >> 1] = $58;
 $60 = $8;
 $61 = $60 - 1 | 0;
 $62 = $4;
 $63 = 0 - $61 | 0;
 $64 = $62 + ($63 << 1) | 0;
 $4 = $64;
 $65 = $4;
 $66 = $8;
 $67 = $66 - 1 | 0;
 $68 = $67 << 1;
 _memset($65 | 0, 0, $68 | 0) | 0;
 $69 = $8;
 $70 = $6;
 $71 = $70 + $69 | 0;
 $6 = $71;
 while (1) {
  $72 = $6;
  $73 = ($72 | 0) != 0;
  if ($73) {
   $74 = $4;
   $75 = $6;
   $76 = $75 - 1 | 0;
   $77 = $74 + ($76 << 1) | 0;
   $78 = HEAP16[$77 >> 1] | 0;
   $79 = $78 & 65535;
   $80 = ($79 | 0) == 0;
   $83 = $80;
  } else {
   $83 = 0;
  }
  $81 = $6;
  if (!$83) {
   break;
  }
  $82 = $81 + -1 | 0;
  $6 = $82;
 }
 STACKTOP = sp;
 return $81 | 0;
}

function _poll_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $7 = $2;
 $3 = $7;
 $8 = $3;
 $9 = $8 + 16 | 0;
 $10 = HEAP16[$9 >> 1] | 0;
 $11 = $10 << 16 >> 16;
 $12 = ($11 | 0) == 0;
 if ($12) {
  $1 = 0;
  $74 = $1;
  STACKTOP = sp;
  return $74 | 0;
 }
 $13 = $3;
 $14 = $13 + 16 | 0;
 $15 = HEAP16[$14 >> 1] | 0;
 $16 = $15 + -1 << 16 >> 16;
 HEAP16[$14 >> 1] = $16;
 $17 = $3;
 $18 = $17 + 18 | 0;
 $19 = HEAP16[$18 >> 1] | 0;
 $20 = $19 << 16 >> 16;
 $4 = $20;
 while (1) {
  $21 = $4;
  $22 = $3;
  $23 = $22 + 4 | 0;
  $24 = $23 + 4 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = $21 >>> 0 < $25 >>> 0;
  $27 = $3;
  if (!$26) {
   label = 11;
   break;
  }
  $28 = $27 + 18 | 0;
  $29 = HEAP16[$28 >> 1] | 0;
  $30 = $29 + 1 << 16 >> 16;
  HEAP16[$28 >> 1] = $30;
  $31 = $3;
  $32 = $31 + 4 | 0;
  $33 = $4;
  $34 = _mp_map_slot_is_filled_1536($32, $33) | 0;
  if ($34) {
   $35 = $3;
   $36 = $35 + 4 | 0;
   $37 = $36 + 8 | 0;
   $38 = HEAP32[$37 >> 2] | 0;
   $39 = $4;
   $40 = $38 + ($39 << 3) | 0;
   $41 = $40 + 4 | 0;
   $42 = HEAP32[$41 >> 2] | 0;
   $5 = $42;
   $43 = $5;
   $44 = $43 + 12 | 0;
   $45 = HEAP32[$44 >> 2] | 0;
   $46 = ($45 | 0) != 0;
   if ($46) {
    break;
   }
  }
  $71 = $4;
  $72 = $71 + 1 | 0;
  $4 = $72;
 }
 if ((label | 0) == 11) {
  $73 = $27 + 16 | 0;
  HEAP16[$73 >> 1] = 0;
  $1 = 0;
  $74 = $1;
  STACKTOP = sp;
  return $74 | 0;
 }
 $47 = $3;
 $48 = $47 + 24 | 0;
 $49 = HEAP32[$48 >> 2] | 0;
 $6 = $49;
 $50 = $5;
 $51 = HEAP32[$50 >> 2] | 0;
 $52 = $6;
 $53 = $52 + 8 | 0;
 HEAP32[$53 >> 2] = $51;
 $54 = $5;
 $55 = $54 + 12 | 0;
 $56 = HEAP32[$55 >> 2] | 0;
 $57 = $56 << 1;
 $58 = $57 | 1;
 $59 = $58;
 $60 = $6;
 $61 = $60 + 8 | 0;
 $62 = $61 + 4 | 0;
 HEAP32[$62 >> 2] = $59;
 $63 = $3;
 $64 = $63 + 20 | 0;
 $65 = HEAP32[$64 >> 2] | 0;
 $66 = $65 & 1;
 $67 = ($66 | 0) != 0;
 if ($67) {
  $68 = $5;
  $69 = $68 + 8 | 0;
  HEAP32[$69 >> 2] = 0;
 }
 $70 = $6;
 $1 = $70;
 $74 = $1;
 STACKTOP = sp;
 return $74 | 0;
}

function _mp_stream_rw($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $$old = 0, $$old1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $16 = $7;
 $11 = $16;
 $17 = $6;
 $18 = _mp_get_stream($17) | 0;
 $13 = $18;
 $19 = $10;
 $20 = $19 & 255;
 $21 = $20 & 2;
 $22 = ($21 | 0) != 0;
 $23 = $13;
 if ($22) {
  $24 = $23 + 4 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $12 = $25;
 } else {
  $26 = HEAP32[$23 >> 2] | 0;
  $12 = $26;
 }
 $27 = $9;
 HEAP32[$27 >> 2] = 0;
 $14 = 0;
 while (1) {
  $28 = $8;
  $29 = $28 >>> 0 > 0;
  if (!$29) {
   label = 17;
   break;
  }
  $30 = $12;
  $31 = $6;
  $32 = $11;
  $33 = $8;
  $34 = $9;
  $35 = FUNCTION_TABLE_iiiii[$30 & 1023]($31, $32, $33, $34) | 0;
  $15 = $35;
  $36 = $15;
  $37 = ($36 | 0) == 0;
  if ($37) {
   label = 7;
   break;
  }
  $39 = $15;
  $40 = ($39 | 0) == -1;
  if ($40) {
   label = 9;
   break;
  }
  $51 = $10;
  $52 = $51 & 255;
  $53 = $52 & 1;
  $54 = ($53 | 0) != 0;
  $55 = $15;
  if ($54) {
   label = 15;
   break;
  }
  $56 = $11;
  $57 = $56 + $55 | 0;
  $11 = $57;
  $58 = $15;
  $59 = $8;
  $60 = $59 - $58 | 0;
  $8 = $60;
  $61 = $15;
  $62 = $14;
  $63 = $62 + $61 | 0;
  $14 = $63;
 }
 if ((label | 0) == 7) {
  $38 = $14;
  $5 = $38;
  $65 = $5;
  STACKTOP = sp;
  return $65 | 0;
 } else if ((label | 0) == 9) {
  $41 = $9;
  $42 = HEAP32[$41 >> 2] | 0;
  $43 = ($42 | 0) == 11;
  if ($43) {
   $$old = $14;
   $$old1 = ($$old | 0) != 0;
   if ($$old1) {
    label = 12;
   }
  } else {
   $44 = $9;
   $45 = HEAP32[$44 >> 2] | 0;
   $46 = ($45 | 0) == 11;
   $47 = $14;
   $48 = ($47 | 0) != 0;
   $or$cond = $46 & $48;
   if ($or$cond) {
    label = 12;
   }
  }
  if ((label | 0) == 12) {
   $49 = $9;
   HEAP32[$49 >> 2] = 0;
  }
  $50 = $14;
  $5 = $50;
  $65 = $5;
  STACKTOP = sp;
  return $65 | 0;
 } else if ((label | 0) == 15) {
  $5 = $55;
  $65 = $5;
  STACKTOP = sp;
  return $65 | 0;
 } else if ((label | 0) == 17) {
  $64 = $14;
  $5 = $64;
  $65 = $5;
  STACKTOP = sp;
  return $65 | 0;
 }
 return 0 | 0;
}

function _mpz_as_bytes($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = $0;
 $15 = $1 & 1;
 $5 = $15;
 $6 = $2;
 $7 = $3;
 $16 = $7;
 $8 = $16;
 $17 = $5;
 $18 = $17 & 1;
 if ($18) {
  $19 = $6;
  $20 = $8;
  $21 = $20 + $19 | 0;
  $8 = $21;
 }
 $22 = $4;
 $23 = $22 + 8 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $9 = $24;
 $10 = 0;
 $11 = 0;
 $12 = 1;
 $25 = $4;
 $26 = $25 + 4 | 0;
 $27 = HEAP32[$26 >> 2] | 0;
 $13 = $27;
 L4 : while (1) {
  $28 = $13;
  $29 = $28 >>> 0 > 0;
  if (!$29) {
   label = 14;
   break;
  }
  $30 = $10;
  $31 = $30 + 16 | 0;
  $10 = $31;
  $32 = $11;
  $33 = $32 << 16;
  $34 = $9;
  $35 = $34 + 2 | 0;
  $9 = $35;
  $36 = HEAP16[$34 >> 1] | 0;
  $37 = $36 & 65535;
  $38 = $33 | $37;
  $11 = $38;
  while (1) {
   $39 = $10;
   $40 = ($39 | 0) >= 8;
   if (!$40) {
    break;
   }
   $41 = $11;
   $42 = $41 & 65535;
   $14 = $42;
   $43 = $4;
   $44 = HEAP32[$43 >> 2] | 0;
   $45 = $44 & 1;
   $46 = ($45 | 0) != 0;
   if ($46) {
    $47 = $14;
    $48 = $47 & 65535;
    $49 = $48 ^ -1;
    $50 = $49 & 255;
    $51 = $12;
    $52 = $50 + $51 | 0;
    $53 = $52 & 65535;
    $14 = $53;
    $54 = $14;
    $55 = $54 & 65535;
    $56 = $55 >> 8;
    $12 = $56;
   }
   $57 = $5;
   $58 = $57 & 1;
   $59 = $14;
   $60 = $59 & 255;
   $61 = $8;
   if ($58) {
    $62 = $61 + -1 | 0;
    $8 = $62;
    HEAP8[$62 >> 0] = $60;
    $63 = $8;
    $64 = $7;
    $65 = ($63 | 0) == ($64 | 0);
    if ($65) {
     label = 14;
     break L4;
    }
   } else {
    $66 = $61 + 1 | 0;
    $8 = $66;
    HEAP8[$61 >> 0] = $60;
    $67 = $8;
    $68 = $7;
    $69 = $6;
    $70 = $68 + $69 | 0;
    $71 = ($67 | 0) == ($70 | 0);
    if ($71) {
     label = 14;
     break L4;
    }
   }
   $72 = $10;
   $73 = $72 - 8 | 0;
   $10 = $73;
   $74 = $11;
   $75 = $74 >>> 8;
   $11 = $75;
  }
  $76 = $13;
  $77 = $76 + -1 | 0;
  $13 = $77;
 }
 if ((label | 0) == 14) {
  STACKTOP = sp;
  return;
 }
}

function _log($0) {
 $0 = +$0;
 var $$0 = 0, $$071 = 0, $$072 = 0.0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0.0, $29 = 0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0.0, $58 = 0.0, $6 = 0, $7 = 0, $8 = 0, $9 = 0.0, $or$cond = 0, $or$cond76 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = $2 >>> 0 < 1048576;
 $4 = ($2 | 0) < 0;
 $or$cond = $4 | $3;
 do {
  if ($or$cond) {
   $5 = $2 & 2147483647;
   $6 = ($1 | 0) == 0;
   $7 = ($5 | 0) == 0;
   $8 = $6 & $7;
   if ($8) {
    $9 = $0 * $0;
    $10 = -1.0 / $9;
    $$072 = $10;
    return +$$072;
   }
   if (!$4) {
    $13 = $0 * 18014398509481984.0;
    HEAPF64[tempDoublePtr >> 3] = $13;
    $14 = HEAP32[tempDoublePtr >> 2] | 0;
    $15 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
    $$0 = -1077;
    $$071 = $15;
    $27 = 0;
    $29 = $14;
    break;
   }
   $11 = $0 - $0;
   $12 = $11 / 0.0;
   $$072 = $12;
   return +$$072;
  } else {
   $16 = $2 >>> 0 > 2146435071;
   if ($16) {
    $$072 = $0;
    return +$$072;
   }
   $17 = ($2 | 0) == 1072693248;
   $18 = ($1 | 0) == 0;
   $19 = 0 == 0;
   $20 = $18 & $19;
   $or$cond76 = $20 & $17;
   if ($or$cond76) {
    $$072 = 0.0;
    return +$$072;
   } else {
    $$0 = -1023;
    $$071 = $2;
    $27 = 0;
    $29 = $1;
   }
  }
 } while (0);
 $21 = $$071 + 614242 | 0;
 $22 = $21 >>> 20;
 $23 = $$0 + $22 | 0;
 $24 = $21 & 1048575;
 $25 = $24 + 1072079006 | 0;
 $26 = $25 | $27;
 HEAP32[tempDoublePtr >> 2] = $29;
 HEAP32[tempDoublePtr + 4 >> 2] = $26;
 $28 = +HEAPF64[tempDoublePtr >> 3];
 $30 = $28 + -1.0;
 $31 = $30 * .5;
 $32 = $30 * $31;
 $33 = $30 + 2.0;
 $34 = $30 / $33;
 $35 = $34 * $34;
 $36 = $35 * $35;
 $37 = $36 * .15313837699209373;
 $38 = $37 + .22222198432149784;
 $39 = $36 * $38;
 $40 = $39 + .3999999999940942;
 $41 = $36 * $40;
 $42 = $36 * .14798198605116586;
 $43 = $42 + .1818357216161805;
 $44 = $36 * $43;
 $45 = $44 + .2857142874366239;
 $46 = $36 * $45;
 $47 = $46 + .6666666666666735;
 $48 = $35 * $47;
 $49 = $41 + $48;
 $50 = +($23 | 0);
 $51 = $32 + $49;
 $52 = $34 * $51;
 $53 = $50 * 1.9082149292705877e-10;
 $54 = $53 + $52;
 $55 = $54 - $32;
 $56 = $30 + $55;
 $57 = $50 * .6931471803691238;
 $58 = $57 + $56;
 $$072 = $58;
 return +$$072;
}

function _instance_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $7 = sp + 24 | 0;
 $8 = sp + 4 | 0;
 $3 = $0;
 $4 = $1;
 $10 = $4;
 $5 = $10;
 $11 = $3;
 $12 = 32993 + $11 | 0;
 $13 = HEAP8[$12 >> 0] | 0;
 $14 = $13 & 255;
 $6 = $14;
 HEAP32[$7 >> 2] = 0 | 0;
 HEAP32[$7 + 4 >> 2] = 0 | 0;
 $15 = $5;
 HEAP32[$8 >> 2] = $15;
 $16 = $8 + 4 | 0;
 $17 = $6;
 HEAP32[$16 >> 2] = $17;
 $18 = $8 + 8 | 0;
 HEAP32[$18 >> 2] = 20;
 $19 = $8 + 12 | 0;
 HEAP32[$19 >> 2] = $7;
 $20 = $8 + 16 | 0;
 HEAP8[$20 >> 0] = 0;
 $21 = $5;
 $22 = HEAP32[$21 >> 2] | 0;
 _mp_obj_class_lookup($8, $22);
 $23 = HEAP32[$7 >> 2] | 0;
 $24 = ($23 | 0) == (4 | 0);
 if ($24) {
  $25 = $3;
  $26 = $5;
  $27 = $26 + 16 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = _mp_unary_op($25, $28) | 0;
  $2 = $29;
  $61 = $2;
  STACKTOP = sp;
  return $61 | 0;
 }
 $30 = HEAP32[$7 >> 2] | 0;
 $31 = ($30 | 0) != (0 | 0);
 if (!$31) {
  $49 = $3;
  $50 = ($49 | 0) == 6;
  if ($50) {
   $51 = $8 + 4 | 0;
   HEAP32[$51 >> 2] = 179;
   $52 = $5;
   $53 = HEAP32[$52 >> 2] | 0;
   _mp_obj_class_lookup($8, $53);
   $54 = HEAP32[$7 >> 2] | 0;
   $55 = ($54 | 0) == (0 | 0);
   if ($55) {
    $56 = $4;
    $57 = $56;
    $58 = $57 << 1;
    $59 = $58 | 1;
    $60 = $59;
    $2 = $60;
    $61 = $2;
    STACKTOP = sp;
    return $61 | 0;
   }
  }
  $2 = 0;
  $61 = $2;
  STACKTOP = sp;
  return $61 | 0;
 }
 $32 = HEAP32[$7 >> 2] | 0;
 $33 = $4;
 $34 = _mp_call_function_1($32, $33) | 0;
 $9 = $34;
 $35 = $3;
 switch ($35 | 0) {
 case 6:
  {
   $36 = $9;
   $37 = _mp_obj_get_int_truncated($36) | 0;
   $38 = $37 << 1;
   $39 = $38 | 1;
   $40 = $39;
   $9 = $40;
   break;
  }
 case 8:
  {
   $41 = $9;
   $42 = _mp_obj_is_small_int_1277($41) | 0;
   if (!$42) {
    $43 = $9;
    $44 = _mp_obj_is_obj_1260($43) | 0;
    if (!$44) {
     _mp_raise_TypeError(0);
    }
    $45 = $9;
    $46 = HEAP32[$45 >> 2] | 0;
    $47 = ($46 | 0) == (16904 | 0);
    if (!$47) {
     _mp_raise_TypeError(0);
    }
   }
   break;
  }
 default:
  {}
 }
 $48 = $9;
 $2 = $48;
 $61 = $2;
 STACKTOP = sp;
 return $61 | 0;
}

function _mp_obj_new_exception_msg_varg($0, $1, $varargs) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $varargs = $varargs | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $9 = sp + 32 | 0;
 $10 = sp + 24 | 0;
 $11 = sp;
 $12 = sp + 16 | 0;
 $3 = $0;
 $4 = $1;
 $13 = _m_malloc_maybe(16) | 0;
 $5 = $13;
 $14 = $4;
 $15 = _strlen($14) | 0;
 $16 = $15 + 1 | 0;
 $6 = $16;
 $17 = $6;
 $18 = $17;
 $19 = _m_malloc_maybe($18) | 0;
 $7 = $19;
 $8 = 0;
 $20 = $5;
 $21 = ($20 | 0) == (0 | 0);
 if ($21) {
  $22 = $3;
  $23 = _mp_obj_exception_make_new($22, 0, 0, 0) | 0;
  $2 = $23;
  $70 = $2;
  STACKTOP = sp;
  return $70 | 0;
 }
 $24 = $7;
 $25 = ($24 | 0) == (0 | 0);
 if ($25) {
  $26 = $6;
  $27 = $26 - 1 | 0;
  $28 = $5;
  $29 = $28 + 8 | 0;
  HEAP32[$29 >> 2] = $27;
  $30 = $4;
  $31 = $5;
  $32 = $31 + 12 | 0;
  HEAP32[$32 >> 2] = $30;
 } else {
  $33 = $8;
  $34 = $33 & 1;
  $35 = $34 ^ 1;
  $36 = $35 & 1;
  HEAP8[$9 >> 0] = $36;
  $37 = $9 + 4 | 0;
  $38 = $6;
  HEAP32[$37 >> 2] = $38;
  $39 = $9 + 8 | 0;
  HEAP32[$39 >> 2] = 0;
  $40 = $9 + 12 | 0;
  $41 = $7;
  HEAP32[$40 >> 2] = $41;
  HEAP32[$10 >> 2] = $9;
  $42 = $10 + 4 | 0;
  HEAP32[$42 >> 2] = 513;
  HEAP32[$11 >> 2] = $varargs;
  $43 = $4;
  _mp_vprintf($10, $43, $11) | 0;
  $44 = $9 + 12 | 0;
  $45 = HEAP32[$44 >> 2] | 0;
  $46 = $9 + 8 | 0;
  $47 = HEAP32[$46 >> 2] | 0;
  $48 = $45 + $47 | 0;
  HEAP8[$48 >> 0] = 0;
  $49 = $9 + 8 | 0;
  $50 = HEAP32[$49 >> 2] | 0;
  $51 = $5;
  $52 = $51 + 8 | 0;
  HEAP32[$52 >> 2] = $50;
  $53 = $9 + 12 | 0;
  $54 = HEAP32[$53 >> 2] | 0;
  $55 = $5;
  $56 = $55 + 12 | 0;
  HEAP32[$56 >> 2] = $54;
 }
 $57 = $5;
 HEAP32[$57 >> 2] = 18680;
 $58 = $5;
 $59 = $58 + 12 | 0;
 $60 = HEAP32[$59 >> 2] | 0;
 $61 = $5;
 $62 = $61 + 8 | 0;
 $63 = HEAP32[$62 >> 2] | 0;
 $64 = _qstr_compute_hash($60, $63) | 0;
 $65 = $5;
 $66 = $65 + 4 | 0;
 HEAP32[$66 >> 2] = $64;
 $67 = $5;
 HEAP32[$12 >> 2] = $67;
 $68 = $3;
 $69 = _mp_obj_exception_make_new($68, 1, 0, $12) | 0;
 $2 = $69;
 $70 = $2;
 STACKTOP = sp;
 return $70 | 0;
}

function _poll_map_poll($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $7 = sp + 4 | 0;
 $2 = $0;
 $3 = $1;
 $4 = 0;
 $5 = 0;
 while (1) {
  $9 = $5;
  $10 = $2;
  $11 = $10 + 4 | 0;
  $12 = HEAP32[$11 >> 2] | 0;
  $13 = $9 >>> 0 < $12 >>> 0;
  if (!$13) {
   label = 15;
   break;
  }
  $14 = $2;
  $15 = $5;
  $16 = _mp_map_slot_is_filled_1536($14, $15) | 0;
  if ($16) {
   $17 = $2;
   $18 = $17 + 8 | 0;
   $19 = HEAP32[$18 >> 2] | 0;
   $20 = $5;
   $21 = $19 + ($20 << 3) | 0;
   $22 = $21 + 4 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   $6 = $23;
   $24 = $6;
   $25 = $24 + 4 | 0;
   $26 = HEAP32[$25 >> 2] | 0;
   $27 = $6;
   $28 = HEAP32[$27 >> 2] | 0;
   $29 = $6;
   $30 = $29 + 8 | 0;
   $31 = HEAP32[$30 >> 2] | 0;
   $32 = FUNCTION_TABLE_iiiii[$26 & 1023]($28, 3, $31, $7) | 0;
   $8 = $32;
   $33 = $8;
   $34 = $6;
   $35 = $34 + 12 | 0;
   HEAP32[$35 >> 2] = $33;
   $36 = $8;
   $37 = ($36 | 0) == -1;
   if ($37) {
    label = 5;
    break;
   }
   $39 = $8;
   $40 = ($39 | 0) != 0;
   if ($40) {
    $41 = $4;
    $42 = $41 + 1 | 0;
    $4 = $42;
    $43 = $3;
    $44 = ($43 | 0) != (0 | 0);
    if ($44) {
     $45 = $8;
     $46 = $45 & 1;
     $47 = ($46 | 0) != 0;
     if ($47) {
      $48 = $3;
      $49 = HEAP32[$48 >> 2] | 0;
      $50 = $49 + 1 | 0;
      HEAP32[$48 >> 2] = $50;
     }
     $51 = $8;
     $52 = $51 & 4;
     $53 = ($52 | 0) != 0;
     if ($53) {
      $54 = $3;
      $55 = $54 + 4 | 0;
      $56 = HEAP32[$55 >> 2] | 0;
      $57 = $56 + 1 | 0;
      HEAP32[$55 >> 2] = $57;
     }
     $58 = $8;
     $59 = $58 & -6;
     $60 = ($59 | 0) != 0;
     if ($60) {
      $61 = $3;
      $62 = $61 + 8 | 0;
      $63 = HEAP32[$62 >> 2] | 0;
      $64 = $63 + 1 | 0;
      HEAP32[$62 >> 2] = $64;
     }
    }
   }
  }
  $65 = $5;
  $66 = $65 + 1 | 0;
  $5 = $66;
 }
 if ((label | 0) == 5) {
  $38 = HEAP32[$7 >> 2] | 0;
  _mp_raise_OSError($38);
 } else if ((label | 0) == 15) {
  $67 = $4;
  STACKTOP = sp;
  return $67 | 0;
 }
 return 0 | 0;
}

function _str_uni_istype($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $10 = $4;
 $11 = _mp_obj_is_qstr_1128($10) | 0;
 $12 = $4;
 if ($11) {
  $13 = $12;
  $14 = $13 >>> 2;
  $15 = _qstr_data($14, $6) | 0;
  $5 = $15;
 } else {
  $16 = $12 + 8 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  HEAP32[$6 >> 2] = $17;
  $18 = $4;
  $19 = $18 + 12 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $5 = $20;
 }
 $21 = HEAP32[$6 >> 2] | 0;
 $22 = ($21 | 0) == 0;
 if ($22) {
  $2 = 13856;
  $56 = $2;
  STACKTOP = sp;
  return $56 | 0;
 }
 $23 = $3;
 $24 = ($23 | 0) != (522 | 0);
 $25 = $3;
 $26 = ($25 | 0) != (521 | 0);
 $or$cond = $24 & $26;
 L9 : do {
  if ($or$cond) {
   $7 = 0;
   while (1) {
    $27 = $7;
    $28 = HEAP32[$6 >> 2] | 0;
    $29 = $27 >>> 0 < $28 >>> 0;
    if (!$29) {
     break L9;
    }
    $30 = $3;
    $31 = $5;
    $32 = $31 + 1 | 0;
    $5 = $32;
    $33 = HEAP8[$31 >> 0] | 0;
    $34 = $33 & 255;
    $35 = FUNCTION_TABLE_ii[$30 & 1023]($34) | 0;
    if (!$35) {
     break;
    }
    $36 = $7;
    $37 = $36 + 1 | 0;
    $7 = $37;
   }
   $2 = 13856;
   $56 = $2;
   STACKTOP = sp;
   return $56 | 0;
  } else {
   $8 = 0;
   $9 = 0;
   while (1) {
    $38 = $9;
    $39 = HEAP32[$6 >> 2] | 0;
    $40 = $38 >>> 0 < $39 >>> 0;
    if (!$40) {
     break;
    }
    $41 = $5;
    $42 = $41 + 1 | 0;
    $5 = $42;
    $43 = HEAP8[$41 >> 0] | 0;
    $44 = $43 & 255;
    $45 = _unichar_isalpha($44) | 0;
    if ($45) {
     $8 = 1;
     $46 = $3;
     $47 = $5;
     $48 = $47 + -1 | 0;
     $49 = HEAP8[$48 >> 0] | 0;
     $50 = $49 & 255;
     $51 = FUNCTION_TABLE_ii[$46 & 1023]($50) | 0;
     if (!$51) {
      label = 16;
      break;
     }
    }
    $52 = $9;
    $53 = $52 + 1 | 0;
    $9 = $53;
   }
   if ((label | 0) == 16) {
    $2 = 13856;
    $56 = $2;
    STACKTOP = sp;
    return $56 | 0;
   }
   $54 = $8;
   $55 = $54 & 1;
   if (!$55) {
    $2 = 13856;
    $56 = $2;
    STACKTOP = sp;
    return $56 | 0;
   }
  }
 } while (0);
 $2 = 13864;
 $56 = $2;
 STACKTOP = sp;
 return $56 | 0;
}

function _mpz_set_from_bytes($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $11 = $1 & 1;
 $5 = $11;
 $6 = $2;
 $7 = $3;
 $8 = 1;
 $12 = $5;
 $13 = $12 & 1;
 if ($13) {
  $14 = $6;
  $15 = $14 - 1 | 0;
  $16 = $7;
  $17 = $16 + $15 | 0;
  $7 = $17;
  $8 = -1;
 }
 $18 = $4;
 $19 = $6;
 $20 = $19 << 3;
 $21 = $20 + 16 | 0;
 $22 = $21 - 1 | 0;
 $23 = ($22 >>> 0) / 16 & -1;
 _mpz_need_dig($18, $23);
 $9 = 0;
 $10 = 0;
 $24 = $4;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = $25 & -2;
 HEAP32[$24 >> 2] = $26;
 $27 = $4;
 $28 = $27 + 4 | 0;
 HEAP32[$28 >> 2] = 0;
 while (1) {
  $29 = $6;
  $30 = ($29 | 0) != 0;
  if (!$30) {
   break;
  }
  while (1) {
   $31 = $6;
   $32 = ($31 | 0) != 0;
   $33 = $10;
   $34 = ($33 | 0) < 16;
   $35 = $32 ? $34 : 0;
   if (!$35) {
    break;
   }
   $36 = $7;
   $37 = HEAP8[$36 >> 0] | 0;
   $38 = $37 & 255;
   $39 = $10;
   $40 = $38 << $39;
   $41 = $9;
   $42 = $41 & 65535;
   $43 = $42 | $40;
   $44 = $43 & 65535;
   $9 = $44;
   $45 = $10;
   $46 = $45 + 8 | 0;
   $10 = $46;
   $47 = $8;
   $48 = $7;
   $49 = $48 + $47 | 0;
   $7 = $49;
   $50 = $6;
   $51 = $50 + -1 | 0;
   $6 = $51;
  }
  $52 = $9;
  $53 = $52 & 65535;
  $54 = $53 & 65535;
  $55 = $54 & 65535;
  $56 = $4;
  $57 = $56 + 8 | 0;
  $58 = HEAP32[$57 >> 2] | 0;
  $59 = $4;
  $60 = $59 + 4 | 0;
  $61 = HEAP32[$60 >> 2] | 0;
  $62 = $61 + 1 | 0;
  HEAP32[$60 >> 2] = $62;
  $63 = $58 + ($61 << 1) | 0;
  HEAP16[$63 >> 1] = $55;
  $9 = 0;
  $64 = $10;
  $65 = $64 - 16 | 0;
  $10 = $65;
 }
 $66 = $4;
 $67 = $66 + 8 | 0;
 $68 = HEAP32[$67 >> 2] | 0;
 $69 = $4;
 $70 = $69 + 8 | 0;
 $71 = HEAP32[$70 >> 2] | 0;
 $72 = $4;
 $73 = $72 + 4 | 0;
 $74 = HEAP32[$73 >> 2] | 0;
 $75 = $71 + ($74 << 1) | 0;
 $76 = _mpn_remove_trailing_zeros($68, $75) | 0;
 $77 = $4;
 $78 = $77 + 4 | 0;
 HEAP32[$78 >> 2] = $76;
 STACKTOP = sp;
 return;
}

function _tgamma($0) {
 $0 = +$0;
 var $$ = 0.0, $$0 = 0.0, $$055 = 0.0, $$056 = 0.0, $$057 = 0.0, $$1 = 0.0, $1 = 0, $10 = 0.0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0.0, $18 = 0, $19 = 0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $29 = 0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $50 = 0.0, $51 = 0.0, $52 = 0.0, $53 = 0.0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = $2 & 2147483647;
 $4 = _bitshift64Lshr($1 | 0, $2 | 0, 63) | 0;
 $5 = getTempRet0() | 0;
 $6 = $3 >>> 0 > 2146435071;
 do {
  if ($6) {
   $7 = $0 + inf;
   $$0 = $7;
  } else {
   $8 = $3 >>> 0 < 1016070144;
   if ($8) {
    $9 = 1.0 / $0;
    $$0 = $9;
    break;
   }
   $10 = +Math_floor(+$0);
   $11 = $10 == $0;
   if ($11) {
    $12 = ($4 | 0) == 0;
    if (!$12) {
     $$0 = nan;
     break;
    }
    $13 = !($0 <= 23.0);
    if (!$13) {
     $14 = ~~$0;
     $15 = $14 + -1 | 0;
     $16 = 9584 + ($15 << 3) | 0;
     $17 = +HEAPF64[$16 >> 3];
     $$0 = $17;
     break;
    }
   }
   $18 = $3 >>> 0 > 1080492031;
   $19 = ($4 | 0) != 0;
   if ($18) {
    if ($19) {
     $20 = +Math_floor(+$0);
     $21 = $20 * .5;
     $22 = $0 * .5;
     $23 = +Math_floor(+$22);
     $24 = $21 == $23;
     $$ = $24 ? 0.0 : -0.0;
     $$0 = $$;
     break;
    } else {
     $25 = $0 * 8988465674311579538646525.0e283;
     $$0 = $25;
     break;
    }
   } else {
    $26 = -$0;
    $27 = $19 ? $26 : $0;
    $28 = $27 + 5.52468004077673;
    $29 = $27 > 5.52468004077673;
    $30 = $28 - $27;
    $31 = $30 + -5.52468004077673;
    $32 = $28 + -5.52468004077673;
    $33 = $32 - $27;
    $$057 = $29 ? $31 : $33;
    $34 = $27 + -.5;
    $35 = +_S($27);
    $36 = -$28;
    $37 = +_exp($36);
    $38 = $35 * $37;
    $39 = $0 < 0.0;
    if ($39) {
     $40 = -$34;
     $41 = -$$057;
     $42 = +_sinpi($27);
     $43 = $27 * $42;
     $44 = $38 * $43;
     $45 = -3.141592653589793 / $44;
     $$055 = $45;
     $$056 = $40;
     $$1 = $41;
    } else {
     $$055 = $38;
     $$056 = $34;
     $$1 = $$057;
    }
    $46 = $$1 * 6.02468004077673;
    $47 = $46 * $$055;
    $48 = $47 / $28;
    $49 = $$055 + $48;
    $50 = $$056 * .5;
    $51 = +_pow($28, $50);
    $52 = $51 * $49;
    $53 = $51 * $52;
    $$0 = $53;
    break;
   }
  }
 } while (0);
 return +$$0;
}

function _mp_builtin_dir($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $10 = sp;
 $3 = $0;
 $4 = $1;
 $11 = _mp_obj_new_list(0, 0) | 0;
 $5 = $11;
 $12 = $3;
 $13 = ($12 | 0) == 0;
 L1 : do {
  if ($13) {
   $14 = _mp_locals_get_1382() | 0;
   $6 = $14;
   $7 = 0;
   while (1) {
    $15 = $7;
    $16 = $6;
    $17 = $16 + 4 | 0;
    $18 = $17 + 4 | 0;
    $19 = HEAP32[$18 >> 2] | 0;
    $20 = $15 >>> 0 < $19 >>> 0;
    if (!$20) {
     break L1;
    }
    $21 = $6;
    $22 = $21 + 4 | 0;
    $23 = $7;
    $24 = _mp_map_slot_is_filled_1385($22, $23) | 0;
    if ($24) {
     $25 = $5;
     $26 = $6;
     $27 = $26 + 4 | 0;
     $28 = $27 + 8 | 0;
     $29 = HEAP32[$28 >> 2] | 0;
     $30 = $7;
     $31 = $29 + ($30 << 3) | 0;
     $32 = HEAP32[$31 >> 2] | 0;
     _mp_obj_list_append($25, $32) | 0;
    }
    $33 = $7;
    $34 = $33 + 1 | 0;
    $7 = $34;
   }
  } else {
   $35 = HEAP32[40572 >> 2] | 0;
   $36 = $35 + 4 | 0;
   $37 = HEAP32[$36 >> 2] | 0;
   $38 = HEAP32[40572 >> 2] | 0;
   $39 = $38 + 12 | 0;
   $40 = HEAP32[$39 >> 2] | 0;
   $41 = $37 + $40 | 0;
   $8 = $41;
   $9 = 2;
   while (1) {
    $42 = $9;
    $43 = $8;
    $44 = $42 >>> 0 < $43 >>> 0;
    if (!$44) {
     break L1;
    }
    $45 = $4;
    $46 = HEAP32[$45 >> 2] | 0;
    $47 = $9;
    _mp_load_method_protected($46, $47, $10, 0);
    $48 = HEAP32[$10 >> 2] | 0;
    $49 = ($48 | 0) != (0 | 0);
    if ($49) {
     $50 = $9;
     $51 = ($50 | 0) == 2;
     if ($51) {
      $52 = $10 + 4 | 0;
      $53 = HEAP32[$52 >> 2] | 0;
      $54 = ($53 | 0) != (0 | 0);
      if ($54) {
       break;
      }
     }
     $56 = $5;
     $57 = $9;
     $58 = $57 << 2;
     $59 = $58 | 2;
     $60 = $59;
     _mp_obj_list_append($56, $60) | 0;
    }
    $61 = $9;
    $62 = $61 + 1 | 0;
    $9 = $62;
   }
   $55 = _mp_call_method_n_kw(0, 0, $10) | 0;
   $2 = $55;
   $64 = $2;
   STACKTOP = sp;
   return $64 | 0;
  }
 } while (0);
 $63 = $5;
 $2 = $63;
 $64 = $2;
 STACKTOP = sp;
 return $64 | 0;
}

function _wcrtomb($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$0 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $3 = ($0 | 0) == (0 | 0);
 do {
  if ($3) {
   $$0 = 1;
  } else {
   $4 = $1 >>> 0 < 128;
   if ($4) {
    $5 = $1 & 255;
    HEAP8[$0 >> 0] = $5;
    $$0 = 1;
    break;
   }
   $6 = ___pthread_self_853() | 0;
   $7 = $6 + 188 | 0;
   $8 = HEAP32[$7 >> 2] | 0;
   $9 = HEAP32[$8 >> 2] | 0;
   $10 = ($9 | 0) == (0 | 0);
   if ($10) {
    $11 = $1 & -128;
    $12 = ($11 | 0) == 57216;
    if ($12) {
     $14 = $1 & 255;
     HEAP8[$0 >> 0] = $14;
     $$0 = 1;
     break;
    } else {
     $13 = ___errno_location() | 0;
     HEAP32[$13 >> 2] = 84;
     $$0 = -1;
     break;
    }
   }
   $15 = $1 >>> 0 < 2048;
   if ($15) {
    $16 = $1 >>> 6;
    $17 = $16 | 192;
    $18 = $17 & 255;
    $19 = $0 + 1 | 0;
    HEAP8[$0 >> 0] = $18;
    $20 = $1 & 63;
    $21 = $20 | 128;
    $22 = $21 & 255;
    HEAP8[$19 >> 0] = $22;
    $$0 = 2;
    break;
   }
   $23 = $1 >>> 0 < 55296;
   $24 = $1 & -8192;
   $25 = ($24 | 0) == 57344;
   $or$cond = $23 | $25;
   if ($or$cond) {
    $26 = $1 >>> 12;
    $27 = $26 | 224;
    $28 = $27 & 255;
    $29 = $0 + 1 | 0;
    HEAP8[$0 >> 0] = $28;
    $30 = $1 >>> 6;
    $31 = $30 & 63;
    $32 = $31 | 128;
    $33 = $32 & 255;
    $34 = $0 + 2 | 0;
    HEAP8[$29 >> 0] = $33;
    $35 = $1 & 63;
    $36 = $35 | 128;
    $37 = $36 & 255;
    HEAP8[$34 >> 0] = $37;
    $$0 = 3;
    break;
   }
   $38 = $1 + -65536 | 0;
   $39 = $38 >>> 0 < 1048576;
   if ($39) {
    $40 = $1 >>> 18;
    $41 = $40 | 240;
    $42 = $41 & 255;
    $43 = $0 + 1 | 0;
    HEAP8[$0 >> 0] = $42;
    $44 = $1 >>> 12;
    $45 = $44 & 63;
    $46 = $45 | 128;
    $47 = $46 & 255;
    $48 = $0 + 2 | 0;
    HEAP8[$43 >> 0] = $47;
    $49 = $1 >>> 6;
    $50 = $49 & 63;
    $51 = $50 | 128;
    $52 = $51 & 255;
    $53 = $0 + 3 | 0;
    HEAP8[$48 >> 0] = $52;
    $54 = $1 & 63;
    $55 = $54 | 128;
    $56 = $55 & 255;
    HEAP8[$53 >> 0] = $56;
    $$0 = 4;
    break;
   } else {
    $57 = ___errno_location() | 0;
    HEAP32[$57 >> 2] = 84;
    $$0 = -1;
    break;
   }
  }
 } while (0);
 return $$0 | 0;
}

function _mpn_or_neg($0, $1, $2, $3, $4, $5, $6, $7) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 $7 = $7 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $80 = 0, $81 = 0, $82 = 0, $83 = 0, $84 = 0, $85 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $8 = $0;
 $9 = $1;
 $10 = $2;
 $11 = $3;
 $12 = $4;
 $13 = $5;
 $14 = $6;
 $15 = $7;
 $20 = $8;
 $16 = $20;
 $21 = $13;
 $22 = 0 == ($21 | 0);
 $23 = $22 ? 0 : 65535;
 $24 = $23 & 65535;
 $17 = $24;
 $25 = $14;
 $26 = 0 == ($25 | 0);
 $27 = $26 ? 0 : 65535;
 $28 = $27 & 65535;
 $18 = $28;
 $29 = $15;
 $30 = 0 == ($29 | 0);
 $31 = $30 ? 0 : 65535;
 $32 = $31 & 65535;
 $19 = $32;
 while (1) {
  $33 = $10;
  $34 = $33 >>> 0 > 0;
  if (!$34) {
   break;
  }
  $35 = $9;
  $36 = HEAP16[$35 >> 1] | 0;
  $37 = $36 & 65535;
  $38 = $18;
  $39 = $38 & 65535;
  $40 = $37 ^ $39;
  $41 = $14;
  $42 = $41 + $40 | 0;
  $14 = $42;
  $43 = $12;
  $44 = $43 + -1 | 0;
  $12 = $44;
  $45 = $10;
  $46 = $45 + -1 | 0;
  $10 = $46;
  $47 = $44 >>> 0 <= $46 >>> 0;
  if ($47) {
   $48 = $11;
   $49 = $48 + 2 | 0;
   $11 = $49;
   $50 = HEAP16[$48 >> 1] | 0;
   $51 = $50 & 65535;
   $52 = $19;
   $53 = $52 & 65535;
   $54 = $51 ^ $53;
   $59 = $54;
  } else {
   $55 = $19;
   $56 = $55 & 65535;
   $59 = $56;
  }
  $57 = $15;
  $58 = $57 + $59 | 0;
  $15 = $58;
  $60 = $14;
  $61 = $15;
  $62 = $60 | $61;
  $63 = $17;
  $64 = $63 & 65535;
  $65 = $62 ^ $64;
  $66 = $65 & 65535;
  $67 = $13;
  $68 = $67 + $66 | 0;
  $13 = $68;
  $69 = $13;
  $70 = $69 & 65535;
  $71 = $70 & 65535;
  $72 = $8;
  HEAP16[$72 >> 1] = $71;
  $73 = $15;
  $74 = $73 >>> 16;
  $15 = $74;
  $75 = $14;
  $76 = $75 >>> 16;
  $14 = $76;
  $77 = $13;
  $78 = $77 >>> 16;
  $13 = $78;
  $79 = $8;
  $80 = $79 + 2 | 0;
  $8 = $80;
  $81 = $9;
  $82 = $81 + 2 | 0;
  $9 = $82;
 }
 $83 = $16;
 $84 = $8;
 $85 = _mpn_remove_trailing_zeros($83, $84) | 0;
 STACKTOP = sp;
 return $85 | 0;
}

function ___vfprintf_internal($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $$0 = 0, $$1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $spec$select = 0, $spec$select45 = 0, $vacopy_currentptr = 0, dest = 0, label = 0, sp = 0, stop = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 224 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(224 | 0);
 $5 = sp + 208 | 0;
 $6 = sp + 160 | 0;
 $7 = sp + 80 | 0;
 $8 = sp;
 dest = $6;
 stop = dest + 40 | 0;
 do {
  HEAP32[dest >> 2] = 0 | 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 $vacopy_currentptr = HEAP32[$2 >> 2] | 0;
 HEAP32[$5 >> 2] = $vacopy_currentptr;
 $9 = _printf_core(0, $1, $5, $7, $6, $3, $4) | 0;
 $10 = ($9 | 0) < 0;
 if ($10) {
  $$0 = -1;
 } else {
  $11 = $0 + 76 | 0;
  $12 = HEAP32[$11 >> 2] | 0;
  $13 = ($12 | 0) > -1;
  if ($13) {
   $14 = ___lockfile($0) | 0;
   $41 = $14;
  } else {
   $41 = 0;
  }
  $15 = HEAP32[$0 >> 2] | 0;
  $16 = $15 & 32;
  $17 = $0 + 74 | 0;
  $18 = HEAP8[$17 >> 0] | 0;
  $19 = $18 << 24 >> 24 < 1;
  if ($19) {
   $20 = $15 & -33;
   HEAP32[$0 >> 2] = $20;
  }
  $21 = $0 + 48 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = ($22 | 0) == 0;
  if ($23) {
   $25 = $0 + 44 | 0;
   $26 = HEAP32[$25 >> 2] | 0;
   HEAP32[$25 >> 2] = $8;
   $27 = $0 + 28 | 0;
   HEAP32[$27 >> 2] = $8;
   $28 = $0 + 20 | 0;
   HEAP32[$28 >> 2] = $8;
   HEAP32[$21 >> 2] = 80;
   $29 = $8 + 80 | 0;
   $30 = $0 + 16 | 0;
   HEAP32[$30 >> 2] = $29;
   $31 = _printf_core($0, $1, $5, $7, $6, $3, $4) | 0;
   $32 = ($26 | 0) == (0 | 0);
   if ($32) {
    $$1 = $31;
   } else {
    $33 = $0 + 36 | 0;
    $34 = HEAP32[$33 >> 2] | 0;
    FUNCTION_TABLE_iiii[$34 & 1023]($0, 0, 0) | 0;
    $35 = HEAP32[$28 >> 2] | 0;
    $36 = ($35 | 0) == (0 | 0);
    $spec$select = $36 ? -1 : $31;
    HEAP32[$25 >> 2] = $26;
    HEAP32[$21 >> 2] = 0;
    HEAP32[$30 >> 2] = 0;
    HEAP32[$27 >> 2] = 0;
    HEAP32[$28 >> 2] = 0;
    $$1 = $spec$select;
   }
  } else {
   $24 = _printf_core($0, $1, $5, $7, $6, $3, $4) | 0;
   $$1 = $24;
  }
  $37 = HEAP32[$0 >> 2] | 0;
  $38 = $37 & 32;
  $39 = ($38 | 0) == 0;
  $spec$select45 = $39 ? $$1 : -1;
  $40 = $37 | $16;
  HEAP32[$0 >> 2] = $40;
  $42 = ($41 | 0) == 0;
  if (!$42) {
   ___unlockfile($0);
  }
  $$0 = $spec$select45;
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _uctypes_struct_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_ptr1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $11 = $4;
 $6 = $11;
 $7 = 34597;
 $12 = $6;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = _mp_obj_is_obj_1471($14) | 0;
 if ($15) {
  $16 = $6;
  $17 = $16 + 4 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = ($19 | 0) == (14112 | 0);
  if ($20) {
   label = 5;
  } else {
   label = 3;
  }
 } else {
  label = 3;
 }
 L3 : do {
  if ((label | 0) == 3) {
   $21 = $6;
   $22 = $21 + 4 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   $24 = _mp_obj_is_obj_1471($23) | 0;
   if ($24) {
    $25 = $6;
    $26 = $25 + 4 | 0;
    $27 = HEAP32[$26 >> 2] | 0;
    $28 = HEAP32[$27 >> 2] | 0;
    $29 = ($28 | 0) == (14436 | 0);
    if ($29) {
     label = 5;
     break;
    }
   }
   $30 = $6;
   $31 = $30 + 4 | 0;
   $32 = HEAP32[$31 >> 2] | 0;
   $33 = _mp_obj_is_obj_1471($32) | 0;
   if ($33) {
    $34 = $6;
    $35 = $34 + 4 | 0;
    $36 = HEAP32[$35 >> 2] | 0;
    $37 = HEAP32[$36 >> 2] | 0;
    $38 = ($37 | 0) == (18952 | 0);
    if ($38) {
     $39 = $6;
     $40 = $39 + 4 | 0;
     $41 = HEAP32[$40 >> 2] | 0;
     $8 = $41;
     $42 = $8;
     $43 = $42 + 8 | 0;
     $44 = HEAP32[$43 >> 2] | 0;
     $45 = $44;
     $46 = $45 >> 1;
     $9 = $46;
     $47 = $9;
     $48 = $47 >> 29;
     $49 = $48 & 3;
     $10 = $49;
     $50 = $10;
     switch ($50 | 0) {
     case 1:
      {
       $7 = 34608;
       break L3;
       break;
      }
     case 2:
      {
       $7 = 34612;
       break L3;
       break;
      }
     default:
      {
       break L3;
      }
     }
    }
   }
   $7 = 34618;
  }
 } while (0);
 if ((label | 0) == 5) {
  $7 = 34601;
 }
 $51 = $3;
 $52 = $7;
 $53 = $6;
 $54 = $53 + 8 | 0;
 $55 = HEAP32[$54 >> 2] | 0;
 HEAP32[$vararg_buffer >> 2] = $52;
 $vararg_ptr1 = $vararg_buffer + 4 | 0;
 HEAP32[$vararg_ptr1 >> 2] = $55;
 _mp_printf($51, 34624, $vararg_buffer) | 0;
 STACKTOP = sp;
 return;
}

function _mod_binascii_a2b_base64($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $2 = sp + 44 | 0;
 $4 = sp + 24 | 0;
 $1 = $0;
 $11 = $1;
 _mp_get_buffer_raise($11, $2, 1);
 $12 = HEAP32[$2 >> 2] | 0;
 $3 = $12;
 $13 = $2 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = ($14 >>> 0) / 4 & -1;
 $16 = $15 * 3 | 0;
 $17 = $16 + 1 | 0;
 _vstr_init($4, $17);
 $18 = $4 + 8 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $5 = $19;
 $6 = 0;
 $7 = 0;
 $8 = 0;
 $9 = 0;
 while (1) {
  $20 = $9;
  $21 = $2 + 4 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $20 >>> 0 < $22 >>> 0;
  if (!$23) {
   break;
  }
  $24 = $3;
  $25 = $9;
  $26 = $24 + $25 | 0;
  $27 = HEAP8[$26 >> 0] | 0;
  $28 = $27 & 255;
  $29 = ($28 | 0) == 61;
  if ($29) {
   $30 = $7;
   $31 = ($30 | 0) == 2;
   if ($31) {
    label = 7;
    break;
   }
   $32 = $7;
   $33 = ($32 | 0) == 4;
   if ($33) {
    $34 = $8;
    $35 = $34 & 1;
    if ($35) {
     label = 7;
     break;
    }
   }
   $8 = 1;
  }
  $36 = $3;
  $37 = $9;
  $38 = $36 + $37 | 0;
  $39 = HEAP8[$38 >> 0] | 0;
  $40 = _mod_binascii_sextet($39) | 0;
  $10 = $40;
  $41 = $10;
  $42 = ($41 | 0) == -1;
  if (!$42) {
   $8 = 0;
   $43 = $6;
   $44 = $43 << 6;
   $45 = $10;
   $46 = $44 | $45;
   $6 = $46;
   $47 = $7;
   $48 = $47 + 6 | 0;
   $7 = $48;
   $49 = $7;
   $50 = ($49 | 0) >= 8;
   if ($50) {
    $51 = $7;
    $52 = $51 - 8 | 0;
    $7 = $52;
    $53 = $6;
    $54 = $7;
    $55 = $53 >>> $54;
    $56 = $55 & 255;
    $57 = $56 & 255;
    $58 = $5;
    $59 = $4 + 4 | 0;
    $60 = HEAP32[$59 >> 2] | 0;
    $61 = $60 + 1 | 0;
    HEAP32[$59 >> 2] = $61;
    $62 = $58 + $60 | 0;
    HEAP8[$62 >> 0] = $57;
   }
  }
  $63 = $9;
  $64 = $63 + 1 | 0;
  $9 = $64;
 }
 if ((label | 0) == 7) {
  $7 = 0;
 }
 $65 = $7;
 $66 = ($65 | 0) != 0;
 if ($66) {
  _mp_raise_ValueError(34987);
 } else {
  $67 = _mp_obj_new_str_from_vstr(18304, $4) | 0;
  STACKTOP = sp;
  return $67 | 0;
 }
 return 0 | 0;
}

function _stringio_ioctl($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $13 = $5;
 $9 = $13;
 $14 = $6;
 switch ($14 | 0) {
 case 2:
  {
   $15 = $7;
   $16 = $15;
   $10 = $16;
   $11 = 0;
   $17 = $10;
   $18 = $17 + 4 | 0;
   $19 = HEAP32[$18 >> 2] | 0;
   switch ($19 | 0) {
   case 1:
    {
     $20 = $9;
     $21 = $20 + 8 | 0;
     $22 = HEAP32[$21 >> 2] | 0;
     $11 = $22;
     break;
    }
   case 2:
    {
     $23 = $9;
     $24 = $23 + 4 | 0;
     $25 = HEAP32[$24 >> 2] | 0;
     $26 = $25 + 4 | 0;
     $27 = HEAP32[$26 >> 2] | 0;
     $11 = $27;
     break;
    }
   default:
    {}
   }
   $28 = $11;
   $29 = $10;
   $30 = HEAP32[$29 >> 2] | 0;
   $31 = $28 + $30 | 0;
   $12 = $31;
   $32 = $10;
   $33 = $32 + 4 | 0;
   $34 = HEAP32[$33 >> 2] | 0;
   $35 = ($34 | 0) != 0;
   if ($35) {
    $36 = $10;
    $37 = HEAP32[$36 >> 2] | 0;
    $38 = ($37 | 0) < 0;
    if ($38) {
     $39 = $12;
     $40 = $11;
     $41 = $39 >>> 0 > $40 >>> 0;
     if ($41) {
      $12 = 0;
     }
    } else {
     label = 9;
    }
   } else {
    label = 9;
   }
   if ((label | 0) == 9) {
    $42 = $12;
    $43 = $11;
    $44 = $42 >>> 0 < $43 >>> 0;
    if ($44) {
     $45 = $8;
     HEAP32[$45 >> 2] = 22;
     $4 = -1;
     $56 = $4;
     STACKTOP = sp;
     return $56 | 0;
    }
   }
   $46 = $12;
   $47 = $9;
   $48 = $47 + 8 | 0;
   HEAP32[$48 >> 2] = $46;
   $49 = $10;
   HEAP32[$49 >> 2] = $46;
   $4 = 0;
   $56 = $4;
   STACKTOP = sp;
   return $56 | 0;
   break;
  }
 case 1:
  {
   $4 = 0;
   $56 = $4;
   STACKTOP = sp;
   return $56 | 0;
   break;
  }
 case 4:
  {
   $50 = $9;
   $51 = $50 + 4 | 0;
   $52 = HEAP32[$51 >> 2] | 0;
   _vstr_free($52);
   $53 = $9;
   $54 = $53 + 4 | 0;
   HEAP32[$54 >> 2] = 0;
   $4 = 0;
   $56 = $4;
   STACKTOP = sp;
   return $56 | 0;
   break;
  }
 default:
  {
   $55 = $8;
   HEAP32[$55 >> 2] = 22;
   $4 = -1;
   $56 = $4;
   STACKTOP = sp;
   return $56 | 0;
  }
 }
 return 0 | 0;
}

function _qstr_find_strn($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $9 = $3;
 $10 = $4;
 $11 = _qstr_compute_hash($9, $10) | 0;
 $5 = $11;
 $12 = HEAP32[40572 >> 2] | 0;
 $6 = $12;
 L1 : while (1) {
  $13 = $6;
  $14 = ($13 | 0) != (0 | 0);
  if (!$14) {
   label = 11;
   break;
  }
  $15 = $6;
  $16 = $15 + 16 | 0;
  $7 = $16;
  $17 = $6;
  $18 = $17 + 16 | 0;
  $19 = $6;
  $20 = $19 + 12 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  $22 = $18 + ($21 << 2) | 0;
  $8 = $22;
  while (1) {
   $23 = $7;
   $24 = $8;
   $25 = $23 >>> 0 < $24 >>> 0;
   if (!$25) {
    break;
   }
   $26 = $7;
   $27 = HEAP32[$26 >> 2] | 0;
   $28 = HEAP8[$27 >> 0] | 0;
   $29 = $28 & 255;
   $30 = $7;
   $31 = HEAP32[$30 >> 2] | 0;
   $32 = $31 + 1 | 0;
   $33 = HEAP8[$32 >> 0] | 0;
   $34 = $33 & 255;
   $35 = $34 << 8;
   $36 = $29 | $35;
   $37 = $5;
   $38 = ($36 | 0) == ($37 | 0);
   if ($38) {
    $39 = $7;
    $40 = HEAP32[$39 >> 2] | 0;
    $41 = $40 + 2 | 0;
    $42 = HEAP8[$41 >> 0] | 0;
    $43 = $42 & 255;
    $44 = $4;
    $45 = ($43 | 0) == ($44 | 0);
    if ($45) {
     $46 = $7;
     $47 = HEAP32[$46 >> 2] | 0;
     $48 = $47 + 2 | 0;
     $49 = $48 + 1 | 0;
     $50 = $3;
     $51 = $4;
     $52 = _memcmp($49, $50, $51) | 0;
     $53 = ($52 | 0) == 0;
     if ($53) {
      label = 8;
      break L1;
     }
    }
   }
   $65 = $7;
   $66 = $65 + 4 | 0;
   $7 = $66;
  }
  $67 = $6;
  $68 = HEAP32[$67 >> 2] | 0;
  $6 = $68;
 }
 if ((label | 0) == 8) {
  $54 = $6;
  $55 = $54 + 4 | 0;
  $56 = HEAP32[$55 >> 2] | 0;
  $57 = $7;
  $58 = $6;
  $59 = $58 + 16 | 0;
  $60 = $57;
  $61 = $59;
  $62 = $60 - $61 | 0;
  $63 = ($62 | 0) / 4 & -1;
  $64 = $56 + $63 | 0;
  $2 = $64;
  $69 = $2;
  STACKTOP = sp;
  return $69 | 0;
 } else if ((label | 0) == 11) {
  $2 = 0;
  $69 = $2;
  STACKTOP = sp;
  return $69 | 0;
 }
 return 0 | 0;
}

function _stream_unbuffered_readline($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $7 = sp + 16 | 0;
 $9 = sp + 4 | 0;
 $3 = $0;
 $4 = $1;
 $11 = $4;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = _mp_get_stream($12) | 0;
 $5 = $13;
 $6 = -1;
 $14 = $3;
 $15 = $14 >>> 0 > 1;
 if ($15) {
  $16 = $4;
  $17 = $16 + 4 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = $18;
  $20 = $19 >> 1;
  $6 = $20;
 }
 $21 = $6;
 $22 = ($21 | 0) != -1;
 if ($22) {
  $23 = $6;
  _vstr_init($7, $23);
 } else {
  _vstr_init($7, 16);
 }
 while (1) {
  $24 = $6;
  $25 = ($24 | 0) == -1;
  if (!$25) {
   $26 = $6;
   $27 = $26 + -1 | 0;
   $6 = $27;
   $28 = ($26 | 0) != 0;
   if (!$28) {
    break;
   }
  }
  $29 = _vstr_add_len($7, 1) | 0;
  $8 = $29;
  $30 = $5;
  $31 = HEAP32[$30 >> 2] | 0;
  $32 = $4;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = $8;
  $35 = FUNCTION_TABLE_iiiii[$31 & 1023]($33, $34, 1, $9) | 0;
  $10 = $35;
  $36 = $10;
  $37 = ($36 | 0) == -1;
  if ($37) {
   label = 10;
   break;
  }
  $46 = $10;
  $47 = ($46 | 0) == 0;
  if ($47) {
   label = 15;
   break;
  }
  $48 = $8;
  $49 = HEAP8[$48 >> 0] | 0;
  $50 = $49 << 24 >> 24;
  $51 = ($50 | 0) == 10;
  if ($51) {
   break;
  }
 }
 if ((label | 0) == 10) {
  $38 = HEAP32[$9 >> 2] | 0;
  $39 = ($38 | 0) == 11;
  $40 = HEAP32[$9 >> 2] | 0;
  $41 = ($40 | 0) == 11;
  $or$cond = $39 | $41;
  if (!$or$cond) {
   $45 = HEAP32[$9 >> 2] | 0;
   _mp_raise_OSError($45);
  }
  $42 = $7 + 4 | 0;
  $43 = HEAP32[$42 >> 2] | 0;
  $44 = ($43 | 0) == 1;
  if ($44) {
   _vstr_clear($7);
   $2 = 17668;
   $60 = $2;
   STACKTOP = sp;
   return $60 | 0;
  } else {
   label = 15;
  }
 }
 if ((label | 0) == 15) {
  _vstr_cut_tail_bytes($7, 1);
 }
 $52 = $5;
 $53 = $52 + 12 | 0;
 $54 = HEAP8[$53 >> 0] | 0;
 $55 = $54 & 1;
 $56 = $55 & 255;
 $57 = ($56 | 0) != 0;
 $58 = $57 ? 18680 : 18304;
 $59 = _mp_obj_new_str_from_vstr($58, $7) | 0;
 $2 = $59;
 $60 = $2;
 STACKTOP = sp;
 return $60 | 0;
}

function _vstr_add_char($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $8 = $3;
 $9 = $8 >>> 0 < 128;
 if ($9) {
  $10 = $2;
  $11 = _vstr_add_len($10, 1) | 0;
  $4 = $11;
  $12 = $3;
  $13 = $12 & 255;
  $14 = $4;
  HEAP8[$14 >> 0] = $13;
  STACKTOP = sp;
  return;
 }
 $15 = $3;
 $16 = $15 >>> 0 < 2048;
 if ($16) {
  $17 = $2;
  $18 = _vstr_add_len($17, 2) | 0;
  $5 = $18;
  $19 = $3;
  $20 = $19 >>> 6;
  $21 = $20 | 192;
  $22 = $21 & 255;
  $23 = $5;
  HEAP8[$23 >> 0] = $22;
  $24 = $3;
  $25 = $24 & 63;
  $26 = $25 | 128;
  $27 = $26 & 255;
  $28 = $5;
  $29 = $28 + 1 | 0;
  HEAP8[$29 >> 0] = $27;
  STACKTOP = sp;
  return;
 }
 $30 = $3;
 $31 = $30 >>> 0 < 65536;
 $32 = $2;
 if ($31) {
  $33 = _vstr_add_len($32, 3) | 0;
  $6 = $33;
  $34 = $3;
  $35 = $34 >>> 12;
  $36 = $35 | 224;
  $37 = $36 & 255;
  $38 = $6;
  HEAP8[$38 >> 0] = $37;
  $39 = $3;
  $40 = $39 >>> 6;
  $41 = $40 & 63;
  $42 = $41 | 128;
  $43 = $42 & 255;
  $44 = $6;
  $45 = $44 + 1 | 0;
  HEAP8[$45 >> 0] = $43;
  $46 = $3;
  $47 = $46 & 63;
  $48 = $47 | 128;
  $49 = $48 & 255;
  $50 = $6;
  $51 = $50 + 2 | 0;
  HEAP8[$51 >> 0] = $49;
  STACKTOP = sp;
  return;
 } else {
  $52 = _vstr_add_len($32, 4) | 0;
  $7 = $52;
  $53 = $3;
  $54 = $53 >>> 18;
  $55 = $54 | 240;
  $56 = $55 & 255;
  $57 = $7;
  HEAP8[$57 >> 0] = $56;
  $58 = $3;
  $59 = $58 >>> 12;
  $60 = $59 & 63;
  $61 = $60 | 128;
  $62 = $61 & 255;
  $63 = $7;
  $64 = $63 + 1 | 0;
  HEAP8[$64 >> 0] = $62;
  $65 = $3;
  $66 = $65 >>> 6;
  $67 = $66 & 63;
  $68 = $67 | 128;
  $69 = $68 & 255;
  $70 = $7;
  $71 = $70 + 2 | 0;
  HEAP8[$71 >> 0] = $69;
  $72 = $3;
  $73 = $72 & 63;
  $74 = $73 | 128;
  $75 = $74 & 255;
  $76 = $7;
  $77 = $76 + 3 | 0;
  HEAP8[$77 >> 0] = $75;
  STACKTOP = sp;
  return;
 }
}

function _compile_funcdef_lambdef($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $11 = $4;
 $12 = $11 + 6 | 0;
 $13 = HEAP8[$12 >> 0] | 0;
 $14 = $13 << 24 >> 24 != 0;
 $15 = $14 & 1;
 $8 = $15;
 $16 = $4;
 $17 = $16 + 20 | 0;
 $18 = HEAP16[$17 >> 1] | 0;
 $9 = $18;
 $19 = $4;
 $20 = $19 + 22 | 0;
 $21 = HEAP16[$20 >> 1] | 0;
 $10 = $21;
 $22 = $4;
 $23 = $22 + 6 | 0;
 HEAP8[$23 >> 0] = 0;
 $24 = $4;
 $25 = $24 + 20 | 0;
 HEAP16[$25 >> 1] = 0;
 $26 = $4;
 $27 = $26 + 22 | 0;
 HEAP16[$27 >> 1] = 0;
 $28 = $4;
 $29 = $6;
 $30 = $7;
 _apply_to_single_or_list($28, $29, $30, 491);
 $31 = $4;
 $32 = $31 + 8 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = ($33 | 0) != (0 | 0);
 if ($34) {
  STACKTOP = sp;
  return;
 }
 $35 = $4;
 $36 = $35 + 22 | 0;
 $37 = HEAP16[$36 >> 1] | 0;
 $38 = $37 & 65535;
 $39 = ($38 | 0) > 0;
 if ($39) {
  $40 = $4;
  $41 = $40 + 20 | 0;
  $42 = HEAP16[$41 >> 1] | 0;
  $43 = $42 & 65535;
  $44 = ($43 | 0) == 0;
  if ($44) {
   $45 = $4;
   $46 = $45 + 40 | 0;
   $47 = HEAP32[$46 >> 2] | 0;
   $48 = $4;
   $49 = $48 + 22 | 0;
   $50 = HEAP16[$49 >> 1] | 0;
   $51 = $50 & 65535;
   _mp_emit_bc_build($47, $51, 0);
   $52 = $4;
   $53 = $52 + 40 | 0;
   $54 = HEAP32[$53 >> 2] | 0;
   _mp_emit_bc_load_null($54);
  }
 }
 $55 = $4;
 $56 = $5;
 $57 = $4;
 $58 = $57 + 22 | 0;
 $59 = HEAP16[$58 >> 1] | 0;
 $60 = $59 & 65535;
 $61 = $4;
 $62 = $61 + 20 | 0;
 $63 = HEAP16[$62 >> 1] | 0;
 $64 = $63 & 65535;
 _close_over_variables_etc($55, $56, $60, $64);
 $65 = $8;
 $66 = $65 & 1;
 $67 = $66 & 1;
 $68 = $4;
 $69 = $68 + 6 | 0;
 HEAP8[$69 >> 0] = $67;
 $70 = $9;
 $71 = $4;
 $72 = $71 + 20 | 0;
 HEAP16[$72 >> 1] = $70;
 $73 = $10;
 $74 = $4;
 $75 = $74 + 22 | 0;
 HEAP16[$75 >> 1] = $73;
 STACKTOP = sp;
 return;
}

function _uctypes_struct_agg_size($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = 0;
 $13 = $4;
 $14 = $13 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $15;
 $17 = $16 >> 1;
 $8 = $17;
 $18 = $8;
 $19 = $18 >> 29;
 $20 = $19 & 3;
 $9 = $20;
 $21 = $9;
 switch ($21 | 0) {
 case 0:
  {
   $22 = $4;
   $23 = $22 + 8 | 0;
   $24 = $23 + 4 | 0;
   $25 = HEAP32[$24 >> 2] | 0;
   $26 = $5;
   $27 = $6;
   $28 = _uctypes_struct_size($25, $26, $27) | 0;
   $3 = $28;
   $68 = $3;
   STACKTOP = sp;
   return $68 | 0;
   break;
  }
 case 1:
  {
   $29 = $6;
   $30 = HEAP32[$29 >> 2] | 0;
   $31 = 4 > $30 >>> 0;
   if ($31) {
    $32 = $6;
    HEAP32[$32 >> 2] = 4;
   }
   $3 = 4;
   $68 = $3;
   STACKTOP = sp;
   return $68 | 0;
   break;
  }
 case 2:
  {
   $33 = $4;
   $34 = $33 + 8 | 0;
   $35 = $34 + 4 | 0;
   $36 = HEAP32[$35 >> 2] | 0;
   $37 = $36;
   $38 = $37 >> 1;
   $10 = $38;
   $39 = $10;
   $40 = $39 >> 27;
   $41 = $40 & 15;
   $11 = $41;
   $42 = $10;
   $43 = $42 & 134217727;
   $10 = $43;
   $44 = $4;
   $45 = $44 + 4 | 0;
   $46 = HEAP32[$45 >> 2] | 0;
   $47 = ($46 | 0) == 2;
   if ($47) {
    $48 = $11;
    $49 = $48 >>> 1;
    $50 = 1 << $49;
    $12 = $50;
    $51 = $12;
    $52 = $6;
    $53 = HEAP32[$52 >> 2] | 0;
    $54 = $51 >>> 0 > $53 >>> 0;
    if ($54) {
     $55 = $12;
     $56 = $6;
     HEAP32[$56 >> 2] = $55;
    }
   } else {
    $57 = $4;
    $58 = $57 + 8 | 0;
    $59 = $58 + 8 | 0;
    $60 = HEAP32[$59 >> 2] | 0;
    $61 = $5;
    $62 = $6;
    $63 = _uctypes_struct_size($60, $61, $62) | 0;
    $12 = $63;
   }
   $64 = $12;
   $65 = $10;
   $66 = Math_imul($64, $65) | 0;
   $3 = $66;
   $68 = $3;
   STACKTOP = sp;
   return $68 | 0;
   break;
  }
 default:
  {
   $67 = $7;
   $3 = $67;
   $68 = $3;
   STACKTOP = sp;
   return $68 | 0;
  }
 }
 return 0 | 0;
}

function _mod_urandom_randrange($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $9 = $4;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = _mp_obj_get_int($10) | 0;
 $5 = $11;
 $12 = $3;
 $13 = ($12 | 0) == 1;
 if ($13) {
  $14 = $5;
  $15 = ($14 | 0) > 0;
  if (!$15) {
   _mp_raise_ValueError(0);
  }
  $16 = $5;
  $17 = _yasmarang_randbelow($16) | 0;
  $18 = _mp_obj_new_int($17) | 0;
  $2 = $18;
  $68 = $2;
  STACKTOP = sp;
  return $68 | 0;
 }
 $19 = $4;
 $20 = $19 + 4 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = _mp_obj_get_int($21) | 0;
 $6 = $22;
 $23 = $3;
 $24 = ($23 | 0) == 2;
 if ($24) {
  $25 = $5;
  $26 = $6;
  $27 = ($25 | 0) < ($26 | 0);
  if (!$27) {
   _mp_raise_ValueError(0);
  }
  $28 = $5;
  $29 = $6;
  $30 = $5;
  $31 = $29 - $30 | 0;
  $32 = _yasmarang_randbelow($31) | 0;
  $33 = $28 + $32 | 0;
  $34 = _mp_obj_new_int($33) | 0;
  $2 = $34;
  $68 = $2;
  STACKTOP = sp;
  return $68 | 0;
 }
 $35 = $4;
 $36 = $35 + 8 | 0;
 $37 = HEAP32[$36 >> 2] | 0;
 $38 = _mp_obj_get_int($37) | 0;
 $7 = $38;
 $39 = $7;
 $40 = ($39 | 0) > 0;
 do {
  if ($40) {
   $41 = $6;
   $42 = $5;
   $43 = $41 - $42 | 0;
   $44 = $7;
   $45 = $43 + $44 | 0;
   $46 = $45 - 1 | 0;
   $47 = $7;
   $48 = ($46 | 0) / ($47 | 0) & -1;
   $8 = $48;
  } else {
   $49 = $7;
   $50 = ($49 | 0) < 0;
   if ($50) {
    $51 = $6;
    $52 = $5;
    $53 = $51 - $52 | 0;
    $54 = $7;
    $55 = $53 + $54 | 0;
    $56 = $55 + 1 | 0;
    $57 = $7;
    $58 = ($56 | 0) / ($57 | 0) & -1;
    $8 = $58;
    break;
   } else {
    _mp_raise_ValueError(0);
   }
  }
 } while (0);
 $59 = $8;
 $60 = ($59 | 0) > 0;
 if (!$60) {
  _mp_raise_ValueError(0);
 }
 $61 = $5;
 $62 = $7;
 $63 = $8;
 $64 = _yasmarang_randbelow($63) | 0;
 $65 = Math_imul($62, $64) | 0;
 $66 = $61 + $65 | 0;
 $67 = _mp_obj_new_int($66) | 0;
 $2 = $67;
 $68 = $2;
 STACKTOP = sp;
 return $68 | 0;
}

function _mp_obj_new_str_from_vstr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $7 = $3;
 $8 = ($7 | 0) == (18680 | 0);
 if ($8) {
  $9 = $4;
  $10 = $9 + 8 | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = $4;
  $13 = $12 + 4 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = _qstr_find_strn($11, $14) | 0;
  $5 = $15;
  $16 = $5;
  $17 = ($16 | 0) != 0;
  if ($17) {
   $18 = $4;
   _vstr_clear($18);
   $19 = $4;
   HEAP32[$19 >> 2] = 0;
   $20 = $5;
   $21 = $20 << 2;
   $22 = $21 | 2;
   $23 = $22;
   $2 = $23;
   $72 = $2;
   STACKTOP = sp;
   return $72 | 0;
  }
 }
 $24 = _m_malloc(16) | 0;
 $6 = $24;
 $25 = $3;
 $26 = $6;
 HEAP32[$26 >> 2] = $25;
 $27 = $4;
 $28 = $27 + 4 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = $6;
 $31 = $30 + 8 | 0;
 HEAP32[$31 >> 2] = $29;
 $32 = $4;
 $33 = $32 + 8 | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = $4;
 $36 = $35 + 4 | 0;
 $37 = HEAP32[$36 >> 2] | 0;
 $38 = _qstr_compute_hash($34, $37) | 0;
 $39 = $6;
 $40 = $39 + 4 | 0;
 HEAP32[$40 >> 2] = $38;
 $41 = $4;
 $42 = $41 + 4 | 0;
 $43 = HEAP32[$42 >> 2] | 0;
 $44 = $43 + 1 | 0;
 $45 = $4;
 $46 = HEAP32[$45 >> 2] | 0;
 $47 = ($44 | 0) == ($46 | 0);
 $48 = $4;
 $49 = $48 + 8 | 0;
 $50 = HEAP32[$49 >> 2] | 0;
 if ($47) {
  $51 = $6;
  $52 = $51 + 12 | 0;
  HEAP32[$52 >> 2] = $50;
 } else {
  $53 = $4;
  $54 = $53 + 4 | 0;
  $55 = HEAP32[$54 >> 2] | 0;
  $56 = $55 + 1 | 0;
  $57 = $56;
  $58 = _m_realloc($50, $57) | 0;
  $59 = $6;
  $60 = $59 + 12 | 0;
  HEAP32[$60 >> 2] = $58;
 }
 $61 = $6;
 $62 = $61 + 12 | 0;
 $63 = HEAP32[$62 >> 2] | 0;
 $64 = $6;
 $65 = $64 + 8 | 0;
 $66 = HEAP32[$65 >> 2] | 0;
 $67 = $63 + $66 | 0;
 HEAP8[$67 >> 0] = 0;
 $68 = $4;
 $69 = $68 + 8 | 0;
 HEAP32[$69 >> 2] = 0;
 $70 = $4;
 HEAP32[$70 >> 2] = 0;
 $71 = $6;
 $2 = $71;
 $72 = $2;
 STACKTOP = sp;
 return $72 | 0;
}

function _mp_get_index($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, $vararg_ptr1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $8 = sp + 12 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $9 = $3 & 1;
 $7 = $9;
 $10 = $6;
 $11 = _mp_obj_is_small_int_784($10) | 0;
 $12 = $6;
 if ($11) {
  $13 = $12;
  $14 = $13 >> 1;
  HEAP32[$8 >> 2] = $14;
 } else {
  $15 = _mp_obj_get_int_maybe($12, $8) | 0;
  if (!$15) {
   $16 = $4;
   $17 = $16 + 6 | 0;
   $18 = HEAP16[$17 >> 1] | 0;
   $19 = $18 & 65535;
   $20 = $6;
   $21 = _mp_obj_get_type_str($20) | 0;
   HEAP32[$vararg_buffer >> 2] = $19;
   $vararg_ptr1 = $vararg_buffer + 4 | 0;
   HEAP32[$vararg_ptr1 >> 2] = $21;
   $22 = _mp_obj_new_exception_msg_varg(16012, 30511, $vararg_buffer) | 0;
   _nlr_jump($22);
  }
 }
 $23 = HEAP32[$8 >> 2] | 0;
 $24 = ($23 | 0) < 0;
 if ($24) {
  $25 = $5;
  $26 = HEAP32[$8 >> 2] | 0;
  $27 = $26 + $25 | 0;
  HEAP32[$8 >> 2] = $27;
 }
 $28 = $7;
 $29 = $28 & 1;
 $30 = HEAP32[$8 >> 2] | 0;
 $31 = ($30 | 0) < 0;
 if (!$29) {
  if ($31) {
   $39 = $4;
   $40 = $39 + 6 | 0;
   $41 = HEAP16[$40 >> 1] | 0;
   $42 = $41 & 65535;
   HEAP32[$vararg_buffer2 >> 2] = $42;
   $43 = _mp_obj_new_exception_msg_varg(15532, 30547, $vararg_buffer2) | 0;
   _nlr_jump($43);
  }
  $36 = HEAP32[$8 >> 2] | 0;
  $37 = $5;
  $38 = $36 >>> 0 >= $37 >>> 0;
  if ($38) {
   $39 = $4;
   $40 = $39 + 6 | 0;
   $41 = HEAP16[$40 >> 1] | 0;
   $42 = $41 & 65535;
   HEAP32[$vararg_buffer2 >> 2] = $42;
   $43 = _mp_obj_new_exception_msg_varg(15532, 30547, $vararg_buffer2) | 0;
   _nlr_jump($43);
  } else {
   $44 = HEAP32[$8 >> 2] | 0;
   STACKTOP = sp;
   return $44 | 0;
  }
 }
 if ($31) {
  HEAP32[$8 >> 2] = 0;
  $44 = HEAP32[$8 >> 2] | 0;
  STACKTOP = sp;
  return $44 | 0;
 }
 $32 = HEAP32[$8 >> 2] | 0;
 $33 = $5;
 $34 = $32 >>> 0 > $33 >>> 0;
 if (!$34) {
  $44 = HEAP32[$8 >> 2] | 0;
  STACKTOP = sp;
  return $44 | 0;
 }
 $35 = $5;
 HEAP32[$8 >> 2] = $35;
 $44 = HEAP32[$8 >> 2] | 0;
 STACKTOP = sp;
 return $44 | 0;
}

function _set_aligned($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0.0, $16 = 0, $17 = 0, $18 = 0.0, $19 = Math_fround(0), $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $6 = 0, $7 = 0, $8 = 0.0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $4;
 $11 = ($10 | 0) == 14;
 $12 = $4;
 $13 = ($12 | 0) == 15;
 $or$cond = $11 | $13;
 $14 = $7;
 if ($or$cond) {
  $15 = +_mp_obj_get_float($14);
  $8 = $15;
  $16 = $4;
  $17 = ($16 | 0) == 14;
  $18 = $8;
  if ($17) {
   $19 = Math_fround($18);
   $20 = $5;
   $21 = $6;
   $22 = $20 + ($21 << 2) | 0;
   HEAPF32[$22 >> 2] = $19;
   STACKTOP = sp;
   return;
  } else {
   $23 = $5;
   $24 = $6;
   $25 = $23 + ($24 << 3) | 0;
   HEAPF64[$25 >> 3] = $18;
   STACKTOP = sp;
   return;
  }
 }
 $26 = _mp_obj_get_int_truncated($14) | 0;
 $9 = $26;
 $27 = $4;
 switch ($27 | 0) {
 case 0:
  {
   $28 = $9;
   $29 = $28 & 255;
   $30 = $5;
   $31 = $6;
   $32 = $30 + $31 | 0;
   HEAP8[$32 >> 0] = $29;
   STACKTOP = sp;
   return;
   break;
  }
 case 1:
  {
   $33 = $9;
   $34 = $33 & 255;
   $35 = $5;
   $36 = $6;
   $37 = $35 + $36 | 0;
   HEAP8[$37 >> 0] = $34;
   STACKTOP = sp;
   return;
   break;
  }
 case 2:
  {
   $38 = $9;
   $39 = $38 & 65535;
   $40 = $5;
   $41 = $6;
   $42 = $40 + ($41 << 1) | 0;
   HEAP16[$42 >> 1] = $39;
   STACKTOP = sp;
   return;
   break;
  }
 case 3:
  {
   $43 = $9;
   $44 = $43 & 65535;
   $45 = $5;
   $46 = $6;
   $47 = $45 + ($46 << 1) | 0;
   HEAP16[$47 >> 1] = $44;
   STACKTOP = sp;
   return;
   break;
  }
 case 4:
  {
   $48 = $9;
   $49 = $5;
   $50 = $6;
   $51 = $49 + ($50 << 2) | 0;
   HEAP32[$51 >> 2] = $48;
   STACKTOP = sp;
   return;
   break;
  }
 case 5:
  {
   $52 = $9;
   $53 = $5;
   $54 = $6;
   $55 = $53 + ($54 << 2) | 0;
   HEAP32[$55 >> 2] = $52;
   STACKTOP = sp;
   return;
   break;
  }
 case 6:
 case 7:
  {
   $56 = $4;
   $57 = $5;
   $58 = $7;
   _set_unaligned($56, $57, 0, $58);
   STACKTOP = sp;
   return;
   break;
  }
 default:
  {
   STACKTOP = sp;
   return;
  }
 }
}

function _mpz_and_inpl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $5;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $9 >>> 0 < $12 >>> 0;
 if ($13) {
  $14 = $4;
  $6 = $14;
  $15 = $5;
  $4 = $15;
  $16 = $6;
  $5 = $16;
 }
 $17 = $3;
 $18 = $4;
 $19 = $18 + 4 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = $4;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = $22 & 1;
 $24 = ($23 | 0) != 0;
 if ($24) {
  $30 = 1;
 } else {
  $25 = $5;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $26 & 1;
  $28 = ($27 | 0) != 0;
  $30 = $28;
 }
 $29 = $30 & 1;
 $31 = $20 + $29 | 0;
 _mpz_need_dig($17, $31);
 $32 = $3;
 $33 = $32 + 8 | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = $4;
 $36 = $35 + 8 | 0;
 $37 = HEAP32[$36 >> 2] | 0;
 $38 = $4;
 $39 = $38 + 4 | 0;
 $40 = HEAP32[$39 >> 2] | 0;
 $41 = $5;
 $42 = $41 + 8 | 0;
 $43 = HEAP32[$42 >> 2] | 0;
 $44 = $5;
 $45 = $44 + 4 | 0;
 $46 = HEAP32[$45 >> 2] | 0;
 $47 = $4;
 $48 = HEAP32[$47 >> 2] | 0;
 $49 = $48 & 1;
 $50 = $5;
 $51 = HEAP32[$50 >> 2] | 0;
 $52 = $51 & 1;
 $53 = ($49 | 0) == ($52 | 0);
 if ($53) {
  $54 = $4;
  $55 = HEAP32[$54 >> 2] | 0;
  $56 = $55 & 1;
  $63 = $56;
 } else {
  $63 = 0;
 }
 $57 = $4;
 $58 = HEAP32[$57 >> 2] | 0;
 $59 = $58 & 1;
 $60 = $5;
 $61 = HEAP32[$60 >> 2] | 0;
 $62 = $61 & 1;
 $64 = _mpn_and_neg($34, $37, $40, $43, $46, $63, $59, $62) | 0;
 $65 = $3;
 $66 = $65 + 4 | 0;
 HEAP32[$66 >> 2] = $64;
 $67 = $4;
 $68 = HEAP32[$67 >> 2] | 0;
 $69 = $68 & 1;
 $70 = $5;
 $71 = HEAP32[$70 >> 2] | 0;
 $72 = $71 & 1;
 $73 = $69 & $72;
 $74 = $3;
 $75 = HEAP32[$74 >> 2] | 0;
 $76 = $73 & 1;
 $77 = $75 & -2;
 $78 = $77 | $76;
 HEAP32[$74 >> 2] = $78;
 STACKTOP = sp;
 return;
}

function _mpz_xor_inpl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $78 = 0, $79 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $5;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $9 >>> 0 < $12 >>> 0;
 if ($13) {
  $14 = $4;
  $6 = $14;
  $15 = $5;
  $4 = $15;
  $16 = $6;
  $5 = $16;
 }
 $17 = $3;
 $18 = $4;
 $19 = $18 + 4 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = $4;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = $22 & 1;
 $24 = ($23 | 0) != 0;
 if ($24) {
  $30 = 1;
 } else {
  $25 = $5;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $26 & 1;
  $28 = ($27 | 0) != 0;
  $30 = $28;
 }
 $29 = $30 & 1;
 $31 = $20 + $29 | 0;
 _mpz_need_dig($17, $31);
 $32 = $3;
 $33 = $32 + 8 | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = $4;
 $36 = $35 + 8 | 0;
 $37 = HEAP32[$36 >> 2] | 0;
 $38 = $4;
 $39 = $38 + 4 | 0;
 $40 = HEAP32[$39 >> 2] | 0;
 $41 = $5;
 $42 = $41 + 8 | 0;
 $43 = HEAP32[$42 >> 2] | 0;
 $44 = $5;
 $45 = $44 + 4 | 0;
 $46 = HEAP32[$45 >> 2] | 0;
 $47 = $4;
 $48 = HEAP32[$47 >> 2] | 0;
 $49 = $48 & 1;
 $50 = $5;
 $51 = HEAP32[$50 >> 2] | 0;
 $52 = $51 & 1;
 $53 = ($49 | 0) != ($52 | 0);
 $54 = $53 & 1;
 $55 = $4;
 $56 = HEAP32[$55 >> 2] | 0;
 $57 = $56 & 1;
 $58 = 0 == ($57 | 0);
 $59 = $58 & 1;
 $60 = $5;
 $61 = HEAP32[$60 >> 2] | 0;
 $62 = $61 & 1;
 $63 = 0 == ($62 | 0);
 $64 = $63 & 1;
 $65 = _mpn_xor_neg($34, $37, $40, $43, $46, $54, $59, $64) | 0;
 $66 = $3;
 $67 = $66 + 4 | 0;
 HEAP32[$67 >> 2] = $65;
 $68 = $4;
 $69 = HEAP32[$68 >> 2] | 0;
 $70 = $69 & 1;
 $71 = $5;
 $72 = HEAP32[$71 >> 2] | 0;
 $73 = $72 & 1;
 $74 = $70 ^ $73;
 $75 = $3;
 $76 = HEAP32[$75 >> 2] | 0;
 $77 = $74 & 1;
 $78 = $76 & -2;
 $79 = $78 | $77;
 HEAP32[$75 >> 2] = $79;
 STACKTOP = sp;
 return;
}

function ___strchrnul($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$0 = 0, $$029$lcssa = 0, $$02936 = 0, $$030$lcssa = 0, $$03039 = 0, $$1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond33 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = $1 & 255;
 $3 = ($2 | 0) == 0;
 L1 : do {
  if ($3) {
   $4 = _strlen($0) | 0;
   $5 = $0 + $4 | 0;
   $$0 = $5;
  } else {
   $6 = $0;
   $7 = $6 & 3;
   $8 = ($7 | 0) == 0;
   if ($8) {
    $$030$lcssa = $0;
   } else {
    $9 = $1 & 255;
    $$03039 = $0;
    while (1) {
     $10 = HEAP8[$$03039 >> 0] | 0;
     $11 = $10 << 24 >> 24 == 0;
     $12 = $10 << 24 >> 24 == $9 << 24 >> 24;
     $or$cond = $11 | $12;
     if ($or$cond) {
      $$0 = $$03039;
      break L1;
     }
     $13 = $$03039 + 1 | 0;
     $14 = $13;
     $15 = $14 & 3;
     $16 = ($15 | 0) == 0;
     if ($16) {
      $$030$lcssa = $13;
      break;
     } else {
      $$03039 = $13;
     }
    }
   }
   $17 = Math_imul($2, 16843009) | 0;
   $18 = HEAP32[$$030$lcssa >> 2] | 0;
   $19 = $18 + -16843009 | 0;
   $20 = $18 & -2139062144;
   $21 = $20 ^ -2139062144;
   $22 = $21 & $19;
   $23 = ($22 | 0) == 0;
   L10 : do {
    if ($23) {
     $$02936 = $$030$lcssa;
     $25 = $18;
     while (1) {
      $24 = $25 ^ $17;
      $26 = $24 + -16843009 | 0;
      $27 = $24 & -2139062144;
      $28 = $27 ^ -2139062144;
      $29 = $28 & $26;
      $30 = ($29 | 0) == 0;
      if (!$30) {
       $$029$lcssa = $$02936;
       break L10;
      }
      $31 = $$02936 + 4 | 0;
      $32 = HEAP32[$31 >> 2] | 0;
      $33 = $32 + -16843009 | 0;
      $34 = $32 & -2139062144;
      $35 = $34 ^ -2139062144;
      $36 = $35 & $33;
      $37 = ($36 | 0) == 0;
      if ($37) {
       $$02936 = $31;
       $25 = $32;
      } else {
       $$029$lcssa = $31;
       break;
      }
     }
    } else {
     $$029$lcssa = $$030$lcssa;
    }
   } while (0);
   $38 = $1 & 255;
   $$1 = $$029$lcssa;
   while (1) {
    $39 = HEAP8[$$1 >> 0] | 0;
    $40 = $39 << 24 >> 24 == 0;
    $41 = $39 << 24 >> 24 == $38 << 24 >> 24;
    $or$cond33 = $40 | $41;
    $42 = $$1 + 1 | 0;
    if ($or$cond33) {
     $$0 = $$1;
     break;
    } else {
     $$1 = $42;
    }
   }
  }
 } while (0);
 return $$0 | 0;
}

function _mp_binary_get_size($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = 0;
 $7 = 1;
 $8 = $3;
 $9 = $8 << 24 >> 24;
 L1 : do {
  switch ($9 | 0) {
  case 62:
  case 60:
   {
    $10 = $4;
    $11 = $10 << 24 >> 24;
    switch ($11 | 0) {
    case 66:
    case 98:
     {
      $6 = 1;
      break L1;
      break;
     }
    case 72:
    case 104:
     {
      $6 = 2;
      break L1;
      break;
     }
    case 73:
    case 105:
     {
      $6 = 4;
      break L1;
      break;
     }
    case 76:
    case 108:
     {
      $6 = 4;
      break L1;
      break;
     }
    case 81:
    case 113:
     {
      $6 = 8;
      break L1;
      break;
     }
    case 83:
    case 79:
    case 80:
     {
      $6 = 4;
      break L1;
      break;
     }
    case 102:
     {
      $6 = 4;
      break L1;
      break;
     }
    case 100:
     {
      $6 = 8;
      break L1;
      break;
     }
    default:
     {
      break L1;
     }
    }
    break;
   }
  case 64:
   {
    $12 = $4;
    $13 = $12 << 24 >> 24;
    switch ($13 | 0) {
    case 66:
    case 98:
    case 1:
     {
      $6 = 1;
      $7 = 1;
      break L1;
      break;
     }
    case 72:
    case 104:
     {
      $7 = 2;
      $6 = 2;
      break L1;
      break;
     }
    case 73:
    case 105:
     {
      $7 = 4;
      $6 = 4;
      break L1;
      break;
     }
    case 76:
    case 108:
     {
      $7 = 4;
      $6 = 4;
      break L1;
      break;
     }
    case 81:
    case 113:
     {
      $7 = 8;
      $6 = 8;
      break L1;
      break;
     }
    case 83:
    case 79:
    case 80:
     {
      $7 = 4;
      $6 = 4;
      break L1;
      break;
     }
    case 102:
     {
      $7 = 4;
      $6 = 4;
      break L1;
      break;
     }
    case 100:
     {
      $7 = 8;
      $6 = 8;
      break L1;
      break;
     }
    default:
     {
      break L1;
     }
    }
    break;
   }
  default:
   {}
  }
 } while (0);
 $14 = $6;
 $15 = ($14 | 0) == 0;
 if ($15) {
  _mp_raise_ValueError(33502);
 }
 $16 = $5;
 $17 = ($16 | 0) != (0 | 0);
 if (!$17) {
  $20 = $6;
  STACKTOP = sp;
  return $20 | 0;
 }
 $18 = $7;
 $19 = $5;
 HEAP32[$19 >> 2] = $18;
 $20 = $6;
 STACKTOP = sp;
 return $20 | 0;
}

function _uzlib_gzip_parse_header($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $5 = $2;
 $6 = _uzlib_get_byte($5) | 0;
 $7 = $6 & 255;
 $8 = ($7 | 0) != 31;
 if (!$8) {
  $9 = $2;
  $10 = _uzlib_get_byte($9) | 0;
  $11 = $10 & 255;
  $12 = ($11 | 0) != 139;
  if (!$12) {
   $13 = $2;
   $14 = _uzlib_get_byte($13) | 0;
   $15 = $14 & 255;
   $16 = ($15 | 0) != 8;
   if ($16) {
    $1 = -3;
    $56 = $1;
    STACKTOP = sp;
    return $56 | 0;
   }
   $17 = $2;
   $18 = _uzlib_get_byte($17) | 0;
   $3 = $18;
   $19 = $3;
   $20 = $19 & 255;
   $21 = $20 & 224;
   $22 = ($21 | 0) != 0;
   if ($22) {
    $1 = -3;
    $56 = $1;
    STACKTOP = sp;
    return $56 | 0;
   }
   $23 = $2;
   _tinf_skip_bytes($23, 6);
   $24 = $3;
   $25 = $24 & 255;
   $26 = $25 & 4;
   $27 = ($26 | 0) != 0;
   if ($27) {
    $28 = $2;
    $29 = _tinf_get_uint16($28) | 0;
    $30 = $29 & 65535;
    $4 = $30;
    $31 = $2;
    $32 = $4;
    _tinf_skip_bytes($31, $32);
   }
   $33 = $3;
   $34 = $33 & 255;
   $35 = $34 & 8;
   $36 = ($35 | 0) != 0;
   L15 : do {
    if ($36) {
     while (1) {
      $37 = $2;
      $38 = _uzlib_get_byte($37) | 0;
      $39 = $38 << 24 >> 24 != 0;
      if (!$39) {
       break L15;
      }
     }
    }
   } while (0);
   $40 = $3;
   $41 = $40 & 255;
   $42 = $41 & 16;
   $43 = ($42 | 0) != 0;
   L21 : do {
    if ($43) {
     while (1) {
      $44 = $2;
      $45 = _uzlib_get_byte($44) | 0;
      $46 = $45 << 24 >> 24 != 0;
      if (!$46) {
       break L21;
      }
     }
    }
   } while (0);
   $47 = $3;
   $48 = $47 & 255;
   $49 = $48 & 2;
   $50 = ($49 | 0) != 0;
   if ($50) {
    $51 = $2;
    _tinf_get_uint16($51) | 0;
   }
   $52 = $2;
   $53 = $52 + 36 | 0;
   HEAP8[$53 >> 0] = 2;
   $54 = $2;
   $55 = $54 + 32 | 0;
   HEAP32[$55 >> 2] = -1;
   $1 = 0;
   $56 = $1;
   STACKTOP = sp;
   return $56 | 0;
  }
 }
 $1 = -3;
 $56 = $1;
 STACKTOP = sp;
 return $56 | 0;
}

function _mpz_or_inpl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $75 = 0, $76 = 0, $77 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $5;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $9 >>> 0 < $12 >>> 0;
 if ($13) {
  $14 = $4;
  $6 = $14;
  $15 = $5;
  $4 = $15;
  $16 = $6;
  $5 = $16;
 }
 $17 = $3;
 $18 = $4;
 $19 = $18 + 4 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = $4;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = $22 & 1;
 $24 = ($23 | 0) != 0;
 if ($24) {
  $30 = 1;
 } else {
  $25 = $5;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $26 & 1;
  $28 = ($27 | 0) != 0;
  $30 = $28;
 }
 $29 = $30 & 1;
 $31 = $20 + $29 | 0;
 _mpz_need_dig($17, $31);
 $32 = $3;
 $33 = $32 + 8 | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = $4;
 $36 = $35 + 8 | 0;
 $37 = HEAP32[$36 >> 2] | 0;
 $38 = $4;
 $39 = $38 + 4 | 0;
 $40 = HEAP32[$39 >> 2] | 0;
 $41 = $5;
 $42 = $41 + 8 | 0;
 $43 = HEAP32[$42 >> 2] | 0;
 $44 = $5;
 $45 = $44 + 4 | 0;
 $46 = HEAP32[$45 >> 2] | 0;
 $47 = $4;
 $48 = HEAP32[$47 >> 2] | 0;
 $49 = $48 & 1;
 $50 = ($49 | 0) != 0;
 if ($50) {
  $56 = 1;
 } else {
  $51 = $5;
  $52 = HEAP32[$51 >> 2] | 0;
  $53 = $52 & 1;
  $54 = ($53 | 0) != 0;
  $56 = $54;
 }
 $55 = $56 & 1;
 $57 = $4;
 $58 = HEAP32[$57 >> 2] | 0;
 $59 = $58 & 1;
 $60 = $5;
 $61 = HEAP32[$60 >> 2] | 0;
 $62 = $61 & 1;
 $63 = _mpn_or_neg($34, $37, $40, $43, $46, $55, $59, $62) | 0;
 $64 = $3;
 $65 = $64 + 4 | 0;
 HEAP32[$65 >> 2] = $63;
 $66 = $4;
 $67 = HEAP32[$66 >> 2] | 0;
 $68 = $67 & 1;
 $69 = $5;
 $70 = HEAP32[$69 >> 2] | 0;
 $71 = $70 & 1;
 $72 = $68 | $71;
 $73 = $3;
 $74 = HEAP32[$73 >> 2] | 0;
 $75 = $72 & 1;
 $76 = $74 & -2;
 $77 = $76 | $75;
 HEAP32[$73 >> 2] = $77;
 STACKTOP = sp;
 return;
}

function _tinf_build_tree($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $6 = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = 0;
 while (1) {
  $9 = $7;
  $10 = $9 >>> 0 < 16;
  if (!$10) {
   break;
  }
  $11 = $3;
  $12 = $7;
  $13 = $11 + ($12 << 1) | 0;
  HEAP16[$13 >> 1] = 0;
  $14 = $7;
  $15 = $14 + 1 | 0;
  $7 = $15;
 }
 $7 = 0;
 while (1) {
  $16 = $7;
  $17 = $5;
  $18 = $16 >>> 0 < $17 >>> 0;
  $19 = $3;
  if (!$18) {
   break;
  }
  $20 = $4;
  $21 = $7;
  $22 = $20 + $21 | 0;
  $23 = HEAP8[$22 >> 0] | 0;
  $24 = $23 & 255;
  $25 = $19 + ($24 << 1) | 0;
  $26 = HEAP16[$25 >> 1] | 0;
  $27 = $26 + 1 << 16 >> 16;
  HEAP16[$25 >> 1] = $27;
  $28 = $7;
  $29 = $28 + 1 | 0;
  $7 = $29;
 }
 HEAP16[$19 >> 1] = 0;
 $8 = 0;
 $7 = 0;
 while (1) {
  $30 = $7;
  $31 = $30 >>> 0 < 16;
  if (!$31) {
   break;
  }
  $32 = $8;
  $33 = $32 & 65535;
  $34 = $7;
  $35 = $6 + ($34 << 1) | 0;
  HEAP16[$35 >> 1] = $33;
  $36 = $3;
  $37 = $7;
  $38 = $36 + ($37 << 1) | 0;
  $39 = HEAP16[$38 >> 1] | 0;
  $40 = $39 & 65535;
  $41 = $8;
  $42 = $41 + $40 | 0;
  $8 = $42;
  $43 = $7;
  $44 = $43 + 1 | 0;
  $7 = $44;
 }
 $7 = 0;
 while (1) {
  $45 = $7;
  $46 = $5;
  $47 = $45 >>> 0 < $46 >>> 0;
  if (!$47) {
   break;
  }
  $48 = $4;
  $49 = $7;
  $50 = $48 + $49 | 0;
  $51 = HEAP8[$50 >> 0] | 0;
  $52 = $51 << 24 >> 24 != 0;
  if ($52) {
   $53 = $7;
   $54 = $53 & 65535;
   $55 = $3;
   $56 = $55 + 32 | 0;
   $57 = $4;
   $58 = $7;
   $59 = $57 + $58 | 0;
   $60 = HEAP8[$59 >> 0] | 0;
   $61 = $60 & 255;
   $62 = $6 + ($61 << 1) | 0;
   $63 = HEAP16[$62 >> 1] | 0;
   $64 = $63 + 1 << 16 >> 16;
   HEAP16[$62 >> 1] = $64;
   $65 = $63 & 65535;
   $66 = $56 + ($65 << 1) | 0;
   HEAP16[$66 >> 1] = $54;
  }
  $67 = $7;
  $68 = $67 + 1 | 0;
  $7 = $68;
 }
 STACKTOP = sp;
 return;
}

function _complex_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0.0, $11 = 0, $12 = 0, $13 = 0, $14 = 0.0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0.0, $22 = 0, $23 = 0, $24 = 0, $25 = 0.0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0.0, $35 = 0.0, $36 = 0, $37 = 0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0.0, $44 = 0, $45 = 0, $46 = 0.0, $47 = 0.0, $48 = 0, $49 = 0, $5 = 0, $50 = 0.0, $51 = 0, $52 = 0, $53 = 0.0, $54 = 0.0, $55 = 0.0, $56 = 0.0, $57 = 0, $58 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $4;
 $5 = $6;
 $7 = $3;
 switch ($7 | 0) {
 case 4:
  {
   $8 = $5;
   $9 = $8 + 8 | 0;
   $10 = +HEAPF64[$9 >> 3];
   $11 = $10 != 0.0;
   if ($11) {
    $17 = 1;
   } else {
    $12 = $5;
    $13 = $12 + 16 | 0;
    $14 = +HEAPF64[$13 >> 3];
    $15 = $14 != 0.0;
    $17 = $15;
   }
   $16 = $17 & 1;
   $18 = _mp_obj_new_bool_859($16) | 0;
   $2 = $18;
   $58 = $2;
   STACKTOP = sp;
   return $58 | 0;
   break;
  }
 case 6:
  {
   $19 = $5;
   $20 = $19 + 8 | 0;
   $21 = +HEAPF64[$20 >> 3];
   $22 = _mp_float_hash($21) | 0;
   $23 = $5;
   $24 = $23 + 16 | 0;
   $25 = +HEAPF64[$24 >> 3];
   $26 = _mp_float_hash($25) | 0;
   $27 = $22 ^ $26;
   $28 = $27 << 1;
   $29 = $28 | 1;
   $30 = $29;
   $2 = $30;
   $58 = $2;
   STACKTOP = sp;
   return $58 | 0;
   break;
  }
 case 0:
  {
   $31 = $4;
   $2 = $31;
   $58 = $2;
   STACKTOP = sp;
   return $58 | 0;
   break;
  }
 case 1:
  {
   $32 = $5;
   $33 = $32 + 8 | 0;
   $34 = +HEAPF64[$33 >> 3];
   $35 = -$34;
   $36 = $5;
   $37 = $36 + 16 | 0;
   $38 = +HEAPF64[$37 >> 3];
   $39 = -$38;
   $40 = _mp_obj_new_complex($35, $39) | 0;
   $2 = $40;
   $58 = $2;
   STACKTOP = sp;
   return $58 | 0;
   break;
  }
 case 7:
  {
   $41 = $5;
   $42 = $41 + 8 | 0;
   $43 = +HEAPF64[$42 >> 3];
   $44 = $5;
   $45 = $44 + 8 | 0;
   $46 = +HEAPF64[$45 >> 3];
   $47 = $43 * $46;
   $48 = $5;
   $49 = $48 + 16 | 0;
   $50 = +HEAPF64[$49 >> 3];
   $51 = $5;
   $52 = $51 + 16 | 0;
   $53 = +HEAPF64[$52 >> 3];
   $54 = $50 * $53;
   $55 = $47 + $54;
   $56 = +Math_sqrt(+$55);
   $57 = _mp_obj_new_float($56) | 0;
   $2 = $57;
   $58 = $2;
   STACKTOP = sp;
   return $58 | 0;
   break;
  }
 default:
  {
   $2 = 0;
   $58 = $2;
   STACKTOP = sp;
   return $58 | 0;
  }
 }
 return 0 | 0;
}

function _mp_obj_get_complex($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0.0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0.0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0.0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = ($6 | 0) == (13856 | 0);
 if ($7) {
  $8 = $4;
  HEAPF64[$8 >> 3] = 0.0;
  $9 = $5;
  HEAPF64[$9 >> 3] = 0.0;
  STACKTOP = sp;
  return;
 }
 $10 = $3;
 $11 = ($10 | 0) == (13864 | 0);
 if ($11) {
  $12 = $4;
  HEAPF64[$12 >> 3] = 1.0;
  $13 = $5;
  HEAPF64[$13 >> 3] = 0.0;
  STACKTOP = sp;
  return;
 }
 $14 = $3;
 $15 = _mp_obj_is_small_int_784($14) | 0;
 $16 = $3;
 if ($15) {
  $17 = $16;
  $18 = $17 >> 1;
  $19 = +($18 | 0);
  $20 = $4;
  HEAPF64[$20 >> 3] = $19;
  $21 = $5;
  HEAPF64[$21 >> 3] = 0.0;
  STACKTOP = sp;
  return;
 }
 $22 = _mp_obj_is_obj_786($16) | 0;
 if ($22) {
  $23 = $3;
  $24 = HEAP32[$23 >> 2] | 0;
  $25 = ($24 | 0) == (16904 | 0);
  if ($25) {
   $26 = $3;
   $27 = +_mp_obj_int_as_float_impl($26);
   $28 = $4;
   HEAPF64[$28 >> 3] = $27;
   $29 = $5;
   HEAPF64[$29 >> 3] = 0.0;
   STACKTOP = sp;
   return;
  }
 }
 $30 = $3;
 $31 = _mp_obj_is_obj_786($30) | 0;
 if ($31) {
  $32 = $3;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = ($33 | 0) == (16252 | 0);
  if ($34) {
   $35 = $3;
   $36 = +_mp_obj_float_get($35);
   $37 = $4;
   HEAPF64[$37 >> 3] = $36;
   $38 = $5;
   HEAPF64[$38 >> 3] = 0.0;
   STACKTOP = sp;
   return;
  }
 }
 $39 = $3;
 $40 = _mp_obj_is_obj_786($39) | 0;
 if (!$40) {
  $47 = $3;
  $48 = _mp_obj_get_type_str($47) | 0;
  HEAP32[$vararg_buffer >> 2] = $48;
  $49 = _mp_obj_new_exception_msg_varg(16012, 30449, $vararg_buffer) | 0;
  _nlr_jump($49);
 }
 $41 = $3;
 $42 = HEAP32[$41 >> 2] | 0;
 $43 = ($42 | 0) == (14052 | 0);
 if (!$43) {
  $47 = $3;
  $48 = _mp_obj_get_type_str($47) | 0;
  HEAP32[$vararg_buffer >> 2] = $48;
  $49 = _mp_obj_new_exception_msg_varg(16012, 30449, $vararg_buffer) | 0;
  _nlr_jump($49);
 }
 $44 = $3;
 $45 = $4;
 $46 = $5;
 _mp_obj_complex_get($44, $45, $46);
 STACKTOP = sp;
 return;
}

function _array_extend($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp + 8 | 0;
 $2 = $0;
 $3 = $1;
 $8 = $2;
 $4 = $8;
 $9 = $3;
 _mp_get_buffer_raise($9, $5, 1);
 $10 = $4;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $12 & 255;
 $14 = $13 & 255;
 $15 = _mp_binary_get_size(64, $14, 0) | 0;
 $6 = $15;
 $16 = $5 + 4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $6;
 $19 = ($17 >>> 0) / ($18 >>> 0) & -1;
 $7 = $19;
 $20 = $4;
 $21 = $20 + 4 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = $22 >>> 8;
 $24 = $7;
 $25 = $23 >>> 0 < $24 >>> 0;
 if ($25) {
  $26 = $4;
  $27 = $26 + 12 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = $4;
  $30 = $29 + 8 | 0;
  $31 = HEAP32[$30 >> 2] | 0;
  $32 = $7;
  $33 = $31 + $32 | 0;
  $34 = $6;
  $35 = Math_imul($33, $34) | 0;
  $36 = $35;
  $37 = _m_realloc($28, $36) | 0;
  $38 = $4;
  $39 = $38 + 12 | 0;
  HEAP32[$39 >> 2] = $37;
  $40 = $4;
  $41 = $40 + 4 | 0;
  $42 = HEAP32[$41 >> 2] | 0;
  $43 = $42 & 255;
  HEAP32[$41 >> 2] = $43;
 } else {
  $44 = $7;
  $45 = $4;
  $46 = $45 + 4 | 0;
  $47 = HEAP32[$46 >> 2] | 0;
  $48 = $47 >>> 8;
  $49 = $48 - $44 | 0;
  $50 = HEAP32[$46 >> 2] | 0;
  $51 = $49 & 16777215;
  $52 = $51 << 8;
  $53 = $50 & 255;
  $54 = $53 | $52;
  HEAP32[$46 >> 2] = $54;
 }
 $55 = $4;
 $56 = $55 + 12 | 0;
 $57 = HEAP32[$56 >> 2] | 0;
 $58 = $4;
 $59 = $58 + 8 | 0;
 $60 = HEAP32[$59 >> 2] | 0;
 $61 = $6;
 $62 = Math_imul($60, $61) | 0;
 $63 = $57 + $62 | 0;
 $64 = HEAP32[$5 >> 2] | 0;
 $65 = $7;
 $66 = $6;
 $67 = Math_imul($65, $66) | 0;
 $68 = $67;
 _memcpy($63 | 0, $64 | 0, $68 | 0) | 0;
 $69 = $7;
 $70 = $4;
 $71 = $70 + 8 | 0;
 $72 = HEAP32[$71 >> 2] | 0;
 $73 = $72 + $69 | 0;
 HEAP32[$71 >> 2] = $73;
 STACKTOP = sp;
 return 17668 | 0;
}

function _mp_obj_is_subclass_fast($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$expand_i1_val4 = 0, $$expand_i1_val6 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 24 | 0;
 $3 = $0;
 $4 = $1;
 L1 : while (1) {
  $9 = $3;
  $10 = $4;
  $11 = ($9 | 0) == ($10 | 0);
  if ($11) {
   label = 3;
   break;
  }
  $12 = $3;
  $13 = _mp_obj_is_obj_1260($12) | 0;
  if (!$13) {
   label = 6;
   break;
  }
  $14 = $3;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = ($15 | 0) == (19048 | 0);
  if (!$16) {
   label = 6;
   break;
  }
  $17 = $3;
  $5 = $17;
  $18 = $5;
  $19 = $18 + 52 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = ($20 | 0) == (0 | 0);
  if ($21) {
   label = 8;
   break;
  }
  $22 = $5;
  $23 = $22 + 52 | 0;
  $24 = HEAP32[$23 >> 2] | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = ($25 | 0) == (18952 | 0);
  $27 = $5;
  $28 = $27 + 52 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  if ($26) {
   $6 = $29;
   $30 = $6;
   $31 = $30 + 8 | 0;
   $7 = $31;
   $32 = $7;
   $33 = $6;
   $34 = $33 + 4 | 0;
   $35 = HEAP32[$34 >> 2] | 0;
   $36 = $32 + ($35 << 2) | 0;
   $37 = $36 + -4 | 0;
   $8 = $37;
   while (1) {
    $38 = $7;
    $39 = $8;
    $40 = $38 >>> 0 < $39 >>> 0;
    $41 = $7;
    $42 = HEAP32[$41 >> 2] | 0;
    if (!$40) {
     break;
    }
    $43 = $4;
    $44 = _mp_obj_is_subclass_fast($42, $43) | 0;
    if ($44) {
     label = 13;
     break L1;
    }
    $45 = $7;
    $46 = $45 + 4 | 0;
    $7 = $46;
   }
   $3 = $42;
  } else {
   $3 = $29;
  }
 }
 if ((label | 0) == 3) {
  $$expand_i1_val = 1;
  HEAP8[$2 >> 0] = $$expand_i1_val;
 } else if ((label | 0) == 6) {
  $$expand_i1_val2 = 0;
  HEAP8[$2 >> 0] = $$expand_i1_val2;
 } else if ((label | 0) == 8) {
  $$expand_i1_val4 = 0;
  HEAP8[$2 >> 0] = $$expand_i1_val4;
 } else if ((label | 0) == 13) {
  $$expand_i1_val6 = 1;
  HEAP8[$2 >> 0] = $$expand_i1_val6;
 }
 $$pre_trunc = HEAP8[$2 >> 0] | 0;
 $47 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $47 | 0;
}

function _mp_obj_is_true($0) {
 $0 = $0 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val10 = 0, $$expand_i1_val12 = 0, $$expand_i1_val14 = 0, $$expand_i1_val2 = 0, $$expand_i1_val4 = 0, $$expand_i1_val6 = 0, $$expand_i1_val8 = 0, $$pre_trunc = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $1 = sp + 16 | 0;
 $2 = $0;
 $6 = $2;
 $7 = ($6 | 0) == (13856 | 0);
 do {
  if ($7) {
   $$expand_i1_val = 0;
   HEAP8[$1 >> 0] = $$expand_i1_val;
  } else {
   $8 = $2;
   $9 = ($8 | 0) == (13864 | 0);
   if ($9) {
    $$expand_i1_val2 = 1;
    HEAP8[$1 >> 0] = $$expand_i1_val2;
    break;
   }
   $10 = $2;
   $11 = ($10 | 0) == (17668 | 0);
   if ($11) {
    $$expand_i1_val4 = 0;
    HEAP8[$1 >> 0] = $$expand_i1_val4;
    break;
   }
   $12 = $2;
   $13 = _mp_obj_is_small_int_784($12) | 0;
   $14 = $2;
   if ($13) {
    $15 = $14;
    $16 = $15 >> 1;
    $17 = ($16 | 0) == 0;
    if ($17) {
     $$expand_i1_val6 = 0;
     HEAP8[$1 >> 0] = $$expand_i1_val6;
     break;
    } else {
     $$expand_i1_val8 = 1;
     HEAP8[$1 >> 0] = $$expand_i1_val8;
     break;
    }
   }
   $18 = _mp_obj_get_type($14) | 0;
   $3 = $18;
   $19 = $3;
   $20 = $19 + 20 | 0;
   $21 = HEAP32[$20 >> 2] | 0;
   $22 = ($21 | 0) != (0 | 0);
   if ($22) {
    $23 = $3;
    $24 = $23 + 20 | 0;
    $25 = HEAP32[$24 >> 2] | 0;
    $26 = $2;
    $27 = FUNCTION_TABLE_iii[$25 & 1023](4, $26) | 0;
    $4 = $27;
    $28 = $4;
    $29 = ($28 | 0) != (0 | 0);
    if ($29) {
     $30 = $4;
     $31 = ($30 | 0) == (13864 | 0);
     $$expand_i1_val10 = $31 & 1;
     HEAP8[$1 >> 0] = $$expand_i1_val10;
     break;
    }
   }
   $32 = $2;
   $33 = _mp_obj_len_maybe($32) | 0;
   $5 = $33;
   $34 = $5;
   $35 = ($34 | 0) != (0 | 0);
   if ($35) {
    $36 = $5;
    $37 = ($36 | 0) != (1 | 0);
    $$expand_i1_val12 = $37 & 1;
    HEAP8[$1 >> 0] = $$expand_i1_val12;
    break;
   } else {
    $$expand_i1_val14 = 1;
    HEAP8[$1 >> 0] = $$expand_i1_val14;
    break;
   }
  }
 } while (0);
 $$pre_trunc = HEAP8[$1 >> 0] | 0;
 $38 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $38 | 0;
}

function _set_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $10 = $4;
 $5 = $10;
 $11 = $3;
 switch ($11 | 0) {
 case 4:
  {
   $12 = $5;
   $13 = $12 + 4 | 0;
   $14 = $13 + 4 | 0;
   $15 = HEAP32[$14 >> 2] | 0;
   $16 = ($15 | 0) != 0;
   $17 = $16 & 1;
   $18 = _mp_obj_new_bool_1106($17) | 0;
   $2 = $18;
   $59 = $2;
   STACKTOP = sp;
   return $59 | 0;
   break;
  }
 case 5:
  {
   $19 = $5;
   $20 = $19 + 4 | 0;
   $21 = $20 + 4 | 0;
   $22 = HEAP32[$21 >> 2] | 0;
   $23 = $22 << 1;
   $24 = $23 | 1;
   $25 = $24;
   $2 = $25;
   $59 = $2;
   STACKTOP = sp;
   return $59 | 0;
   break;
  }
 case 6:
  {
   $26 = $4;
   $27 = _mp_obj_is_obj_1105($26) | 0;
   if ($27) {
    $28 = $4;
    $29 = HEAP32[$28 >> 2] | 0;
    $30 = ($29 | 0) == (18084 | 0);
    if ($30) {
     $6 = 18084;
     $31 = $5;
     $32 = $31 + 4 | 0;
     $33 = HEAP32[$32 >> 2] | 0;
     $7 = $33;
     $34 = $5;
     $35 = $34 + 4 | 0;
     $8 = $35;
     $9 = 0;
     while (1) {
      $36 = $9;
      $37 = $7;
      $38 = $36 >>> 0 < $37 >>> 0;
      if (!$38) {
       break;
      }
      $39 = $8;
      $40 = $9;
      $41 = _mp_set_slot_is_filled_1104($39, $40) | 0;
      if ($41) {
       $42 = $8;
       $43 = $42 + 8 | 0;
       $44 = HEAP32[$43 >> 2] | 0;
       $45 = $9;
       $46 = $44 + ($45 << 2) | 0;
       $47 = HEAP32[$46 >> 2] | 0;
       $48 = _mp_unary_op(6, $47) | 0;
       $49 = $48;
       $50 = $49 >> 1;
       $51 = $6;
       $52 = $51 + $50 | 0;
       $6 = $52;
      }
      $53 = $9;
      $54 = $53 + 1 | 0;
      $9 = $54;
     }
     $55 = $6;
     $56 = $55 << 1;
     $57 = $56 | 1;
     $58 = $57;
     $2 = $58;
     $59 = $2;
     STACKTOP = sp;
     return $59 | 0;
    }
   }
   break;
  }
 default:
  {}
 }
 $2 = 0;
 $59 = $2;
 STACKTOP = sp;
 return $59 | 0;
}

function _mpn_add($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $9 = $4;
 $12 = $5;
 $10 = $12;
 $11 = 0;
 $13 = $9;
 $14 = $7;
 $15 = $14 - $13 | 0;
 $7 = $15;
 while (1) {
  $16 = $9;
  $17 = $16 >>> 0 > 0;
  if (!$17) {
   break;
  }
  $18 = $6;
  $19 = HEAP16[$18 >> 1] | 0;
  $20 = $19 & 65535;
  $21 = $8;
  $22 = HEAP16[$21 >> 1] | 0;
  $23 = $22 & 65535;
  $24 = $20 + $23 | 0;
  $25 = $11;
  $26 = $25 + $24 | 0;
  $11 = $26;
  $27 = $11;
  $28 = $27 & 65535;
  $29 = $28 & 65535;
  $30 = $5;
  HEAP16[$30 >> 1] = $29;
  $31 = $11;
  $32 = $31 >>> 16;
  $11 = $32;
  $33 = $9;
  $34 = $33 + -1 | 0;
  $9 = $34;
  $35 = $5;
  $36 = $35 + 2 | 0;
  $5 = $36;
  $37 = $6;
  $38 = $37 + 2 | 0;
  $6 = $38;
  $39 = $8;
  $40 = $39 + 2 | 0;
  $8 = $40;
 }
 while (1) {
  $41 = $7;
  $42 = $41 >>> 0 > 0;
  if (!$42) {
   break;
  }
  $43 = $6;
  $44 = HEAP16[$43 >> 1] | 0;
  $45 = $44 & 65535;
  $46 = $11;
  $47 = $46 + $45 | 0;
  $11 = $47;
  $48 = $11;
  $49 = $48 & 65535;
  $50 = $49 & 65535;
  $51 = $5;
  HEAP16[$51 >> 1] = $50;
  $52 = $11;
  $53 = $52 >>> 16;
  $11 = $53;
  $54 = $7;
  $55 = $54 + -1 | 0;
  $7 = $55;
  $56 = $5;
  $57 = $56 + 2 | 0;
  $5 = $57;
  $58 = $6;
  $59 = $58 + 2 | 0;
  $6 = $59;
 }
 $60 = $11;
 $61 = ($60 | 0) != 0;
 if (!$61) {
  $66 = $5;
  $67 = $10;
  $68 = $66;
  $69 = $67;
  $70 = $68 - $69 | 0;
  $71 = ($70 | 0) / 2 & -1;
  STACKTOP = sp;
  return $71 | 0;
 }
 $62 = $11;
 $63 = $62 & 65535;
 $64 = $5;
 $65 = $64 + 2 | 0;
 $5 = $65;
 HEAP16[$64 >> 1] = $63;
 $66 = $5;
 $67 = $10;
 $68 = $66;
 $69 = $67;
 $70 = $68 - $69 | 0;
 $71 = ($70 | 0) / 2 & -1;
 STACKTOP = sp;
 return $71 | 0;
}

function _mp_help_print_obj($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $1 = $0;
 $5 = $1;
 $6 = ($5 | 0) == (1698 | 0);
 if ($6) {
  _mp_help_print_modules();
  STACKTOP = sp;
  return;
 }
 $7 = $1;
 $8 = _mp_obj_get_type($7) | 0;
 $2 = $8;
 _mp_print_str(13344, 33600) | 0;
 $9 = $1;
 _mp_obj_print($9, 0);
 $10 = $2;
 $11 = $10 + 6 | 0;
 $12 = HEAP16[$11 >> 1] | 0;
 $13 = $12 & 65535;
 HEAP32[$vararg_buffer >> 2] = $13;
 _mp_printf(13344, 33608, $vararg_buffer) | 0;
 $3 = 0;
 $14 = $2;
 $15 = ($14 | 0) == (17264 | 0);
 if ($15) {
  $16 = $1;
  $17 = _mp_obj_module_get_globals_1371($16) | 0;
  $18 = $17 + 4 | 0;
  $3 = $18;
 } else {
  $19 = $2;
  $20 = ($19 | 0) == (19048 | 0);
  if ($20) {
   $21 = $1;
   $2 = $21;
  }
  $22 = $2;
  $23 = $22 + 56 | 0;
  $24 = HEAP32[$23 >> 2] | 0;
  $25 = ($24 | 0) != (0 | 0);
  if ($25) {
   $26 = $2;
   $27 = $26 + 56 | 0;
   $28 = HEAP32[$27 >> 2] | 0;
   $29 = $28 + 4 | 0;
   $3 = $29;
  }
 }
 $30 = $3;
 $31 = ($30 | 0) != (0 | 0);
 if (!$31) {
  STACKTOP = sp;
  return;
 }
 $4 = 0;
 while (1) {
  $32 = $4;
  $33 = $3;
  $34 = $33 + 4 | 0;
  $35 = HEAP32[$34 >> 2] | 0;
  $36 = $32 >>> 0 < $35 >>> 0;
  if (!$36) {
   break;
  }
  $37 = $3;
  $38 = $37 + 8 | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  $40 = $4;
  $41 = $39 + ($40 << 3) | 0;
  $42 = HEAP32[$41 >> 2] | 0;
  $43 = ($42 | 0) != (0 | 0);
  if ($43) {
   $44 = $3;
   $45 = $44 + 8 | 0;
   $46 = HEAP32[$45 >> 2] | 0;
   $47 = $4;
   $48 = $46 + ($47 << 3) | 0;
   $49 = HEAP32[$48 >> 2] | 0;
   $50 = $3;
   $51 = $50 + 8 | 0;
   $52 = HEAP32[$51 >> 2] | 0;
   $53 = $4;
   $54 = $52 + ($53 << 3) | 0;
   $55 = $54 + 4 | 0;
   $56 = HEAP32[$55 >> 2] | 0;
   _mp_help_print_info_about_object($49, $56);
  }
  $57 = $4;
  $58 = $57 + 1 | 0;
  $4 = $58;
 }
 STACKTOP = sp;
 return;
}

function _mp_builtin_chr($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = sp + 12 | 0;
 $1 = $0;
 $5 = $1;
 $6 = _mp_obj_get_int($5) | 0;
 $2 = $6;
 $4 = 0;
 $7 = $2;
 $8 = $7 >>> 0 < 128;
 $9 = $2;
 if ($8) {
  $10 = $9 & 255;
  HEAP8[$3 >> 0] = $10;
  $4 = 1;
  $59 = $4;
  $60 = _mp_obj_new_str_via_qstr($3, $59) | 0;
  STACKTOP = sp;
  return $60 | 0;
 }
 $11 = $9 >>> 0 < 2048;
 $12 = $2;
 if ($11) {
  $13 = $12 >>> 6;
  $14 = $13 | 192;
  $15 = $14 & 255;
  HEAP8[$3 >> 0] = $15;
  $16 = $2;
  $17 = $16 & 63;
  $18 = $17 | 128;
  $19 = $18 & 255;
  $20 = $3 + 1 | 0;
  HEAP8[$20 >> 0] = $19;
  $4 = 2;
  $59 = $4;
  $60 = _mp_obj_new_str_via_qstr($3, $59) | 0;
  STACKTOP = sp;
  return $60 | 0;
 }
 $21 = $12 >>> 0 < 65536;
 $22 = $2;
 if ($21) {
  $23 = $22 >>> 12;
  $24 = $23 | 224;
  $25 = $24 & 255;
  HEAP8[$3 >> 0] = $25;
  $26 = $2;
  $27 = $26 >>> 6;
  $28 = $27 & 63;
  $29 = $28 | 128;
  $30 = $29 & 255;
  $31 = $3 + 1 | 0;
  HEAP8[$31 >> 0] = $30;
  $32 = $2;
  $33 = $32 & 63;
  $34 = $33 | 128;
  $35 = $34 & 255;
  $36 = $3 + 2 | 0;
  HEAP8[$36 >> 0] = $35;
  $4 = 3;
  $59 = $4;
  $60 = _mp_obj_new_str_via_qstr($3, $59) | 0;
  STACKTOP = sp;
  return $60 | 0;
 }
 $37 = $22 >>> 0 < 1114112;
 if (!$37) {
  _mp_raise_ValueError(33668);
 }
 $38 = $2;
 $39 = $38 >>> 18;
 $40 = $39 | 240;
 $41 = $40 & 255;
 HEAP8[$3 >> 0] = $41;
 $42 = $2;
 $43 = $42 >>> 12;
 $44 = $43 & 63;
 $45 = $44 | 128;
 $46 = $45 & 255;
 $47 = $3 + 1 | 0;
 HEAP8[$47 >> 0] = $46;
 $48 = $2;
 $49 = $48 >>> 6;
 $50 = $49 & 63;
 $51 = $50 | 128;
 $52 = $51 & 255;
 $53 = $3 + 2 | 0;
 HEAP8[$53 >> 0] = $52;
 $54 = $2;
 $55 = $54 & 63;
 $56 = $55 | 128;
 $57 = $56 & 255;
 $58 = $3 + 3 | 0;
 HEAP8[$58 >> 0] = $57;
 $4 = 4;
 $59 = $4;
 $60 = _mp_obj_new_str_via_qstr($3, $59) | 0;
 STACKTOP = sp;
 return $60 | 0;
}

function _decompio_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $12 = $5;
 $13 = $6;
 _mp_arg_check_num_1518($12, $13, 1, 2, 0);
 $14 = $7;
 $15 = HEAP32[$14 >> 2] | 0;
 _mp_get_stream_raise($15, 1) | 0;
 $16 = _m_malloc(1296) | 0;
 $8 = $16;
 $17 = $4;
 $18 = $8;
 HEAP32[$18 >> 2] = $17;
 $19 = $8;
 $20 = $19 + 8 | 0;
 _memset($20 | 0, 0, 1284) | 0;
 $21 = $8;
 $22 = $21 + 8 | 0;
 $23 = $22 + 8 | 0;
 HEAP32[$23 >> 2] = 615;
 $24 = $7;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = $8;
 $27 = $26 + 4 | 0;
 HEAP32[$27 >> 2] = $25;
 $28 = $8;
 $29 = $28 + 1292 | 0;
 HEAP8[$29 >> 0] = 0;
 $9 = 0;
 $30 = $5;
 $31 = $30 >>> 0 > 1;
 if ($31) {
  $32 = $7;
  $33 = $32 + 4 | 0;
  $34 = HEAP32[$33 >> 2] | 0;
  $35 = _mp_obj_get_int($34) | 0;
  $9 = $35;
 }
 $36 = $9;
 $37 = ($36 | 0) >= 16;
 do {
  if ($37) {
   $38 = $8;
   $39 = $38 + 8 | 0;
   $40 = _uzlib_gzip_parse_header($39) | 0;
   $11 = $40;
   $41 = $11;
   $42 = ($41 | 0) != 0;
   if ($42) {
    _mp_raise_ValueError(34899);
   } else {
    $43 = $9;
    $44 = $43 - 16 | 0;
    $45 = 1 << $44;
    $10 = $45;
    break;
   }
  } else {
   $46 = $9;
   $47 = ($46 | 0) >= 0;
   if (!$47) {
    $55 = $9;
    $56 = 0 - $55 | 0;
    $57 = 1 << $56;
    $10 = $57;
    break;
   }
   $48 = $8;
   $49 = $48 + 8 | 0;
   $50 = _uzlib_zlib_parse_header($49) | 0;
   $9 = $50;
   $51 = $9;
   $52 = ($51 | 0) < 0;
   if ($52) {
    _mp_raise_ValueError(34899);
   } else {
    $53 = $9;
    $54 = 1 << $53;
    $10 = $54;
    break;
   }
  }
 } while (0);
 $58 = $8;
 $59 = $58 + 8 | 0;
 $60 = $10;
 $61 = $60;
 $62 = _m_malloc($61) | 0;
 $63 = $10;
 _uzlib_uncompress_init($59, $62, $63);
 $64 = $8;
 STACKTOP = sp;
 return $64 | 0;
}

function _exc_add_strn($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $3;
 $6 = $9;
 $10 = $6;
 $11 = $10 + 8 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $5;
 $14 = $12 + $13 | 0;
 $15 = $6;
 $16 = $15 + 4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $14 >>> 0 >= $17 >>> 0;
 do {
  if ($18) {
   $19 = $6;
   $20 = HEAP8[$19 >> 0] | 0;
   $21 = $20 & 1;
   $22 = $6;
   $23 = $22 + 4 | 0;
   $24 = HEAP32[$23 >> 2] | 0;
   if (!$21) {
    $51 = $6;
    $52 = $51 + 8 | 0;
    $53 = HEAP32[$52 >> 2] | 0;
    $54 = $24 - $53 | 0;
    $55 = $54 - 1 | 0;
    $5 = $55;
    break;
   }
   $25 = $5;
   $26 = $24 + $25 | 0;
   $27 = $26 + 16 | 0;
   $7 = $27;
   $28 = $6;
   $29 = $28 + 12 | 0;
   $30 = HEAP32[$29 >> 2] | 0;
   $31 = $7;
   $32 = $31;
   $33 = _m_realloc_maybe($30, $32, 1) | 0;
   $8 = $33;
   $34 = $8;
   $35 = ($34 | 0) == (0 | 0);
   if ($35) {
    $36 = $6;
    HEAP8[$36 >> 0] = 0;
    $37 = $6;
    $38 = $37 + 4 | 0;
    $39 = HEAP32[$38 >> 2] | 0;
    $40 = $6;
    $41 = $40 + 8 | 0;
    $42 = HEAP32[$41 >> 2] | 0;
    $43 = $39 - $42 | 0;
    $44 = $43 - 1 | 0;
    $5 = $44;
    break;
   } else {
    $45 = $7;
    $46 = $6;
    $47 = $46 + 4 | 0;
    HEAP32[$47 >> 2] = $45;
    $48 = $8;
    $49 = $6;
    $50 = $49 + 12 | 0;
    HEAP32[$50 >> 2] = $48;
    break;
   }
  }
 } while (0);
 $56 = $6;
 $57 = $56 + 12 | 0;
 $58 = HEAP32[$57 >> 2] | 0;
 $59 = $6;
 $60 = $59 + 8 | 0;
 $61 = HEAP32[$60 >> 2] | 0;
 $62 = $58 + $61 | 0;
 $63 = $4;
 $64 = $5;
 _memcpy($62 | 0, $63 | 0, $64 | 0) | 0;
 $65 = $5;
 $66 = $6;
 $67 = $66 + 8 | 0;
 $68 = HEAP32[$67 >> 2] | 0;
 $69 = $68 + $65 | 0;
 HEAP32[$67 >> 2] = $69;
 STACKTOP = sp;
 return;
}

function _framebuf_scroll($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $72 = 0, $73 = 0, $74 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $16 = $3;
 $6 = $16;
 $17 = $4;
 $18 = _mp_obj_get_int($17) | 0;
 $7 = $18;
 $19 = $5;
 $20 = _mp_obj_get_int($19) | 0;
 $8 = $20;
 $21 = $7;
 $22 = ($21 | 0) < 0;
 if ($22) {
  $9 = 0;
  $23 = $6;
  $24 = $23 + 12 | 0;
  $25 = HEAP16[$24 >> 1] | 0;
  $26 = $25 & 65535;
  $27 = $7;
  $28 = $26 + $27 | 0;
  $11 = $28;
  $13 = 1;
 } else {
  $29 = $6;
  $30 = $29 + 12 | 0;
  $31 = HEAP16[$30 >> 1] | 0;
  $32 = $31 & 65535;
  $33 = $32 - 1 | 0;
  $9 = $33;
  $34 = $7;
  $35 = $34 - 1 | 0;
  $11 = $35;
  $13 = -1;
 }
 $36 = $8;
 $37 = ($36 | 0) < 0;
 if ($37) {
  $10 = 0;
  $38 = $6;
  $39 = $38 + 14 | 0;
  $40 = HEAP16[$39 >> 1] | 0;
  $41 = $40 & 65535;
  $42 = $8;
  $43 = $41 + $42 | 0;
  $12 = $43;
  $14 = 1;
 } else {
  $44 = $6;
  $45 = $44 + 14 | 0;
  $46 = HEAP16[$45 >> 1] | 0;
  $47 = $46 & 65535;
  $48 = $47 - 1 | 0;
  $10 = $48;
  $49 = $8;
  $50 = $49 - 1 | 0;
  $12 = $50;
  $14 = -1;
 }
 while (1) {
  $51 = $10;
  $52 = $12;
  $53 = ($51 | 0) != ($52 | 0);
  if (!$53) {
   break;
  }
  $54 = $9;
  $15 = $54;
  while (1) {
   $55 = $15;
   $56 = $11;
   $57 = ($55 | 0) != ($56 | 0);
   if (!$57) {
    break;
   }
   $58 = $6;
   $59 = $15;
   $60 = $10;
   $61 = $6;
   $62 = $15;
   $63 = $7;
   $64 = $62 - $63 | 0;
   $65 = $10;
   $66 = $8;
   $67 = $65 - $66 | 0;
   $68 = _getpixel($61, $64, $67) | 0;
   _setpixel($58, $59, $60, $68);
   $69 = $13;
   $70 = $15;
   $71 = $70 + $69 | 0;
   $15 = $71;
  }
  $72 = $14;
  $73 = $10;
  $74 = $73 + $72 | 0;
  $10 = $74;
 }
 STACKTOP = sp;
 return 17668 | 0;
}

function _compile_try_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp + 12 | 0;
 $7 = sp + 4 | 0;
 $2 = $0;
 $3 = $1;
 $9 = $3;
 $10 = $9 + 8 | 0;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $12;
 $4 = $13;
 $14 = $4;
 $15 = $14 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $16 & 255;
 $18 = ($17 | 0) == 119;
 if ($18) {
  $19 = $2;
  $20 = $3;
  $21 = $20 + 8 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $4;
  $24 = $23 + 8 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  _compile_try_finally($19, $22, 0, 0, 0, $25);
  STACKTOP = sp;
  return;
 }
 $26 = $4;
 $27 = $26 + 4 | 0;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = $28 & 255;
 $30 = ($29 | 0) == 115;
 if (!$30) {
  $56 = $3;
  $57 = $56 + 8 | 0;
  $58 = $57 + 4 | 0;
  $59 = _mp_parse_node_extract_list($58, 118, $7) | 0;
  $8 = $59;
  $60 = $2;
  $61 = $3;
  $62 = $61 + 8 | 0;
  $63 = HEAP32[$62 >> 2] | 0;
  $64 = $8;
  $65 = HEAP32[$7 >> 2] | 0;
  _compile_try_except($60, $63, $64, $65, 0);
  STACKTOP = sp;
  return;
 }
 $31 = $4;
 $32 = $31 + 8 | 0;
 $33 = _mp_parse_node_extract_list($32, 118, $5) | 0;
 $6 = $33;
 $34 = $4;
 $35 = $34 + 8 | 0;
 $36 = $35 + 8 | 0;
 $37 = HEAP32[$36 >> 2] | 0;
 $38 = ($37 | 0) == 0;
 $39 = $2;
 $40 = $3;
 $41 = $40 + 8 | 0;
 $42 = HEAP32[$41 >> 2] | 0;
 $43 = $6;
 $44 = HEAP32[$5 >> 2] | 0;
 $45 = $4;
 $46 = $45 + 8 | 0;
 $47 = $46 + 4 | 0;
 $48 = HEAP32[$47 >> 2] | 0;
 if ($38) {
  _compile_try_except($39, $42, $43, $44, $48);
  STACKTOP = sp;
  return;
 } else {
  $49 = $4;
  $50 = $49 + 8 | 0;
  $51 = $50 + 8 | 0;
  $52 = HEAP32[$51 >> 2] | 0;
  $53 = $52;
  $54 = $53 + 8 | 0;
  $55 = HEAP32[$54 >> 2] | 0;
  _compile_try_finally($39, $42, $43, $44, $48, $55);
  STACKTOP = sp;
  return;
 }
}

function _push_result_rule($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $7 = sp + 12 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 HEAP32[$7 >> 2] = $3;
 $11 = $6;
 $12 = $11 & 255;
 $13 = ($12 | 0) == 44;
 if ($13) {
  $14 = $4;
  $15 = _peek_result($14, 0) | 0;
  $8 = $15;
  $16 = $8;
  $17 = ($16 | 0) == 0;
  if (!$17) {
   $18 = $8;
   $19 = ($18 | 0) != 0;
   if (!$19) {
    STACKTOP = sp;
    return;
   }
   $20 = $8;
   $21 = $20 & 3;
   $22 = ($21 | 0) == 0;
   if (!$22) {
    STACKTOP = sp;
    return;
   }
   $23 = $8;
   $24 = $23;
   $25 = $24 + 4 | 0;
   $26 = HEAP32[$25 >> 2] | 0;
   $27 = $26 & 255;
   $28 = ($27 | 0) == 144;
   if (!$28) {
    STACKTOP = sp;
    return;
   }
  }
 }
 $29 = $4;
 $30 = $6;
 $31 = _fold_logical_constants($29, $30, $7) | 0;
 if ($31) {
  STACKTOP = sp;
  return;
 }
 $32 = $4;
 $33 = $6;
 $34 = HEAP32[$7 >> 2] | 0;
 $35 = _fold_constants($32, $33, $34) | 0;
 if ($35) {
  STACKTOP = sp;
  return;
 }
 $36 = $4;
 $37 = HEAP32[$7 >> 2] | 0;
 $38 = $37 << 2;
 $39 = 8 + $38 | 0;
 $40 = _parser_alloc($36, $39) | 0;
 $9 = $40;
 $41 = $5;
 $42 = $9;
 HEAP32[$42 >> 2] = $41;
 $43 = $6;
 $44 = $43 & 255;
 $45 = $44 & 255;
 $46 = HEAP32[$7 >> 2] | 0;
 $47 = $46 << 8;
 $48 = $45 | $47;
 $49 = $9;
 $50 = $49 + 4 | 0;
 HEAP32[$50 >> 2] = $48;
 $51 = HEAP32[$7 >> 2] | 0;
 $10 = $51;
 while (1) {
  $52 = $10;
  $53 = $52 >>> 0 > 0;
  $54 = $4;
  if (!$53) {
   break;
  }
  $55 = _pop_result($54) | 0;
  $56 = $9;
  $57 = $56 + 8 | 0;
  $58 = $10;
  $59 = $58 - 1 | 0;
  $60 = $57 + ($59 << 2) | 0;
  HEAP32[$60 >> 2] = $55;
  $61 = $10;
  $62 = $61 + -1 | 0;
  $10 = $62;
 }
 $63 = $9;
 $64 = $63;
 _push_result_node($54, $64);
 STACKTOP = sp;
 return;
}

function _mpz_pow_inpl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $4;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = ($10 | 0) == 0;
 if (!$11) {
  $12 = $5;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = $13 & 1;
  $15 = ($14 | 0) != 0;
  if (!$15) {
   $17 = $5;
   $18 = $17 + 4 | 0;
   $19 = HEAP32[$18 >> 2] | 0;
   $20 = ($19 | 0) == 0;
   if ($20) {
    $21 = $3;
    _mpz_set_from_int($21, 1);
    STACKTOP = sp;
    return;
   }
   $22 = $4;
   $23 = _mpz_clone($22) | 0;
   $6 = $23;
   $24 = $5;
   $25 = _mpz_clone($24) | 0;
   $7 = $25;
   $26 = $3;
   _mpz_set_from_int($26, 1);
   while (1) {
    $27 = $7;
    $28 = $27 + 4 | 0;
    $29 = HEAP32[$28 >> 2] | 0;
    $30 = $29 >>> 0 > 0;
    if (!$30) {
     break;
    }
    $31 = $7;
    $32 = $31 + 8 | 0;
    $33 = HEAP32[$32 >> 2] | 0;
    $34 = HEAP16[$33 >> 1] | 0;
    $35 = $34 & 65535;
    $36 = $35 & 1;
    $37 = ($36 | 0) != 0;
    if ($37) {
     $38 = $3;
     $39 = $3;
     $40 = $6;
     _mpz_mul_inpl($38, $39, $40);
    }
    $41 = $7;
    $42 = $41 + 8 | 0;
    $43 = HEAP32[$42 >> 2] | 0;
    $44 = $7;
    $45 = $44 + 8 | 0;
    $46 = HEAP32[$45 >> 2] | 0;
    $47 = $7;
    $48 = $47 + 4 | 0;
    $49 = HEAP32[$48 >> 2] | 0;
    $50 = _mpn_shr($43, $46, $49, 1) | 0;
    $51 = $7;
    $52 = $51 + 4 | 0;
    HEAP32[$52 >> 2] = $50;
    $53 = $7;
    $54 = $53 + 4 | 0;
    $55 = HEAP32[$54 >> 2] | 0;
    $56 = ($55 | 0) == 0;
    if ($56) {
     break;
    }
    $57 = $6;
    $58 = $6;
    $59 = $6;
    _mpz_mul_inpl($57, $58, $59);
   }
   $60 = $6;
   _mpz_free($60);
   $61 = $7;
   _mpz_free($61);
   STACKTOP = sp;
   return;
  }
 }
 $16 = $3;
 _mpz_set_from_int($16, 0);
 STACKTOP = sp;
 return;
}

function _mp_obj_int_pow3($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $8 = sp + 36 | 0;
 $9 = sp + 24 | 0;
 $10 = sp + 12 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $14 = $3;
 $15 = _mp_obj_is_small_int_1030($14) | 0;
 if (!$15) {
  $16 = $3;
  $17 = _mp_obj_is_obj_1037($16) | 0;
  if (!$17) {
   _mp_raise_TypeError(31466);
  }
  $18 = $3;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = ($19 | 0) == (16904 | 0);
  if (!$20) {
   _mp_raise_TypeError(31466);
  }
 }
 $21 = $4;
 $22 = _mp_obj_is_small_int_1030($21) | 0;
 if (!$22) {
  $23 = $4;
  $24 = _mp_obj_is_obj_1037($23) | 0;
  if (!$24) {
   _mp_raise_TypeError(31466);
  }
  $25 = $4;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = ($26 | 0) == (16904 | 0);
  if (!$27) {
   _mp_raise_TypeError(31466);
  }
 }
 $28 = $5;
 $29 = _mp_obj_is_small_int_1030($28) | 0;
 if (!$29) {
  $30 = $5;
  $31 = _mp_obj_is_obj_1037($30) | 0;
  if (!$31) {
   _mp_raise_TypeError(31466);
  }
  $32 = $5;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = ($33 | 0) == (16904 | 0);
  if (!$34) {
   _mp_raise_TypeError(31466);
  }
 }
 $35 = _mp_obj_new_int_from_ull(0, 0) | 0;
 $6 = $35;
 $36 = $6;
 $7 = $36;
 $37 = $3;
 $38 = _mp_mpz_for_int($37, $8) | 0;
 $11 = $38;
 $39 = $4;
 $40 = _mp_mpz_for_int($39, $9) | 0;
 $12 = $40;
 $41 = $5;
 $42 = _mp_mpz_for_int($41, $10) | 0;
 $13 = $42;
 $43 = $7;
 $44 = $43 + 4 | 0;
 $45 = $11;
 $46 = $12;
 $47 = $13;
 _mpz_pow3_inpl($44, $45, $46, $47);
 $48 = $11;
 $49 = ($48 | 0) == ($8 | 0);
 if ($49) {
  $50 = $11;
  _mpz_deinit($50);
 }
 $51 = $12;
 $52 = ($51 | 0) == ($9 | 0);
 if ($52) {
  $53 = $12;
  _mpz_deinit($53);
 }
 $54 = $13;
 $55 = ($54 | 0) == ($10 | 0);
 if (!$55) {
  $57 = $6;
  STACKTOP = sp;
  return $57 | 0;
 }
 $56 = $13;
 _mpz_deinit($56);
 $57 = $6;
 STACKTOP = sp;
 return $57 | 0;
}

function _compile_with_stmt_helper($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $5;
 $11 = ($10 | 0) == 0;
 $12 = $4;
 if ($11) {
  $13 = $7;
  _compile_node($12, $13);
  STACKTOP = sp;
  return;
 }
 $14 = _comp_next_label($12) | 0;
 $8 = $14;
 $15 = $6;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($16 | 0) != 0;
 if ($17) {
  $18 = $6;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = $19 & 3;
  $21 = ($20 | 0) == 0;
  if ($21) {
   $22 = $6;
   $23 = HEAP32[$22 >> 2] | 0;
   $24 = $23;
   $25 = $24 + 4 | 0;
   $26 = HEAP32[$25 >> 2] | 0;
   $27 = $26 & 255;
   $28 = ($27 | 0) == 122;
   if ($28) {
    $29 = $6;
    $30 = HEAP32[$29 >> 2] | 0;
    $31 = $30;
    $9 = $31;
    $32 = $4;
    $33 = $9;
    $34 = $33 + 8 | 0;
    $35 = HEAP32[$34 >> 2] | 0;
    _compile_node($32, $35);
    $36 = $4;
    $37 = $8;
    _compile_increase_except_level($36, $37, 0);
    $38 = $4;
    $39 = $9;
    $40 = $39 + 8 | 0;
    $41 = $40 + 4 | 0;
    $42 = HEAP32[$41 >> 2] | 0;
    _c_assign($38, $42, 0);
   } else {
    label = 7;
   }
  } else {
   label = 7;
  }
 } else {
  label = 7;
 }
 if ((label | 0) == 7) {
  $43 = $4;
  $44 = $6;
  $45 = HEAP32[$44 >> 2] | 0;
  _compile_node($43, $45);
  $46 = $4;
  $47 = $8;
  _compile_increase_except_level($46, $47, 0);
  $48 = $4;
  $49 = $48 + 40 | 0;
  $50 = HEAP32[$49 >> 2] | 0;
  _mp_emit_bc_pop_top($50);
 }
 $51 = $4;
 $52 = $5;
 $53 = $52 - 1 | 0;
 $54 = $6;
 $55 = $54 + 4 | 0;
 $56 = $7;
 _compile_with_stmt_helper($51, $53, $55, $56);
 $57 = $4;
 $58 = $57 + 40 | 0;
 $59 = HEAP32[$58 >> 2] | 0;
 $60 = $8;
 _mp_emit_bc_with_cleanup($59, $60);
 $61 = $4;
 _compile_decrease_except_level($61);
 STACKTOP = sp;
 return;
}

function _mpz_not_inpl($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = sp + 10 | 0;
 $5 = sp + 8 | 0;
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = $3;
 $8 = ($6 | 0) != ($7 | 0);
 if ($8) {
  $9 = $2;
  $10 = $3;
  _mpz_set($9, $10);
 }
 $11 = $2;
 $12 = $11 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = ($13 | 0) == 0;
 $15 = $2;
 if ($14) {
  _mpz_need_dig($15, 1);
  $16 = $2;
  $17 = $16 + 8 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  HEAP16[$18 >> 1] = 1;
  $19 = $2;
  $20 = $19 + 4 | 0;
  HEAP32[$20 >> 2] = 1;
  $21 = $2;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $22 & -2;
  $24 = $23 | 1;
  HEAP32[$21 >> 2] = $24;
  STACKTOP = sp;
  return;
 }
 $25 = HEAP32[$15 >> 2] | 0;
 $26 = $25 & 1;
 $27 = ($26 | 0) != 0;
 $28 = $2;
 if ($27) {
  $29 = HEAP32[$28 >> 2] | 0;
  $30 = $29 & -2;
  HEAP32[$28 >> 2] = $30;
  HEAP16[$4 >> 1] = 1;
  $31 = $2;
  $32 = $31 + 8 | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = $2;
  $35 = $34 + 8 | 0;
  $36 = HEAP32[$35 >> 2] | 0;
  $37 = $2;
  $38 = $37 + 4 | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  $40 = _mpn_sub($33, $36, $39, $4, 1) | 0;
  $41 = $2;
  $42 = $41 + 4 | 0;
  HEAP32[$42 >> 2] = $40;
  STACKTOP = sp;
  return;
 } else {
  $43 = $2;
  $44 = $43 + 4 | 0;
  $45 = HEAP32[$44 >> 2] | 0;
  $46 = $45 + 1 | 0;
  _mpz_need_dig($28, $46);
  HEAP16[$5 >> 1] = 1;
  $47 = $2;
  $48 = $47 + 8 | 0;
  $49 = HEAP32[$48 >> 2] | 0;
  $50 = $2;
  $51 = $50 + 8 | 0;
  $52 = HEAP32[$51 >> 2] | 0;
  $53 = $2;
  $54 = $53 + 4 | 0;
  $55 = HEAP32[$54 >> 2] | 0;
  $56 = _mpn_add($49, $52, $55, $5, 1) | 0;
  $57 = $2;
  $58 = $57 + 4 | 0;
  HEAP32[$58 >> 2] = $56;
  $59 = $2;
  $60 = HEAP32[$59 >> 2] | 0;
  $61 = $60 & -2;
  $62 = $61 | 1;
  HEAP32[$59 >> 2] = $62;
  STACKTOP = sp;
  return;
 }
}

function ___fwritex($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$03846 = 0, $$042 = 0, $$1 = 0, $$139 = 0, $$141 = 0, $$143 = 0, $$pre = 0, $$pre48 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $3 = $2 + 16 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = ($4 | 0) == (0 | 0);
 if ($5) {
  $7 = ___towrite($2) | 0;
  $8 = ($7 | 0) == 0;
  if ($8) {
   $$pre = HEAP32[$3 >> 2] | 0;
   $12 = $$pre;
   label = 5;
  } else {
   $$1 = 0;
  }
 } else {
  $6 = $4;
  $12 = $6;
  label = 5;
 }
 L5 : do {
  if ((label | 0) == 5) {
   $9 = $2 + 20 | 0;
   $10 = HEAP32[$9 >> 2] | 0;
   $11 = $12 - $10 | 0;
   $13 = $11 >>> 0 < $1 >>> 0;
   $14 = $10;
   if ($13) {
    $15 = $2 + 36 | 0;
    $16 = HEAP32[$15 >> 2] | 0;
    $17 = FUNCTION_TABLE_iiii[$16 & 1023]($2, $0, $1) | 0;
    $$1 = $17;
    break;
   }
   $18 = $2 + 75 | 0;
   $19 = HEAP8[$18 >> 0] | 0;
   $20 = $19 << 24 >> 24 < 0;
   $21 = ($1 | 0) == 0;
   $or$cond = $20 | $21;
   L10 : do {
    if ($or$cond) {
     $$139 = 0;
     $$141 = $0;
     $$143 = $1;
     $32 = $14;
    } else {
     $$03846 = $1;
     while (1) {
      $22 = $$03846 + -1 | 0;
      $24 = $0 + $22 | 0;
      $25 = HEAP8[$24 >> 0] | 0;
      $26 = $25 << 24 >> 24 == 10;
      if ($26) {
       break;
      }
      $23 = ($22 | 0) == 0;
      if ($23) {
       $$139 = 0;
       $$141 = $0;
       $$143 = $1;
       $32 = $14;
       break L10;
      } else {
       $$03846 = $22;
      }
     }
     $27 = $2 + 36 | 0;
     $28 = HEAP32[$27 >> 2] | 0;
     $29 = FUNCTION_TABLE_iiii[$28 & 1023]($2, $0, $$03846) | 0;
     $30 = $29 >>> 0 < $$03846 >>> 0;
     if ($30) {
      $$1 = $29;
      break L5;
     }
     $31 = $0 + $$03846 | 0;
     $$042 = $1 - $$03846 | 0;
     $$pre48 = HEAP32[$9 >> 2] | 0;
     $$139 = $$03846;
     $$141 = $31;
     $$143 = $$042;
     $32 = $$pre48;
    }
   } while (0);
   _memcpy($32 | 0, $$141 | 0, $$143 | 0) | 0;
   $33 = HEAP32[$9 >> 2] | 0;
   $34 = $33 + $$143 | 0;
   HEAP32[$9 >> 2] = $34;
   $35 = $$139 + $$143 | 0;
   $$1 = $35;
  }
 } while (0);
 return $$1 | 0;
}

function _poll_map_add($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $14 = $4 & 1;
 $9 = $14;
 $10 = 0;
 while (1) {
  $15 = $10;
  $16 = $7;
  $17 = $15 >>> 0 < $16 >>> 0;
  if (!$17) {
   break;
  }
  $18 = $5;
  $19 = $6;
  $20 = $10;
  $21 = $19 + ($20 << 2) | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = _mp_obj_id($22) | 0;
  $24 = _mp_map_lookup($18, $23, 1) | 0;
  $11 = $24;
  $25 = $11;
  $26 = $25 + 4 | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $28 = ($27 | 0) == (0 | 0);
  do {
   if ($28) {
    $29 = $6;
    $30 = $10;
    $31 = $29 + ($30 << 2) | 0;
    $32 = HEAP32[$31 >> 2] | 0;
    $33 = _mp_get_stream_raise($32, 4) | 0;
    $12 = $33;
    $34 = _m_malloc(16) | 0;
    $13 = $34;
    $35 = $6;
    $36 = $10;
    $37 = $35 + ($36 << 2) | 0;
    $38 = HEAP32[$37 >> 2] | 0;
    $39 = $13;
    HEAP32[$39 >> 2] = $38;
    $40 = $12;
    $41 = $40 + 8 | 0;
    $42 = HEAP32[$41 >> 2] | 0;
    $43 = $13;
    $44 = $43 + 4 | 0;
    HEAP32[$44 >> 2] = $42;
    $45 = $8;
    $46 = $13;
    $47 = $46 + 8 | 0;
    HEAP32[$47 >> 2] = $45;
    $48 = $13;
    $49 = $48 + 12 | 0;
    HEAP32[$49 >> 2] = 0;
    $50 = $13;
    $51 = $11;
    $52 = $51 + 4 | 0;
    HEAP32[$52 >> 2] = $50;
   } else {
    $53 = $9;
    $54 = $53 & 1;
    $55 = $8;
    $56 = $11;
    $57 = $56 + 4 | 0;
    $58 = HEAP32[$57 >> 2] | 0;
    $59 = $58 + 8 | 0;
    if ($54) {
     $60 = HEAP32[$59 >> 2] | 0;
     $61 = $60 | $55;
     HEAP32[$59 >> 2] = $61;
     break;
    } else {
     HEAP32[$59 >> 2] = $55;
     break;
    }
   }
  } while (0);
  $62 = $10;
  $63 = $62 + 1 | 0;
  $10 = $63;
 }
 STACKTOP = sp;
 return;
}

function _emit_write_bytecode_byte_int($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = sp + 16 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $3;
 $10 = $4;
 _emit_write_bytecode_byte($9, $10);
 $11 = $6 + 5 | 0;
 $7 = $11;
 while (1) {
  $12 = $5;
  $13 = $12 & 127;
  $14 = $13 & 255;
  $15 = $7;
  $16 = $15 + -1 | 0;
  $7 = $16;
  HEAP8[$16 >> 0] = $14;
  $17 = $5;
  $18 = $17 >> 7;
  $5 = $18;
  $19 = $5;
  $20 = ($19 | 0) != 0;
  $21 = $5;
  $22 = ($21 | 0) != -1;
  $23 = $20 ? $22 : 0;
  if (!$23) {
   break;
  }
 }
 $24 = $5;
 $25 = ($24 | 0) == -1;
 if ($25) {
  $26 = $7;
  $27 = HEAP8[$26 >> 0] | 0;
  $28 = $27 & 255;
  $29 = $28 & 64;
  $30 = ($29 | 0) == 0;
  if ($30) {
   $31 = $7;
   $32 = $31 + -1 | 0;
   $7 = $32;
   HEAP8[$32 >> 0] = 127;
  } else {
   label = 6;
  }
 } else {
  label = 6;
 }
 if ((label | 0) == 6) {
  $33 = $5;
  $34 = ($33 | 0) == 0;
  if ($34) {
   $35 = $7;
   $36 = HEAP8[$35 >> 0] | 0;
   $37 = $36 & 255;
   $38 = $37 & 64;
   $39 = ($38 | 0) != 0;
   if ($39) {
    $40 = $7;
    $41 = $40 + -1 | 0;
    $7 = $41;
    HEAP8[$41 >> 0] = 0;
   }
  }
 }
 $42 = $3;
 $43 = $6 + 5 | 0;
 $44 = $7;
 $45 = $43;
 $46 = $44;
 $47 = $45 - $46 | 0;
 $48 = _emit_get_cur_to_write_bytecode($42, $47) | 0;
 $8 = $48;
 while (1) {
  $49 = $7;
  $50 = $6 + 5 | 0;
  $51 = $50 + -1 | 0;
  $52 = ($49 | 0) != ($51 | 0);
  $53 = $7;
  if (!$52) {
   break;
  }
  $54 = $53 + 1 | 0;
  $7 = $54;
  $55 = HEAP8[$53 >> 0] | 0;
  $56 = $55 & 255;
  $57 = $56 | 128;
  $58 = $57 & 255;
  $59 = $8;
  $60 = $59 + 1 | 0;
  $8 = $60;
  HEAP8[$59 >> 0] = $58;
 }
 $61 = HEAP8[$53 >> 0] | 0;
 $62 = $8;
 HEAP8[$62 >> 0] = $61;
 STACKTOP = sp;
 return;
}

function _poll_poll($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $9 = sp;
 $2 = $0;
 $3 = $1;
 $10 = $3;
 $11 = HEAP32[$10 >> 2] | 0;
 $4 = $11;
 $12 = $2;
 $13 = $3;
 $14 = _poll_poll_internal($12, $13) | 0;
 $5 = $14;
 $15 = $5;
 $16 = _mp_obj_new_list($15, 0) | 0;
 $6 = $16;
 $5 = 0;
 $7 = 0;
 while (1) {
  $17 = $7;
  $18 = $4;
  $19 = $18 + 4 | 0;
  $20 = $19 + 4 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  $22 = $17 >>> 0 < $21 >>> 0;
  if (!$22) {
   break;
  }
  $23 = $4;
  $24 = $23 + 4 | 0;
  $25 = $7;
  $26 = _mp_map_slot_is_filled_1536($24, $25) | 0;
  if ($26) {
   $27 = $4;
   $28 = $27 + 4 | 0;
   $29 = $28 + 8 | 0;
   $30 = HEAP32[$29 >> 2] | 0;
   $31 = $7;
   $32 = $30 + ($31 << 3) | 0;
   $33 = $32 + 4 | 0;
   $34 = HEAP32[$33 >> 2] | 0;
   $8 = $34;
   $35 = $8;
   $36 = $35 + 12 | 0;
   $37 = HEAP32[$36 >> 2] | 0;
   $38 = ($37 | 0) != 0;
   if ($38) {
    $39 = $8;
    $40 = HEAP32[$39 >> 2] | 0;
    HEAP32[$9 >> 2] = $40;
    $41 = $9 + 4 | 0;
    $42 = $8;
    $43 = $42 + 12 | 0;
    $44 = HEAP32[$43 >> 2] | 0;
    $45 = $44 << 1;
    $46 = $45 | 1;
    $47 = $46;
    HEAP32[$41 >> 2] = $47;
    $48 = _mp_obj_new_tuple(2, $9) | 0;
    $49 = $6;
    $50 = $49 + 12 | 0;
    $51 = HEAP32[$50 >> 2] | 0;
    $52 = $5;
    $53 = $52 + 1 | 0;
    $5 = $53;
    $54 = $51 + ($52 << 2) | 0;
    HEAP32[$54 >> 2] = $48;
    $55 = $4;
    $56 = $55 + 20 | 0;
    $57 = HEAP32[$56 >> 2] | 0;
    $58 = $57 & 1;
    $59 = ($58 | 0) != 0;
    if ($59) {
     $60 = $8;
     $61 = $60 + 8 | 0;
     HEAP32[$61 >> 2] = 0;
    }
   }
  }
  $62 = $7;
  $63 = $62 + 1 | 0;
  $7 = $63;
 }
 $64 = $6;
 STACKTOP = sp;
 return $64 | 0;
}

function _compile_yield_expr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 36 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = ($7 | 0) != 7;
 if ($8) {
  $9 = $2;
  $10 = $9 + 36 | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = HEAP32[$11 >> 2] | 0;
  $13 = ($12 | 0) != 2;
  if ($13) {
   $14 = $2;
   $15 = $3;
   $16 = $15;
   _compile_syntax_error($14, $16, 28823);
   STACKTOP = sp;
   return;
  }
 }
 $17 = $3;
 $18 = $17 + 8 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = ($19 | 0) == 0;
 if ($20) {
  $21 = $2;
  $22 = $21 + 40 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  _mp_emit_bc_load_const_tok($23, 14);
  $24 = $2;
  $25 = $24 + 40 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  _mp_emit_bc_yield($26, 0);
  STACKTOP = sp;
  return;
 }
 $27 = $3;
 $28 = $27 + 8 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = ($29 | 0) != 0;
 if ($30) {
  $31 = $3;
  $32 = $31 + 8 | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = $33 & 3;
  $35 = ($34 | 0) == 0;
  if ($35) {
   $36 = $3;
   $37 = $36 + 8 | 0;
   $38 = HEAP32[$37 >> 2] | 0;
   $39 = $38;
   $40 = $39 + 4 | 0;
   $41 = HEAP32[$40 >> 2] | 0;
   $42 = $41 & 255;
   $43 = ($42 | 0) == 174;
   if ($43) {
    $44 = $3;
    $45 = $44 + 8 | 0;
    $46 = HEAP32[$45 >> 2] | 0;
    $47 = $46;
    $3 = $47;
    $48 = $2;
    $49 = $3;
    $50 = $49 + 8 | 0;
    $51 = HEAP32[$50 >> 2] | 0;
    _compile_node($48, $51);
    $52 = $2;
    _compile_yield_from($52);
    STACKTOP = sp;
    return;
   }
  }
 }
 $53 = $2;
 $54 = $3;
 $55 = $54 + 8 | 0;
 $56 = HEAP32[$55 >> 2] | 0;
 _compile_node($53, $56);
 $57 = $2;
 $58 = $57 + 40 | 0;
 $59 = HEAP32[$58 >> 2] | 0;
 _mp_emit_bc_yield($59, 0);
 STACKTOP = sp;
 return;
}

function _mpn_xor_neg($0, $1, $2, $3, $4, $5, $6, $7) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 $7 = $7 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $8 = $0;
 $9 = $1;
 $10 = $2;
 $11 = $3;
 $12 = $4;
 $13 = $5;
 $14 = $6;
 $15 = $7;
 $17 = $8;
 $16 = $17;
 while (1) {
  $18 = $10;
  $19 = $18 >>> 0 > 0;
  if (!$19) {
   break;
  }
  $20 = $9;
  $21 = HEAP16[$20 >> 1] | 0;
  $22 = $21 & 65535;
  $23 = $22 + 65535 | 0;
  $24 = $14;
  $25 = $24 + $23 | 0;
  $14 = $25;
  $26 = $12;
  $27 = $26 + -1 | 0;
  $12 = $27;
  $28 = $10;
  $29 = $28 + -1 | 0;
  $10 = $29;
  $30 = $27 >>> 0 <= $29 >>> 0;
  if ($30) {
   $31 = $11;
   $32 = $31 + 2 | 0;
   $11 = $32;
   $33 = HEAP16[$31 >> 1] | 0;
   $34 = $33 & 65535;
   $35 = $34 + 65535 | 0;
   $38 = $35;
  } else {
   $38 = 65535;
  }
  $36 = $15;
  $37 = $36 + $38 | 0;
  $15 = $37;
  $39 = $14;
  $40 = $15;
  $41 = $39 ^ $40;
  $42 = $41 & 65535;
  $43 = $13;
  $44 = $43 + $42 | 0;
  $13 = $44;
  $45 = $13;
  $46 = $45 & 65535;
  $47 = $46 & 65535;
  $48 = $8;
  HEAP16[$48 >> 1] = $47;
  $49 = $15;
  $50 = $49 >>> 16;
  $15 = $50;
  $51 = $14;
  $52 = $51 >>> 16;
  $14 = $52;
  $53 = $13;
  $54 = $53 >>> 16;
  $13 = $54;
  $55 = $8;
  $56 = $55 + 2 | 0;
  $8 = $56;
  $57 = $9;
  $58 = $57 + 2 | 0;
  $9 = $58;
 }
 $59 = $13;
 $60 = 0 != ($59 | 0);
 if (!$60) {
  $65 = $16;
  $66 = $8;
  $67 = _mpn_remove_trailing_zeros($65, $66) | 0;
  STACKTOP = sp;
  return $67 | 0;
 }
 $61 = $13;
 $62 = $61 & 65535;
 $63 = $8;
 $64 = $63 + 2 | 0;
 $8 = $64;
 HEAP16[$63 >> 1] = $62;
 $65 = $16;
 $66 = $8;
 $67 = _mpn_remove_trailing_zeros($65, $66) | 0;
 STACKTOP = sp;
 return $67 | 0;
}

function _qstr_pool_info($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $11 = $4;
 HEAP32[$11 >> 2] = 0;
 $12 = $5;
 HEAP32[$12 >> 2] = 0;
 $13 = $6;
 HEAP32[$13 >> 2] = 0;
 $14 = $7;
 HEAP32[$14 >> 2] = 0;
 $15 = HEAP32[40572 >> 2] | 0;
 $8 = $15;
 while (1) {
  $16 = $8;
  $17 = ($16 | 0) != (0 | 0);
  $18 = $8;
  $19 = ($18 | 0) != (11280 | 0);
  $20 = $17 ? $19 : 0;
  if (!$20) {
   break;
  }
  $21 = $4;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $22 + 1 | 0;
  HEAP32[$21 >> 2] = $23;
  $24 = $8;
  $25 = $24 + 12 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $5;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = $28 + $26 | 0;
  HEAP32[$27 >> 2] = $29;
  $30 = $8;
  $31 = $30 + 16 | 0;
  $9 = $31;
  $32 = $8;
  $33 = $32 + 16 | 0;
  $34 = $8;
  $35 = $34 + 12 | 0;
  $36 = HEAP32[$35 >> 2] | 0;
  $37 = $33 + ($36 << 2) | 0;
  $10 = $37;
  while (1) {
   $38 = $9;
   $39 = $10;
   $40 = $38 >>> 0 < $39 >>> 0;
   if (!$40) {
    break;
   }
   $41 = $9;
   $42 = HEAP32[$41 >> 2] | 0;
   $43 = $42 + 2 | 0;
   $44 = HEAP8[$43 >> 0] | 0;
   $45 = $44 & 255;
   $46 = 3 + $45 | 0;
   $47 = $46 + 1 | 0;
   $48 = $6;
   $49 = HEAP32[$48 >> 2] | 0;
   $50 = $49 + $47 | 0;
   HEAP32[$48 >> 2] = $50;
   $51 = $9;
   $52 = $51 + 4 | 0;
   $9 = $52;
  }
  $53 = $8;
  $54 = _gc_nbytes($53) | 0;
  $55 = $7;
  $56 = HEAP32[$55 >> 2] | 0;
  $57 = $56 + $54 | 0;
  HEAP32[$55 >> 2] = $57;
  $58 = $8;
  $59 = HEAP32[$58 >> 2] | 0;
  $8 = $59;
 }
 $60 = $6;
 $61 = HEAP32[$60 >> 2] | 0;
 $62 = $7;
 $63 = HEAP32[$62 >> 2] | 0;
 $64 = $63 + $61 | 0;
 HEAP32[$62 >> 2] = $64;
 STACKTOP = sp;
 return;
}

function _heap_siftup($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $8 = $3;
 $4 = $8;
 $9 = $2;
 $10 = $9 + 8 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $5 = $11;
 $12 = $2;
 $13 = $12 + 12 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $3;
 $16 = $14 + ($15 << 2) | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $6 = $17;
 $18 = $3;
 $19 = $18 << 1;
 $20 = $19 + 1 | 0;
 $7 = $20;
 while (1) {
  $21 = $7;
  $22 = $5;
  $23 = $21 >>> 0 < $22 >>> 0;
  if (!$23) {
   break;
  }
  $24 = $7;
  $25 = $24 + 1 | 0;
  $26 = $5;
  $27 = $25 >>> 0 < $26 >>> 0;
  if ($27) {
   $28 = $2;
   $29 = $28 + 12 | 0;
   $30 = HEAP32[$29 >> 2] | 0;
   $31 = $7;
   $32 = $30 + ($31 << 2) | 0;
   $33 = HEAP32[$32 >> 2] | 0;
   $34 = $2;
   $35 = $34 + 12 | 0;
   $36 = HEAP32[$35 >> 2] | 0;
   $37 = $7;
   $38 = $37 + 1 | 0;
   $39 = $36 + ($38 << 2) | 0;
   $40 = HEAP32[$39 >> 2] | 0;
   $41 = _mp_binary_op(0, $33, $40) | 0;
   $42 = ($41 | 0) == (13856 | 0);
   if ($42) {
    $43 = $7;
    $44 = $43 + 1 | 0;
    $7 = $44;
   }
  }
  $45 = $2;
  $46 = $45 + 12 | 0;
  $47 = HEAP32[$46 >> 2] | 0;
  $48 = $7;
  $49 = $47 + ($48 << 2) | 0;
  $50 = HEAP32[$49 >> 2] | 0;
  $51 = $2;
  $52 = $51 + 12 | 0;
  $53 = HEAP32[$52 >> 2] | 0;
  $54 = $3;
  $55 = $53 + ($54 << 2) | 0;
  HEAP32[$55 >> 2] = $50;
  $56 = $7;
  $3 = $56;
  $57 = $3;
  $58 = $57 << 1;
  $59 = $58 + 1 | 0;
  $7 = $59;
 }
 $60 = $6;
 $61 = $2;
 $62 = $61 + 12 | 0;
 $63 = HEAP32[$62 >> 2] | 0;
 $64 = $3;
 $65 = $63 + ($64 << 2) | 0;
 HEAP32[$65 >> 2] = $60;
 $66 = $2;
 $67 = $4;
 $68 = $3;
 _heap_siftdown($66, $67, $68);
 STACKTOP = sp;
 return;
}

function _math_generic_2($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0.0, $11 = 0, $12 = 0.0, $13 = 0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0.0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0.0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0.0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0.0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0.0, $59 = 0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $3;
 $10 = +_mp_obj_get_float($9);
 $6 = $10;
 $11 = $4;
 $12 = +_mp_obj_get_float($11);
 $7 = $12;
 $13 = $5;
 $14 = $6;
 $15 = $7;
 $16 = +FUNCTION_TABLE_ddd[$13 & 1023]($14, $15);
 $8 = $16;
 $17 = $8;
 $18 = ___DOUBLE_BITS_1412($17) | 0;
 $19 = getTempRet0() | 0;
 $20 = $19 & 2147483647;
 $21 = $20 >>> 0 > 2146435072;
 $22 = $18 >>> 0 > 0;
 $23 = ($20 | 0) == 2146435072;
 $24 = $23 & $22;
 $25 = $21 | $24;
 if ($25) {
  $26 = $6;
  $27 = ___DOUBLE_BITS_1412($26) | 0;
  $28 = getTempRet0() | 0;
  $29 = $28 & 2147483647;
  $30 = $29 >>> 0 > 2146435072;
  $31 = $27 >>> 0 > 0;
  $32 = ($29 | 0) == 2146435072;
  $33 = $32 & $31;
  $34 = $30 | $33;
  if (!$34) {
   $35 = $7;
   $36 = ___DOUBLE_BITS_1412($35) | 0;
   $37 = getTempRet0() | 0;
   $38 = $37 & 2147483647;
   $39 = $38 >>> 0 > 2146435072;
   $40 = $36 >>> 0 > 0;
   $41 = ($38 | 0) == 2146435072;
   $42 = $41 & $40;
   $43 = $39 | $42;
   if (!$43) {
    _math_error();
   }
  }
 }
 $44 = $8;
 $45 = ___DOUBLE_BITS_1412($44) | 0;
 $46 = getTempRet0() | 0;
 $47 = $46 & 2147483647;
 $48 = ($45 | 0) == 0;
 $49 = ($47 | 0) == 2146435072;
 $50 = $48 & $49;
 if (!$50) {
  $58 = $8;
  $59 = _mp_obj_new_float($58) | 0;
  STACKTOP = sp;
  return $59 | 0;
 }
 $51 = $6;
 $52 = ___DOUBLE_BITS_1412($51) | 0;
 $53 = getTempRet0() | 0;
 $54 = $53 & 2147483647;
 $55 = ($52 | 0) == 0;
 $56 = ($54 | 0) == 2146435072;
 $57 = $55 & $56;
 if ($57) {
  $58 = $8;
  $59 = _mp_obj_new_float($58) | 0;
  STACKTOP = sp;
  return $59 | 0;
 } else {
  _math_error();
 }
 return 0 | 0;
}

function _instance_count_native_bases($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = 0;
 while (1) {
  $10 = $3;
  $11 = ($10 | 0) == (17348 | 0);
  if ($11) {
   label = 3;
   break;
  }
  $13 = $3;
  $14 = $13 + 12 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = ($15 | 0) != (515 | 0);
  $17 = $3;
  if ($16) {
   label = 5;
   break;
  }
  $21 = $17 + 52 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = ($22 | 0) == (0 | 0);
  if ($23) {
   label = 7;
   break;
  }
  $25 = $3;
  $26 = $25 + 52 | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = ($28 | 0) == (18952 | 0);
  $30 = $3;
  $31 = $30 + 52 | 0;
  $32 = HEAP32[$31 >> 2] | 0;
  if ($29) {
   label = 9;
   break;
  }
  $3 = $32;
 }
 if ((label | 0) == 3) {
  $12 = $5;
  $2 = $12;
  $53 = $2;
  STACKTOP = sp;
  return $53 | 0;
 } else if ((label | 0) == 5) {
  $18 = $4;
  HEAP32[$18 >> 2] = $17;
  $19 = $5;
  $20 = $19 + 1 | 0;
  $2 = $20;
  $53 = $2;
  STACKTOP = sp;
  return $53 | 0;
 } else if ((label | 0) == 7) {
  $24 = $5;
  $2 = $24;
  $53 = $2;
  STACKTOP = sp;
  return $53 | 0;
 } else if ((label | 0) == 9) {
  $6 = $32;
  $33 = $6;
  $34 = $33 + 8 | 0;
  $7 = $34;
  $35 = $7;
  $36 = $6;
  $37 = $36 + 4 | 0;
  $38 = HEAP32[$37 >> 2] | 0;
  $39 = $35 + ($38 << 2) | 0;
  $8 = $39;
  while (1) {
   $40 = $7;
   $41 = $8;
   $42 = $40 >>> 0 < $41 >>> 0;
   if (!$42) {
    break;
   }
   $43 = $7;
   $44 = HEAP32[$43 >> 2] | 0;
   $9 = $44;
   $45 = $9;
   $46 = $4;
   $47 = _instance_count_native_bases($45, $46) | 0;
   $48 = $5;
   $49 = $48 + $47 | 0;
   $5 = $49;
   $50 = $7;
   $51 = $50 + 4 | 0;
   $7 = $51;
  }
  $52 = $5;
  $2 = $52;
  $53 = $2;
  STACKTOP = sp;
  return $53 | 0;
 }
 return 0 | 0;
}

function _erfc($0) {
 $0 = +$0;
 var $$0 = 0.0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0, $13 = 0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0, $36 = 0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0.0, $42 = 0.0, $43 = 0.0, $44 = 0, $45 = 0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0.0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = _bitshift64Lshr($1 | 0, $2 | 0, 63) | 0;
 $4 = getTempRet0() | 0;
 $5 = $2 & 2147483647;
 $6 = $5 >>> 0 > 2146435071;
 do {
  if ($6) {
   $7 = _bitshift64Shl($3 | 0, $4 | 0, 1) | 0;
   $8 = getTempRet0() | 0;
   $9 = +($7 | 0);
   $10 = 1.0 / $0;
   $11 = $10 + $9;
   $$0 = $11;
  } else {
   $12 = $5 >>> 0 < 1072365568;
   if (!$12) {
    $44 = $5 >>> 0 < 1077673984;
    $45 = ($3 | 0) != 0;
    if ($44) {
     $46 = +_erfc2($5, $0);
     $47 = 2.0 - $46;
     $48 = $45 ? $47 : $46;
     $$0 = $48;
     break;
    } else {
     $49 = $45 ? 2.0 : 0.0;
     $$0 = $49;
     break;
    }
   }
   $13 = $5 >>> 0 < 1013972992;
   if ($13) {
    $14 = 1.0 - $0;
    $$0 = $14;
    break;
   }
   $15 = $0 * $0;
   $16 = $15 * 2.3763016656650163e-05;
   $17 = -.005770270296489442 - $16;
   $18 = $15 * $17;
   $19 = $18 + -.02848174957559851;
   $20 = $15 * $19;
   $21 = $20 + -.3250421072470015;
   $22 = $15 * $21;
   $23 = $22 + .12837916709551256;
   $24 = $15 * 3.960228278775368e-06;
   $25 = 1.3249473800432164e-04 - $24;
   $26 = $15 * $25;
   $27 = $26 + .005081306281875766;
   $28 = $15 * $27;
   $29 = $28 + .0650222499887673;
   $30 = $15 * $29;
   $31 = $30 + .39791722395915535;
   $32 = $15 * $31;
   $33 = $32 + 1.0;
   $34 = $23 / $33;
   $35 = ($3 | 0) != 0;
   $36 = $5 >>> 0 < 1070596096;
   $or$cond = $35 | $36;
   if ($or$cond) {
    $37 = $34 * $0;
    $38 = $37 + $0;
    $39 = 1.0 - $38;
    $$0 = $39;
    break;
   } else {
    $40 = $0 + -.5;
    $41 = $34 * $0;
    $42 = $40 + $41;
    $43 = .5 - $42;
    $$0 = $43;
    break;
   }
  }
 } while (0);
 return +$$0;
}

function _mp_import_from($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer = sp;
 $5 = sp + 24 | 0;
 $6 = sp + 20 | 0;
 $3 = $0;
 $4 = $1;
 $11 = $3;
 $12 = $4;
 _mp_load_method_maybe($11, $12, $5);
 $13 = $5 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = ($14 | 0) != (0 | 0);
 if ($15) {
  $16 = $4;
  HEAP32[$vararg_buffer >> 2] = $16;
  $17 = _mp_obj_new_exception_msg_varg(15412, 29946, $vararg_buffer) | 0;
  _nlr_jump($17);
 }
 $18 = HEAP32[$5 >> 2] | 0;
 $19 = ($18 | 0) != (0 | 0);
 if ($19) {
  $20 = HEAP32[$5 >> 2] | 0;
  $2 = $20;
  $53 = $2;
  STACKTOP = sp;
  return $53 | 0;
 }
 $21 = $3;
 $22 = _mp_obj_is_package($21) | 0;
 if (!$22) {
  $16 = $4;
  HEAP32[$vararg_buffer >> 2] = $16;
  $17 = _mp_obj_new_exception_msg_varg(15412, 29946, $vararg_buffer) | 0;
  _nlr_jump($17);
 }
 $23 = $3;
 _mp_load_method_maybe($23, 23, $5);
 $24 = HEAP32[$5 >> 2] | 0;
 $25 = _mp_obj_str_get_data($24, $6) | 0;
 $7 = $25;
 $26 = HEAP32[$6 >> 2] | 0;
 $27 = $26 + 1 | 0;
 $28 = $4;
 $29 = _qstr_len($28) | 0;
 $30 = $27 + $29 | 0;
 $8 = $30;
 $31 = $8;
 $32 = _mp_local_alloc_752($31) | 0;
 $9 = $32;
 $33 = $9;
 $34 = $7;
 $35 = HEAP32[$6 >> 2] | 0;
 _memcpy($33 | 0, $34 | 0, $35 | 0) | 0;
 $36 = $9;
 $37 = HEAP32[$6 >> 2] | 0;
 $38 = $36 + $37 | 0;
 HEAP8[$38 >> 0] = 46;
 $39 = $9;
 $40 = HEAP32[$6 >> 2] | 0;
 $41 = $39 + $40 | 0;
 $42 = $41 + 1 | 0;
 $43 = $4;
 $44 = _qstr_str($43) | 0;
 $45 = $4;
 $46 = _qstr_len($45) | 0;
 _memcpy($42 | 0, $44 | 0, $46 | 0) | 0;
 $47 = $9;
 $48 = $8;
 $49 = _qstr_from_strn($47, $48) | 0;
 $10 = $49;
 $50 = $9;
 _mp_local_free_753($50);
 $51 = $10;
 $52 = _mp_import_name($51, 13864, 1) | 0;
 $2 = $52;
 $53 = $2;
 STACKTOP = sp;
 return $53 | 0;
}

function _instance_subscr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $8 = sp;
 $9 = sp + 24 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $12 = $4;
 $7 = $12;
 HEAP32[$8 >> 2] = 0;
 $13 = $8 + 4 | 0;
 HEAP32[$13 >> 2] = 0;
 $14 = $13 + 4 | 0;
 $15 = $5;
 HEAP32[$14 >> 2] = $15;
 $16 = $14 + 4 | 0;
 $17 = $6;
 HEAP32[$16 >> 2] = $17;
 $18 = $7;
 HEAP32[$9 >> 2] = $18;
 $19 = $9 + 4 | 0;
 HEAP32[$19 >> 2] = 0;
 $20 = $9 + 8 | 0;
 HEAP32[$20 >> 2] = 32;
 $21 = $9 + 12 | 0;
 HEAP32[$21 >> 2] = $8;
 $22 = $9 + 16 | 0;
 HEAP8[$22 >> 0] = 0;
 $23 = $6;
 $24 = ($23 | 0) == (0 | 0);
 do {
  if ($24) {
   $25 = $9 + 4 | 0;
   HEAP32[$25 >> 2] = 11;
  } else {
   $26 = $6;
   $27 = ($26 | 0) == (4 | 0);
   $28 = $9 + 4 | 0;
   if ($27) {
    HEAP32[$28 >> 2] = 15;
    break;
   } else {
    HEAP32[$28 >> 2] = 28;
    break;
   }
  }
 } while (0);
 $29 = $7;
 $30 = HEAP32[$29 >> 2] | 0;
 _mp_obj_class_lookup($9, $30);
 $31 = HEAP32[$8 >> 2] | 0;
 $32 = ($31 | 0) == (4 | 0);
 if ($32) {
  $33 = $7;
  $34 = $33 + 16 | 0;
  $35 = HEAP32[$34 >> 2] | 0;
  $36 = $5;
  $37 = $6;
  $38 = _mp_obj_subscr($35, $36, $37) | 0;
  $3 = $38;
  $52 = $3;
  STACKTOP = sp;
  return $52 | 0;
 }
 $39 = HEAP32[$8 >> 2] | 0;
 $40 = ($39 | 0) != (0 | 0);
 if (!$40) {
  $3 = 0;
  $52 = $3;
  STACKTOP = sp;
  return $52 | 0;
 }
 $41 = $6;
 $42 = ($41 | 0) == (0 | 0);
 $43 = $6;
 $44 = ($43 | 0) == (4 | 0);
 $45 = $42 ? 1 : $44;
 $46 = $45 ? 1 : 2;
 $10 = $46;
 $47 = $10;
 $48 = _mp_call_method_n_kw($47, 0, $8) | 0;
 $11 = $48;
 $49 = $6;
 $50 = ($49 | 0) == (4 | 0);
 if ($50) {
  $51 = $11;
  $3 = $51;
  $52 = $3;
  STACKTOP = sp;
  return $52 | 0;
 } else {
  $3 = 17668;
  $52 = $3;
  STACKTOP = sp;
  return $52 | 0;
 }
 return 0 | 0;
}

function _mp_binary_get_int($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $9 = sp;
 $4 = $0;
 $11 = $1 & 1;
 $5 = $11;
 $12 = $2 & 1;
 $6 = $12;
 $7 = $3;
 $13 = $6;
 $14 = $13 & 1;
 if ($14) {
  $8 = 1;
 } else {
  $8 = -1;
  $15 = $4;
  $16 = $15 - 1 | 0;
  $17 = $7;
  $18 = $17 + $16 | 0;
  $7 = $18;
 }
 $19 = $9;
 $20 = $19;
 HEAP32[$20 >> 2] = 0;
 $21 = $19 + 4 | 0;
 $22 = $21;
 HEAP32[$22 >> 2] = 0;
 $23 = $5;
 $24 = $23 & 1;
 if ($24) {
  $25 = $7;
  $26 = HEAP8[$25 >> 0] | 0;
  $27 = $26 & 255;
  $28 = $27 & 128;
  $29 = ($28 | 0) != 0;
  if ($29) {
   $30 = $9;
   $31 = $30;
   HEAP32[$31 >> 2] = -1;
   $32 = $30 + 4 | 0;
   $33 = $32;
   HEAP32[$33 >> 2] = -1;
  }
 }
 $10 = 0;
 while (1) {
  $34 = $10;
  $35 = $4;
  $36 = $34 >>> 0 < $35 >>> 0;
  $37 = $9;
  $38 = $37;
  $39 = HEAP32[$38 >> 2] | 0;
  $40 = $37 + 4 | 0;
  $41 = $40;
  $42 = HEAP32[$41 >> 2] | 0;
  if (!$36) {
   break;
  }
  $43 = _bitshift64Shl($39 | 0, $42 | 0, 8) | 0;
  $44 = getTempRet0() | 0;
  $45 = $9;
  $46 = $45;
  HEAP32[$46 >> 2] = $43;
  $47 = $45 + 4 | 0;
  $48 = $47;
  HEAP32[$48 >> 2] = $44;
  $49 = $7;
  $50 = HEAP8[$49 >> 0] | 0;
  $51 = $50 & 255;
  $52 = $9;
  $53 = $52;
  $54 = HEAP32[$53 >> 2] | 0;
  $55 = $52 + 4 | 0;
  $56 = $55;
  $57 = HEAP32[$56 >> 2] | 0;
  $58 = $54 | $51;
  $59 = $9;
  $60 = $59;
  HEAP32[$60 >> 2] = $58;
  $61 = $59 + 4 | 0;
  $62 = $61;
  HEAP32[$62 >> 2] = $57;
  $63 = $8;
  $64 = $7;
  $65 = $64 + $63 | 0;
  $7 = $65;
  $66 = $10;
  $67 = $66 + 1 | 0;
  $10 = $67;
 }
 setTempRet0($42 | 0);
 STACKTOP = sp;
 return $39 | 0;
}

function _mp_obj_print_exception($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, $vararg_ptr1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $4 = sp + 24 | 0;
 $5 = sp + 20 | 0;
 $2 = $0;
 $3 = $1;
 $8 = $3;
 $9 = _mp_obj_is_exception_instance($8) | 0;
 if (!$9) {
  $39 = $2;
  $40 = $3;
  _mp_obj_print_helper($39, $40, 2);
  $41 = $2;
  _mp_print_str($41, 34812) | 0;
  STACKTOP = sp;
  return;
 }
 $10 = $3;
 _mp_obj_exception_get_traceback($10, $4, $5);
 $11 = HEAP32[$4 >> 2] | 0;
 $12 = $11 >>> 0 > 0;
 if (!$12) {
  $39 = $2;
  $40 = $3;
  _mp_obj_print_helper($39, $40, 2);
  $41 = $2;
  _mp_print_str($41, 34812) | 0;
  STACKTOP = sp;
  return;
 }
 $13 = $2;
 _mp_print_str($13, 30357) | 0;
 $14 = HEAP32[$4 >> 2] | 0;
 $15 = $14 - 3 | 0;
 $6 = $15;
 while (1) {
  $16 = $6;
  $17 = ($16 | 0) >= 0;
  if (!$17) {
   break;
  }
  $18 = $2;
  $19 = HEAP32[$5 >> 2] | 0;
  $20 = $6;
  $21 = $19 + ($20 << 2) | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = HEAP32[$5 >> 2] | 0;
  $24 = $6;
  $25 = $24 + 1 | 0;
  $26 = $23 + ($25 << 2) | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  HEAP32[$vararg_buffer >> 2] = $22;
  $vararg_ptr1 = $vararg_buffer + 4 | 0;
  HEAP32[$vararg_ptr1 >> 2] = $27;
  _mp_printf($18, 30393, $vararg_buffer) | 0;
  $28 = HEAP32[$5 >> 2] | 0;
  $29 = $6;
  $30 = $29 + 2 | 0;
  $31 = $28 + ($30 << 2) | 0;
  $32 = HEAP32[$31 >> 2] | 0;
  $7 = $32;
  $33 = $7;
  $34 = ($33 | 0) == 0;
  $35 = $2;
  if ($34) {
   _mp_print_str($35, 34812) | 0;
  } else {
   $36 = $7;
   HEAP32[$vararg_buffer2 >> 2] = $36;
   _mp_printf($35, 30414, $vararg_buffer2) | 0;
  }
  $37 = $6;
  $38 = $37 - 3 | 0;
  $6 = $38;
 }
 $39 = $2;
 $40 = $3;
 _mp_obj_print_helper($39, $40, 2);
 $41 = $2;
 _mp_print_str($41, 34812) | 0;
 STACKTOP = sp;
 return;
}

function _erf($0) {
 $0 = +$0;
 var $$0 = 0.0, $$041 = 0.0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0, $14 = 0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0.0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0, $42 = 0.0, $43 = 0.0, $44 = 0, $45 = 0, $46 = 0, $47 = 0.0, $48 = 0.0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = _bitshift64Lshr($1 | 0, $2 | 0, 63) | 0;
 $4 = getTempRet0() | 0;
 $5 = $2 & 2147483647;
 $6 = $5 >>> 0 > 2146435071;
 do {
  if ($6) {
   $7 = _bitshift64Shl($3 | 0, $4 | 0, 1) | 0;
   $8 = getTempRet0() | 0;
   $9 = 1 - $7 | 0;
   $10 = +($9 | 0);
   $11 = 1.0 / $0;
   $12 = $11 + $10;
   $$0 = $12;
  } else {
   $13 = $5 >>> 0 < 1072365568;
   if ($13) {
    $14 = $5 >>> 0 < 1043333120;
    if ($14) {
     $15 = $0 * 8.0;
     $16 = $0 * 1.0270333367641007;
     $17 = $15 + $16;
     $18 = $17 * .125;
     $$0 = $18;
     break;
    } else {
     $19 = $0 * $0;
     $20 = $19 * 2.3763016656650163e-05;
     $21 = -.005770270296489442 - $20;
     $22 = $19 * $21;
     $23 = $22 + -.02848174957559851;
     $24 = $19 * $23;
     $25 = $24 + -.3250421072470015;
     $26 = $19 * $25;
     $27 = $26 + .12837916709551256;
     $28 = $19 * 3.960228278775368e-06;
     $29 = 1.3249473800432164e-04 - $28;
     $30 = $19 * $29;
     $31 = $30 + .005081306281875766;
     $32 = $19 * $31;
     $33 = $32 + .0650222499887673;
     $34 = $19 * $33;
     $35 = $34 + .39791722395915535;
     $36 = $19 * $35;
     $37 = $36 + 1.0;
     $38 = $27 / $37;
     $39 = $38 * $0;
     $40 = $39 + $0;
     $$0 = $40;
     break;
    }
   } else {
    $41 = $5 >>> 0 < 1075314688;
    if ($41) {
     $42 = +_erfc2($5, $0);
     $43 = 1.0 - $42;
     $$041 = $43;
    } else {
     $$041 = 1.0;
    }
    $44 = ($3 | 0) == 0;
    $45 = ($4 | 0) == 0;
    $46 = $44 & $45;
    $47 = -$$041;
    $48 = $46 ? $$041 : $47;
    $$0 = $48;
    break;
   }
  }
 } while (0);
 return +$$0;
}

function _qstr_add($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $4 = HEAP32[40572 >> 2] | 0;
 $5 = $4 + 12 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = HEAP32[40572 >> 2] | 0;
 $8 = $7 + 8 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $6 >>> 0 >= $9 >>> 0;
 do {
  if ($10) {
   $11 = HEAP32[40572 >> 2] | 0;
   $12 = $11 + 8 | 0;
   $13 = HEAP32[$12 >> 2] | 0;
   $14 = $13 << 1;
   $2 = $14;
   $15 = $2;
   $16 = $15 << 2;
   $17 = 16 + $16 | 0;
   $18 = _m_malloc_maybe($17) | 0;
   $3 = $18;
   $19 = $3;
   $20 = ($19 | 0) == (0 | 0);
   if ($20) {
    $21 = $2;
    _m_malloc_fail($21);
   } else {
    $22 = HEAP32[40572 >> 2] | 0;
    $23 = $3;
    HEAP32[$23 >> 2] = $22;
    $24 = HEAP32[40572 >> 2] | 0;
    $25 = $24 + 4 | 0;
    $26 = HEAP32[$25 >> 2] | 0;
    $27 = HEAP32[40572 >> 2] | 0;
    $28 = $27 + 12 | 0;
    $29 = HEAP32[$28 >> 2] | 0;
    $30 = $26 + $29 | 0;
    $31 = $3;
    $32 = $31 + 4 | 0;
    HEAP32[$32 >> 2] = $30;
    $33 = $2;
    $34 = $3;
    $35 = $34 + 8 | 0;
    HEAP32[$35 >> 2] = $33;
    $36 = $3;
    $37 = $36 + 12 | 0;
    HEAP32[$37 >> 2] = 0;
    $38 = $3;
    HEAP32[40572 >> 2] = $38;
    break;
   }
  }
 } while (0);
 $39 = $1;
 $40 = HEAP32[40572 >> 2] | 0;
 $41 = $40 + 16 | 0;
 $42 = HEAP32[40572 >> 2] | 0;
 $43 = $42 + 12 | 0;
 $44 = HEAP32[$43 >> 2] | 0;
 $45 = $44 + 1 | 0;
 HEAP32[$43 >> 2] = $45;
 $46 = $41 + ($44 << 2) | 0;
 HEAP32[$46 >> 2] = $39;
 $47 = HEAP32[40572 >> 2] | 0;
 $48 = $47 + 4 | 0;
 $49 = HEAP32[$48 >> 2] | 0;
 $50 = HEAP32[40572 >> 2] | 0;
 $51 = $50 + 12 | 0;
 $52 = HEAP32[$51 >> 2] | 0;
 $53 = $49 + $52 | 0;
 $54 = $53 - 1 | 0;
 STACKTOP = sp;
 return $54 | 0;
}

function _array_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $4;
 $6 = $8;
 $9 = $6;
 $10 = $9 + 4 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $11 & 255;
 $13 = ($12 | 0) == 1;
 $14 = $3;
 if ($13) {
  _mp_print_str($14, 30825) | 0;
  $15 = $3;
  $16 = $6;
  $17 = $16 + 12 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = $6;
  $20 = $19 + 8 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  _mp_str_print_quoted($15, $18, $21, 1);
  $53 = $3;
  _mp_print_str($53, 32991) | 0;
  STACKTOP = sp;
  return;
 }
 $22 = $6;
 $23 = $22 + 4 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $24 & 255;
 HEAP32[$vararg_buffer >> 2] = $25;
 _mp_printf($14, 30837, $vararg_buffer) | 0;
 $26 = $6;
 $27 = $26 + 8 | 0;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = $28 >>> 0 > 0;
 if (!$29) {
  $53 = $3;
  _mp_print_str($53, 32991) | 0;
  STACKTOP = sp;
  return;
 }
 $30 = $3;
 _mp_print_str($30, 30848) | 0;
 $7 = 0;
 while (1) {
  $31 = $7;
  $32 = $6;
  $33 = $32 + 8 | 0;
  $34 = HEAP32[$33 >> 2] | 0;
  $35 = $31 >>> 0 < $34 >>> 0;
  if (!$35) {
   break;
  }
  $36 = $7;
  $37 = $36 >>> 0 > 0;
  if ($37) {
   $38 = $3;
   _mp_print_str($38, 33327) | 0;
  }
  $39 = $3;
  $40 = $6;
  $41 = $40 + 4 | 0;
  $42 = HEAP32[$41 >> 2] | 0;
  $43 = $42 & 255;
  $44 = $43 & 255;
  $45 = $6;
  $46 = $45 + 12 | 0;
  $47 = HEAP32[$46 >> 2] | 0;
  $48 = $7;
  $49 = _mp_binary_get_val_array($44, $47, $48) | 0;
  _mp_obj_print_helper($39, $49, 1);
  $50 = $7;
  $51 = $50 + 1 | 0;
  $7 = $51;
 }
 $52 = $3;
 _mp_print_str($52, 32987) | 0;
 $53 = $3;
 _mp_print_str($53, 32991) | 0;
 STACKTOP = sp;
 return;
}

function _set_issubset_internal($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $3 = sp + 40 | 0;
 $4 = sp + 36 | 0;
 $11 = sp + 8 | 0;
 HEAP32[$3 >> 2] = $0;
 HEAP32[$4 >> 2] = $1;
 $14 = $2 & 1;
 $5 = $14;
 $7 = 0;
 $15 = HEAP32[$3 >> 2] | 0;
 $16 = _is_set_or_frozenset($15) | 0;
 if ($16) {
  $17 = HEAP32[$3 >> 2] | 0;
  $6 = $17;
 } else {
  $18 = _set_make_new(17860, 1, 0, $3) | 0;
  $6 = $18;
  $7 = 1;
 }
 $9 = 0;
 $19 = HEAP32[$4 >> 2] | 0;
 $20 = _is_set_or_frozenset($19) | 0;
 if ($20) {
  $21 = HEAP32[$4 >> 2] | 0;
  $8 = $21;
 } else {
  $22 = _set_make_new(17860, 1, 0, $4) | 0;
  $8 = $22;
  $9 = 1;
 }
 $10 = 13864;
 $23 = $5;
 $24 = $23 & 1;
 if ($24) {
  $25 = $6;
  $26 = $25 + 4 | 0;
  $27 = $26 + 4 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = $8;
  $30 = $29 + 4 | 0;
  $31 = $30 + 4 | 0;
  $32 = HEAP32[$31 >> 2] | 0;
  $33 = ($28 | 0) == ($32 | 0);
  if ($33) {
   $10 = 13856;
  } else {
   label = 10;
  }
 } else {
  label = 10;
 }
 L12 : do {
  if ((label | 0) == 10) {
   $34 = $6;
   $35 = _set_getiter($34, $11) | 0;
   $12 = $35;
   while (1) {
    $36 = $12;
    $37 = _set_it_iternext($36) | 0;
    $13 = $37;
    $38 = ($37 | 0) != (0 | 0);
    if (!$38) {
     break L12;
    }
    $39 = $8;
    $40 = $39 + 4 | 0;
    $41 = $13;
    $42 = _mp_set_lookup($40, $41, 0) | 0;
    $43 = ($42 | 0) != (0 | 0);
    if (!$43) {
     break;
    }
   }
   $10 = 13856;
  }
 } while (0);
 $44 = $7;
 $45 = $44 & 1;
 if ($45) {
  $46 = $6;
  _set_clear($46) | 0;
 }
 $47 = $9;
 $48 = $47 & 1;
 if (!$48) {
  $50 = $10;
  STACKTOP = sp;
  return $50 | 0;
 }
 $49 = $8;
 _set_clear($49) | 0;
 $50 = $10;
 STACKTOP = sp;
 return $50 | 0;
}

function _mpz_divmod_inpl($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $8 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $4;
 $10 = $6;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $12 + 1 | 0;
 _mpz_need_dig($9, $13);
 $14 = $4;
 $15 = $14 + 8 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $6;
 $18 = $17 + 4 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $19 + 1 | 0;
 $21 = $20 << 1;
 _memset($16 | 0, 0, $21 | 0) | 0;
 $22 = $4;
 $23 = $22 + 4 | 0;
 HEAP32[$23 >> 2] = 0;
 $24 = $5;
 $25 = $6;
 $26 = $25 + 4 | 0;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = $27 + 1 | 0;
 _mpz_need_dig($24, $28);
 $29 = $5;
 $30 = $6;
 _mpz_set($29, $30);
 $31 = $5;
 $32 = $31 + 8 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = $5;
 $35 = $34 + 4 | 0;
 $36 = $7;
 $37 = $36 + 8 | 0;
 $38 = HEAP32[$37 >> 2] | 0;
 $39 = $7;
 $40 = $39 + 4 | 0;
 $41 = HEAP32[$40 >> 2] | 0;
 $42 = $4;
 $43 = $42 + 8 | 0;
 $44 = HEAP32[$43 >> 2] | 0;
 $45 = $4;
 $46 = $45 + 4 | 0;
 _mpn_div($33, $35, $38, $41, $44, $46);
 $47 = $6;
 $48 = HEAP32[$47 >> 2] | 0;
 $49 = $48 & 1;
 $50 = $7;
 $51 = HEAP32[$50 >> 2] | 0;
 $52 = $51 & 1;
 $53 = ($49 | 0) != ($52 | 0);
 if (!$53) {
  STACKTOP = sp;
  return;
 }
 $54 = $4;
 $55 = HEAP32[$54 >> 2] | 0;
 $56 = $55 & -2;
 $57 = $56 | 1;
 HEAP32[$54 >> 2] = $57;
 $58 = $5;
 $59 = _mpz_is_zero($58) | 0;
 if ($59) {
  STACKTOP = sp;
  return;
 }
 _mpz_init_from_int($8, -1);
 $60 = $4;
 $61 = $4;
 _mpz_add_inpl($60, $61, $8);
 $62 = $5;
 $63 = $5;
 $64 = $7;
 _mpz_add_inpl($62, $63, $64);
 STACKTOP = sp;
 return;
}

function _mono_horiz_fill_rect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $68 = 0, $69 = 0, $7 = 0, $70 = 0, $71 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 $17 = $6;
 $18 = $17 + 18 | 0;
 $19 = HEAP8[$18 >> 0] | 0;
 $20 = $19 & 255;
 $21 = ($20 | 0) == 4;
 $22 = $21 & 1;
 $12 = $22;
 $23 = $6;
 $24 = $23 + 16 | 0;
 $25 = HEAP16[$24 >> 1] | 0;
 $26 = $25 & 65535;
 $27 = $26 >> 3;
 $13 = $27;
 while (1) {
  $28 = $9;
  $29 = $28 + -1 | 0;
  $9 = $29;
  $30 = ($28 | 0) != 0;
  if (!$30) {
   break;
  }
  $31 = $6;
  $32 = $31 + 8 | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = $7;
  $35 = $34 >> 3;
  $36 = $8;
  $37 = $13;
  $38 = Math_imul($36, $37) | 0;
  $39 = $35 + $38 | 0;
  $40 = $33 + $39 | 0;
  $14 = $40;
  $41 = $12;
  $42 = ($41 | 0) != 0;
  $43 = $7;
  $44 = $43 & 7;
  $45 = 7 - $44 | 0;
  $46 = $42 ? $44 : $45;
  $15 = $46;
  $47 = $10;
  $16 = $47;
  while (1) {
   $48 = $16;
   $49 = ($48 | 0) != 0;
   if (!$49) {
    break;
   }
   $50 = $14;
   $51 = HEAP8[$50 >> 0] | 0;
   $52 = $51 & 255;
   $53 = $15;
   $54 = 1 << $53;
   $55 = $54 ^ -1;
   $56 = $52 & $55;
   $57 = $11;
   $58 = ($57 | 0) != 0;
   $59 = $58 & 1;
   $60 = $15;
   $61 = $59 << $60;
   $62 = $56 | $61;
   $63 = $62 & 255;
   $64 = $14;
   HEAP8[$64 >> 0] = $63;
   $65 = $13;
   $66 = $14;
   $67 = $66 + $65 | 0;
   $14 = $67;
   $68 = $16;
   $69 = $68 + -1 | 0;
   $16 = $69;
  }
  $70 = $7;
  $71 = $70 + 1 | 0;
  $7 = $71;
 }
 STACKTOP = sp;
 return;
}

function _str_startswith_word($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp + 12 | 0;
 $3 = $0;
 $4 = $1;
 $5 = 0;
 while (1) {
  $6 = $3;
  $7 = $5;
  $8 = $6 + $7 | 0;
  $9 = HEAP8[$8 >> 0] | 0;
  $10 = $9 << 24 >> 24;
  $11 = ($10 | 0) != 0;
  if (!$11) {
   break;
  }
  $12 = $4;
  $13 = $5;
  $14 = $12 + $13 | 0;
  $15 = HEAP8[$14 >> 0] | 0;
  $16 = $15 << 24 >> 24;
  $17 = ($16 | 0) != 0;
  if (!$17) {
   break;
  }
  $18 = $3;
  $19 = $5;
  $20 = $18 + $19 | 0;
  $21 = HEAP8[$20 >> 0] | 0;
  $22 = $21 << 24 >> 24;
  $23 = $4;
  $24 = $5;
  $25 = $23 + $24 | 0;
  $26 = HEAP8[$25 >> 0] | 0;
  $27 = $26 << 24 >> 24;
  $28 = ($22 | 0) != ($27 | 0);
  if ($28) {
   label = 5;
   break;
  }
  $29 = $5;
  $30 = $29 + 1 | 0;
  $5 = $30;
 }
 if ((label | 0) == 5) {
  $$expand_i1_val = 0;
  HEAP8[$2 >> 0] = $$expand_i1_val;
  $$pre_trunc = HEAP8[$2 >> 0] | 0;
  $51 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $51 | 0;
 }
 $31 = $4;
 $32 = $5;
 $33 = $31 + $32 | 0;
 $34 = HEAP8[$33 >> 0] | 0;
 $35 = $34 << 24 >> 24;
 $36 = ($35 | 0) == 0;
 if ($36) {
  $37 = $3;
  $38 = $5;
  $39 = $37 + $38 | 0;
  $40 = HEAP8[$39 >> 0] | 0;
  $41 = $40 << 24 >> 24;
  $42 = ($41 | 0) == 0;
  if ($42) {
   $50 = 1;
  } else {
   $43 = $3;
   $44 = $5;
   $45 = $43 + $44 | 0;
   $46 = HEAP8[$45 >> 0] | 0;
   $47 = $46 << 24 >> 24;
   $48 = _unichar_isident($47) | 0;
   $49 = $48 ^ 1;
   $50 = $49;
  }
 } else {
  $50 = 0;
 }
 $$expand_i1_val2 = $50 & 1;
 HEAP8[$2 >> 0] = $$expand_i1_val2;
 $$pre_trunc = HEAP8[$2 >> 0] | 0;
 $51 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $51 | 0;
}

function _mpn_mul($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $67 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $9 = $4;
 $16 = $5;
 $10 = $16;
 $11 = 0;
 while (1) {
  $17 = $9;
  $18 = $17 >>> 0 > 0;
  if (!$18) {
   break;
  }
  $19 = $5;
  $12 = $19;
  $13 = 0;
  $20 = $7;
  $14 = $20;
  $21 = $6;
  $15 = $21;
  while (1) {
   $22 = $14;
   $23 = $22 >>> 0 > 0;
   if (!$23) {
    break;
   }
   $24 = $12;
   $25 = HEAP16[$24 >> 1] | 0;
   $26 = $25 & 65535;
   $27 = $15;
   $28 = HEAP16[$27 >> 1] | 0;
   $29 = $28 & 65535;
   $30 = $8;
   $31 = HEAP16[$30 >> 1] | 0;
   $32 = $31 & 65535;
   $33 = Math_imul($29, $32) | 0;
   $34 = $26 + $33 | 0;
   $35 = $13;
   $36 = $35 + $34 | 0;
   $13 = $36;
   $37 = $13;
   $38 = $37 & 65535;
   $39 = $38 & 65535;
   $40 = $12;
   HEAP16[$40 >> 1] = $39;
   $41 = $13;
   $42 = $41 >>> 16;
   $13 = $42;
   $43 = $14;
   $44 = $43 + -1 | 0;
   $14 = $44;
   $45 = $15;
   $46 = $45 + 2 | 0;
   $15 = $46;
   $47 = $12;
   $48 = $47 + 2 | 0;
   $12 = $48;
  }
  $49 = $13;
  $50 = ($49 | 0) != 0;
  if ($50) {
   $51 = $13;
   $52 = $51 & 65535;
   $53 = $12;
   $54 = $53 + 2 | 0;
   $12 = $54;
   HEAP16[$53 >> 1] = $52;
  }
  $55 = $12;
  $56 = $10;
  $57 = $55;
  $58 = $56;
  $59 = $57 - $58 | 0;
  $60 = ($59 | 0) / 2 & -1;
  $11 = $60;
  $61 = $9;
  $62 = $61 + -1 | 0;
  $9 = $62;
  $63 = $5;
  $64 = $63 + 2 | 0;
  $5 = $64;
  $65 = $8;
  $66 = $65 + 2 | 0;
  $8 = $66;
 }
 $67 = $11;
 STACKTOP = sp;
 return $67 | 0;
}

function _set_intersect_int($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $11 = $2 & 1;
 $6 = $11;
 $12 = $4;
 $13 = $5;
 $14 = ($12 | 0) == ($13 | 0);
 if ($14) {
  $15 = $6;
  $16 = $15 & 1;
  if ($16) {
   $19 = 17668;
  } else {
   $17 = $4;
   $18 = _set_copy($17) | 0;
   $19 = $18;
  }
  $3 = $19;
  $63 = $3;
  STACKTOP = sp;
  return $63 | 0;
 }
 $20 = $4;
 $7 = $20;
 $21 = _mp_obj_new_set(0, 0) | 0;
 $8 = $21;
 $22 = $5;
 $23 = _mp_getiter($22, 0) | 0;
 $9 = $23;
 while (1) {
  $24 = $9;
  $25 = _mp_iternext($24) | 0;
  $10 = $25;
  $26 = ($25 | 0) != (0 | 0);
  if (!$26) {
   break;
  }
  $27 = $7;
  $28 = $27 + 4 | 0;
  $29 = $10;
  $30 = _mp_set_lookup($28, $29, 0) | 0;
  $31 = ($30 | 0) != (0 | 0);
  if ($31) {
   $32 = $8;
   $33 = $10;
   _set_add($32, $33) | 0;
  }
 }
 $34 = $6;
 $35 = $34 & 1;
 if ($35) {
  $36 = $7;
  $37 = $36 + 4 | 0;
  $38 = $37 + 8 | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  _m_free($39);
  $40 = $8;
  $41 = $40 + 4 | 0;
  $42 = HEAP32[$41 >> 2] | 0;
  $43 = $7;
  $44 = $43 + 4 | 0;
  HEAP32[$44 >> 2] = $42;
  $45 = $8;
  $46 = $45 + 4 | 0;
  $47 = $46 + 4 | 0;
  $48 = HEAP32[$47 >> 2] | 0;
  $49 = $7;
  $50 = $49 + 4 | 0;
  $51 = $50 + 4 | 0;
  HEAP32[$51 >> 2] = $48;
  $52 = $8;
  $53 = $52 + 4 | 0;
  $54 = $53 + 8 | 0;
  $55 = HEAP32[$54 >> 2] | 0;
  $56 = $7;
  $57 = $56 + 4 | 0;
  $58 = $57 + 8 | 0;
  HEAP32[$58 >> 2] = $55;
 }
 $59 = $6;
 $60 = $59 & 1;
 $61 = $8;
 $62 = $60 ? 17668 : $61;
 $3 = $62;
 $63 = $3;
 STACKTOP = sp;
 return $63 | 0;
}

function _memcpy(dest, src, num) {
 dest = dest | 0;
 src = src | 0;
 num = num | 0;
 var ret = 0, aligned_dest_end = 0, block_aligned_dest_end = 0, dest_end = 0;
 if ((num | 0) >= 8192) {
  _emscripten_memcpy_big(dest | 0, src | 0, num | 0) | 0;
  return dest | 0;
 }
 ret = dest | 0;
 dest_end = dest + num | 0;
 if ((dest & 3) == (src & 3)) {
  while (dest & 3) {
   if ((num | 0) == 0) return ret | 0;
   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
   dest = dest + 1 | 0;
   src = src + 1 | 0;
   num = num - 1 | 0;
  }
  aligned_dest_end = dest_end & -4 | 0;
  block_aligned_dest_end = aligned_dest_end - 64 | 0;
  while ((dest | 0) <= (block_aligned_dest_end | 0)) {
   HEAP32[dest >> 2] = HEAP32[src >> 2] | 0;
   HEAP32[dest + 4 >> 2] = HEAP32[src + 4 >> 2] | 0;
   HEAP32[dest + 8 >> 2] = HEAP32[src + 8 >> 2] | 0;
   HEAP32[dest + 12 >> 2] = HEAP32[src + 12 >> 2] | 0;
   HEAP32[dest + 16 >> 2] = HEAP32[src + 16 >> 2] | 0;
   HEAP32[dest + 20 >> 2] = HEAP32[src + 20 >> 2] | 0;
   HEAP32[dest + 24 >> 2] = HEAP32[src + 24 >> 2] | 0;
   HEAP32[dest + 28 >> 2] = HEAP32[src + 28 >> 2] | 0;
   HEAP32[dest + 32 >> 2] = HEAP32[src + 32 >> 2] | 0;
   HEAP32[dest + 36 >> 2] = HEAP32[src + 36 >> 2] | 0;
   HEAP32[dest + 40 >> 2] = HEAP32[src + 40 >> 2] | 0;
   HEAP32[dest + 44 >> 2] = HEAP32[src + 44 >> 2] | 0;
   HEAP32[dest + 48 >> 2] = HEAP32[src + 48 >> 2] | 0;
   HEAP32[dest + 52 >> 2] = HEAP32[src + 52 >> 2] | 0;
   HEAP32[dest + 56 >> 2] = HEAP32[src + 56 >> 2] | 0;
   HEAP32[dest + 60 >> 2] = HEAP32[src + 60 >> 2] | 0;
   dest = dest + 64 | 0;
   src = src + 64 | 0;
  }
  while ((dest | 0) < (aligned_dest_end | 0)) {
   HEAP32[dest >> 2] = HEAP32[src >> 2] | 0;
   dest = dest + 4 | 0;
   src = src + 4 | 0;
  }
 } else {
  aligned_dest_end = dest_end - 4 | 0;
  while ((dest | 0) < (aligned_dest_end | 0)) {
   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
   HEAP8[dest + 1 >> 0] = HEAP8[src + 1 >> 0] | 0;
   HEAP8[dest + 2 >> 0] = HEAP8[src + 2 >> 0] | 0;
   HEAP8[dest + 3 >> 0] = HEAP8[src + 3 >> 0] | 0;
   dest = dest + 4 | 0;
   src = src + 4 | 0;
  }
 }
 while ((dest | 0) < (dest_end | 0)) {
  HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
  dest = dest + 1 | 0;
  src = src + 1 | 0;
 }
 return ret | 0;
}

function _fun_bc_call($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $15 = $4;
 $8 = $15;
 $16 = $8;
 $17 = $16 + 8 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = _mp_decode_uint_value($18) | 0;
 $9 = $19;
 $20 = $8;
 $21 = $20 + 8 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = _mp_decode_uint_skip($22) | 0;
 $24 = _mp_decode_uint_value($23) | 0;
 $11 = $24;
 $25 = $9;
 $26 = $25 << 2;
 $27 = $11;
 $28 = $27 * 12 | 0;
 $29 = $26 + $28 | 0;
 $10 = $29;
 $12 = 0;
 $30 = $10;
 $31 = 20 + $30 | 0;
 $32 = _mp_pystack_alloc($31) | 0;
 $12 = $32;
 $33 = $8;
 $34 = $12;
 HEAP32[$34 >> 2] = $33;
 $35 = $12;
 $36 = $35 + 4 | 0;
 HEAP32[$36 >> 2] = 0;
 $37 = $12;
 $38 = $5;
 $39 = $6;
 $40 = $7;
 _mp_setup_code_state($37, $38, $39, $40);
 $41 = _mp_globals_get_988() | 0;
 $42 = $12;
 $43 = $42 + 16 | 0;
 HEAP32[$43 >> 2] = $41;
 $44 = $8;
 $45 = $44 + 4 | 0;
 $46 = HEAP32[$45 >> 2] | 0;
 _mp_globals_set_989($46);
 $47 = $12;
 $48 = _mp_execute_bytecode($47, 0) | 0;
 $13 = $48;
 $49 = $12;
 $50 = $49 + 16 | 0;
 $51 = HEAP32[$50 >> 2] | 0;
 _mp_globals_set_989($51);
 $52 = $13;
 $53 = ($52 | 0) == 0;
 $54 = $12;
 if ($53) {
  $55 = $54 + 8 | 0;
  $56 = HEAP32[$55 >> 2] | 0;
  $57 = HEAP32[$56 >> 2] | 0;
  $14 = $57;
 } else {
  $58 = $54 + 20 | 0;
  $59 = HEAP32[$58 >> 2] | 0;
  $14 = $59;
 }
 $60 = $12;
 _mp_pystack_free_990($60);
 $61 = $13;
 $62 = ($61 | 0) == 0;
 $63 = $14;
 if ($62) {
  STACKTOP = sp;
  return $63 | 0;
 } else {
  _nlr_jump($63);
 }
 return 0 | 0;
}

function _utf8_check($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$expand_i1_val4 = 0, $$expand_i1_val6 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp + 14 | 0;
 $3 = $0;
 $4 = $1;
 $5 = 0;
 $8 = $3;
 $9 = $4;
 $10 = $8 + $9 | 0;
 $6 = $10;
 L1 : while (1) {
  $11 = $3;
  $12 = $6;
  $13 = $11 >>> 0 < $12 >>> 0;
  if (!$13) {
   label = 14;
   break;
  }
  $14 = $3;
  $15 = HEAP8[$14 >> 0] | 0;
  $7 = $15;
  $16 = $5;
  $17 = $16 << 24 >> 24 != 0;
  $18 = $7;
  $19 = $18 & 255;
  do {
   if ($17) {
    $20 = $19 & 192;
    $21 = ($20 | 0) == 128;
    if (!$21) {
     label = 6;
     break L1;
    }
    $22 = $5;
    $23 = $22 + -1 << 24 >> 24;
    $5 = $23;
   } else {
    $24 = ($19 | 0) >= 192;
    $25 = $7;
    $26 = $25 & 255;
    if (!$24) {
     $35 = ($26 | 0) >= 128;
     if ($35) {
      label = 12;
      break L1;
     } else {
      break;
     }
    }
    $27 = ($26 | 0) >= 248;
    if ($27) {
     label = 9;
     break L1;
    }
    $28 = $7;
    $29 = $28 & 255;
    $30 = $29 >> 3;
    $31 = $30 & 6;
    $32 = 229 >> $31;
    $33 = $32 & 3;
    $34 = $33 & 255;
    $5 = $34;
   }
  } while (0);
  $36 = $3;
  $37 = $36 + 1 | 0;
  $3 = $37;
 }
 if ((label | 0) == 6) {
  $$expand_i1_val = 0;
  HEAP8[$2 >> 0] = $$expand_i1_val;
 } else if ((label | 0) == 9) {
  $$expand_i1_val2 = 0;
  HEAP8[$2 >> 0] = $$expand_i1_val2;
 } else if ((label | 0) == 12) {
  $$expand_i1_val4 = 0;
  HEAP8[$2 >> 0] = $$expand_i1_val4;
 } else if ((label | 0) == 14) {
  $38 = $5;
  $39 = $38 & 255;
  $40 = ($39 | 0) == 0;
  $$expand_i1_val6 = $40 & 1;
  HEAP8[$2 >> 0] = $$expand_i1_val6;
 }
 $$pre_trunc = HEAP8[$2 >> 0] | 0;
 $41 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $41 | 0;
}

function _mp_parse_node_get_int_maybe($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$expand_i1_val4 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp + 12 | 0;
 $3 = $0;
 $4 = $1;
 $6 = $3;
 $7 = $6 & 1;
 $8 = ($7 | 0) == 1;
 $9 = $3;
 if ($8) {
  $10 = $9 >> 1;
  $11 = $10 << 1;
  $12 = $11 | 1;
  $13 = $12;
  $14 = $4;
  HEAP32[$14 >> 2] = $13;
  $$expand_i1_val = 1;
  HEAP8[$2 >> 0] = $$expand_i1_val;
  $$pre_trunc = HEAP8[$2 >> 0] | 0;
  $43 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $43 | 0;
 }
 $15 = ($9 | 0) != 0;
 if ($15) {
  $16 = $3;
  $17 = $16 & 3;
  $18 = ($17 | 0) == 0;
  if ($18) {
   $19 = $3;
   $20 = $19;
   $21 = $20 + 4 | 0;
   $22 = HEAP32[$21 >> 2] | 0;
   $23 = $22 & 255;
   $24 = ($23 | 0) == 57;
   if ($24) {
    $25 = $3;
    $26 = $25;
    $5 = $26;
    $27 = $5;
    $28 = $27 + 8 | 0;
    $29 = HEAP32[$28 >> 2] | 0;
    $30 = $29;
    $31 = $4;
    HEAP32[$31 >> 2] = $30;
    $32 = $4;
    $33 = HEAP32[$32 >> 2] | 0;
    $34 = _mp_obj_is_small_int_558($33) | 0;
    if ($34) {
     $42 = 1;
    } else {
     $35 = $4;
     $36 = HEAP32[$35 >> 2] | 0;
     $37 = _mp_obj_is_obj_559($36) | 0;
     if ($37) {
      $38 = $4;
      $39 = HEAP32[$38 >> 2] | 0;
      $40 = HEAP32[$39 >> 2] | 0;
      $41 = ($40 | 0) == (16904 | 0);
      $42 = $41;
     } else {
      $42 = 0;
     }
    }
    $$expand_i1_val2 = $42 & 1;
    HEAP8[$2 >> 0] = $$expand_i1_val2;
    $$pre_trunc = HEAP8[$2 >> 0] | 0;
    $43 = $$pre_trunc & 1;
    STACKTOP = sp;
    return $43 | 0;
   }
  }
 }
 $$expand_i1_val4 = 0;
 HEAP8[$2 >> 0] = $$expand_i1_val4;
 $$pre_trunc = HEAP8[$2 >> 0] | 0;
 $43 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $43 | 0;
}

function _calc_size_items($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 24 | 0;
 $8 = sp + 4 | 0;
 HEAP32[$2 >> 2] = $0;
 $3 = $1;
 $10 = _get_fmt_type($2) | 0;
 $4 = $10;
 $5 = 0;
 $6 = 0;
 while (1) {
  $11 = HEAP32[$2 >> 2] | 0;
  $12 = HEAP8[$11 >> 0] | 0;
  $13 = $12 << 24 >> 24 != 0;
  if (!$13) {
   break;
  }
  $7 = 1;
  $14 = HEAP32[$2 >> 2] | 0;
  $15 = HEAP8[$14 >> 0] | 0;
  $16 = $15 << 24 >> 24;
  $17 = _unichar_isdigit($16) | 0;
  if ($17) {
   $18 = _get_fmt_num($2) | 0;
   $7 = $18;
  }
  $19 = HEAP32[$2 >> 2] | 0;
  $20 = HEAP8[$19 >> 0] | 0;
  $21 = $20 << 24 >> 24;
  $22 = ($21 | 0) == 115;
  L7 : do {
   if ($22) {
    $23 = $5;
    $24 = $23 + 1 | 0;
    $5 = $24;
    $25 = $7;
    $26 = $6;
    $27 = $26 + $25 | 0;
    $6 = $27;
   } else {
    $28 = $7;
    $29 = $5;
    $30 = $29 + $28 | 0;
    $5 = $30;
    $31 = $4;
    $32 = HEAP32[$2 >> 2] | 0;
    $33 = HEAP8[$32 >> 0] | 0;
    $34 = _mp_binary_get_size($31, $33, $8) | 0;
    $9 = $34;
    while (1) {
     $35 = $7;
     $36 = $35 + -1 | 0;
     $7 = $36;
     $37 = ($35 | 0) != 0;
     if (!$37) {
      break L7;
     }
     $38 = $6;
     $39 = HEAP32[$8 >> 2] | 0;
     $40 = $38 + $39 | 0;
     $41 = $40 - 1 | 0;
     $42 = HEAP32[$8 >> 2] | 0;
     $43 = $42 - 1 | 0;
     $44 = $43 ^ -1;
     $45 = $41 & $44;
     $6 = $45;
     $46 = $9;
     $47 = $6;
     $48 = $47 + $46 | 0;
     $6 = $48;
    }
   }
  } while (0);
  $49 = HEAP32[$2 >> 2] | 0;
  $50 = $49 + 1 | 0;
  HEAP32[$2 >> 2] = $50;
 }
 $51 = $6;
 $52 = $3;
 HEAP32[$52 >> 2] = $51;
 $53 = $5;
 STACKTOP = sp;
 return $53 | 0;
}

function _compile_atom_paren($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $6 = $5 + 8 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = ($7 | 0) == 0;
 if ($8) {
  $9 = $2;
  _c_tuple($9, 0, 0);
  STACKTOP = sp;
  return;
 }
 $10 = $3;
 $11 = $10 + 8 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $12;
 $3 = $13;
 $14 = $3;
 $15 = $14 + 8 | 0;
 $16 = $15 + 4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = ($17 | 0) != 0;
 if ($18) {
  $19 = $3;
  $20 = $19 + 8 | 0;
  $21 = $20 + 4 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $22 & 3;
  $24 = ($23 | 0) == 0;
  if ($24) {
   $25 = $3;
   $26 = $25 + 8 | 0;
   $27 = $26 + 4 | 0;
   $28 = HEAP32[$27 >> 2] | 0;
   $29 = $28;
   $4 = $29;
   $30 = $4;
   $31 = $30 + 4 | 0;
   $32 = HEAP32[$31 >> 2] | 0;
   $33 = $32 & 255;
   $34 = ($33 | 0) == 147;
   if ($34) {
    $35 = $2;
    $36 = $3;
    $37 = $36 + 8 | 0;
    $38 = HEAP32[$37 >> 2] | 0;
    _c_tuple($35, $38, 0);
    STACKTOP = sp;
    return;
   }
   $39 = $4;
   $40 = $39 + 4 | 0;
   $41 = HEAP32[$40 >> 2] | 0;
   $42 = $41 & 255;
   $43 = ($42 | 0) == 148;
   if ($43) {
    $44 = $2;
    $45 = $3;
    $46 = $45 + 8 | 0;
    $47 = HEAP32[$46 >> 2] | 0;
    $48 = $4;
    _c_tuple($44, $47, $48);
    STACKTOP = sp;
    return;
   }
   $49 = $4;
   $50 = $49 + 4 | 0;
   $51 = HEAP32[$50 >> 2] | 0;
   $52 = $51 & 255;
   $53 = ($52 | 0) == 171;
   if ($53) {
    $54 = $2;
    $55 = $3;
    _compile_comprehension($54, $55, 6);
    STACKTOP = sp;
    return;
   }
  }
 }
 $56 = $2;
 $57 = $3;
 _c_tuple($56, 0, $57);
 STACKTOP = sp;
 return;
}

function _set_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $10 = $4;
 $6 = $10;
 $11 = $4;
 $12 = _mp_obj_is_obj_1105($11) | 0;
 if ($12) {
  $13 = $4;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = ($14 | 0) == (18084 | 0);
  $17 = $15;
 } else {
  $17 = 0;
 }
 $16 = $17 & 1;
 $7 = $16;
 $18 = $6;
 $19 = $18 + 4 | 0;
 $20 = $19 + 4 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = ($21 | 0) == 0;
 if ($22) {
  $23 = $7;
  $24 = $23 & 1;
  if ($24) {
   $25 = $3;
   _mp_print_str($25, 31678) | 0;
  }
  $26 = $3;
  _mp_print_str($26, 31685) | 0;
  STACKTOP = sp;
  return;
 }
 $8 = 1;
 $27 = $7;
 $28 = $27 & 1;
 if ($28) {
  $29 = $3;
  _mp_print_str($29, 31691) | 0;
 }
 $30 = $3;
 _mp_print_str($30, 31702) | 0;
 $9 = 0;
 while (1) {
  $31 = $9;
  $32 = $6;
  $33 = $32 + 4 | 0;
  $34 = HEAP32[$33 >> 2] | 0;
  $35 = $31 >>> 0 < $34 >>> 0;
  if (!$35) {
   break;
  }
  $36 = $6;
  $37 = $36 + 4 | 0;
  $38 = $9;
  $39 = _mp_set_slot_is_filled_1104($37, $38) | 0;
  if ($39) {
   $40 = $8;
   $41 = $40 & 1;
   if (!$41) {
    $42 = $3;
    _mp_print_str($42, 33327) | 0;
   }
   $8 = 0;
   $43 = $3;
   $44 = $6;
   $45 = $44 + 4 | 0;
   $46 = $45 + 8 | 0;
   $47 = HEAP32[$46 >> 2] | 0;
   $48 = $9;
   $49 = $47 + ($48 << 2) | 0;
   $50 = HEAP32[$49 >> 2] | 0;
   _mp_obj_print_helper($43, $50, 1);
  }
  $51 = $9;
  $52 = $51 + 1 | 0;
  $9 = $52;
 }
 $53 = $3;
 _mp_print_str($53, 31704) | 0;
 $54 = $7;
 $55 = $54 & 1;
 if (!$55) {
  STACKTOP = sp;
  return;
 }
 $56 = $3;
 _mp_print_str($56, 32991) | 0;
 STACKTOP = sp;
 return;
}

function _mp_load_method_maybe($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $5;
 HEAP32[$9 >> 2] = 0;
 $10 = $5;
 $11 = $10 + 4 | 0;
 HEAP32[$11 >> 2] = 0;
 $12 = $3;
 $13 = _mp_obj_get_type($12) | 0;
 $6 = $13;
 $14 = $4;
 $15 = ($14 | 0) == 10;
 if ($15) {
  $16 = $6;
  $17 = $5;
  HEAP32[$17 >> 2] = $16;
  STACKTOP = sp;
  return;
 }
 $18 = $4;
 $19 = ($18 | 0) == 25;
 if ($19) {
  $20 = $6;
  $21 = $20 + 40 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = ($22 | 0) != (0 | 0);
  if ($23) {
   $24 = $5;
   HEAP32[$24 >> 2] = 19780;
   $25 = $3;
   $26 = $5;
   $27 = $26 + 4 | 0;
   HEAP32[$27 >> 2] = $25;
   STACKTOP = sp;
   return;
  }
 }
 $28 = $6;
 $29 = $28 + 28 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = ($30 | 0) != (0 | 0);
 $32 = $6;
 if ($31) {
  $33 = $32 + 28 | 0;
  $34 = HEAP32[$33 >> 2] | 0;
  $35 = $3;
  $36 = $4;
  $37 = $5;
  FUNCTION_TABLE_viii[$34 & 1023]($35, $36, $37);
  STACKTOP = sp;
  return;
 }
 $38 = $32 + 56 | 0;
 $39 = HEAP32[$38 >> 2] | 0;
 $40 = ($39 | 0) != (0 | 0);
 if (!$40) {
  STACKTOP = sp;
  return;
 }
 $41 = $6;
 $42 = $41 + 56 | 0;
 $43 = HEAP32[$42 >> 2] | 0;
 $44 = $43 + 4 | 0;
 $7 = $44;
 $45 = $7;
 $46 = $4;
 $47 = $46 << 2;
 $48 = $47 | 2;
 $49 = $48;
 $50 = _mp_map_lookup($45, $49, 0) | 0;
 $8 = $50;
 $51 = $8;
 $52 = ($51 | 0) != (0 | 0);
 if (!$52) {
  STACKTOP = sp;
  return;
 }
 $53 = $3;
 $54 = $6;
 $55 = $8;
 $56 = $55 + 4 | 0;
 $57 = HEAP32[$56 >> 2] | 0;
 $58 = $5;
 _mp_convert_member_lookup($53, $54, $57, $58);
 STACKTOP = sp;
 return;
}

function _emit_write_code_info_bytes_lines($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 while (1) {
  $9 = $4;
  $10 = $9 >>> 0 > 0;
  $11 = $5;
  $12 = $11 >>> 0 > 0;
  $13 = $10 ? 1 : $12;
  if (!$13) {
   break;
  }
  $14 = $5;
  $15 = $14 >>> 0 <= 6;
  $16 = $4;
  $17 = $16 >>> 0 > 15;
  $or$cond = $15 | $17;
  $18 = $4;
  if ($or$cond) {
   $19 = $18 >>> 0 < 31;
   $20 = $4;
   $21 = $19 ? $20 : 31;
   $6 = $21;
   $22 = $6;
   $23 = $4;
   $24 = $22 >>> 0 < $23 >>> 0;
   if ($24) {
    $7 = 0;
   } else {
    $25 = $5;
    $26 = $25 >>> 0 < 3;
    $27 = $5;
    $28 = $26 ? $27 : 3;
    $7 = $28;
   }
   $29 = $6;
   $30 = $7;
   $31 = $30 << 5;
   $32 = $29 | $31;
   $33 = $32 & 255;
   $34 = $3;
   $35 = _emit_get_cur_to_write_code_info($34, 1) | 0;
   HEAP8[$35 >> 0] = $33;
  } else {
   $36 = $18 >>> 0 < 15;
   $37 = $4;
   $38 = $36 ? $37 : 15;
   $6 = $38;
   $39 = $5;
   $40 = $39 >>> 0 < 2047;
   $41 = $5;
   $42 = $40 ? $41 : 2047;
   $7 = $42;
   $43 = $3;
   $44 = _emit_get_cur_to_write_code_info($43, 2) | 0;
   $8 = $44;
   $45 = $6;
   $46 = 128 | $45;
   $47 = $7;
   $48 = $47 >>> 4;
   $49 = $48 & 112;
   $50 = $46 | $49;
   $51 = $50 & 255;
   $52 = $8;
   HEAP8[$52 >> 0] = $51;
   $53 = $7;
   $54 = $53 & 255;
   $55 = $8;
   $56 = $55 + 1 | 0;
   HEAP8[$56 >> 0] = $54;
  }
  $57 = $6;
  $58 = $4;
  $59 = $58 - $57 | 0;
  $4 = $59;
  $60 = $7;
  $61 = $5;
  $62 = $61 - $60 | 0;
  $5 = $62;
 }
 STACKTOP = sp;
 return;
}

function _mp_print_float($0, $1, $2, $3, $4, $5, $6) {
 $0 = $0 | 0;
 $1 = +$1;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0.0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $66 = 0, $7 = 0, $8 = 0.0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $14 = sp;
 $7 = $0;
 $8 = $1;
 $9 = $2;
 $10 = $3;
 $11 = $4;
 $12 = $5;
 $13 = $6;
 $15 = 0;
 $16 = 0;
 $19 = $10;
 $20 = $19 & 2;
 $21 = ($20 | 0) != 0;
 if ($21) {
  $15 = 43;
 } else {
  $22 = $10;
  $23 = $22 & 4;
  $24 = ($23 | 0) != 0;
  if ($24) {
   $15 = 32;
  }
 }
 $25 = $8;
 $26 = $9;
 $27 = $13;
 $28 = $15;
 $29 = _mp_format_float($25, $14, 32, $26, $27, $28) | 0;
 $17 = $29;
 $18 = $14;
 $30 = $10;
 $31 = $30 & 256;
 $32 = ($31 | 0) != 0;
 if ($32) {
  $33 = $17;
  $34 = $33 + 1 | 0;
  $35 = $34 >>> 0 < 32;
  if ($35) {
   $36 = $17;
   $37 = $36 + 1 | 0;
   $17 = $37;
   $38 = $14 + $36 | 0;
   HEAP8[$38 >> 0] = 37;
   $39 = $17;
   $40 = $14 + $39 | 0;
   HEAP8[$40 >> 0] = 0;
  }
 }
 $41 = $10;
 $42 = $41 & 64;
 $43 = ($42 | 0) != 0;
 if ($43) {
  $44 = HEAP8[$14 >> 0] | 0;
  $45 = $44 << 24 >> 24;
  $46 = ($45 | 0) < 48;
  if ($46) {
   $47 = $18;
   $48 = $47 + 1 | 0;
   $18 = $48;
   $49 = $7;
   $50 = _mp_print_strn($49, $14, 1, 0, 0, 1) | 0;
   $51 = $16;
   $52 = $51 + $50 | 0;
   $16 = $52;
   $53 = $12;
   $54 = $53 + -1 | 0;
   $12 = $54;
   $55 = $17;
   $56 = $55 + -1 | 0;
   $17 = $56;
  }
 }
 $57 = $7;
 $58 = $18;
 $59 = $17;
 $60 = $10;
 $61 = $11;
 $62 = $12;
 $63 = _mp_print_strn($57, $58, $59, $60, $61, $62) | 0;
 $64 = $16;
 $65 = $64 + $63 | 0;
 $16 = $65;
 $66 = $16;
 STACKTOP = sp;
 return $66 | 0;
}

function _mp_map_rehash($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $1 = $0;
 $7 = $1;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $2 = $9;
 $10 = $1;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $12 + 1 | 0;
 $14 = _get_hash_alloc_greater_or_equal_to($13) | 0;
 $3 = $14;
 $15 = $1;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $4 = $17;
 $18 = $3;
 $19 = $18 << 3;
 $20 = _m_malloc0($19) | 0;
 $5 = $20;
 $21 = $3;
 $22 = $1;
 $23 = $22 + 4 | 0;
 HEAP32[$23 >> 2] = $21;
 $24 = $1;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = $25 & 7;
 HEAP32[$24 >> 2] = $26;
 $27 = $1;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = $28 & -2;
 $30 = $29 | 1;
 HEAP32[$27 >> 2] = $30;
 $31 = $5;
 $32 = $1;
 $33 = $32 + 8 | 0;
 HEAP32[$33 >> 2] = $31;
 $6 = 0;
 while (1) {
  $34 = $6;
  $35 = $2;
  $36 = $34 >>> 0 < $35 >>> 0;
  if (!$36) {
   break;
  }
  $37 = $4;
  $38 = $6;
  $39 = $37 + ($38 << 3) | 0;
  $40 = HEAP32[$39 >> 2] | 0;
  $41 = ($40 | 0) != (0 | 0);
  if ($41) {
   $42 = $4;
   $43 = $6;
   $44 = $42 + ($43 << 3) | 0;
   $45 = HEAP32[$44 >> 2] | 0;
   $46 = ($45 | 0) != (4 | 0);
   if ($46) {
    $47 = $4;
    $48 = $6;
    $49 = $47 + ($48 << 3) | 0;
    $50 = $49 + 4 | 0;
    $51 = HEAP32[$50 >> 2] | 0;
    $52 = $1;
    $53 = $4;
    $54 = $6;
    $55 = $53 + ($54 << 3) | 0;
    $56 = HEAP32[$55 >> 2] | 0;
    $57 = _mp_map_lookup($52, $56, 1) | 0;
    $58 = $57 + 4 | 0;
    HEAP32[$58 >> 2] = $51;
   }
  }
  $59 = $6;
  $60 = $59 + 1 | 0;
  $6 = $60;
 }
 $61 = $4;
 _m_free($61);
 STACKTOP = sp;
 return;
}

function _stream_readall($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = sp + 16 | 0;
 $8 = sp + 4 | 0;
 $2 = $0;
 $10 = $2;
 $11 = _mp_get_stream($10) | 0;
 $3 = $11;
 $4 = 0;
 _vstr_init($5, 256);
 $12 = $5 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $6 = $13;
 $7 = 256;
 while (1) {
  $14 = $3;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $2;
  $17 = $6;
  $18 = $7;
  $19 = FUNCTION_TABLE_iiiii[$15 & 1023]($16, $17, $18, $8) | 0;
  $9 = $19;
  $20 = $9;
  $21 = ($20 | 0) == -1;
  if ($21) {
   label = 3;
   break;
  }
  $29 = $9;
  $30 = ($29 | 0) == 0;
  if ($30) {
   break;
  }
  $31 = $9;
  $32 = $4;
  $33 = $32 + $31 | 0;
  $4 = $33;
  $34 = $9;
  $35 = $7;
  $36 = $34 >>> 0 < $35 >>> 0;
  if ($36) {
   $37 = $9;
   $38 = $7;
   $39 = $38 - $37 | 0;
   $7 = $39;
   $40 = $9;
   $41 = $6;
   $42 = $41 + $40 | 0;
   $6 = $42;
  } else {
   $43 = _vstr_extend($5, 256) | 0;
   $6 = $43;
   $7 = 256;
  }
 }
 if ((label | 0) == 3) {
  $22 = HEAP32[$8 >> 2] | 0;
  $23 = ($22 | 0) == 11;
  $24 = HEAP32[$8 >> 2] | 0;
  $25 = ($24 | 0) == 11;
  $or$cond = $23 | $25;
  if (!$or$cond) {
   $28 = HEAP32[$8 >> 2] | 0;
   _mp_raise_OSError($28);
  }
  $26 = $4;
  $27 = ($26 | 0) == 0;
  if ($27) {
   $1 = 17668;
   $54 = $1;
   STACKTOP = sp;
   return $54 | 0;
  }
 }
 $44 = $4;
 $45 = $5 + 4 | 0;
 HEAP32[$45 >> 2] = $44;
 $46 = $3;
 $47 = $46 + 12 | 0;
 $48 = HEAP8[$47 >> 0] | 0;
 $49 = $48 & 1;
 $50 = $49 & 255;
 $51 = ($50 | 0) != 0;
 $52 = $51 ? 18680 : 18304;
 $53 = _mp_obj_new_str_from_vstr($52, $5) | 0;
 $1 = $53;
 $54 = $1;
 STACKTOP = sp;
 return $54 | 0;
}

function _modf($0, $1) {
 $0 = +$0;
 $1 = $1 | 0;
 var $$0 = 0.0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0.0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0.0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0.0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0.0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $spec$select = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $2 = HEAP32[tempDoublePtr >> 2] | 0;
 $3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $4 = _bitshift64Lshr($2 | 0, $3 | 0, 52) | 0;
 $5 = getTempRet0() | 0;
 $6 = $4 & 2047;
 $7 = $6 + -1023 | 0;
 $8 = $6 >>> 0 > 1074;
 if ($8) {
  HEAPF64[$1 >> 3] = $0;
  $9 = ($7 | 0) != 1024;
  $10 = $3 & 1048575;
  $11 = ($2 | 0) == 0;
  $12 = ($10 | 0) == 0;
  $13 = $11 & $12;
  $or$cond = $13 | $9;
  $14 = $3 & -2147483648;
  HEAP32[tempDoublePtr >> 2] = 0;
  HEAP32[tempDoublePtr + 4 >> 2] = $14;
  $15 = +HEAPF64[tempDoublePtr >> 3];
  $spec$select = $or$cond ? $15 : $0;
  return +$spec$select;
 }
 $16 = $6 >>> 0 < 1023;
 do {
  if ($16) {
   $17 = $3 & -2147483648;
   $18 = $1;
   $19 = $18;
   HEAP32[$19 >> 2] = 0;
   $20 = $18 + 4 | 0;
   $21 = $20;
   HEAP32[$21 >> 2] = $17;
   $$0 = $0;
  } else {
   $22 = _bitshift64Lshr(-1, 1048575, $7 | 0) | 0;
   $23 = getTempRet0() | 0;
   $24 = $22 & $2;
   $25 = $23 & $3;
   $26 = ($24 | 0) == 0;
   $27 = ($25 | 0) == 0;
   $28 = $26 & $27;
   if ($28) {
    HEAPF64[$1 >> 3] = $0;
    $29 = $3 & -2147483648;
    HEAP32[tempDoublePtr >> 2] = 0;
    HEAP32[tempDoublePtr + 4 >> 2] = $29;
    $30 = +HEAPF64[tempDoublePtr >> 3];
    $$0 = $30;
    break;
   } else {
    $31 = _bitshift64Ashr(0, -1048576, $7 | 0) | 0;
    $32 = getTempRet0() | 0;
    $33 = $31 & $2;
    $34 = $32 & $3;
    HEAP32[tempDoublePtr >> 2] = $33;
    HEAP32[tempDoublePtr + 4 >> 2] = $34;
    $35 = +HEAPF64[tempDoublePtr >> 3];
    $36 = $1;
    $37 = $36;
    HEAP32[$37 >> 2] = $33;
    $38 = $36 + 4 | 0;
    $39 = $38;
    HEAP32[$39 >> 2] = $34;
    $40 = $0 - $35;
    $$0 = $40;
    break;
   }
  }
 } while (0);
 return +$$0;
}

function _bytes_subscr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $9 = sp + 16 | 0;
 $10 = sp + 4 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $12 = $4;
 $13 = _mp_obj_get_type($12) | 0;
 $7 = $13;
 $14 = $4;
 $15 = _mp_obj_is_qstr_1128($14) | 0;
 $16 = $4;
 if ($15) {
  $17 = $16;
  $18 = $17 >>> 2;
  $19 = _qstr_data($18, $9) | 0;
  $8 = $19;
 } else {
  $20 = $16 + 8 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  HEAP32[$9 >> 2] = $21;
  $22 = $4;
  $23 = $22 + 12 | 0;
  $24 = HEAP32[$23 >> 2] | 0;
  $8 = $24;
 }
 $25 = $6;
 $26 = ($25 | 0) == (4 | 0);
 if (!$26) {
  $3 = 0;
  $56 = $3;
  STACKTOP = sp;
  return $56 | 0;
 }
 $27 = $5;
 $28 = _mp_obj_is_obj_1154($27) | 0;
 if ($28) {
  $29 = $5;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = ($30 | 0) == (18228 | 0);
  if ($31) {
   $32 = HEAP32[$9 >> 2] | 0;
   $33 = $5;
   $34 = _mp_seq_get_fast_slice_indexes($32, $33, $10) | 0;
   if (!$34) {
    _mp_raise_NotImplementedError(32934);
   }
   $35 = $7;
   $36 = $8;
   $37 = HEAP32[$10 >> 2] | 0;
   $38 = $36 + $37 | 0;
   $39 = $10 + 4 | 0;
   $40 = HEAP32[$39 >> 2] | 0;
   $41 = HEAP32[$10 >> 2] | 0;
   $42 = $40 - $41 | 0;
   $43 = _mp_obj_new_str_of_type($35, $38, $42) | 0;
   $3 = $43;
   $56 = $3;
   STACKTOP = sp;
   return $56 | 0;
  }
 }
 $44 = $7;
 $45 = HEAP32[$9 >> 2] | 0;
 $46 = $5;
 $47 = _mp_get_index($44, $45, $46, 0) | 0;
 $11 = $47;
 $48 = $8;
 $49 = $11;
 $50 = $48 + $49 | 0;
 $51 = HEAP8[$50 >> 0] | 0;
 $52 = $51 & 255;
 $53 = $52 << 1;
 $54 = $53 | 1;
 $55 = $54;
 $3 = $55;
 $56 = $3;
 STACKTOP = sp;
 return $56 | 0;
}

function _scope_find_or_add_id($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $8 = $4;
 $9 = $5;
 $10 = _scope_find($8, $9) | 0;
 $7 = $10;
 $11 = $7;
 $12 = ($11 | 0) != (0 | 0);
 if ($12) {
  $13 = $7;
  $3 = $13;
  $61 = $3;
  STACKTOP = sp;
  return $61 | 0;
 }
 $14 = $4;
 $15 = $14 + 42 | 0;
 $16 = HEAP16[$15 >> 1] | 0;
 $17 = $16 & 65535;
 $18 = $4;
 $19 = $18 + 40 | 0;
 $20 = HEAP16[$19 >> 1] | 0;
 $21 = $20 & 65535;
 $22 = ($17 | 0) >= ($21 | 0);
 if ($22) {
  $23 = $4;
  $24 = $23 + 44 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = $4;
  $27 = $26 + 40 | 0;
  $28 = HEAP16[$27 >> 1] | 0;
  $29 = $28 & 65535;
  $30 = $29 + 6 | 0;
  $31 = $30 << 3;
  $32 = _m_realloc($25, $31) | 0;
  $33 = $4;
  $34 = $33 + 44 | 0;
  HEAP32[$34 >> 2] = $32;
  $35 = $4;
  $36 = $35 + 40 | 0;
  $37 = HEAP16[$36 >> 1] | 0;
  $38 = $37 & 65535;
  $39 = $38 + 6 | 0;
  $40 = $39 & 65535;
  HEAP16[$36 >> 1] = $40;
 }
 $41 = $4;
 $42 = $41 + 44 | 0;
 $43 = HEAP32[$42 >> 2] | 0;
 $44 = $4;
 $45 = $44 + 42 | 0;
 $46 = HEAP16[$45 >> 1] | 0;
 $47 = $46 + 1 << 16 >> 16;
 HEAP16[$45 >> 1] = $47;
 $48 = $46 & 65535;
 $49 = $43 + ($48 << 3) | 0;
 $7 = $49;
 $50 = $6;
 $51 = $50 & 255;
 $52 = $7;
 HEAP8[$52 >> 0] = $51;
 $53 = $7;
 $54 = $53 + 1 | 0;
 HEAP8[$54 >> 0] = 0;
 $55 = $7;
 $56 = $55 + 2 | 0;
 HEAP16[$56 >> 1] = 0;
 $57 = $5;
 $58 = $7;
 $59 = $58 + 4 | 0;
 HEAP32[$59 >> 2] = $57;
 $60 = $7;
 $3 = $60;
 $61 = $3;
 STACKTOP = sp;
 return $61 | 0;
}

function _dict_copy($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $63 = 0, $64 = 0, $65 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $5 = $1;
 $2 = $5;
 $6 = $2;
 $7 = $6 + 4 | 0;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = _mp_obj_new_dict($9) | 0;
 $3 = $10;
 $11 = $3;
 $4 = $11;
 $12 = $2;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $4;
 HEAP32[$14 >> 2] = $13;
 $15 = $2;
 $16 = $15 + 4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $17 >>> 3;
 $19 = $4;
 $20 = $19 + 4 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $18 & 536870911;
 $23 = $22 << 3;
 $24 = $21 & 7;
 $25 = $24 | $23;
 HEAP32[$20 >> 2] = $25;
 $26 = $2;
 $27 = $26 + 4 | 0;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = $28 & 1;
 $30 = $4;
 $31 = $30 + 4 | 0;
 $32 = HEAP32[$31 >> 2] | 0;
 $33 = $29 & 1;
 $34 = $32 & -2;
 $35 = $34 | $33;
 HEAP32[$31 >> 2] = $35;
 $36 = $4;
 $37 = $36 + 4 | 0;
 $38 = HEAP32[$37 >> 2] | 0;
 $39 = $38 & -3;
 HEAP32[$37 >> 2] = $39;
 $40 = $2;
 $41 = $40 + 4 | 0;
 $42 = HEAP32[$41 >> 2] | 0;
 $43 = $42 >>> 2;
 $44 = $43 & 1;
 $45 = $4;
 $46 = $45 + 4 | 0;
 $47 = HEAP32[$46 >> 2] | 0;
 $48 = $44 & 1;
 $49 = $48 << 2;
 $50 = $47 & -5;
 $51 = $50 | $49;
 HEAP32[$46 >> 2] = $51;
 $52 = $4;
 $53 = $52 + 4 | 0;
 $54 = $53 + 8 | 0;
 $55 = HEAP32[$54 >> 2] | 0;
 $56 = $2;
 $57 = $56 + 4 | 0;
 $58 = $57 + 8 | 0;
 $59 = HEAP32[$58 >> 2] | 0;
 $60 = $2;
 $61 = $60 + 4 | 0;
 $62 = $61 + 4 | 0;
 $63 = HEAP32[$62 >> 2] | 0;
 $64 = $63 << 3;
 _memcpy($55 | 0, $59 | 0, $64 | 0) | 0;
 $65 = $3;
 STACKTOP = sp;
 return $65 | 0;
}

function _ure_exec($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $8 = sp + 16 | 0;
 $9 = sp + 12 | 0;
 $13 = $0 & 1;
 $4 = $13;
 $5 = $1;
 $6 = $2;
 $14 = $6;
 $15 = HEAP32[$14 >> 2] | 0;
 $7 = $15;
 $16 = $6;
 $17 = $16 + 4 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = _mp_obj_str_get_data($18, $9) | 0;
 HEAP32[$8 >> 2] = $19;
 $20 = HEAP32[$8 >> 2] | 0;
 $21 = HEAP32[$9 >> 2] | 0;
 $22 = $20 + $21 | 0;
 $23 = $8 + 4 | 0;
 HEAP32[$23 >> 2] = $22;
 $24 = $7;
 $25 = $24 + 4 | 0;
 $26 = $25 + 8 | 0;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = $27 + 1 | 0;
 $29 = $28 << 1;
 $10 = $29;
 $30 = $10;
 $31 = $30 << 2;
 $32 = 12 + $31 | 0;
 $33 = _m_malloc($32) | 0;
 $11 = $33;
 $34 = $11;
 $35 = $34 + 12 | 0;
 $36 = $10;
 $37 = $36 << 2;
 _memset($35 | 0, 0, $37 | 0) | 0;
 $38 = $7;
 $39 = $38 + 4 | 0;
 $40 = $11;
 $41 = $40 + 12 | 0;
 $42 = $10;
 $43 = $4;
 $44 = $43 & 1;
 $45 = $44 & 1;
 $46 = _re1_5_recursiveloopprog($39, $8, $41, $42, $45) | 0;
 $12 = $46;
 $47 = $12;
 $48 = ($47 | 0) == 0;
 if ($48) {
  $49 = $11;
  _m_free($49);
  $3 = 17668;
  $61 = $3;
  STACKTOP = sp;
  return $61 | 0;
 } else {
  $50 = $11;
  HEAP32[$50 >> 2] = 21096;
  $51 = $10;
  $52 = ($51 | 0) / 2 & -1;
  $53 = $11;
  $54 = $53 + 4 | 0;
  HEAP32[$54 >> 2] = $52;
  $55 = $6;
  $56 = $55 + 4 | 0;
  $57 = HEAP32[$56 >> 2] | 0;
  $58 = $11;
  $59 = $58 + 8 | 0;
  HEAP32[$59 >> 2] = $57;
  $60 = $11;
  $3 = $60;
  $61 = $3;
  STACKTOP = sp;
  return $61 | 0;
 }
 return 0 | 0;
}

function _mp_obj_int_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $10 = $4;
 $5 = $10;
 $11 = $3;
 L1 : do {
  switch ($11 | 0) {
  case 4:
   {
    $12 = $5;
    $13 = $12 + 4 | 0;
    $14 = _mpz_is_zero_1033($13) | 0;
    $15 = $14 ^ 1;
    $16 = $15 & 1;
    $17 = _mp_obj_new_bool_1034($16) | 0;
    $2 = $17;
    break;
   }
  case 6:
   {
    $18 = $5;
    $19 = $18 + 4 | 0;
    $20 = _mpz_hash($19) | 0;
    $21 = $20 << 1;
    $22 = $21 | 1;
    $23 = $22;
    $2 = $23;
    break;
   }
  case 0:
   {
    $24 = $4;
    $2 = $24;
    break;
   }
  case 1:
   {
    $25 = _mp_obj_int_new_mpz() | 0;
    $6 = $25;
    $26 = $6;
    $27 = $26 + 4 | 0;
    $28 = $5;
    $29 = $28 + 4 | 0;
    _mpz_neg_inpl($27, $29);
    $30 = $6;
    $2 = $30;
    break;
   }
  case 2:
   {
    $31 = _mp_obj_int_new_mpz() | 0;
    $7 = $31;
    $32 = $7;
    $33 = $32 + 4 | 0;
    $34 = $5;
    $35 = $34 + 4 | 0;
    _mpz_not_inpl($33, $35);
    $36 = $7;
    $2 = $36;
    break;
   }
  case 7:
   {
    $37 = $4;
    $8 = $37;
    $38 = $8;
    $39 = $38 + 4 | 0;
    $40 = HEAP32[$39 >> 2] | 0;
    $41 = $40 & 1;
    $42 = ($41 | 0) == 0;
    if ($42) {
     $43 = $4;
     $2 = $43;
     break L1;
    } else {
     $44 = _mp_obj_int_new_mpz() | 0;
     $9 = $44;
     $45 = $9;
     $46 = $45 + 4 | 0;
     $47 = $8;
     $48 = $47 + 4 | 0;
     _mpz_abs_inpl($46, $48);
     $49 = $9;
     $2 = $49;
     break L1;
    }
    break;
   }
  default:
   {
    $2 = 0;
   }
  }
 } while (0);
 $50 = $2;
 STACKTOP = sp;
 return $50 | 0;
}

function _str_startswith($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $7 = sp + 12 | 0;
 $8 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $11 = $4;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = _mp_obj_get_type($12) | 0;
 $5 = $13;
 $14 = $4;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = _mp_obj_is_qstr_1128($15) | 0;
 $17 = $4;
 $18 = HEAP32[$17 >> 2] | 0;
 if ($16) {
  $19 = $18;
  $20 = $19 >>> 2;
  $21 = _qstr_data($20, $7) | 0;
  $6 = $21;
 } else {
  $22 = $18 + 8 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  HEAP32[$7 >> 2] = $23;
  $24 = $4;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = $25 + 12 | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $6 = $27;
 }
 $28 = $4;
 $29 = $28 + 4 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = _mp_obj_str_get_data($30, $8) | 0;
 $9 = $31;
 $32 = $6;
 $10 = $32;
 $33 = $3;
 $34 = $33 >>> 0 > 2;
 if ($34) {
  $35 = $5;
  $36 = $6;
  $37 = HEAP32[$7 >> 2] | 0;
  $38 = $4;
  $39 = $38 + 8 | 0;
  $40 = HEAP32[$39 >> 2] | 0;
  $41 = _str_index_to_ptr($35, $36, $37, $40, 1) | 0;
  $10 = $41;
 }
 $42 = HEAP32[$8 >> 2] | 0;
 $43 = $10;
 $44 = $6;
 $45 = $43;
 $46 = $44;
 $47 = $45 - $46 | 0;
 $48 = $42 + $47 | 0;
 $49 = HEAP32[$7 >> 2] | 0;
 $50 = $48 >>> 0 > $49 >>> 0;
 if ($50) {
  $2 = 13856;
  $58 = $2;
  STACKTOP = sp;
  return $58 | 0;
 } else {
  $51 = $10;
  $52 = $9;
  $53 = HEAP32[$8 >> 2] | 0;
  $54 = _memcmp($51, $52, $53) | 0;
  $55 = ($54 | 0) == 0;
  $56 = $55 & 1;
  $57 = _mp_obj_new_bool_1159($56) | 0;
  $2 = $57;
  $58 = $2;
  STACKTOP = sp;
  return $58 | 0;
 }
 return 0 | 0;
}

function _compile_classdef_helper($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $3;
 $10 = $9 + 5 | 0;
 $11 = HEAP8[$10 >> 0] | 0;
 $12 = $11 & 255;
 $13 = ($12 | 0) == 1;
 if ($13) {
  $14 = $3;
  $15 = $4;
  $16 = $15;
  $17 = $5;
  $18 = _scope_new_and_link($14, 1, $16, $17) | 0;
  $6 = $18;
  $19 = $6;
  $20 = $19;
  $21 = $4;
  $22 = $21 + 8 | 0;
  $23 = $22 + 12 | 0;
  HEAP32[$23 >> 2] = $20;
 }
 $24 = $3;
 $25 = $24 + 40 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 _mp_emit_bc_load_build_class($26);
 $27 = $4;
 $28 = $27 + 8 | 0;
 $29 = $28 + 12 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = $30;
 $7 = $31;
 $32 = $3;
 $33 = $7;
 _close_over_variables_etc($32, $33, 0, 0);
 $34 = $3;
 $35 = $34 + 40 | 0;
 $36 = HEAP32[$35 >> 2] | 0;
 $37 = $7;
 $38 = $37 + 22 | 0;
 $39 = HEAP16[$38 >> 1] | 0;
 $40 = $39 & 65535;
 _mp_emit_bc_load_const_str($36, $40);
 $41 = $4;
 $42 = $41 + 8 | 0;
 $43 = $42 + 4 | 0;
 $44 = HEAP32[$43 >> 2] | 0;
 $8 = $44;
 $45 = $8;
 $46 = ($45 | 0) != 0;
 if ($46) {
  $47 = $8;
  $48 = $47 & 3;
  $49 = ($48 | 0) == 0;
  if ($49) {
   $50 = $8;
   $51 = $50;
   $52 = $51 + 4 | 0;
   $53 = HEAP32[$52 >> 2] | 0;
   $54 = $53 & 255;
   $55 = ($54 | 0) == 162;
   if ($55) {
    $8 = 0;
   }
  }
 }
 $56 = $3;
 $57 = $8;
 _compile_trailer_paren_helper($56, $57, 0, 2);
 $58 = $7;
 $59 = $58 + 22 | 0;
 $60 = HEAP16[$59 >> 1] | 0;
 $61 = $60 & 65535;
 STACKTOP = sp;
 return $61 | 0;
}

function _str_it_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp + 12 | 0;
 $2 = $0;
 $9 = $2;
 $3 = $9;
 $10 = $3;
 $11 = $10 + 8 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = _mp_obj_is_qstr_1200($12) | 0;
 $14 = $3;
 $15 = $14 + 8 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 if ($13) {
  $17 = $16;
  $18 = $17 >>> 2;
  $19 = _qstr_data($18, $5) | 0;
  $4 = $19;
 } else {
  $20 = $16 + 8 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  HEAP32[$5 >> 2] = $21;
  $22 = $3;
  $23 = $22 + 8 | 0;
  $24 = HEAP32[$23 >> 2] | 0;
  $25 = $24 + 12 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $4 = $26;
 }
 $27 = $3;
 $28 = $27 + 12 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = HEAP32[$5 >> 2] | 0;
 $31 = $29 >>> 0 < $30 >>> 0;
 if ($31) {
  $32 = $4;
  $33 = $3;
  $34 = $33 + 12 | 0;
  $35 = HEAP32[$34 >> 2] | 0;
  $36 = $32 + $35 | 0;
  $6 = $36;
  $37 = $4;
  $38 = $3;
  $39 = $38 + 12 | 0;
  $40 = HEAP32[$39 >> 2] | 0;
  $41 = $37 + $40 | 0;
  $42 = _utf8_next_char($41) | 0;
  $7 = $42;
  $43 = $6;
  $44 = $7;
  $45 = $6;
  $46 = $44;
  $47 = $45;
  $48 = $46 - $47 | 0;
  $49 = _mp_obj_new_str_via_qstr($43, $48) | 0;
  $8 = $49;
  $50 = $7;
  $51 = $6;
  $52 = $50;
  $53 = $51;
  $54 = $52 - $53 | 0;
  $55 = $3;
  $56 = $55 + 12 | 0;
  $57 = HEAP32[$56 >> 2] | 0;
  $58 = $57 + $54 | 0;
  HEAP32[$56 >> 2] = $58;
  $59 = $8;
  $1 = $59;
  $60 = $1;
  STACKTOP = sp;
  return $60 | 0;
 } else {
  $1 = 0;
  $60 = $1;
  STACKTOP = sp;
  return $60 | 0;
 }
 return 0 | 0;
}

function _instance_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $9 = sp + 24 | 0;
 $10 = sp + 4 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $12 = $5;
 $7 = $12;
 while (1) {
  $13 = $4;
  $14 = 4608 + $13 | 0;
  $15 = HEAP8[$14 >> 0] | 0;
  $16 = $15 & 255;
  $8 = $16;
  HEAP32[$9 >> 2] = 0 | 0;
  HEAP32[$9 + 4 >> 2] = 0 | 0;
  HEAP32[$9 + 8 >> 2] = 0 | 0;
  $17 = $7;
  HEAP32[$10 >> 2] = $17;
  $18 = $10 + 4 | 0;
  $19 = $8;
  HEAP32[$18 >> 2] = $19;
  $20 = $10 + 8 | 0;
  HEAP32[$20 >> 2] = 24;
  $21 = $10 + 12 | 0;
  HEAP32[$21 >> 2] = $9;
  $22 = $10 + 16 | 0;
  HEAP8[$22 >> 0] = 0;
  $23 = $7;
  $24 = HEAP32[$23 >> 2] | 0;
  _mp_obj_class_lookup($10, $24);
  $25 = HEAP32[$9 >> 2] | 0;
  $26 = ($25 | 0) == (4 | 0);
  if ($26) {
   label = 3;
   break;
  }
  $33 = HEAP32[$9 >> 2] | 0;
  $34 = ($33 | 0) != (0 | 0);
  if ($34) {
   label = 5;
   break;
  }
  $38 = $4;
  $39 = $38 >>> 0 >= 9;
  $40 = $4;
  $41 = $40 >>> 0 <= 20;
  $or$cond = $39 & $41;
  if (!$or$cond) {
   label = 8;
   break;
  }
  $42 = $4;
  $43 = $42 - -12 | 0;
  $4 = $43;
 }
 if ((label | 0) == 3) {
  $27 = $4;
  $28 = $7;
  $29 = $28 + 16 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = $6;
  $32 = _mp_binary_op($27, $30, $31) | 0;
  $11 = $32;
 } else if ((label | 0) == 5) {
  $35 = $6;
  $36 = $9 + 8 | 0;
  HEAP32[$36 >> 2] = $35;
  $37 = _mp_call_method_n_kw(1, 0, $9) | 0;
  $11 = $37;
 } else if ((label | 0) == 8) {
  $3 = 0;
  $45 = $3;
  STACKTOP = sp;
  return $45 | 0;
 }
 $44 = $11;
 $3 = $44;
 $45 = $3;
 STACKTOP = sp;
 return $45 | 0;
}

function _mp_obj_tuple_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $15 = $6;
 $16 = $7;
 _mp_arg_check_num_1244($15, $16, 0, 1, 0);
 $17 = $6;
 $cond = ($17 | 0) == 0;
 if ($cond) {
  $4 = 18944;
  $55 = $4;
  STACKTOP = sp;
  return $55 | 0;
 }
 $18 = $8;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = _mp_obj_is_obj_1239($19) | 0;
 if ($20) {
  $21 = $8;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = ($23 | 0) == (18952 | 0);
  if ($24) {
   $25 = $8;
   $26 = HEAP32[$25 >> 2] | 0;
   $4 = $26;
   $55 = $4;
   STACKTOP = sp;
   return $55 | 0;
  }
 }
 $9 = 4;
 $10 = 0;
 $27 = $9;
 $28 = $27 << 2;
 $29 = _m_malloc($28) | 0;
 $11 = $29;
 $30 = $8;
 $31 = HEAP32[$30 >> 2] | 0;
 $32 = _mp_getiter($31, 0) | 0;
 $12 = $32;
 while (1) {
  $33 = $12;
  $34 = _mp_iternext($33) | 0;
  $13 = $34;
  $35 = ($34 | 0) != (0 | 0);
  $36 = $10;
  if (!$35) {
   break;
  }
  $37 = $9;
  $38 = $36 >>> 0 >= $37 >>> 0;
  if ($38) {
   $39 = $11;
   $40 = $9;
   $41 = $40 << 1;
   $42 = $41 << 2;
   $43 = _m_realloc($39, $42) | 0;
   $11 = $43;
   $44 = $9;
   $45 = $44 << 1;
   $9 = $45;
  }
  $46 = $13;
  $47 = $11;
  $48 = $10;
  $49 = $48 + 1 | 0;
  $10 = $49;
  $50 = $47 + ($48 << 2) | 0;
  HEAP32[$50 >> 2] = $46;
 }
 $51 = $11;
 $52 = _mp_obj_new_tuple($36, $51) | 0;
 $14 = $52;
 $53 = $11;
 _m_free($53);
 $54 = $14;
 $4 = $54;
 $55 = $4;
 STACKTOP = sp;
 return $55 | 0;
}

function _fflush($0) {
 $0 = $0 | 0;
 var $$0 = 0, $$023 = 0, $$02325 = 0, $$02327 = 0, $$024$lcssa = 0, $$02426 = 0, $$1 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $phitmp = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = ($0 | 0) == (0 | 0);
 do {
  if ($1) {
   $8 = HEAP32[5587] | 0;
   $9 = ($8 | 0) == (0 | 0);
   if ($9) {
    $29 = 0;
   } else {
    $10 = HEAP32[5587] | 0;
    $11 = _fflush($10) | 0;
    $29 = $11;
   }
   $12 = ___ofl_lock() | 0;
   $$02325 = HEAP32[$12 >> 2] | 0;
   $13 = ($$02325 | 0) == (0 | 0);
   if ($13) {
    $$024$lcssa = $29;
   } else {
    $$02327 = $$02325;
    $$02426 = $29;
    while (1) {
     $14 = $$02327 + 76 | 0;
     $15 = HEAP32[$14 >> 2] | 0;
     $16 = ($15 | 0) > -1;
     if ($16) {
      $17 = ___lockfile($$02327) | 0;
      $25 = $17;
     } else {
      $25 = 0;
     }
     $18 = $$02327 + 20 | 0;
     $19 = HEAP32[$18 >> 2] | 0;
     $20 = $$02327 + 28 | 0;
     $21 = HEAP32[$20 >> 2] | 0;
     $22 = $19 >>> 0 > $21 >>> 0;
     if ($22) {
      $23 = ___fflush_unlocked($$02327) | 0;
      $24 = $23 | $$02426;
      $$1 = $24;
     } else {
      $$1 = $$02426;
     }
     $26 = ($25 | 0) == 0;
     if (!$26) {
      ___unlockfile($$02327);
     }
     $27 = $$02327 + 56 | 0;
     $$023 = HEAP32[$27 >> 2] | 0;
     $28 = ($$023 | 0) == (0 | 0);
     if ($28) {
      $$024$lcssa = $$1;
      break;
     } else {
      $$02327 = $$023;
      $$02426 = $$1;
     }
    }
   }
   ___ofl_unlock();
   $$0 = $$024$lcssa;
  } else {
   $2 = $0 + 76 | 0;
   $3 = HEAP32[$2 >> 2] | 0;
   $4 = ($3 | 0) > -1;
   if (!$4) {
    $5 = ___fflush_unlocked($0) | 0;
    $$0 = $5;
    break;
   }
   $6 = ___lockfile($0) | 0;
   $phitmp = ($6 | 0) == 0;
   $7 = ___fflush_unlocked($0) | 0;
   if ($phitmp) {
    $$0 = $7;
   } else {
    ___unlockfile($0);
    $$0 = $7;
   }
  }
 } while (0);
 return $$0 | 0;
}

function _mpn_sub($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $9 = $4;
 $12 = $5;
 $10 = $12;
 $11 = 0;
 $13 = $9;
 $14 = $7;
 $15 = $14 - $13 | 0;
 $7 = $15;
 while (1) {
  $16 = $9;
  $17 = $16 >>> 0 > 0;
  if (!$17) {
   break;
  }
  $18 = $6;
  $19 = HEAP16[$18 >> 1] | 0;
  $20 = $19 & 65535;
  $21 = $8;
  $22 = HEAP16[$21 >> 1] | 0;
  $23 = $22 & 65535;
  $24 = $20 - $23 | 0;
  $25 = $11;
  $26 = $25 + $24 | 0;
  $11 = $26;
  $27 = $11;
  $28 = $27 & 65535;
  $29 = $28 & 65535;
  $30 = $5;
  HEAP16[$30 >> 1] = $29;
  $31 = $11;
  $32 = $31 >> 16;
  $11 = $32;
  $33 = $9;
  $34 = $33 + -1 | 0;
  $9 = $34;
  $35 = $5;
  $36 = $35 + 2 | 0;
  $5 = $36;
  $37 = $6;
  $38 = $37 + 2 | 0;
  $6 = $38;
  $39 = $8;
  $40 = $39 + 2 | 0;
  $8 = $40;
 }
 while (1) {
  $41 = $7;
  $42 = $41 >>> 0 > 0;
  if (!$42) {
   break;
  }
  $43 = $6;
  $44 = HEAP16[$43 >> 1] | 0;
  $45 = $44 & 65535;
  $46 = $11;
  $47 = $46 + $45 | 0;
  $11 = $47;
  $48 = $11;
  $49 = $48 & 65535;
  $50 = $49 & 65535;
  $51 = $5;
  HEAP16[$51 >> 1] = $50;
  $52 = $11;
  $53 = $52 >> 16;
  $11 = $53;
  $54 = $7;
  $55 = $54 + -1 | 0;
  $7 = $55;
  $56 = $5;
  $57 = $56 + 2 | 0;
  $5 = $57;
  $58 = $6;
  $59 = $58 + 2 | 0;
  $6 = $59;
 }
 $60 = $10;
 $61 = $5;
 $62 = _mpn_remove_trailing_zeros($60, $61) | 0;
 STACKTOP = sp;
 return $62 | 0;
}

function _mp_arg_check_num_sig($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, $vararg_buffer5 = 0, $vararg_ptr1 = 0, $vararg_ptr8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer5 = sp + 16 | 0;
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $5;
 $10 = $9 & 1;
 $11 = ($10 | 0) != 0;
 $12 = $11 & 1;
 $6 = $12;
 $13 = $5;
 $14 = $13 >>> 17;
 $7 = $14;
 $15 = $5;
 $16 = $15 >>> 1;
 $17 = $16 & 65535;
 $8 = $17;
 $18 = $4;
 $19 = ($18 | 0) != 0;
 if ($19) {
  $20 = $6;
  $21 = $20 & 1;
  if (!$21) {
   _mp_raise_TypeError(30055);
  }
 }
 $22 = $7;
 $23 = $8;
 $24 = ($22 | 0) == ($23 | 0);
 $25 = $3;
 $26 = $7;
 if ($24) {
  $27 = ($25 | 0) != ($26 | 0);
  if ($27) {
   $28 = $7;
   $29 = $3;
   HEAP32[$vararg_buffer >> 2] = $28;
   $vararg_ptr1 = $vararg_buffer + 4 | 0;
   HEAP32[$vararg_ptr1 >> 2] = $29;
   $30 = _mp_obj_new_exception_msg_varg(16012, 34348, $vararg_buffer) | 0;
   _nlr_jump($30);
  } else {
   STACKTOP = sp;
   return;
  }
 }
 $31 = $25 >>> 0 < $26 >>> 0;
 if ($31) {
  $32 = $7;
  $33 = $3;
  $34 = $32 - $33 | 0;
  HEAP32[$vararg_buffer2 >> 2] = $34;
  $35 = _mp_obj_new_exception_msg_varg(16012, 30095, $vararg_buffer2) | 0;
  _nlr_jump($35);
 }
 $36 = $3;
 $37 = $8;
 $38 = $36 >>> 0 > $37 >>> 0;
 if ($38) {
  $39 = $8;
  $40 = $3;
  HEAP32[$vararg_buffer5 >> 2] = $39;
  $vararg_ptr8 = $vararg_buffer5 + 4 | 0;
  HEAP32[$vararg_ptr8 >> 2] = $40;
  $41 = _mp_obj_new_exception_msg_varg(16012, 30145, $vararg_buffer5) | 0;
  _nlr_jump($41);
 } else {
  STACKTOP = sp;
  return;
 }
}

function _mpn_shr($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $60 = 0, $61 = 0, $62 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $13 = $8;
 $14 = ($13 >>> 0) / 16 & -1;
 $9 = $14;
 $15 = $8;
 $16 = ($15 >>> 0) % 16 & -1;
 $10 = $16;
 $17 = $9;
 $18 = $7;
 $19 = $17 >>> 0 >= $18 >>> 0;
 if ($19) {
  $4 = 0;
  $62 = $4;
  STACKTOP = sp;
  return $62 | 0;
 }
 $20 = $9;
 $21 = $6;
 $22 = $21 + ($20 << 1) | 0;
 $6 = $22;
 $23 = $9;
 $24 = $7;
 $25 = $24 - $23 | 0;
 $7 = $25;
 $26 = $7;
 $11 = $26;
 while (1) {
  $27 = $11;
  $28 = $27 >>> 0 > 0;
  if (!$28) {
   break;
  }
  $29 = $6;
  $30 = HEAP16[$29 >> 1] | 0;
  $31 = $30 & 65535;
  $12 = $31;
  $32 = $11;
  $33 = $32 >>> 0 > 1;
  if ($33) {
   $34 = $6;
   $35 = $34 + 2 | 0;
   $36 = HEAP16[$35 >> 1] | 0;
   $37 = $36 & 65535;
   $38 = $37 << 16;
   $39 = $12;
   $40 = $39 | $38;
   $12 = $40;
  }
  $41 = $10;
  $42 = $12;
  $43 = $42 >>> $41;
  $12 = $43;
  $44 = $12;
  $45 = $44 & 65535;
  $46 = $45 & 65535;
  $47 = $5;
  HEAP16[$47 >> 1] = $46;
  $48 = $11;
  $49 = $48 + -1 | 0;
  $11 = $49;
  $50 = $5;
  $51 = $50 + 2 | 0;
  $5 = $51;
  $52 = $6;
  $53 = $52 + 2 | 0;
  $6 = $53;
 }
 $54 = $5;
 $55 = $54 + -2 | 0;
 $56 = HEAP16[$55 >> 1] | 0;
 $57 = $56 & 65535;
 $58 = ($57 | 0) == 0;
 if ($58) {
  $59 = $7;
  $60 = $59 + -1 | 0;
  $7 = $60;
 }
 $61 = $7;
 $4 = $61;
 $62 = $4;
 STACKTOP = sp;
 return $62 | 0;
}

function _mp_obj_is_subclass($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = sp + 12 | 0;
 $5 = sp + 8 | 0;
 $6 = sp + 4 | 0;
 $3 = $0;
 HEAP32[$4 >> 2] = $1;
 $8 = HEAP32[$4 >> 2] | 0;
 $9 = _mp_obj_is_obj_1260($8) | 0;
 if ($9) {
  $10 = HEAP32[$4 >> 2] | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = ($11 | 0) == (19048 | 0);
  if ($12) {
   HEAP32[$5 >> 2] = 1;
   HEAP32[$6 >> 2] = $4;
  } else {
   label = 4;
  }
 } else {
  label = 4;
 }
 do {
  if ((label | 0) == 4) {
   $13 = HEAP32[$4 >> 2] | 0;
   $14 = _mp_obj_is_obj_1260($13) | 0;
   if (!$14) {
    _mp_raise_TypeError(33365);
   }
   $15 = HEAP32[$4 >> 2] | 0;
   $16 = HEAP32[$15 >> 2] | 0;
   $17 = ($16 | 0) == (18952 | 0);
   if ($17) {
    $18 = HEAP32[$4 >> 2] | 0;
    _mp_obj_tuple_get($18, $5, $6);
    break;
   } else {
    _mp_raise_TypeError(33365);
   }
  }
 } while (0);
 $7 = 0;
 while (1) {
  $19 = $7;
  $20 = HEAP32[$5 >> 2] | 0;
  $21 = $19 >>> 0 < $20 >>> 0;
  if (!$21) {
   label = 14;
   break;
  }
  $22 = HEAP32[$6 >> 2] | 0;
  $23 = $7;
  $24 = $22 + ($23 << 2) | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = ($25 | 0) == (17348 | 0);
  if ($26) {
   label = 12;
   break;
  }
  $27 = $3;
  $28 = HEAP32[$6 >> 2] | 0;
  $29 = $7;
  $30 = $28 + ($29 << 2) | 0;
  $31 = HEAP32[$30 >> 2] | 0;
  $32 = _mp_obj_is_subclass_fast($27, $31) | 0;
  if ($32) {
   label = 12;
   break;
  }
  $33 = $7;
  $34 = $33 + 1 | 0;
  $7 = $34;
 }
 if ((label | 0) == 12) {
  $2 = 13864;
  $35 = $2;
  STACKTOP = sp;
  return $35 | 0;
 } else if ((label | 0) == 14) {
  $2 = 13856;
  $35 = $2;
  STACKTOP = sp;
  return $35 | 0;
 }
 return 0 | 0;
}

function _dict_get_helper($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $4;
 $10 = HEAP32[$9 >> 2] | 0;
 $6 = $10;
 $11 = $5;
 $12 = ($11 | 0) != 0;
 if ($12) {
  $13 = $6;
  _mp_ensure_not_fixed($13);
 }
 $14 = $6;
 $15 = $14 + 4 | 0;
 $16 = $4;
 $17 = $16 + 4 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $5;
 $20 = _mp_map_lookup($15, $18, $19) | 0;
 $7 = $20;
 $21 = $7;
 $22 = ($21 | 0) == (0 | 0);
 if (!$22) {
  $23 = $7;
  $24 = $23 + 4 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = ($25 | 0) == (0 | 0);
  if (!$26) {
   $43 = $7;
   $44 = $43 + 4 | 0;
   $45 = HEAP32[$44 >> 2] | 0;
   $8 = $45;
   $46 = $5;
   $47 = ($46 | 0) == 2;
   if (!$47) {
    $50 = $8;
    STACKTOP = sp;
    return $50 | 0;
   }
   $48 = $7;
   $49 = $48 + 4 | 0;
   HEAP32[$49 >> 2] = 0;
   $50 = $8;
   STACKTOP = sp;
   return $50 | 0;
  }
 }
 $27 = $3;
 $28 = ($27 | 0) == 2;
 do {
  if ($28) {
   $29 = $5;
   $30 = ($29 | 0) == 2;
   if ($30) {
    $31 = $4;
    $32 = $31 + 4 | 0;
    $33 = HEAP32[$32 >> 2] | 0;
    $34 = _mp_obj_new_exception_arg1(15592, $33) | 0;
    _nlr_jump($34);
   } else {
    $8 = 17668;
    break;
   }
  } else {
   $35 = $4;
   $36 = $35 + 8 | 0;
   $37 = HEAP32[$36 >> 2] | 0;
   $8 = $37;
  }
 } while (0);
 $38 = $5;
 $39 = ($38 | 0) == 1;
 if (!$39) {
  $50 = $8;
  STACKTOP = sp;
  return $50 | 0;
 }
 $40 = $8;
 $41 = $7;
 $42 = $41 + 4 | 0;
 HEAP32[$42 >> 2] = $40;
 $50 = $8;
 STACKTOP = sp;
 return $50 | 0;
}

function _mp_lexer_new($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = _m_malloc(84) | 0;
 $3 = $4;
 $5 = $2;
 $6 = $3;
 HEAP32[$6 >> 2] = $5;
 $7 = $3;
 $8 = $7 + 4 | 0;
 HEAP32[$8 >> 2] = HEAP32[$1 >> 2] | 0;
 HEAP32[$8 + 4 >> 2] = HEAP32[$1 + 4 >> 2] | 0;
 HEAP32[$8 + 8 >> 2] = HEAP32[$1 + 8 >> 2] | 0;
 $9 = $3;
 $10 = $9 + 28 | 0;
 HEAP32[$10 >> 2] = 1;
 $11 = $3;
 $12 = $11 + 32 | 0;
 HEAP32[$12 >> 2] = -2;
 $13 = $3;
 $14 = $13 + 36 | 0;
 HEAP32[$14 >> 2] = 0;
 $15 = $3;
 $16 = $15 + 40 | 0;
 HEAP32[$16 >> 2] = 0;
 $17 = $3;
 $18 = $17 + 44 | 0;
 HEAP32[$18 >> 2] = 10;
 $19 = $3;
 $20 = $19 + 48 | 0;
 HEAP32[$20 >> 2] = 1;
 $21 = $3;
 $22 = $21 + 44 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $23 << 1;
 $25 = _m_malloc($24) | 0;
 $26 = $3;
 $27 = $26 + 52 | 0;
 HEAP32[$27 >> 2] = $25;
 $28 = $3;
 $29 = $28 + 68 | 0;
 _vstr_init($29, 32);
 $30 = $3;
 $31 = $30 + 52 | 0;
 $32 = HEAP32[$31 >> 2] | 0;
 HEAP16[$32 >> 1] = 0;
 $33 = $3;
 $34 = $33 + 24 | 0;
 HEAP32[$34 >> 2] = 0;
 $35 = $3;
 $36 = $35 + 20 | 0;
 HEAP32[$36 >> 2] = 0;
 $37 = $3;
 $38 = $37 + 16 | 0;
 HEAP32[$38 >> 2] = 0;
 $39 = $3;
 _next_char($39);
 $40 = $3;
 _next_char($40);
 $41 = $3;
 _next_char($41);
 $42 = $3;
 _mp_lexer_to_next($42);
 $43 = $3;
 $44 = $43 + 60 | 0;
 $45 = HEAP32[$44 >> 2] | 0;
 $46 = ($45 | 0) != 1;
 if (!$46) {
  $49 = $3;
  STACKTOP = sp;
  return $49 | 0;
 }
 $47 = $3;
 $48 = $47 + 64 | 0;
 HEAP32[$48 >> 2] = 5;
 $49 = $3;
 STACKTOP = sp;
 return $49 | 0;
}

function _complex_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0.0, $13 = 0, $14 = 0, $15 = 0, $16 = 0.0, $17 = 0, $18 = 0, $19 = 0.0, $20 = 0, $21 = 0, $22 = 0, $23 = 0.0, $24 = 0, $25 = 0, $26 = 0, $27 = 0.0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0.0, $4 = 0, $40 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 80 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(80 | 0);
 $vararg_buffer4 = sp + 48 | 0;
 $vararg_buffer1 = sp + 40 | 0;
 $vararg_buffer = sp + 32 | 0;
 $7 = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $4;
 $6 = $9;
 $8 = 16;
 $10 = $6;
 $11 = $10 + 8 | 0;
 $12 = +HEAPF64[$11 >> 3];
 $13 = $12 == 0.0;
 $14 = $6;
 if ($13) {
  $15 = $14 + 16 | 0;
  $16 = +HEAPF64[$15 >> 3];
  _mp_format_float($16, $7, 32, 103, 16, 0) | 0;
  $17 = $3;
  HEAP32[$vararg_buffer >> 2] = $7;
  _mp_printf($17, 30963, $vararg_buffer) | 0;
  STACKTOP = sp;
  return;
 }
 $18 = $14 + 8 | 0;
 $19 = +HEAPF64[$18 >> 3];
 _mp_format_float($19, $7, 32, 103, 16, 0) | 0;
 $20 = $3;
 HEAP32[$vararg_buffer1 >> 2] = $7;
 _mp_printf($20, 30967, $vararg_buffer1) | 0;
 $21 = $6;
 $22 = $21 + 16 | 0;
 $23 = +HEAPF64[$22 >> 3];
 $24 = $23 >= 0.0;
 if ($24) {
  label = 5;
 } else {
  $25 = $6;
  $26 = $25 + 16 | 0;
  $27 = +HEAPF64[$26 >> 3];
  $28 = ___DOUBLE_BITS_870($27) | 0;
  $29 = getTempRet0() | 0;
  $30 = $29 & 2147483647;
  $31 = $30 >>> 0 > 2146435072;
  $32 = $28 >>> 0 > 0;
  $33 = ($30 | 0) == 2146435072;
  $34 = $33 & $32;
  $35 = $31 | $34;
  if ($35) {
   label = 5;
  }
 }
 if ((label | 0) == 5) {
  $36 = $3;
  _mp_print_str($36, 30971) | 0;
 }
 $37 = $6;
 $38 = $37 + 16 | 0;
 $39 = +HEAPF64[$38 >> 3];
 _mp_format_float($39, $7, 32, 103, 16, 0) | 0;
 $40 = $3;
 HEAP32[$vararg_buffer4 >> 2] = $7;
 _mp_printf($40, 30973, $vararg_buffer4) | 0;
 STACKTOP = sp;
 return;
}

function _mp_obj_tuple_subscr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $8 = sp + 8 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $11 = $6;
 $12 = ($11 | 0) == (4 | 0);
 if (!$12) {
  $3 = 0;
  $52 = $3;
  STACKTOP = sp;
  return $52 | 0;
 }
 $13 = $4;
 $7 = $13;
 $14 = $5;
 $15 = _mp_obj_is_obj_1239($14) | 0;
 if ($15) {
  $16 = $5;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = ($17 | 0) == (18228 | 0);
  if ($18) {
   $19 = $7;
   $20 = $19 + 4 | 0;
   $21 = HEAP32[$20 >> 2] | 0;
   $22 = $5;
   $23 = _mp_seq_get_fast_slice_indexes($21, $22, $8) | 0;
   if (!$23) {
    _mp_raise_NotImplementedError(32934);
   }
   $24 = $8 + 4 | 0;
   $25 = HEAP32[$24 >> 2] | 0;
   $26 = HEAP32[$8 >> 2] | 0;
   $27 = $25 - $26 | 0;
   $28 = _mp_obj_new_tuple($27, 0) | 0;
   $9 = $28;
   $29 = $9;
   $30 = $29 + 8 | 0;
   $31 = $7;
   $32 = $31 + 8 | 0;
   $33 = HEAP32[$8 >> 2] | 0;
   $34 = $32 + ($33 << 2) | 0;
   $35 = $9;
   $36 = $35 + 4 | 0;
   $37 = HEAP32[$36 >> 2] | 0;
   $38 = $37 << 2;
   _memcpy($30 | 0, $34 | 0, $38 | 0) | 0;
   $39 = $9;
   $3 = $39;
   $52 = $3;
   STACKTOP = sp;
   return $52 | 0;
  }
 }
 $40 = $7;
 $41 = HEAP32[$40 >> 2] | 0;
 $42 = $7;
 $43 = $42 + 4 | 0;
 $44 = HEAP32[$43 >> 2] | 0;
 $45 = $5;
 $46 = _mp_get_index($41, $44, $45, 0) | 0;
 $10 = $46;
 $47 = $7;
 $48 = $47 + 8 | 0;
 $49 = $10;
 $50 = $48 + ($49 << 2) | 0;
 $51 = HEAP32[$50 >> 2] | 0;
 $3 = $51;
 $52 = $3;
 STACKTOP = sp;
 return $52 | 0;
}

function _mp_obj_int_binary_op_extra_cases($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $6;
 $8 = ($7 | 0) == (13856 | 0);
 if ($8) {
  $9 = $4;
  $10 = $5;
  $11 = _mp_binary_op($9, $10, 1) | 0;
  $3 = $11;
  $41 = $3;
  STACKTOP = sp;
  return $41 | 0;
 }
 $12 = $6;
 $13 = ($12 | 0) == (13864 | 0);
 $14 = $4;
 if ($13) {
  $15 = $5;
  $16 = _mp_binary_op($14, $15, 3) | 0;
  $3 = $16;
  $41 = $3;
  STACKTOP = sp;
  return $41 | 0;
 }
 $17 = ($14 | 0) == 28;
 L9 : do {
  if ($17) {
   $18 = $6;
   $19 = _mp_obj_is_qstr_1015($18) | 0;
   do {
    if (!$19) {
     $20 = $6;
     $21 = _mp_obj_is_obj_1014($20) | 0;
     if ($21) {
      $22 = $6;
      $23 = HEAP32[$22 >> 2] | 0;
      $24 = $23 + 24 | 0;
      $25 = HEAP32[$24 >> 2] | 0;
      $26 = ($25 | 0) == (206 | 0);
      if ($26) {
       break;
      }
     }
     $27 = $6;
     $28 = _mp_obj_is_obj_1014($27) | 0;
     if ($28) {
      $29 = $6;
      $30 = HEAP32[$29 >> 2] | 0;
      $31 = ($30 | 0) == (18952 | 0);
      if ($31) {
       break;
      }
     }
     $32 = $6;
     $33 = _mp_obj_is_obj_1014($32) | 0;
     if (!$33) {
      break L9;
     }
     $34 = $6;
     $35 = HEAP32[$34 >> 2] | 0;
     $36 = ($35 | 0) == (17028 | 0);
     if (!$36) {
      break L9;
     }
    }
   } while (0);
   $37 = $4;
   $38 = $6;
   $39 = $5;
   $40 = _mp_binary_op($37, $38, $39) | 0;
   $3 = $40;
   $41 = $3;
   STACKTOP = sp;
   return $41 | 0;
  }
 } while (0);
 $3 = 0;
 $41 = $3;
 STACKTOP = sp;
 return $41 | 0;
}

function _mod_binascii_unhexlify($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $2 = sp + 32 | 0;
 $3 = sp + 16 | 0;
 $1 = $0;
 $9 = $1;
 _mp_get_buffer_raise($9, $2, 1);
 $10 = $2 + 4 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $11 & 1;
 $13 = ($12 | 0) != 0;
 if ($13) {
  _mp_raise_ValueError(34949);
 }
 $14 = $2 + 4 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = ($15 >>> 0) / 2 & -1;
 _vstr_init_len($3, $16);
 $17 = HEAP32[$2 >> 2] | 0;
 $4 = $17;
 $18 = $3 + 8 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $5 = $19;
 $6 = 0;
 $20 = $2 + 4 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $7 = $21;
 while (1) {
  $22 = $7;
  $23 = $22 + -1 | 0;
  $7 = $23;
  $24 = ($22 | 0) != 0;
  if (!$24) {
   label = 11;
   break;
  }
  $25 = $4;
  $26 = $25 + 1 | 0;
  $4 = $26;
  $27 = HEAP8[$25 >> 0] | 0;
  $8 = $27;
  $28 = $8;
  $29 = $28 & 255;
  $30 = _unichar_isxdigit($29) | 0;
  if (!$30) {
   label = 7;
   break;
  }
  $31 = $8;
  $32 = $31 & 255;
  $33 = _unichar_xdigit_value($32) | 0;
  $34 = $6;
  $35 = $34 & 255;
  $36 = $35 + $33 | 0;
  $37 = $36 & 255;
  $6 = $37;
  $38 = $7;
  $39 = $38 & 1;
  $40 = ($39 | 0) != 0;
  $41 = $6;
  if ($40) {
   $42 = $41 & 255;
   $43 = $42 << 4;
   $44 = $43 & 255;
   $6 = $44;
  } else {
   $45 = $5;
   $46 = $45 + 1 | 0;
   $5 = $46;
   HEAP8[$45 >> 0] = $41;
   $6 = 0;
  }
 }
 if ((label | 0) == 7) {
  _mp_raise_ValueError(34967);
 } else if ((label | 0) == 11) {
  $47 = _mp_obj_new_str_from_vstr(18304, $3) | 0;
  STACKTOP = sp;
  return $47 | 0;
 }
 return 0 | 0;
}

function _compile_global_nonlocal_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp + 16 | 0;
 $2 = $0;
 $3 = $1;
 $10 = $2;
 $11 = $10 + 5 | 0;
 $12 = HEAP8[$11 >> 0] | 0;
 $13 = $12 & 255;
 $14 = ($13 | 0) == 1;
 if (!$14) {
  STACKTOP = sp;
  return;
 }
 $15 = $3;
 $16 = $15 + 4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $17 & 255;
 $19 = ($18 | 0) == 16;
 $20 = $19 & 1;
 $4 = $20;
 $21 = $4;
 $22 = $21 & 1;
 if (!$22) {
  $23 = $2;
  $24 = $23 + 36 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = ($26 | 0) == 0;
  if ($27) {
   $28 = $2;
   $29 = $3;
   $30 = $29;
   _compile_syntax_error($28, $30, 29203);
   STACKTOP = sp;
   return;
  }
 }
 $31 = $3;
 $32 = $31 + 8 | 0;
 $33 = _mp_parse_node_extract_list($32, 108, $5) | 0;
 $6 = $33;
 $7 = 0;
 while (1) {
  $34 = $7;
  $35 = $6;
  $36 = ($34 | 0) < ($35 | 0);
  if (!$36) {
   break;
  }
  $37 = HEAP32[$5 >> 2] | 0;
  $38 = $7;
  $39 = $37 + ($38 << 2) | 0;
  $40 = HEAP32[$39 >> 2] | 0;
  $41 = $40 >>> 4;
  $8 = $41;
  $42 = $2;
  $43 = $42 + 36 | 0;
  $44 = HEAP32[$43 >> 2] | 0;
  $45 = $8;
  $46 = _scope_find_or_add_id($44, $45, 0) | 0;
  $9 = $46;
  $47 = $4;
  $48 = $47 & 1;
  $49 = $2;
  $50 = $3;
  $51 = $50;
  $52 = $9;
  if ($48) {
   _compile_declare_global($49, $51, $52);
  } else {
   _compile_declare_nonlocal($49, $51, $52);
  }
  $53 = $7;
  $54 = $53 + 1 | 0;
  $7 = $54;
 }
 STACKTOP = sp;
 return;
}

function _mp_help_print_modules() {
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $0 = sp + 28 | 0;
 $1 = sp + 24 | 0;
 $2 = sp + 20 | 0;
 $8 = _mp_obj_new_list(0, 0) | 0;
 HEAP32[$0 >> 2] = $8;
 $9 = HEAP32[$0 >> 2] | 0;
 _mp_help_add_from_map($9, 17324);
 $10 = HEAP32[$0 >> 2] | 0;
 _mp_help_add_from_map($10, 17336);
 _mp_obj_list_sort(1, $0, 13444) | 0;
 $11 = HEAP32[$0 >> 2] | 0;
 _mp_obj_list_get($11, $1, $2);
 $12 = HEAP32[$1 >> 2] | 0;
 $13 = $12 + 4 | 0;
 $14 = $13 - 1 | 0;
 $15 = ($14 >>> 0) / 4 & -1;
 $3 = $15;
 $4 = 0;
 while (1) {
  $16 = $4;
  $17 = $3;
  $18 = $16 >>> 0 < $17 >>> 0;
  if (!$18) {
   break;
  }
  $19 = $4;
  $5 = $19;
  while (1) {
   $20 = HEAP32[$2 >> 2] | 0;
   $21 = $5;
   $22 = $20 + ($21 << 2) | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   $24 = _mp_obj_str_get_str($23) | 0;
   $25 = _mp_print_str(13344, $24) | 0;
   $6 = $25;
   $26 = $3;
   $27 = $5;
   $28 = $27 + $26 | 0;
   $5 = $28;
   $29 = $5;
   $30 = HEAP32[$1 >> 2] | 0;
   $31 = $29 >>> 0 >= $30 >>> 0;
   if ($31) {
    break;
   }
   $32 = $6;
   $33 = 18 - $32 | 0;
   $7 = $33;
   while (1) {
    $34 = $7;
    $35 = ($34 | 0) < 1;
    if (!$35) {
     break;
    }
    $36 = $7;
    $37 = $36 + 18 | 0;
    $7 = $37;
   }
   while (1) {
    $38 = $7;
    $39 = $38 + -1 | 0;
    $7 = $39;
    $40 = ($38 | 0) != 0;
    if (!$40) {
     break;
    }
    _mp_print_str(13344, 34451) | 0;
   }
  }
  _mp_print_str(13344, 34812) | 0;
  $41 = $4;
  $42 = $41 + 1 | 0;
  $4 = $42;
 }
 _mp_print_str(13344, 33632) | 0;
 STACKTOP = sp;
 return;
}

function _module_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $3;
 $6 = $9;
 $10 = $5;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = ($11 | 0) == (0 | 0);
 $13 = $6;
 $14 = $13 + 4 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 if ($12) {
  $16 = $15 + 4 | 0;
  $17 = $4;
  $18 = $17 << 2;
  $19 = $18 | 2;
  $20 = $19;
  $21 = _mp_map_lookup($16, $20, 0) | 0;
  $7 = $21;
  $22 = $7;
  $23 = ($22 | 0) != (0 | 0);
  if (!$23) {
   STACKTOP = sp;
   return;
  }
  $24 = $7;
  $25 = $24 + 4 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $5;
  HEAP32[$27 >> 2] = $26;
  STACKTOP = sp;
  return;
 }
 $8 = $15;
 $28 = $8;
 $29 = $28 + 4 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = $30 >>> 1;
 $32 = $31 & 1;
 $33 = ($32 | 0) != 0;
 if ($33) {
  $34 = $8;
  $35 = ($34 | 0) == (19844 | 0);
  if (!$35) {
   STACKTOP = sp;
   return;
  }
  $36 = HEAP32[40684 >> 2] | 0;
  $37 = ($36 | 0) == (0 | 0);
  if ($37) {
   $38 = _mp_obj_new_dict(1) | 0;
   HEAP32[40684 >> 2] = $38;
  }
  $39 = HEAP32[40684 >> 2] | 0;
  $8 = $39;
 }
 $40 = $5;
 $41 = $40 + 4 | 0;
 $42 = HEAP32[$41 >> 2] | 0;
 $43 = ($42 | 0) == (0 | 0);
 $44 = $8;
 $45 = $4;
 $46 = $45 << 2;
 $47 = $46 | 2;
 $48 = $47;
 if ($43) {
  _mp_obj_dict_delete($44, $48) | 0;
 } else {
  $49 = $5;
  $50 = $49 + 4 | 0;
  $51 = HEAP32[$50 >> 2] | 0;
  _mp_obj_dict_store($44, $48, $51) | 0;
 }
 $52 = $5;
 HEAP32[$52 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _compile_raise_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = ($6 | 0) == 0;
 if ($7) {
  $8 = $2;
  $9 = $8 + 40 | 0;
  $10 = HEAP32[$9 >> 2] | 0;
  _mp_emit_bc_raise_varargs($10, 0);
  STACKTOP = sp;
  return;
 }
 $11 = $3;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = ($13 | 0) != 0;
 if ($14) {
  $15 = $3;
  $16 = $15 + 8 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = $17 & 3;
  $19 = ($18 | 0) == 0;
  if ($19) {
   $20 = $3;
   $21 = $20 + 8 | 0;
   $22 = HEAP32[$21 >> 2] | 0;
   $23 = $22;
   $24 = $23 + 4 | 0;
   $25 = HEAP32[$24 >> 2] | 0;
   $26 = $25 & 255;
   $27 = ($26 | 0) == 93;
   if ($27) {
    $28 = $3;
    $29 = $28 + 8 | 0;
    $30 = HEAP32[$29 >> 2] | 0;
    $31 = $30;
    $3 = $31;
    $32 = $2;
    $33 = $3;
    $34 = $33 + 8 | 0;
    $35 = HEAP32[$34 >> 2] | 0;
    _compile_node($32, $35);
    $36 = $2;
    $37 = $3;
    $38 = $37 + 8 | 0;
    $39 = $38 + 4 | 0;
    $40 = HEAP32[$39 >> 2] | 0;
    _compile_node($36, $40);
    $41 = $2;
    $42 = $41 + 40 | 0;
    $43 = HEAP32[$42 >> 2] | 0;
    _mp_emit_bc_raise_varargs($43, 2);
    STACKTOP = sp;
    return;
   }
  }
 }
 $44 = $2;
 $45 = $3;
 $46 = $45 + 8 | 0;
 $47 = HEAP32[$46 >> 2] | 0;
 _compile_node($44, $47);
 $48 = $2;
 $49 = $48 + 40 | 0;
 $50 = HEAP32[$49 >> 2] | 0;
 _mp_emit_bc_raise_varargs($50, 1);
 STACKTOP = sp;
 return;
}

function _array_get_buffer($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $9 = $4;
 $7 = $9;
 $10 = $7;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $12 & 255;
 $14 = $13 & 127;
 $15 = $14 & 255;
 $16 = _mp_binary_get_size(64, $15, 0) | 0;
 $8 = $16;
 $17 = $7;
 $18 = $17 + 12 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $5;
 HEAP32[$20 >> 2] = $19;
 $21 = $7;
 $22 = $21 + 8 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $8;
 $25 = Math_imul($23, $24) | 0;
 $26 = $5;
 $27 = $26 + 4 | 0;
 HEAP32[$27 >> 2] = $25;
 $28 = $7;
 $29 = $28 + 4 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = $30 & 255;
 $32 = $31 & 127;
 $33 = $5;
 $34 = $33 + 8 | 0;
 HEAP32[$34 >> 2] = $32;
 $35 = $7;
 $36 = HEAP32[$35 >> 2] | 0;
 $37 = ($36 | 0) == (13464 | 0);
 if ($37) {
  $38 = $7;
  $39 = $38 + 4 | 0;
  $40 = HEAP32[$39 >> 2] | 0;
  $41 = $40 & 255;
  $42 = $41 & 128;
  $43 = ($42 | 0) != 0;
  if (!$43) {
   $44 = $6;
   $45 = $44 & 2;
   $46 = ($45 | 0) != 0;
   if ($46) {
    $3 = 1;
    $57 = $3;
    STACKTOP = sp;
    return $57 | 0;
   }
  }
  $47 = $5;
  $48 = HEAP32[$47 >> 2] | 0;
  $49 = $7;
  $50 = $49 + 4 | 0;
  $51 = HEAP32[$50 >> 2] | 0;
  $52 = $51 >>> 8;
  $53 = $8;
  $54 = Math_imul($52, $53) | 0;
  $55 = $48 + $54 | 0;
  $56 = $5;
  HEAP32[$56 >> 2] = $55;
 }
 $3 = 0;
 $57 = $3;
 STACKTOP = sp;
 return $57 | 0;
}

function _mp_obj_float_divmod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0.0, $11 = 0.0, $12 = 0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0, $21 = 0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0, $26 = 0, $27 = 0, $28 = 0.0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0, $4 = 0.0, $40 = 0, $41 = 0.0, $42 = 0, $43 = 0.0, $44 = 0.0, $45 = 0.0, $46 = 0.0, $47 = 0.0, $48 = 0.0, $49 = 0.0, $5 = 0.0, $50 = 0.0, $51 = 0, $52 = 0.0, $53 = 0.0, $54 = 0.0, $55 = 0, $56 = 0.0, $57 = 0, $6 = 0.0, $7 = 0, $8 = 0.0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $7 = $2;
 $8 = +HEAPF64[$7 >> 3];
 $9 = $3;
 $10 = +HEAPF64[$9 >> 3];
 $11 = $8 % $10;
 $4 = $11;
 $12 = $2;
 $13 = +HEAPF64[$12 >> 3];
 $14 = $4;
 $15 = $13 - $14;
 $16 = $3;
 $17 = +HEAPF64[$16 >> 3];
 $18 = $15 / $17;
 $5 = $18;
 $19 = $4;
 $20 = $19 == 0.0;
 if ($20) {
  $21 = $3;
  $22 = +HEAPF64[$21 >> 3];
  $23 = +_llvm_copysign_f64(0.0, +$22);
  $4 = $23;
 } else {
  $24 = $4;
  $25 = $24 < 0.0;
  $26 = $25 & 1;
  $27 = $3;
  $28 = +HEAPF64[$27 >> 3];
  $29 = $28 < 0.0;
  $30 = $29 & 1;
  $31 = ($26 | 0) != ($30 | 0);
  if ($31) {
   $32 = $3;
   $33 = +HEAPF64[$32 >> 3];
   $34 = $4;
   $35 = $34 + $33;
   $4 = $35;
   $36 = $5;
   $37 = $36 - 1.0;
   $5 = $37;
  }
 }
 $38 = $5;
 $39 = $38 == 0.0;
 if ($39) {
  $40 = $2;
  $41 = +HEAPF64[$40 >> 3];
  $42 = $3;
  $43 = +HEAPF64[$42 >> 3];
  $44 = $41 / $43;
  $45 = +_llvm_copysign_f64(0.0, +$44);
  $6 = $45;
 } else {
  $46 = $5;
  $47 = +Math_floor(+$46);
  $6 = $47;
  $48 = $5;
  $49 = $6;
  $50 = $48 - $49;
  $51 = $50 > .5;
  if ($51) {
   $52 = $6;
   $53 = $52 + 1.0;
   $6 = $53;
  }
 }
 $54 = $6;
 $55 = $2;
 HEAPF64[$55 >> 3] = $54;
 $56 = $4;
 $57 = $3;
 HEAPF64[$57 >> 3] = $56;
 STACKTOP = sp;
 return;
}

function _compile_comprehension($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $4;
 $10 = $9 + 8 | 0;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $12;
 $6 = $13;
 $14 = $3;
 $15 = $14 + 5 | 0;
 $16 = HEAP8[$15 >> 0] | 0;
 $17 = $16 & 255;
 $18 = ($17 | 0) == 1;
 if ($18) {
  $19 = $3;
  $20 = $5;
  $21 = $4;
  $22 = $21;
  $23 = $3;
  $24 = $23 + 36 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = $25 + 26 | 0;
  $27 = HEAP16[$26 >> 1] | 0;
  $28 = $27 & 65535;
  $29 = _scope_new_and_link($19, $20, $22, $28) | 0;
  $7 = $29;
  $30 = $7;
  $31 = $30;
  $32 = $6;
  $33 = $32 + 8 | 0;
  $34 = $33 + 12 | 0;
  HEAP32[$34 >> 2] = $31;
 }
 $35 = $6;
 $36 = $35 + 8 | 0;
 $37 = $36 + 12 | 0;
 $38 = HEAP32[$37 >> 2] | 0;
 $39 = $38;
 $8 = $39;
 $40 = $3;
 $41 = $8;
 _close_over_variables_etc($40, $41, 0, 0);
 $42 = $3;
 $43 = $6;
 $44 = $43 + 8 | 0;
 $45 = $44 + 4 | 0;
 $46 = HEAP32[$45 >> 2] | 0;
 _compile_node($42, $46);
 $47 = $5;
 $48 = ($47 | 0) == 6;
 if (!$48) {
  $52 = $3;
  $53 = $52 + 40 | 0;
  $54 = HEAP32[$53 >> 2] | 0;
  _mp_emit_bc_call_function($54, 1, 0, 0);
  STACKTOP = sp;
  return;
 }
 $49 = $3;
 $50 = $49 + 40 | 0;
 $51 = HEAP32[$50 >> 2] | 0;
 _mp_emit_bc_get_iter($51, 0);
 $52 = $3;
 $53 = $52 + 40 | 0;
 $54 = HEAP32[$53 >> 2] | 0;
 _mp_emit_bc_call_function($54, 1, 0, 0);
 STACKTOP = sp;
 return;
}

function _list_insert($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $3;
 $6 = $9;
 $10 = $4;
 $11 = $10;
 $12 = $11 >> 1;
 $7 = $12;
 $13 = $7;
 $14 = ($13 | 0) < 0;
 if ($14) {
  $15 = $6;
  $16 = $15 + 8 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = $7;
  $19 = $18 + $17 | 0;
  $7 = $19;
 }
 $20 = $7;
 $21 = ($20 | 0) < 0;
 if ($21) {
  $7 = 0;
 }
 $22 = $7;
 $23 = $6;
 $24 = $23 + 8 | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = $22 >>> 0 > $25 >>> 0;
 if ($26) {
  $27 = $6;
  $28 = $27 + 8 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  $7 = $29;
 }
 $30 = $3;
 _mp_obj_list_append($30, 17668) | 0;
 $31 = $6;
 $32 = $31 + 8 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = $33 - 1 | 0;
 $8 = $34;
 while (1) {
  $35 = $8;
  $36 = $7;
  $37 = ($35 | 0) > ($36 | 0);
  if (!$37) {
   break;
  }
  $38 = $6;
  $39 = $38 + 12 | 0;
  $40 = HEAP32[$39 >> 2] | 0;
  $41 = $8;
  $42 = $41 - 1 | 0;
  $43 = $40 + ($42 << 2) | 0;
  $44 = HEAP32[$43 >> 2] | 0;
  $45 = $6;
  $46 = $45 + 12 | 0;
  $47 = HEAP32[$46 >> 2] | 0;
  $48 = $8;
  $49 = $47 + ($48 << 2) | 0;
  HEAP32[$49 >> 2] = $44;
  $50 = $8;
  $51 = $50 + -1 | 0;
  $8 = $51;
 }
 $52 = $5;
 $53 = $6;
 $54 = $53 + 12 | 0;
 $55 = HEAP32[$54 >> 2] | 0;
 $56 = $7;
 $57 = $55 + ($56 << 2) | 0;
 HEAP32[$57 >> 2] = $52;
 STACKTOP = sp;
 return 17668 | 0;
}

function _int_from_bytes($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = sp + 16 | 0;
 $3 = $0;
 $4 = $1;
 $10 = $4;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 _mp_get_buffer_raise($12, $5, 1);
 $13 = HEAP32[$5 >> 2] | 0;
 $6 = $13;
 $7 = 1;
 $14 = $4;
 $15 = $14 + 8 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($16 | 0) == (438 | 0);
 if ($17) {
  $18 = $5 + 4 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = $19 - 1 | 0;
  $21 = $6;
  $22 = $21 + $20 | 0;
  $6 = $22;
  $7 = -1;
 }
 $8 = 0;
 $23 = $5 + 4 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $9 = $24;
 while (1) {
  $25 = $9;
  $26 = $25 + -1 | 0;
  $9 = $26;
  $27 = ($25 | 0) != 0;
  $28 = $8;
  if (!$27) {
   label = 8;
   break;
  }
  $29 = $28 >>> 0 > 4194303;
  if ($29) {
   label = 6;
   break;
  }
  $38 = $8;
  $39 = $38 << 8;
  $40 = $6;
  $41 = HEAP8[$40 >> 0] | 0;
  $42 = $41 & 255;
  $43 = $39 | $42;
  $8 = $43;
  $44 = $7;
  $45 = $6;
  $46 = $45 + $44 | 0;
  $6 = $46;
 }
 if ((label | 0) == 6) {
  $30 = $4;
  $31 = $30 + 8 | 0;
  $32 = HEAP32[$31 >> 2] | 0;
  $33 = ($32 | 0) != (438 | 0);
  $34 = $5 + 4 | 0;
  $35 = HEAP32[$34 >> 2] | 0;
  $36 = HEAP32[$5 >> 2] | 0;
  $37 = _mp_obj_int_from_bytes_impl($33, $35, $36) | 0;
  $2 = $37;
  $48 = $2;
  STACKTOP = sp;
  return $48 | 0;
 } else if ((label | 0) == 8) {
  $47 = _mp_obj_new_int_from_uint($28) | 0;
  $2 = $47;
  $48 = $2;
  STACKTOP = sp;
  return $48 | 0;
 }
 return 0 | 0;
}

function _find_file($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $7 = sp + 20 | 0;
 $8 = sp + 16 | 0;
 $10 = sp + 8 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 _mp_obj_list_get(40652, $7, $8);
 $13 = HEAP32[$7 >> 2] | 0;
 $14 = ($13 | 0) == 0;
 if ($14) {
  $15 = $6;
  $16 = $4;
  $17 = $5;
  _vstr_add_strn($15, $16, $17);
  $18 = $6;
  $19 = _stat_dir_or_file($18) | 0;
  $3 = $19;
  $45 = $3;
  STACKTOP = sp;
  return $45 | 0;
 }
 $9 = 0;
 while (1) {
  $20 = $9;
  $21 = HEAP32[$7 >> 2] | 0;
  $22 = $20 >>> 0 < $21 >>> 0;
  if (!$22) {
   label = 10;
   break;
  }
  $23 = $6;
  _vstr_reset_1359($23);
  $24 = HEAP32[$8 >> 2] | 0;
  $25 = $9;
  $26 = $24 + ($25 << 2) | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $28 = _mp_obj_str_get_data($27, $10) | 0;
  $11 = $28;
  $29 = HEAP32[$10 >> 2] | 0;
  $30 = $29 >>> 0 > 0;
  if ($30) {
   $31 = $6;
   $32 = $11;
   $33 = HEAP32[$10 >> 2] | 0;
   _vstr_add_strn($31, $32, $33);
   $34 = $6;
   _vstr_add_char($34, 47);
  }
  $35 = $6;
  $36 = $4;
  $37 = $5;
  _vstr_add_strn($35, $36, $37);
  $38 = $6;
  $39 = _stat_dir_or_file($38) | 0;
  $12 = $39;
  $40 = $12;
  $41 = ($40 | 0) != 0;
  if ($41) {
   label = 8;
   break;
  }
  $43 = $9;
  $44 = $43 + 1 | 0;
  $9 = $44;
 }
 if ((label | 0) == 8) {
  $42 = $12;
  $3 = $42;
  $45 = $3;
  STACKTOP = sp;
  return $45 | 0;
 } else if ((label | 0) == 10) {
  $3 = 0;
  $45 = $3;
  STACKTOP = sp;
  return $45 | 0;
 }
 return 0 | 0;
}

function _mp_binary_set_val_array($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0.0, $13 = Math_fround(0), $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0.0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $4;
 $10 = $9 << 24 >> 24;
 switch ($10 | 0) {
 case 102:
  {
   $11 = $7;
   $12 = +_mp_obj_get_float($11);
   $13 = Math_fround($12);
   $14 = $5;
   $15 = $6;
   $16 = $14 + ($15 << 2) | 0;
   HEAPF32[$16 >> 2] = $13;
   STACKTOP = sp;
   return;
   break;
  }
 case 100:
  {
   $17 = $7;
   $18 = +_mp_obj_get_float($17);
   $19 = $5;
   $20 = $6;
   $21 = $19 + ($20 << 3) | 0;
   HEAPF64[$21 >> 3] = $18;
   STACKTOP = sp;
   return;
   break;
  }
 case 79:
  {
   $22 = $7;
   $23 = $5;
   $24 = $6;
   $25 = $23 + ($24 << 2) | 0;
   HEAP32[$25 >> 2] = $22;
   STACKTOP = sp;
   return;
   break;
  }
 default:
  {
   $26 = $7;
   $27 = _mp_obj_is_obj_1345($26) | 0;
   if ($27) {
    $28 = $7;
    $29 = HEAP32[$28 >> 2] | 0;
    $30 = ($29 | 0) == (16904 | 0);
    if ($30) {
     $31 = $4;
     $32 = _mp_binary_get_size(64, $31, 0) | 0;
     $8 = $32;
     $33 = $7;
     $34 = $8;
     $35 = $5;
     $36 = $6;
     $37 = $8;
     $38 = Math_imul($36, $37) | 0;
     $39 = $35 + $38 | 0;
     _mp_obj_int_to_bytes_impl($33, 0, $34, $39);
     STACKTOP = sp;
     return;
    }
   }
   $40 = $4;
   $41 = $5;
   $42 = $6;
   $43 = $7;
   $44 = _mp_obj_get_int($43) | 0;
   _mp_binary_set_val_array_from_int($40, $41, $42, $44);
   STACKTOP = sp;
   return;
  }
 }
}

function _uctypes_struct_sizeof($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = sp + 12 | 0;
 $3 = $0;
 $4 = $1;
 $10 = $4;
 $11 = HEAP32[$10 >> 2] | 0;
 $5 = $11;
 HEAP32[$6 >> 2] = 0;
 $12 = $5;
 $13 = _mp_obj_is_obj_1471($12) | 0;
 if ($13) {
  $14 = $5;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = ($15 | 0) == (13584 | 0);
  if ($16) {
   $17 = $5;
   $18 = _mp_obj_len($17) | 0;
   $2 = $18;
   $46 = $2;
   STACKTOP = sp;
   return $46 | 0;
  }
 }
 $7 = 2;
 $19 = $5;
 $20 = _mp_obj_is_obj_1471($19) | 0;
 do {
  if ($20) {
   $21 = $5;
   $22 = HEAP32[$21 >> 2] | 0;
   $23 = ($22 | 0) == (20948 | 0);
   if ($23) {
    $24 = $3;
    $25 = ($24 | 0) != 1;
    if ($25) {
     _mp_raise_TypeError(0);
    } else {
     $26 = $5;
     $8 = $26;
     $27 = $8;
     $28 = $27 + 4 | 0;
     $29 = HEAP32[$28 >> 2] | 0;
     $5 = $29;
     $30 = $8;
     $31 = $30 + 12 | 0;
     $32 = HEAP32[$31 >> 2] | 0;
     $7 = $32;
     break;
    }
   } else {
    label = 9;
   }
  } else {
   label = 9;
  }
 } while (0);
 if ((label | 0) == 9) {
  $33 = $3;
  $34 = ($33 | 0) == 2;
  if ($34) {
   $35 = $4;
   $36 = $35 + 4 | 0;
   $37 = HEAP32[$36 >> 2] | 0;
   $38 = _mp_obj_get_int($37) | 0;
   $7 = $38;
  }
 }
 $39 = $5;
 $40 = $7;
 $41 = _uctypes_struct_size($39, $40, $6) | 0;
 $9 = $41;
 $42 = $9;
 $43 = $42 << 1;
 $44 = $43 | 1;
 $45 = $44;
 $2 = $45;
 $46 = $2;
 STACKTOP = sp;
 return $46 | 0;
}

function _int_to_bytes($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $6 = sp + 16 | 0;
 $2 = $0;
 $3 = $1;
 $10 = $3;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = _mp_obj_get_int($12) | 0;
 $4 = $13;
 $14 = $4;
 $15 = ($14 | 0) < 0;
 if ($15) {
  _mp_raise_ValueError(0);
 }
 $16 = $3;
 $17 = $16 + 8 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = ($18 | 0) != (438 | 0);
 $20 = $19 & 1;
 $5 = $20;
 $21 = $4;
 _vstr_init_len($6, $21);
 $22 = $6 + 8 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $7 = $23;
 $24 = $7;
 $25 = $4;
 _memset($24 | 0, 0, $25 | 0) | 0;
 $26 = $3;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = _mp_obj_is_small_int_1012($27) | 0;
 $29 = $3;
 $30 = HEAP32[$29 >> 2] | 0;
 if (!$28) {
  $31 = $5;
  $32 = $31 & 1;
  $33 = $4;
  $34 = $7;
  _mp_obj_int_to_bytes_impl($30, $32, $33, $34);
  $53 = _mp_obj_new_str_from_vstr(18304, $6) | 0;
  STACKTOP = sp;
  return $53 | 0;
 }
 $35 = $30;
 $36 = $35 >> 1;
 $8 = $36;
 $37 = $4;
 $38 = $37 >>> 0 < 4;
 $39 = $4;
 $40 = $38 ? $39 : 4;
 $9 = $40;
 $41 = $9;
 $42 = $5;
 $43 = $42 & 1;
 $44 = $7;
 $45 = $5;
 $46 = $45 & 1;
 if ($46) {
  $47 = $4;
  $48 = $9;
  $49 = $47 - $48 | 0;
  $51 = $49;
 } else {
  $51 = 0;
 }
 $50 = $44 + $51 | 0;
 $52 = $8;
 _mp_binary_set_int($41, $43, $50, $52);
 $53 = _mp_obj_new_str_from_vstr(18304, $6) | 0;
 STACKTOP = sp;
 return $53 | 0;
}

function _mp_builtin_round($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0.0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0.0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0.0, $33 = 0.0, $34 = 0.0, $35 = 0.0, $36 = 0.0, $37 = 0.0, $38 = 0.0, $39 = 0.0, $4 = 0, $40 = 0.0, $41 = 0, $42 = 0.0, $43 = 0.0, $44 = 0.0, $45 = 0, $46 = 0, $5 = 0, $6 = 0.0, $7 = 0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $3 = $0;
 $4 = $1;
 $11 = $4;
 $12 = HEAP32[$11 >> 2] | 0;
 $5 = $12;
 $13 = $5;
 $14 = _mp_obj_is_small_int_1399($13) | 0;
 do {
  if (!$14) {
   $15 = $5;
   $16 = _mp_obj_is_obj_1391($15) | 0;
   if ($16) {
    $17 = $5;
    $18 = HEAP32[$17 >> 2] | 0;
    $19 = ($18 | 0) == (16904 | 0);
    if ($19) {
     break;
    }
   }
   $23 = $5;
   $24 = +_mp_obj_get_float($23);
   $6 = $24;
   $25 = $3;
   $26 = $25 >>> 0 > 1;
   if ($26) {
    $27 = $4;
    $28 = $27 + 4 | 0;
    $29 = HEAP32[$28 >> 2] | 0;
    $30 = _mp_obj_get_int($29) | 0;
    $7 = $30;
    $31 = $7;
    $32 = +($31 | 0);
    $33 = +Math_pow(10.0, +$32);
    $8 = $33;
    $34 = $6;
    $35 = $8;
    $36 = $34 * $35;
    $37 = +_llvm_nearbyint_f64(+$36);
    $38 = $8;
    $39 = $37 / $38;
    $9 = $39;
    $40 = $9;
    $41 = _mp_obj_new_float($40) | 0;
    $2 = $41;
    $46 = $2;
    STACKTOP = sp;
    return $46 | 0;
   } else {
    $42 = $6;
    $43 = +_llvm_nearbyint_f64(+$42);
    $10 = $43;
    $44 = $10;
    $45 = _mp_obj_new_int_from_float($44) | 0;
    $2 = $45;
    $46 = $2;
    STACKTOP = sp;
    return $46 | 0;
   }
  }
 } while (0);
 $20 = $3;
 $21 = $20 >>> 0 <= 1;
 if (!$21) {
  _mp_raise_NotImplementedError(0);
 }
 $22 = $5;
 $2 = $22;
 $46 = $2;
 STACKTOP = sp;
 return $46 | 0;
}

function _mp_obj_list_append($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $4 = $5;
 $6 = $4;
 $7 = $6 + 8 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $4;
 $10 = $9 + 4 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $8 >>> 0 >= $11 >>> 0;
 if ($12) {
  $13 = $4;
  $14 = $13 + 12 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $4;
  $17 = $16 + 4 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = $18 << 1;
  $20 = $19 << 2;
  $21 = _m_realloc($15, $20) | 0;
  $22 = $4;
  $23 = $22 + 12 | 0;
  HEAP32[$23 >> 2] = $21;
  $24 = $4;
  $25 = $24 + 4 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $26 << 1;
  HEAP32[$25 >> 2] = $27;
  $28 = $4;
  $29 = $28 + 12 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = $4;
  $32 = $31 + 8 | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = $33 + 1 | 0;
  $35 = $34 << 2;
  $36 = $30 + $35 | 0;
  $37 = $4;
  $38 = $37 + 4 | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  $40 = $4;
  $41 = $40 + 8 | 0;
  $42 = HEAP32[$41 >> 2] | 0;
  $43 = $42 + 1 | 0;
  $44 = $39 - $43 | 0;
  $45 = $44 << 2;
  _memset($36 | 0, 0, $45 | 0) | 0;
 }
 $46 = $3;
 $47 = $4;
 $48 = $47 + 12 | 0;
 $49 = HEAP32[$48 >> 2] | 0;
 $50 = $4;
 $51 = $50 + 8 | 0;
 $52 = HEAP32[$51 >> 2] | 0;
 $53 = $52 + 1 | 0;
 HEAP32[$51 >> 2] = $53;
 $54 = $49 + ($52 << 2) | 0;
 HEAP32[$54 >> 2] = $46;
 STACKTOP = sp;
 return 17668 | 0;
}

function _mvlsb_fill_rect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $58 = 0, $59 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 while (1) {
  $15 = $10;
  $16 = $15 + -1 | 0;
  $10 = $16;
  $17 = ($15 | 0) != 0;
  if (!$17) {
   break;
  }
  $18 = $6;
  $19 = $18 + 8 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = $8;
  $22 = $21 >> 3;
  $23 = $6;
  $24 = $23 + 16 | 0;
  $25 = HEAP16[$24 >> 1] | 0;
  $26 = $25 & 65535;
  $27 = Math_imul($22, $26) | 0;
  $28 = $7;
  $29 = $27 + $28 | 0;
  $30 = $20 + $29 | 0;
  $12 = $30;
  $31 = $8;
  $32 = $31 & 7;
  $33 = $32 & 255;
  $13 = $33;
  $34 = $9;
  $14 = $34;
  while (1) {
   $35 = $14;
   $36 = ($35 | 0) != 0;
   if (!$36) {
    break;
   }
   $37 = $12;
   $38 = HEAP8[$37 >> 0] | 0;
   $39 = $38 & 255;
   $40 = $13;
   $41 = $40 & 255;
   $42 = 1 << $41;
   $43 = $42 ^ -1;
   $44 = $39 & $43;
   $45 = $11;
   $46 = ($45 | 0) != 0;
   $47 = $46 & 1;
   $48 = $13;
   $49 = $48 & 255;
   $50 = $47 << $49;
   $51 = $44 | $50;
   $52 = $51 & 255;
   $53 = $12;
   HEAP8[$53 >> 0] = $52;
   $54 = $12;
   $55 = $54 + 1 | 0;
   $12 = $55;
   $56 = $14;
   $57 = $56 + -1 | 0;
   $14 = $57;
  }
  $58 = $8;
  $59 = $58 + 1 | 0;
  $8 = $59;
 }
 STACKTOP = sp;
 return;
}

function _stream_write_method($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = sp + 8 | 0;
 $2 = $0;
 $3 = $1;
 $7 = $3;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 _mp_get_buffer_raise($9, $4, 1);
 $5 = -1;
 $6 = 0;
 $10 = $2;
 $11 = ($10 | 0) == 3;
 if ($11) {
  $12 = $3;
  $13 = $12 + 8 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = _mp_obj_get_int_truncated($14) | 0;
  $5 = $15;
 } else {
  $16 = $2;
  $17 = ($16 | 0) == 4;
  if ($17) {
   $18 = $3;
   $19 = $18 + 8 | 0;
   $20 = HEAP32[$19 >> 2] | 0;
   $21 = _mp_obj_get_int_truncated($20) | 0;
   $6 = $21;
   $22 = $3;
   $23 = $22 + 12 | 0;
   $24 = HEAP32[$23 >> 2] | 0;
   $25 = _mp_obj_get_int_truncated($24) | 0;
   $5 = $25;
   $26 = $6;
   $27 = $4 + 4 | 0;
   $28 = HEAP32[$27 >> 2] | 0;
   $29 = $26 >>> 0 > $28 >>> 0;
   if ($29) {
    $30 = $4 + 4 | 0;
    $31 = HEAP32[$30 >> 2] | 0;
    $6 = $31;
   }
  }
 }
 $32 = $6;
 $33 = $4 + 4 | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = $34 - $32 | 0;
 HEAP32[$33 >> 2] = $35;
 $36 = $3;
 $37 = HEAP32[$36 >> 2] | 0;
 $38 = HEAP32[$4 >> 2] | 0;
 $39 = $6;
 $40 = $38 + $39 | 0;
 $41 = $4 + 4 | 0;
 $42 = HEAP32[$41 >> 2] | 0;
 $43 = $5;
 $44 = $42 >>> 0 < $43 >>> 0;
 $45 = $4 + 4 | 0;
 $46 = HEAP32[$45 >> 2] | 0;
 $47 = $5;
 $48 = $44 ? $46 : $47;
 $49 = _mp_stream_write($37, $40, $48, 2) | 0;
 STACKTOP = sp;
 return $49 | 0;
}

function _mp_small_int_mul_overflow($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$expand_i1_val4 = 0, $$expand_i1_val6 = 0, $$expand_i1_val8 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $3;
 $6 = ($5 | 0) > 0;
 $7 = $4;
 $8 = ($7 | 0) > 0;
 do {
  if ($6) {
   if ($8) {
    $9 = $3;
    $10 = $4;
    $11 = 1073741823 / ($10 | 0) & -1;
    $12 = ($9 | 0) > ($11 | 0);
    if (!$12) {
     label = 13;
     break;
    }
    $$expand_i1_val = 1;
    HEAP8[$2 >> 0] = $$expand_i1_val;
    break;
   } else {
    $13 = $4;
    $14 = $3;
    $15 = -1073741824 / ($14 | 0) & -1;
    $16 = ($13 | 0) < ($15 | 0);
    if (!$16) {
     label = 13;
     break;
    }
    $$expand_i1_val2 = 1;
    HEAP8[$2 >> 0] = $$expand_i1_val2;
    break;
   }
  } else {
   $17 = $3;
   if ($8) {
    $18 = $4;
    $19 = -1073741824 / ($18 | 0) & -1;
    $20 = ($17 | 0) < ($19 | 0);
    if (!$20) {
     label = 13;
     break;
    }
    $$expand_i1_val4 = 1;
    HEAP8[$2 >> 0] = $$expand_i1_val4;
    break;
   }
   $21 = ($17 | 0) != 0;
   if ($21) {
    $22 = $4;
    $23 = $3;
    $24 = 1073741823 / ($23 | 0) & -1;
    $25 = ($22 | 0) < ($24 | 0);
    if ($25) {
     $$expand_i1_val6 = 1;
     HEAP8[$2 >> 0] = $$expand_i1_val6;
    } else {
     label = 13;
    }
   } else {
    label = 13;
   }
  }
 } while (0);
 if ((label | 0) == 13) {
  $$expand_i1_val8 = 0;
  HEAP8[$2 >> 0] = $$expand_i1_val8;
 }
 $$pre_trunc = HEAP8[$2 >> 0] | 0;
 $26 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $26 | 0;
}

function _mp_obj_new_fun_bc($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $8 = 0;
 $9 = 0;
 $12 = $4;
 $10 = $12;
 $13 = $4;
 $14 = ($13 | 0) != (0 | 0);
 if ($14) {
  $15 = $10;
  $16 = $15 + 4 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $8 = $17;
  $18 = $10;
  $19 = $18 + 4 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $9 = $20;
 }
 $21 = $5;
 $22 = ($21 | 0) != (0 | 0);
 if ($22) {
  $23 = $9;
  $24 = $23 + 1 | 0;
  $9 = $24;
 }
 $25 = $9;
 $26 = $25 << 2;
 $27 = 16 + $26 | 0;
 $28 = _m_malloc($27) | 0;
 $11 = $28;
 $29 = $11;
 HEAP32[$29 >> 2] = 16612;
 $30 = _mp_globals_get_988() | 0;
 $31 = $11;
 $32 = $31 + 4 | 0;
 HEAP32[$32 >> 2] = $30;
 $33 = $6;
 $34 = $11;
 $35 = $34 + 8 | 0;
 HEAP32[$35 >> 2] = $33;
 $36 = $7;
 $37 = $11;
 $38 = $37 + 12 | 0;
 HEAP32[$38 >> 2] = $36;
 $39 = $10;
 $40 = ($39 | 0) != (0 | 0);
 if ($40) {
  $41 = $11;
  $42 = $41 + 16 | 0;
  $43 = $10;
  $44 = $43 + 8 | 0;
  $45 = $8;
  $46 = $45 << 2;
  _memcpy($42 | 0, $44 | 0, $46 | 0) | 0;
 }
 $47 = $5;
 $48 = ($47 | 0) != (0 | 0);
 if (!$48) {
  $54 = $11;
  STACKTOP = sp;
  return $54 | 0;
 }
 $49 = $5;
 $50 = $11;
 $51 = $50 + 16 | 0;
 $52 = $8;
 $53 = $51 + ($52 << 2) | 0;
 HEAP32[$53 >> 2] = $49;
 $54 = $11;
 STACKTOP = sp;
 return $54 | 0;
}

function _scope_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = _m_malloc0(48) | 0;
 $8 = $9;
 $10 = $4;
 $11 = $8;
 HEAP32[$11 >> 2] = $10;
 $12 = $5;
 $13 = $8;
 $14 = $13 + 12 | 0;
 HEAP32[$14 >> 2] = $12;
 $15 = $6;
 $16 = $15 & 65535;
 $17 = $8;
 $18 = $17 + 20 | 0;
 HEAP16[$18 >> 1] = $16;
 $19 = $4;
 $20 = ($19 | 0) == 7;
 $21 = $4;
 $22 = ($21 | 0) == 1;
 $or$cond = $20 | $22;
 if ($or$cond) {
  $23 = $5;
  $24 = $23;
  $25 = $24 + 8 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $26 >>> 4;
  $28 = $27 & 65535;
  $29 = $8;
  $30 = $29 + 22 | 0;
  HEAP16[$30 >> 1] = $28;
 } else {
  $31 = $4;
  $32 = 28727 + $31 | 0;
  $33 = HEAP8[$32 >> 0] | 0;
  $34 = $33 & 255;
  $35 = $8;
  $36 = $35 + 22 | 0;
  HEAP16[$36 >> 1] = $34;
 }
 $37 = _mp_emit_glue_new_raw_code() | 0;
 $38 = $8;
 $39 = $38 + 16 | 0;
 HEAP32[$39 >> 2] = $37;
 $40 = $7;
 $41 = $40 & 65535;
 $42 = $8;
 $43 = $42 + 26 | 0;
 HEAP16[$43 >> 1] = $41;
 $44 = $8;
 $45 = $44 + 40 | 0;
 HEAP16[$45 >> 1] = 4;
 $46 = $8;
 $47 = $46 + 40 | 0;
 $48 = HEAP16[$47 >> 1] | 0;
 $49 = $48 & 65535;
 $50 = $49 << 3;
 $51 = _m_malloc($50) | 0;
 $52 = $8;
 $53 = $52 + 44 | 0;
 HEAP32[$53 >> 2] = $51;
 $54 = $8;
 STACKTOP = sp;
 return $54 | 0;
}

function _dict_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $8 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $10 = $4;
 $6 = $10;
 $7 = 1;
 $11 = $5;
 $12 = ($11 | 0) == 3;
 if (!$12) {
  $5 = 1;
 }
 $13 = $6;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = ($14 | 0) != (14112 | 0);
 if ($15) {
  $16 = $3;
  $17 = $6;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = $18 + 6 | 0;
  $20 = HEAP16[$19 >> 1] | 0;
  $21 = $20 & 65535;
  HEAP32[$vararg_buffer >> 2] = $21;
  _mp_printf($16, 31086, $vararg_buffer) | 0;
 }
 $22 = $3;
 _mp_print_str($22, 31702) | 0;
 HEAP32[$8 >> 2] = 0;
 $9 = 0;
 while (1) {
  $23 = $6;
  $24 = _dict_iter_next($23, $8) | 0;
  $9 = $24;
  $25 = ($24 | 0) != (0 | 0);
  if (!$25) {
   break;
  }
  $26 = $7;
  $27 = $26 & 1;
  if (!$27) {
   $28 = $3;
   _mp_print_str($28, 33327) | 0;
  }
  $7 = 0;
  $29 = $3;
  $30 = $9;
  $31 = HEAP32[$30 >> 2] | 0;
  $32 = $5;
  _mp_obj_print_helper($29, $31, $32);
  $33 = $3;
  _mp_print_str($33, 31090) | 0;
  $34 = $3;
  $35 = $9;
  $36 = $35 + 4 | 0;
  $37 = HEAP32[$36 >> 2] | 0;
  $38 = $5;
  _mp_obj_print_helper($34, $37, $38);
 }
 $39 = $3;
 _mp_print_str($39, 31704) | 0;
 $40 = $6;
 $41 = HEAP32[$40 >> 2] | 0;
 $42 = ($41 | 0) != (14112 | 0);
 if (!$42) {
  STACKTOP = sp;
  return;
 }
 $43 = $3;
 _mp_print_str($43, 32991) | 0;
 STACKTOP = sp;
 return;
}

function _framebuf_pixel($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $8 = $4;
 $9 = HEAP32[$8 >> 2] | 0;
 $5 = $9;
 $10 = $4;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = _mp_obj_get_int($12) | 0;
 $6 = $13;
 $14 = $4;
 $15 = $14 + 8 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = _mp_obj_get_int($16) | 0;
 $7 = $17;
 $18 = $6;
 $19 = 0 <= ($18 | 0);
 do {
  if ($19) {
   $20 = $6;
   $21 = $5;
   $22 = $21 + 12 | 0;
   $23 = HEAP16[$22 >> 1] | 0;
   $24 = $23 & 65535;
   $25 = ($20 | 0) < ($24 | 0);
   $26 = $7;
   $27 = 0 <= ($26 | 0);
   $or$cond = $25 & $27;
   if ($or$cond) {
    $28 = $7;
    $29 = $5;
    $30 = $29 + 14 | 0;
    $31 = HEAP16[$30 >> 1] | 0;
    $32 = $31 & 65535;
    $33 = ($28 | 0) < ($32 | 0);
    if ($33) {
     $34 = $3;
     $35 = ($34 | 0) == 3;
     $36 = $5;
     $37 = $6;
     $38 = $7;
     if (!$35) {
      $43 = $4;
      $44 = $43 + 12 | 0;
      $45 = HEAP32[$44 >> 2] | 0;
      $46 = _mp_obj_get_int($45) | 0;
      _setpixel($36, $37, $38, $46);
      break;
     }
     $39 = _getpixel($36, $37, $38) | 0;
     $40 = $39 << 1;
     $41 = $40 | 1;
     $42 = $41;
     $2 = $42;
     $47 = $2;
     STACKTOP = sp;
     return $47 | 0;
    }
   }
  }
 } while (0);
 $2 = 17668;
 $47 = $2;
 STACKTOP = sp;
 return $47 | 0;
}

function _poll_poll_internal($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $10 = $3;
 $11 = HEAP32[$10 >> 2] | 0;
 $4 = $11;
 $5 = -1;
 $6 = 0;
 $12 = $2;
 $13 = $12 >>> 0 >= 2;
 if ($13) {
  $14 = $3;
  $15 = $14 + 4 | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  $17 = ($16 | 0) != (17668 | 0);
  if ($17) {
   $18 = $3;
   $19 = $18 + 4 | 0;
   $20 = HEAP32[$19 >> 2] | 0;
   $21 = _mp_obj_get_int($20) | 0;
   $7 = $21;
   $22 = $7;
   $23 = ($22 | 0) >= 0;
   if ($23) {
    $24 = $7;
    $5 = $24;
   }
  }
  $25 = $2;
  $26 = $25 >>> 0 >= 3;
  if ($26) {
   $27 = $3;
   $28 = $27 + 8 | 0;
   $29 = HEAP32[$28 >> 2] | 0;
   $30 = _mp_obj_get_int($29) | 0;
   $6 = $30;
  }
 }
 $31 = $6;
 $32 = $4;
 $33 = $32 + 20 | 0;
 HEAP32[$33 >> 2] = $31;
 $34 = _mp_hal_ticks_ms() | 0;
 $8 = $34;
 while (1) {
  $35 = $4;
  $36 = $35 + 4 | 0;
  $37 = _poll_map_poll($36, 0) | 0;
  $9 = $37;
  $38 = $9;
  $39 = $38 >>> 0 > 0;
  if ($39) {
   label = 12;
   break;
  }
  $40 = $5;
  $41 = ($40 | 0) != -1;
  if ($41) {
   $42 = _mp_hal_ticks_ms() | 0;
   $43 = $8;
   $44 = $42 - $43 | 0;
   $45 = $5;
   $46 = $44 >>> 0 >= $45 >>> 0;
   if ($46) {
    label = 12;
    break;
   }
  }
  _mp_handle_pending();
 }
 if ((label | 0) == 12) {
  $47 = $9;
  STACKTOP = sp;
  return $47 | 0;
 }
 return 0 | 0;
}

function _sin($0) {
 $0 = +$0;
 var $$0 = 0.0, $1 = 0, $10 = 0, $11 = 0.0, $12 = 0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0.0, $trunc = 0, $trunc$clear = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = sp;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $2 = HEAP32[tempDoublePtr >> 2] | 0;
 $3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $4 = $3 & 2147483647;
 $5 = $4 >>> 0 < 1072243196;
 L1 : do {
  if ($5) {
   $6 = $4 >>> 0 < 1045430272;
   if ($6) {
    $$0 = $0;
   } else {
    $7 = +___sin($0, 0.0, 0);
    $$0 = $7;
   }
  } else {
   $8 = $4 >>> 0 > 2146435071;
   if ($8) {
    $9 = $0 - $0;
    $$0 = $9;
    break;
   }
   $10 = ___rem_pio2($0, $1) | 0;
   $trunc = $10 & 255;
   $trunc$clear = $trunc & 3;
   switch ($trunc$clear << 24 >> 24) {
   case 0:
    {
     $11 = +HEAPF64[$1 >> 3];
     $12 = $1 + 8 | 0;
     $13 = +HEAPF64[$12 >> 3];
     $14 = +___sin($11, $13, 1);
     $$0 = $14;
     break L1;
     break;
    }
   case 1:
    {
     $15 = +HEAPF64[$1 >> 3];
     $16 = $1 + 8 | 0;
     $17 = +HEAPF64[$16 >> 3];
     $18 = +___cos($15, $17);
     $$0 = $18;
     break L1;
     break;
    }
   case 2:
    {
     $19 = +HEAPF64[$1 >> 3];
     $20 = $1 + 8 | 0;
     $21 = +HEAPF64[$20 >> 3];
     $22 = +___sin($19, $21, 1);
     $23 = -$22;
     $$0 = $23;
     break L1;
     break;
    }
   default:
    {
     $24 = +HEAPF64[$1 >> 3];
     $25 = $1 + 8 | 0;
     $26 = +HEAPF64[$25 >> 3];
     $27 = +___cos($24, $26);
     $28 = -$27;
     $$0 = $28;
     break L1;
    }
   }
  }
 } while (0);
 STACKTOP = sp;
 return +$$0;
}

function _mp_seq_index_obj($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $13 = $7;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = _mp_obj_get_type($14) | 0;
 $8 = $15;
 $16 = $7;
 $17 = $16 + 4 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $9 = $18;
 $10 = 0;
 $19 = $5;
 $11 = $19;
 $20 = $6;
 $21 = $20 >>> 0 >= 3;
 if ($21) {
  $22 = $8;
  $23 = $5;
  $24 = $7;
  $25 = $24 + 8 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = _mp_get_index($22, $23, $26, 1) | 0;
  $10 = $27;
  $28 = $6;
  $29 = $28 >>> 0 >= 4;
  if ($29) {
   $30 = $8;
   $31 = $5;
   $32 = $7;
   $33 = $32 + 12 | 0;
   $34 = HEAP32[$33 >> 2] | 0;
   $35 = _mp_get_index($30, $31, $34, 1) | 0;
   $11 = $35;
  }
 }
 $36 = $10;
 $12 = $36;
 while (1) {
  $37 = $12;
  $38 = $11;
  $39 = $37 >>> 0 < $38 >>> 0;
  if (!$39) {
   label = 9;
   break;
  }
  $40 = $4;
  $41 = $12;
  $42 = $40 + ($41 << 2) | 0;
  $43 = HEAP32[$42 >> 2] | 0;
  $44 = $9;
  $45 = _mp_obj_equal($43, $44) | 0;
  $46 = $12;
  if ($45) {
   label = 7;
   break;
  }
  $50 = $46 + 1 | 0;
  $12 = $50;
 }
 if ((label | 0) == 7) {
  $47 = $46 << 1;
  $48 = $47 | 1;
  $49 = $48;
  STACKTOP = sp;
  return $49 | 0;
 } else if ((label | 0) == 9) {
  _mp_raise_ValueError(33448);
 }
 return 0 | 0;
}

function _cos($0) {
 $0 = +$0;
 var $$0 = 0.0, $1 = 0, $10 = 0, $11 = 0.0, $12 = 0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0, $27 = 0.0, $28 = 0.0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0.0, $trunc = 0, $trunc$clear = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = sp;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $2 = HEAP32[tempDoublePtr >> 2] | 0;
 $3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $4 = $3 & 2147483647;
 $5 = $4 >>> 0 < 1072243196;
 L1 : do {
  if ($5) {
   $6 = $4 >>> 0 < 1044816030;
   if ($6) {
    $$0 = 1.0;
   } else {
    $7 = +___cos($0, 0.0);
    $$0 = $7;
   }
  } else {
   $8 = $4 >>> 0 > 2146435071;
   if ($8) {
    $9 = $0 - $0;
    $$0 = $9;
    break;
   }
   $10 = ___rem_pio2($0, $1) | 0;
   $trunc = $10 & 255;
   $trunc$clear = $trunc & 3;
   switch ($trunc$clear << 24 >> 24) {
   case 0:
    {
     $11 = +HEAPF64[$1 >> 3];
     $12 = $1 + 8 | 0;
     $13 = +HEAPF64[$12 >> 3];
     $14 = +___cos($11, $13);
     $$0 = $14;
     break L1;
     break;
    }
   case 1:
    {
     $15 = +HEAPF64[$1 >> 3];
     $16 = $1 + 8 | 0;
     $17 = +HEAPF64[$16 >> 3];
     $18 = +___sin($15, $17, 1);
     $19 = -$18;
     $$0 = $19;
     break L1;
     break;
    }
   case 2:
    {
     $20 = +HEAPF64[$1 >> 3];
     $21 = $1 + 8 | 0;
     $22 = +HEAPF64[$21 >> 3];
     $23 = +___cos($20, $22);
     $24 = -$23;
     $$0 = $24;
     break L1;
     break;
    }
   default:
    {
     $25 = +HEAPF64[$1 >> 3];
     $26 = $1 + 8 | 0;
     $27 = +HEAPF64[$26 >> 3];
     $28 = +___sin($25, $27, 1);
     $$0 = $28;
     break L1;
    }
   }
  }
 } while (0);
 STACKTOP = sp;
 return +$$0;
}

function _push_rule($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $4;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $4;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $12 >>> 0 >= $14 >>> 0;
 if ($15) {
  $16 = $4;
  $17 = $16 + 8 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = $4;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = $20 + 16 | 0;
  $22 = $21 << 3;
  $23 = _m_realloc($18, $22) | 0;
  $8 = $23;
  $24 = $8;
  $25 = $4;
  $26 = $25 + 8 | 0;
  HEAP32[$26 >> 2] = $24;
  $27 = $4;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = $28 + 16 | 0;
  HEAP32[$27 >> 2] = $29;
 }
 $30 = $4;
 $31 = $30 + 8 | 0;
 $32 = HEAP32[$31 >> 2] | 0;
 $33 = $4;
 $34 = $33 + 4 | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 $36 = $35 + 1 | 0;
 HEAP32[$34 >> 2] = $36;
 $37 = $32 + ($35 << 3) | 0;
 $9 = $37;
 $38 = $5;
 $39 = $9;
 $40 = HEAP32[$39 >> 2] | 0;
 $41 = $38 & 16777215;
 $42 = $40 & -16777216;
 $43 = $42 | $41;
 HEAP32[$39 >> 2] = $43;
 $44 = $6;
 $45 = $44 & 255;
 $46 = $9;
 $47 = HEAP32[$46 >> 2] | 0;
 $48 = $45 & 255;
 $49 = $48 << 24;
 $50 = $47 & 16777215;
 $51 = $50 | $49;
 HEAP32[$46 >> 2] = $51;
 $52 = $7;
 $53 = $9;
 $54 = $53 + 4 | 0;
 HEAP32[$54 >> 2] = $52;
 STACKTOP = sp;
 return;
}

function _mp_obj_tuple_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $8 = $4;
 $5 = $8;
 $9 = $3;
 switch ($9 | 0) {
 case 4:
  {
   $10 = $5;
   $11 = $10 + 4 | 0;
   $12 = HEAP32[$11 >> 2] | 0;
   $13 = ($12 | 0) != 0;
   $14 = $13 & 1;
   $15 = _mp_obj_new_bool_1243($14) | 0;
   $2 = $15;
   $43 = $2;
   STACKTOP = sp;
   return $43 | 0;
   break;
  }
 case 6:
  {
   $6 = 18944;
   $7 = 0;
   while (1) {
    $16 = $7;
    $17 = $5;
    $18 = $17 + 4 | 0;
    $19 = HEAP32[$18 >> 2] | 0;
    $20 = $16 >>> 0 < $19 >>> 0;
    if (!$20) {
     break;
    }
    $21 = $5;
    $22 = $21 + 8 | 0;
    $23 = $7;
    $24 = $22 + ($23 << 2) | 0;
    $25 = HEAP32[$24 >> 2] | 0;
    $26 = _mp_unary_op(6, $25) | 0;
    $27 = $26;
    $28 = $27 >> 1;
    $29 = $6;
    $30 = $29 + $28 | 0;
    $6 = $30;
    $31 = $7;
    $32 = $31 + 1 | 0;
    $7 = $32;
   }
   $33 = $6;
   $34 = $33 << 1;
   $35 = $34 | 1;
   $36 = $35;
   $2 = $36;
   $43 = $2;
   STACKTOP = sp;
   return $43 | 0;
   break;
  }
 case 5:
  {
   $37 = $5;
   $38 = $37 + 4 | 0;
   $39 = HEAP32[$38 >> 2] | 0;
   $40 = $39 << 1;
   $41 = $40 | 1;
   $42 = $41;
   $2 = $42;
   $43 = $2;
   STACKTOP = sp;
   return $43 | 0;
   break;
  }
 default:
  {
   $2 = 0;
   $43 = $2;
   STACKTOP = sp;
   return $43 | 0;
  }
 }
 return 0 | 0;
}
function _pyexec_raw_repl_process_char($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $5 = ($4 | 0) == 1;
 do {
  if ($5) {
   _mp_hal_stdout_tx_str(35293);
   label = 13;
  } else {
   $6 = $2;
   $7 = ($6 | 0) == 2;
   if ($7) {
    HEAP32[5566] = 1;
    $8 = HEAP32[40720 >> 2] | 0;
    _vstr_reset_1555($8);
    HEAP8[41654] = 0;
    HEAP8[41655] = 0;
    _pyexec_friendly_repl_process_char(2) | 0;
    $1 = 0;
    break;
   }
   $9 = $2;
   $10 = ($9 | 0) == 3;
   if ($10) {
    $11 = HEAP32[40720 >> 2] | 0;
    _vstr_reset_1555($11);
    $1 = 0;
    break;
   }
   $12 = $2;
   $13 = ($12 | 0) == 4;
   if (!$13) {
    $14 = HEAP32[40720 >> 2] | 0;
    $15 = $2;
    $16 = $15 & 255;
    _vstr_add_byte($14, $16);
    $1 = 0;
    break;
   }
   _mp_hal_stdout_tx_str(35320);
   $17 = HEAP32[40720 >> 2] | 0;
   $18 = $17 + 4 | 0;
   $19 = HEAP32[$18 >> 2] | 0;
   $20 = ($19 | 0) == 0;
   if ($20) {
    _mp_hal_stdout_tx_str(35325);
    $21 = HEAP32[40720 >> 2] | 0;
    _vstr_clear($21);
    $1 = 256;
    break;
   }
   $22 = HEAP32[40720 >> 2] | 0;
   $23 = _parse_compile_execute($22, 1, 17) | 0;
   $3 = $23;
   $24 = $3;
   $25 = $24 & 256;
   $26 = ($25 | 0) != 0;
   if ($26) {
    $27 = $3;
    $1 = $27;
   } else {
    label = 13;
   }
  }
 } while (0);
 if ((label | 0) == 13) {
  $28 = HEAP32[40720 >> 2] | 0;
  _vstr_reset_1555($28);
  _mp_hal_stdout_tx_str(35323);
  $1 = 0;
 }
 $29 = $1;
 STACKTOP = sp;
 return $29 | 0;
}

function _math_generic_1($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0.0, $11 = 0.0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0.0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0.0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0.0, $37 = 0, $38 = 0, $39 = 0, $4 = 0.0, $40 = 0, $41 = 0, $42 = 0, $43 = 0.0, $44 = 0, $5 = 0.0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = +_mp_obj_get_float($6);
 $4 = $7;
 $8 = $3;
 $9 = $4;
 $10 = +FUNCTION_TABLE_dd[$8 & 1023]($9);
 $5 = $10;
 $11 = $5;
 $12 = ___DOUBLE_BITS_1412($11) | 0;
 $13 = getTempRet0() | 0;
 $14 = $13 & 2147483647;
 $15 = $14 >>> 0 > 2146435072;
 $16 = $12 >>> 0 > 0;
 $17 = ($14 | 0) == 2146435072;
 $18 = $17 & $16;
 $19 = $15 | $18;
 if ($19) {
  $20 = $4;
  $21 = ___DOUBLE_BITS_1412($20) | 0;
  $22 = getTempRet0() | 0;
  $23 = $22 & 2147483647;
  $24 = $23 >>> 0 > 2146435072;
  $25 = $21 >>> 0 > 0;
  $26 = ($23 | 0) == 2146435072;
  $27 = $26 & $25;
  $28 = $24 | $27;
  if (!$28) {
   _math_error();
  }
 }
 $29 = $5;
 $30 = ___DOUBLE_BITS_1412($29) | 0;
 $31 = getTempRet0() | 0;
 $32 = $31 & 2147483647;
 $33 = ($30 | 0) == 0;
 $34 = ($32 | 0) == 2146435072;
 $35 = $33 & $34;
 if (!$35) {
  $43 = $5;
  $44 = _mp_obj_new_float($43) | 0;
  STACKTOP = sp;
  return $44 | 0;
 }
 $36 = $4;
 $37 = ___DOUBLE_BITS_1412($36) | 0;
 $38 = getTempRet0() | 0;
 $39 = $38 & 2147483647;
 $40 = ($37 | 0) == 0;
 $41 = ($39 | 0) == 2146435072;
 $42 = $40 & $41;
 if ($42) {
  $43 = $5;
  $44 = _mp_obj_new_float($43) | 0;
  STACKTOP = sp;
  return $44 | 0;
 } else {
  _math_error();
 }
 return 0 | 0;
}

function _framebuf_rect($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $53 = 0, $54 = 0, $55 = 0, $56 = 0, $57 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $10 = $3;
 $11 = HEAP32[$10 >> 2] | 0;
 $4 = $11;
 $12 = $3;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = _mp_obj_get_int($14) | 0;
 $5 = $15;
 $16 = $3;
 $17 = $16 + 8 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = _mp_obj_get_int($18) | 0;
 $6 = $19;
 $20 = $3;
 $21 = $20 + 12 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = _mp_obj_get_int($22) | 0;
 $7 = $23;
 $24 = $3;
 $25 = $24 + 16 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = _mp_obj_get_int($26) | 0;
 $8 = $27;
 $28 = $3;
 $29 = $28 + 20 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = _mp_obj_get_int($30) | 0;
 $9 = $31;
 $32 = $4;
 $33 = $5;
 $34 = $6;
 $35 = $7;
 $36 = $9;
 _fill_rect($32, $33, $34, $35, 1, $36);
 $37 = $4;
 $38 = $5;
 $39 = $6;
 $40 = $8;
 $41 = $39 + $40 | 0;
 $42 = $41 - 1 | 0;
 $43 = $7;
 $44 = $9;
 _fill_rect($37, $38, $42, $43, 1, $44);
 $45 = $4;
 $46 = $5;
 $47 = $6;
 $48 = $8;
 $49 = $9;
 _fill_rect($45, $46, $47, 1, $48, $49);
 $50 = $4;
 $51 = $5;
 $52 = $7;
 $53 = $51 + $52 | 0;
 $54 = $53 - 1 | 0;
 $55 = $6;
 $56 = $8;
 $57 = $9;
 _fill_rect($50, $54, $55, 1, $56, $57);
 STACKTOP = sp;
 return 17668 | 0;
}

function _mp_obj_get_float_maybe($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0.0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0.0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0, $31 = 0, $4 = 0, $5 = 0.0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 16 | 0;
 $3 = $0;
 $4 = $1;
 $6 = $3;
 $7 = ($6 | 0) == (13856 | 0);
 do {
  if ($7) {
   $5 = 0.0;
  } else {
   $8 = $3;
   $9 = ($8 | 0) == (13864 | 0);
   if ($9) {
    $5 = 1.0;
    break;
   }
   $10 = $3;
   $11 = _mp_obj_is_small_int_784($10) | 0;
   $12 = $3;
   if ($11) {
    $13 = $12;
    $14 = $13 >> 1;
    $15 = +($14 | 0);
    $5 = $15;
    break;
   }
   $16 = _mp_obj_is_obj_786($12) | 0;
   if ($16) {
    $17 = $3;
    $18 = HEAP32[$17 >> 2] | 0;
    $19 = ($18 | 0) == (16904 | 0);
    if ($19) {
     $20 = $3;
     $21 = +_mp_obj_int_as_float_impl($20);
     $5 = $21;
     break;
    }
   }
   $22 = $3;
   $23 = _mp_obj_is_obj_786($22) | 0;
   if ($23) {
    $24 = $3;
    $25 = HEAP32[$24 >> 2] | 0;
    $26 = ($25 | 0) == (16252 | 0);
    if ($26) {
     $27 = $3;
     $28 = +_mp_obj_float_get($27);
     $5 = $28;
     break;
    }
   }
   $$expand_i1_val = 0;
   HEAP8[$2 >> 0] = $$expand_i1_val;
   $$pre_trunc = HEAP8[$2 >> 0] | 0;
   $31 = $$pre_trunc & 1;
   STACKTOP = sp;
   return $31 | 0;
  }
 } while (0);
 $29 = $5;
 $30 = $4;
 HEAPF64[$30 >> 3] = $29;
 $$expand_i1_val2 = 1;
 HEAP8[$2 >> 0] = $$expand_i1_val2;
 $$pre_trunc = HEAP8[$2 >> 0] | 0;
 $31 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $31 | 0;
}

function _stringio_read($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $51 = 0, $52 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $11 = $5;
 $9 = $11;
 $12 = $9;
 _check_stringio_is_open($12);
 $13 = $9;
 $14 = $13 + 4 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $15 + 4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $9;
 $19 = $18 + 8 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = $17 >>> 0 <= $20 >>> 0;
 if ($21) {
  $4 = 0;
  $52 = $4;
  STACKTOP = sp;
  return $52 | 0;
 }
 $22 = $9;
 $23 = $22 + 4 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $24 + 4 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = $9;
 $28 = $27 + 8 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = $26 - $29 | 0;
 $10 = $30;
 $31 = $7;
 $32 = $10;
 $33 = $31 >>> 0 > $32 >>> 0;
 if ($33) {
  $34 = $10;
  $7 = $34;
 }
 $35 = $6;
 $36 = $9;
 $37 = $36 + 4 | 0;
 $38 = HEAP32[$37 >> 2] | 0;
 $39 = $38 + 8 | 0;
 $40 = HEAP32[$39 >> 2] | 0;
 $41 = $9;
 $42 = $41 + 8 | 0;
 $43 = HEAP32[$42 >> 2] | 0;
 $44 = $40 + $43 | 0;
 $45 = $7;
 _memcpy($35 | 0, $44 | 0, $45 | 0) | 0;
 $46 = $7;
 $47 = $9;
 $48 = $47 + 8 | 0;
 $49 = HEAP32[$48 >> 2] | 0;
 $50 = $49 + $46 | 0;
 HEAP32[$48 >> 2] = $50;
 $51 = $7;
 $4 = $51;
 $52 = $4;
 STACKTOP = sp;
 return $52 | 0;
}

function _scope_check_to_close_over($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) != (0 | 0);
 if (!$9) {
  STACKTOP = sp;
  return;
 }
 $10 = $2;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $4 = $12;
 while (1) {
  $13 = $4;
  $14 = $13 + 4 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = ($15 | 0) != (0 | 0);
  if (!$16) {
   label = 10;
   break;
  }
  $17 = $4;
  $18 = $3;
  $19 = $18 + 4 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = _scope_find($17, $20) | 0;
  $5 = $21;
  $22 = $5;
  $23 = ($22 | 0) != (0 | 0);
  if ($23) {
   break;
  }
  $41 = $4;
  $42 = $41 + 4 | 0;
  $43 = HEAP32[$42 >> 2] | 0;
  $4 = $43;
 }
 if ((label | 0) == 10) {
  STACKTOP = sp;
  return;
 }
 $24 = $5;
 $25 = HEAP8[$24 >> 0] | 0;
 $26 = $25 & 255;
 $27 = ($26 | 0) == 3;
 if (!$27) {
  $28 = $5;
  $29 = HEAP8[$28 >> 0] | 0;
  $30 = $29 & 255;
  $31 = ($30 | 0) == 4;
  if (!$31) {
   $32 = $5;
   $33 = HEAP8[$32 >> 0] | 0;
   $34 = $33 & 255;
   $35 = ($34 | 0) == 5;
   if (!$35) {
    STACKTOP = sp;
    return;
   }
  }
 }
 $36 = $3;
 HEAP8[$36 >> 0] = 5;
 $37 = $2;
 $38 = $3;
 $39 = $38 + 4 | 0;
 $40 = HEAP32[$39 >> 2] | 0;
 _scope_close_over_in_parents($37, $40);
 STACKTOP = sp;
 return;
}

function _range_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $5;
 $10 = $6;
 _mp_arg_check_num_1097($9, $10, 1, 3, 0);
 $11 = _m_malloc(16) | 0;
 $8 = $11;
 $12 = $4;
 $13 = $8;
 HEAP32[$13 >> 2] = $12;
 $14 = $8;
 $15 = $14 + 4 | 0;
 HEAP32[$15 >> 2] = 0;
 $16 = $8;
 $17 = $16 + 12 | 0;
 HEAP32[$17 >> 2] = 1;
 $18 = $5;
 $19 = ($18 | 0) == 1;
 $20 = $7;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = _mp_obj_get_int($21) | 0;
 $23 = $8;
 if ($19) {
  $24 = $23 + 8 | 0;
  HEAP32[$24 >> 2] = $22;
  $44 = $8;
  STACKTOP = sp;
  return $44 | 0;
 }
 $25 = $23 + 4 | 0;
 HEAP32[$25 >> 2] = $22;
 $26 = $7;
 $27 = $26 + 4 | 0;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = _mp_obj_get_int($28) | 0;
 $30 = $8;
 $31 = $30 + 8 | 0;
 HEAP32[$31 >> 2] = $29;
 $32 = $5;
 $33 = ($32 | 0) == 3;
 if (!$33) {
  $44 = $8;
  STACKTOP = sp;
  return $44 | 0;
 }
 $34 = $7;
 $35 = $34 + 8 | 0;
 $36 = HEAP32[$35 >> 2] | 0;
 $37 = _mp_obj_get_int($36) | 0;
 $38 = $8;
 $39 = $38 + 12 | 0;
 HEAP32[$39 >> 2] = $37;
 $40 = $8;
 $41 = $40 + 12 | 0;
 $42 = HEAP32[$41 >> 2] | 0;
 $43 = ($42 | 0) == 0;
 if ($43) {
  _mp_raise_ValueError(31627);
 } else {
  $44 = $8;
  STACKTOP = sp;
  return $44 | 0;
 }
 return 0 | 0;
}

function _skip_whitespace($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $5 = $1 & 1;
 $3 = $5;
 $4 = 0;
 L1 : while (1) {
  $6 = $2;
  $7 = _is_end($6) | 0;
  $8 = $7 ^ 1;
  if (!$8) {
   label = 17;
   break;
  }
  $9 = $2;
  $10 = _is_physical_newline($9) | 0;
  L4 : do {
   if ($10) {
    $11 = $3;
    $12 = $11 & 1;
    if ($12) {
     $13 = $2;
     $14 = $13 + 40 | 0;
     $15 = HEAP32[$14 >> 2] | 0;
     $16 = ($15 | 0) == 0;
     if ($16) {
      label = 17;
      break L1;
     }
    }
    $4 = 1;
    $17 = $2;
    _next_char($17);
   } else {
    $18 = $2;
    $19 = _is_whitespace($18) | 0;
    $20 = $2;
    if ($19) {
     _next_char($20);
     break;
    }
    $21 = _is_char($20, 35) | 0;
    $22 = $2;
    if (!$21) {
     $29 = _is_char_and($22, 92, 10) | 0;
     if (!$29) {
      label = 17;
      break L1;
     }
     $30 = $2;
     _next_char($30);
     $31 = $2;
     _next_char($31);
     break;
    }
    _next_char($22);
    while (1) {
     $23 = $2;
     $24 = _is_end($23) | 0;
     if ($24) {
      break L4;
     }
     $25 = $2;
     $26 = _is_physical_newline($25) | 0;
     $27 = $26 ^ 1;
     if (!$27) {
      break L4;
     }
     $28 = $2;
     _next_char($28);
    }
   }
  } while (0);
 }
 if ((label | 0) == 17) {
  $32 = $4;
  $33 = $32 & 1;
  STACKTOP = sp;
  return $33 | 0;
 }
 return 0 | 0;
}

function _str_center($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $6 = sp + 28 | 0;
 $8 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $10 = $3;
 $11 = _mp_obj_is_qstr_1128($10) | 0;
 $12 = $3;
 if ($11) {
  $13 = $12;
  $14 = $13 >>> 2;
  $15 = _qstr_data($14, $6) | 0;
  $5 = $15;
 } else {
  $16 = $12 + 8 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  HEAP32[$6 >> 2] = $17;
  $18 = $3;
  $19 = $18 + 12 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $5 = $20;
 }
 $21 = $4;
 $22 = _mp_obj_get_int($21) | 0;
 $7 = $22;
 $23 = HEAP32[$6 >> 2] | 0;
 $24 = $7;
 $25 = $23 >>> 0 >= $24 >>> 0;
 if ($25) {
  $26 = $3;
  $2 = $26;
  $44 = $2;
  STACKTOP = sp;
  return $44 | 0;
 } else {
  $27 = $7;
  _vstr_init_len($8, $27);
  $28 = $8 + 8 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  $30 = $7;
  _memset($29 | 0, 32, $30 | 0) | 0;
  $31 = $7;
  $32 = HEAP32[$6 >> 2] | 0;
  $33 = $31 - $32 | 0;
  $34 = ($33 >>> 0) / 2 & -1;
  $9 = $34;
  $35 = $8 + 8 | 0;
  $36 = HEAP32[$35 >> 2] | 0;
  $37 = $9;
  $38 = $36 + $37 | 0;
  $39 = $5;
  $40 = HEAP32[$6 >> 2] | 0;
  _memcpy($38 | 0, $39 | 0, $40 | 0) | 0;
  $41 = $3;
  $42 = _mp_obj_get_type($41) | 0;
  $43 = _mp_obj_new_str_from_vstr($42, $8) | 0;
  $2 = $43;
  $44 = $2;
  STACKTOP = sp;
  return $44 | 0;
 }
 return 0 | 0;
}

function _mpn_cmp($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $6;
 $11 = $8;
 $12 = $10 >>> 0 < $11 >>> 0;
 do {
  if ($12) {
   $4 = -1;
  } else {
   $13 = $6;
   $14 = $8;
   $15 = $13 >>> 0 > $14 >>> 0;
   if ($15) {
    $4 = 1;
    break;
   }
   $16 = $6;
   $17 = $5;
   $18 = $17 + ($16 << 1) | 0;
   $5 = $18;
   $19 = $6;
   $20 = $7;
   $21 = $20 + ($19 << 1) | 0;
   $7 = $21;
   while (1) {
    $22 = $6;
    $23 = $22 >>> 0 > 0;
    if (!$23) {
     label = 12;
     break;
    }
    $24 = $5;
    $25 = $24 + -2 | 0;
    $5 = $25;
    $26 = HEAP16[$25 >> 1] | 0;
    $27 = $26 & 65535;
    $28 = $7;
    $29 = $28 + -2 | 0;
    $7 = $29;
    $30 = HEAP16[$29 >> 1] | 0;
    $31 = $30 & 65535;
    $32 = $27 - $31 | 0;
    $9 = $32;
    $33 = $9;
    $34 = ($33 | 0) < 0;
    if ($34) {
     label = 8;
     break;
    }
    $35 = $9;
    $36 = ($35 | 0) > 0;
    if ($36) {
     label = 10;
     break;
    }
    $37 = $6;
    $38 = $37 + -1 | 0;
    $6 = $38;
   }
   if ((label | 0) == 8) {
    $4 = -1;
    break;
   } else if ((label | 0) == 10) {
    $4 = 1;
    break;
   } else if ((label | 0) == 12) {
    $4 = 0;
    break;
   }
  }
 } while (0);
 $39 = $4;
 STACKTOP = sp;
 return $39 | 0;
}

function _struct_pack_into($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = sp + 16 | 0;
 $2 = $0;
 $3 = $1;
 $9 = $3;
 $10 = $9 + 4 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 _mp_get_buffer_raise($11, $4, 2);
 $12 = $3;
 $13 = $12 + 8 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = _mp_obj_get_int($14) | 0;
 $5 = $15;
 $16 = $5;
 $17 = ($16 | 0) < 0;
 if ($17) {
  $18 = $4 + 4 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = $5;
  $21 = $19 + $20 | 0;
  $5 = $21;
  $22 = $5;
  $23 = ($22 | 0) < 0;
  if ($23) {
   _mp_raise_ValueError(33963);
  }
 }
 $24 = HEAP32[$4 >> 2] | 0;
 $6 = $24;
 $25 = $6;
 $26 = $4 + 4 | 0;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = $25 + $27 | 0;
 $7 = $28;
 $29 = $5;
 $30 = $6;
 $31 = $30 + $29 | 0;
 $6 = $31;
 $32 = $3;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = _struct_calcsize($33) | 0;
 $35 = $34;
 $36 = $35 >> 1;
 $8 = $36;
 $37 = $6;
 $38 = $8;
 $39 = $37 + $38 | 0;
 $40 = $7;
 $41 = $39 >>> 0 > $40 >>> 0;
 if ($41) {
  _mp_raise_ValueError(33963);
 } else {
  $42 = $3;
  $43 = HEAP32[$42 >> 2] | 0;
  $44 = $6;
  $45 = $2;
  $46 = $45 - 3 | 0;
  $47 = $3;
  $48 = $47 + 12 | 0;
  _struct_pack_into_internal($43, $44, $46, $48);
  STACKTOP = sp;
  return 17668 | 0;
 }
 return 0 | 0;
}

function _str_endswith($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = sp + 8 | 0;
 $7 = sp + 4 | 0;
 $3 = $0;
 $4 = $1;
 $9 = $4;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = _mp_obj_is_qstr_1128($10) | 0;
 $12 = $4;
 $13 = HEAP32[$12 >> 2] | 0;
 if ($11) {
  $14 = $13;
  $15 = $14 >>> 2;
  $16 = _qstr_data($15, $6) | 0;
  $5 = $16;
 } else {
  $17 = $13 + 8 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  HEAP32[$6 >> 2] = $18;
  $19 = $4;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = $20 + 12 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $5 = $22;
 }
 $23 = $4;
 $24 = $23 + 4 | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = _mp_obj_str_get_data($25, $7) | 0;
 $8 = $26;
 $27 = $3;
 $28 = $27 >>> 0 > 2;
 if ($28) {
  _mp_raise_NotImplementedError(32352);
 }
 $29 = HEAP32[$7 >> 2] | 0;
 $30 = HEAP32[$6 >> 2] | 0;
 $31 = $29 >>> 0 > $30 >>> 0;
 if ($31) {
  $2 = 13856;
  $43 = $2;
  STACKTOP = sp;
  return $43 | 0;
 } else {
  $32 = $5;
  $33 = HEAP32[$6 >> 2] | 0;
  $34 = HEAP32[$7 >> 2] | 0;
  $35 = $33 - $34 | 0;
  $36 = $32 + $35 | 0;
  $37 = $8;
  $38 = HEAP32[$7 >> 2] | 0;
  $39 = _memcmp($36, $37, $38) | 0;
  $40 = ($39 | 0) == 0;
  $41 = $40 & 1;
  $42 = _mp_obj_new_bool_1159($41) | 0;
  $2 = $42;
  $43 = $2;
  STACKTOP = sp;
  return $43 | 0;
 }
 return 0 | 0;
}

function _mp_getiter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer = sp;
 $7 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $8 = $3;
 $9 = _mp_obj_get_type($8) | 0;
 $5 = $9;
 $10 = $5;
 $11 = $10 + 36 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = ($12 | 0) == (59 | 0);
 if ($13) {
  $14 = $3;
  $2 = $14;
  $39 = $2;
  STACKTOP = sp;
  return $39 | 0;
 }
 $15 = $4;
 $16 = ($15 | 0) == (0 | 0);
 if ($16) {
  $17 = _m_malloc(16) | 0;
  $4 = $17;
 }
 $18 = $5;
 $19 = $18 + 36 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = ($20 | 0) != (0 | 0);
 if ($21) {
  $22 = $5;
  $23 = $22 + 36 | 0;
  $24 = HEAP32[$23 >> 2] | 0;
  $25 = $3;
  $26 = $4;
  $27 = FUNCTION_TABLE_iii[$24 & 1023]($25, $26) | 0;
  $6 = $27;
  $28 = $6;
  $29 = ($28 | 0) != (0 | 0);
  if ($29) {
   $30 = $6;
   $2 = $30;
   $39 = $2;
   STACKTOP = sp;
   return $39 | 0;
  }
 }
 $31 = $3;
 _mp_load_method_maybe($31, 15, $7);
 $32 = HEAP32[$7 >> 2] | 0;
 $33 = ($32 | 0) != (0 | 0);
 if (!$33) {
  $36 = $3;
  $37 = _mp_obj_get_type_str($36) | 0;
  HEAP32[$vararg_buffer >> 2] = $37;
  $38 = _mp_obj_new_exception_msg_varg(16012, 29729, $vararg_buffer) | 0;
  _nlr_jump($38);
 }
 $34 = $4;
 $35 = _mp_obj_new_getitem_iter($7, $34) | 0;
 $2 = $35;
 $39 = $2;
 STACKTOP = sp;
 return $39 | 0;
}

function _mp_obj_subscr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer1 = 0, $vararg_buffer4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer4 = sp + 16 | 0;
 $vararg_buffer1 = sp + 8 | 0;
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $3;
 $9 = _mp_obj_get_type($8) | 0;
 $6 = $9;
 $10 = $6;
 $11 = $10 + 32 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = ($12 | 0) != (0 | 0);
 if ($13) {
  $14 = $6;
  $15 = $14 + 32 | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  $17 = $3;
  $18 = $4;
  $19 = $5;
  $20 = FUNCTION_TABLE_iiii[$16 & 1023]($17, $18, $19) | 0;
  $7 = $20;
  $21 = $7;
  $22 = ($21 | 0) != (0 | 0);
  if ($22) {
   $23 = $7;
   STACKTOP = sp;
   return $23 | 0;
  }
 }
 $24 = $5;
 $25 = ($24 | 0) == (0 | 0);
 if ($25) {
  $26 = $3;
  $27 = _mp_obj_get_type_str($26) | 0;
  HEAP32[$vararg_buffer >> 2] = $27;
  $28 = _mp_obj_new_exception_msg_varg(16012, 30602, $vararg_buffer) | 0;
  _nlr_jump($28);
 }
 $29 = $5;
 $30 = ($29 | 0) == (4 | 0);
 $31 = $3;
 $32 = _mp_obj_get_type_str($31) | 0;
 if ($30) {
  HEAP32[$vararg_buffer1 >> 2] = $32;
  $33 = _mp_obj_new_exception_msg_varg(16012, 30644, $vararg_buffer1) | 0;
  _nlr_jump($33);
 } else {
  HEAP32[$vararg_buffer4 >> 2] = $32;
  $34 = _mp_obj_new_exception_msg_varg(16012, 30676, $vararg_buffer4) | 0;
  _nlr_jump($34);
 }
 return 0 | 0;
}

function _fmt_u($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$010$lcssa$off0 = 0, $$012 = 0, $$09$lcssa = 0, $$0914 = 0, $$1$lcssa = 0, $$111 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $3 = $1 >>> 0 > 0;
 $4 = $0 >>> 0 > 4294967295;
 $5 = ($1 | 0) == 0;
 $6 = $5 & $4;
 $7 = $3 | $6;
 if ($7) {
  $$0914 = $2;
  $8 = $0;
  $9 = $1;
  while (1) {
   $10 = ___udivdi3($8 | 0, $9 | 0, 10, 0) | 0;
   $11 = getTempRet0() | 0;
   $12 = ___muldi3($10 | 0, $11 | 0, 10, 0) | 0;
   $13 = getTempRet0() | 0;
   $14 = _i64Subtract($8 | 0, $9 | 0, $12 | 0, $13 | 0) | 0;
   $15 = getTempRet0() | 0;
   $16 = $14 & 255;
   $17 = $16 | 48;
   $18 = $$0914 + -1 | 0;
   HEAP8[$18 >> 0] = $17;
   $19 = $9 >>> 0 > 9;
   $20 = $8 >>> 0 > 4294967295;
   $21 = ($9 | 0) == 9;
   $22 = $21 & $20;
   $23 = $19 | $22;
   if ($23) {
    $$0914 = $18;
    $8 = $10;
    $9 = $11;
   } else {
    break;
   }
  }
  $$010$lcssa$off0 = $10;
  $$09$lcssa = $18;
 } else {
  $$010$lcssa$off0 = $0;
  $$09$lcssa = $2;
 }
 $24 = ($$010$lcssa$off0 | 0) == 0;
 if ($24) {
  $$1$lcssa = $$09$lcssa;
 } else {
  $$012 = $$010$lcssa$off0;
  $$111 = $$09$lcssa;
  while (1) {
   $25 = ($$012 >>> 0) / 10 & -1;
   $26 = $25 * 10 | 0;
   $27 = $$012 - $26 | 0;
   $28 = $27 | 48;
   $29 = $28 & 255;
   $30 = $$111 + -1 | 0;
   HEAP8[$30 >> 0] = $29;
   $31 = $$012 >>> 0 < 10;
   if ($31) {
    $$1$lcssa = $30;
    break;
   } else {
    $$012 = $25;
    $$111 = $30;
   }
  }
 }
 return $$1$lcssa | 0;
}

function _mp_builtin_ord($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = sp + 8 | 0;
 $2 = $0;
 $5 = $2;
 $6 = _mp_obj_str_get_data($5, $3) | 0;
 $4 = $6;
 $7 = $2;
 $8 = _mp_obj_is_qstr_1390($7) | 0;
 do {
  if (!$8) {
   $9 = $2;
   $10 = _mp_obj_is_obj_1391($9) | 0;
   if ($10) {
    $11 = $2;
    $12 = HEAP32[$11 >> 2] | 0;
    $13 = ($12 | 0) == (18680 | 0);
    if ($13) {
     break;
    }
   }
   $22 = HEAP32[$3 >> 2] | 0;
   $23 = ($22 | 0) == 1;
   if (!$23) {
    $30 = HEAP32[$3 >> 2] | 0;
    HEAP32[$vararg_buffer >> 2] = $30;
    $31 = _mp_obj_new_exception_msg_varg(16012, 33726, $vararg_buffer) | 0;
    _nlr_jump($31);
   }
   $24 = $4;
   $25 = HEAP8[$24 >> 0] | 0;
   $26 = $25 & 255;
   $27 = $26 << 1;
   $28 = $27 | 1;
   $29 = $28;
   $1 = $29;
   $32 = $1;
   STACKTOP = sp;
   return $32 | 0;
  }
 } while (0);
 $14 = $4;
 $15 = HEAP32[$3 >> 2] | 0;
 $16 = _utf8_charlen($14, $15) | 0;
 HEAP32[$3 >> 2] = $16;
 $17 = HEAP32[$3 >> 2] | 0;
 $18 = ($17 | 0) == 1;
 if (!$18) {
  $30 = HEAP32[$3 >> 2] | 0;
  HEAP32[$vararg_buffer >> 2] = $30;
  $31 = _mp_obj_new_exception_msg_varg(16012, 33726, $vararg_buffer) | 0;
  _nlr_jump($31);
 }
 $19 = $4;
 $20 = _utf8_get_char($19) | 0;
 $21 = _mp_obj_new_int($20) | 0;
 $1 = $21;
 $32 = $1;
 STACKTOP = sp;
 return $32 | 0;
}

function _compile_term($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $8 = $3;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $10 >>> 8;
 $4 = $11;
 $12 = $2;
 $13 = $3;
 $14 = $13 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 _compile_node($12, $15);
 $5 = 1;
 while (1) {
  $16 = $5;
  $17 = $16 + 1 | 0;
  $18 = $4;
  $19 = ($17 | 0) < ($18 | 0);
  if (!$19) {
   break;
  }
  $20 = $2;
  $21 = $3;
  $22 = $21 + 8 | 0;
  $23 = $5;
  $24 = $23 + 1 | 0;
  $25 = $22 + ($24 << 2) | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  _compile_node($20, $26);
  $27 = $3;
  $28 = $27 + 8 | 0;
  $29 = $5;
  $30 = $28 + ($29 << 2) | 0;
  $31 = HEAP32[$30 >> 2] | 0;
  $32 = $31 >>> 4;
  $7 = $32;
  $33 = $7;
  switch ($33 | 0) {
  case 49:
   {
    $6 = 26;
    break;
   }
  case 50:
   {
    $6 = 27;
    break;
   }
  case 51:
   {
    $6 = 28;
    break;
   }
  case 54:
   {
    $6 = 29;
    break;
   }
  case 53:
   {
    $6 = 30;
    break;
   }
  case 55:
   {
    $6 = 31;
    break;
   }
  case 57:
   {
    $6 = 24;
    break;
   }
  default:
   {
    $6 = 25;
   }
  }
  $34 = $2;
  $35 = $34 + 40 | 0;
  $36 = HEAP32[$35 >> 2] | 0;
  $37 = $6;
  _mp_emit_bc_binary_op($36, $37);
  $38 = $5;
  $39 = $38 + 2 | 0;
  $5 = $39;
 }
 STACKTOP = sp;
 return;
}

function _str_to_int($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $4;
 $8 = $6 >>> 0 < $7 >>> 0;
 L1 : do {
  if ($8) {
   $9 = $3;
   $10 = HEAP8[$9 >> 0] | 0;
   $11 = $10 << 24 >> 24;
   $12 = 48 <= ($11 | 0);
   if ($12) {
    $13 = $3;
    $14 = HEAP8[$13 >> 0] | 0;
    $15 = $14 << 24 >> 24;
    $16 = ($15 | 0) <= 57;
    if ($16) {
     $17 = $5;
     HEAP32[$17 >> 2] = 0;
     while (1) {
      $18 = $5;
      $19 = HEAP32[$18 >> 2] | 0;
      $20 = $19 * 10 | 0;
      $21 = $3;
      $22 = HEAP8[$21 >> 0] | 0;
      $23 = $22 << 24 >> 24;
      $24 = $23 - 48 | 0;
      $25 = $20 + $24 | 0;
      $26 = $5;
      HEAP32[$26 >> 2] = $25;
      $27 = $3;
      $28 = $27 + 1 | 0;
      $3 = $28;
      $29 = $3;
      $30 = $4;
      $31 = $29 >>> 0 < $30 >>> 0;
      if (!$31) {
       break L1;
      }
      $32 = $3;
      $33 = HEAP8[$32 >> 0] | 0;
      $34 = $33 << 24 >> 24;
      $35 = 48 <= ($34 | 0);
      if (!$35) {
       break L1;
      }
      $36 = $3;
      $37 = HEAP8[$36 >> 0] | 0;
      $38 = $37 << 24 >> 24;
      $39 = ($38 | 0) <= 57;
      if (!$39) {
       break;
      }
     }
    }
   }
  }
 } while (0);
 $40 = $3;
 STACKTOP = sp;
 return $40 | 0;
}

function _match_group($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $8 = $3;
 $5 = $8;
 $9 = $4;
 $10 = _mp_obj_get_int($9) | 0;
 $6 = $10;
 $11 = $6;
 $12 = ($11 | 0) < 0;
 if ($12) {
  $18 = $4;
  $19 = _mp_obj_new_exception_arg1(15532, $18) | 0;
  _nlr_jump($19);
 }
 $13 = $6;
 $14 = $5;
 $15 = $14 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($13 | 0) >= ($16 | 0);
 if ($17) {
  $18 = $4;
  $19 = _mp_obj_new_exception_arg1(15532, $18) | 0;
  _nlr_jump($19);
 }
 $20 = $5;
 $21 = $20 + 12 | 0;
 $22 = $6;
 $23 = $22 << 1;
 $24 = $21 + ($23 << 2) | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 $7 = $25;
 $26 = $7;
 $27 = ($26 | 0) == (0 | 0);
 if ($27) {
  $2 = 17668;
  $45 = $2;
  STACKTOP = sp;
  return $45 | 0;
 } else {
  $28 = $5;
  $29 = $28 + 8 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = _mp_obj_get_type($30) | 0;
  $32 = $7;
  $33 = $5;
  $34 = $33 + 12 | 0;
  $35 = $6;
  $36 = $35 << 1;
  $37 = $36 + 1 | 0;
  $38 = $34 + ($37 << 2) | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  $40 = $7;
  $41 = $39;
  $42 = $40;
  $43 = $41 - $42 | 0;
  $44 = _mp_obj_new_str_of_type($31, $32, $43) | 0;
  $2 = $44;
  $45 = $2;
  STACKTOP = sp;
  return $45 | 0;
 }
 return 0 | 0;
}

function _stream_readinto($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = sp + 12 | 0;
 $7 = sp + 4 | 0;
 $3 = $0;
 $4 = $1;
 $9 = $4;
 $10 = $9 + 4 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 _mp_get_buffer_raise($11, $5, 2);
 $12 = $5 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $6 = $13;
 $14 = $3;
 $15 = $14 >>> 0 > 2;
 if ($15) {
  $16 = $4;
  $17 = $16 + 8 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = _mp_obj_get_int($18) | 0;
  $6 = $19;
  $20 = $6;
  $21 = $5 + 4 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $20 >>> 0 > $22 >>> 0;
  if ($23) {
   $24 = $5 + 4 | 0;
   $25 = HEAP32[$24 >> 2] | 0;
   $6 = $25;
  }
 }
 $26 = $4;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = HEAP32[$5 >> 2] | 0;
 $29 = $6;
 $30 = _mp_stream_rw($27, $28, $29, $7, 0) | 0;
 $8 = $30;
 $31 = HEAP32[$7 >> 2] | 0;
 $32 = ($31 | 0) != 0;
 if (!$32) {
  $38 = $8;
  $39 = $38 << 1;
  $40 = $39 | 1;
  $41 = $40;
  $2 = $41;
  $42 = $2;
  STACKTOP = sp;
  return $42 | 0;
 }
 $33 = HEAP32[$7 >> 2] | 0;
 $34 = ($33 | 0) == 11;
 $35 = HEAP32[$7 >> 2] | 0;
 $36 = ($35 | 0) == 11;
 $or$cond = $34 | $36;
 if (!$or$cond) {
  $37 = HEAP32[$7 >> 2] | 0;
  _mp_raise_OSError($37);
 }
 $2 = 17668;
 $42 = $2;
 STACKTOP = sp;
 return $42 | 0;
}

function _sha256_update($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = 0;
 while (1) {
  $7 = $6;
  $8 = $5;
  $9 = $7 >>> 0 < $8 >>> 0;
  if (!$9) {
   break;
  }
  $10 = $4;
  $11 = $6;
  $12 = $10 + $11 | 0;
  $13 = HEAP8[$12 >> 0] | 0;
  $14 = $3;
  $15 = $3;
  $16 = $15 + 64 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = $14 + $17 | 0;
  HEAP8[$18 >> 0] = $13;
  $19 = $3;
  $20 = $19 + 64 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  $22 = $21 + 1 | 0;
  HEAP32[$20 >> 2] = $22;
  $23 = $3;
  $24 = $23 + 64 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = ($25 | 0) == 64;
  if ($26) {
   $27 = $3;
   $28 = $3;
   _sha256_transform($27, $28);
   $29 = $3;
   $30 = $29 + 72 | 0;
   $31 = $30;
   $32 = $31;
   $33 = HEAP32[$32 >> 2] | 0;
   $34 = $31 + 4 | 0;
   $35 = $34;
   $36 = HEAP32[$35 >> 2] | 0;
   $37 = _i64Add($33 | 0, $36 | 0, 512, 0) | 0;
   $38 = getTempRet0() | 0;
   $39 = $30;
   $40 = $39;
   HEAP32[$40 >> 2] = $37;
   $41 = $39 + 4 | 0;
   $42 = $41;
   HEAP32[$42 >> 2] = $38;
   $43 = $3;
   $44 = $43 + 64 | 0;
   HEAP32[$44 >> 2] = 0;
  }
  $45 = $6;
  $46 = $45 + 1 | 0;
  $6 = $46;
 }
 STACKTOP = sp;
 return;
}

function _legacy_framebuffer1($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp;
 $2 = $0;
 $3 = $1;
 $6 = _m_malloc(20) | 0;
 $4 = $6;
 $7 = $4;
 HEAP32[$7 >> 2] = 21996;
 $8 = $3;
 $9 = HEAP32[$8 >> 2] | 0;
 _mp_get_buffer_raise($9, $5, 2);
 $10 = HEAP32[$5 >> 2] | 0;
 $11 = $4;
 $12 = $11 + 8 | 0;
 HEAP32[$12 >> 2] = $10;
 $13 = $3;
 $14 = $13 + 4 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = _mp_obj_get_int($15) | 0;
 $17 = $16 & 65535;
 $18 = $4;
 $19 = $18 + 12 | 0;
 HEAP16[$19 >> 1] = $17;
 $20 = $3;
 $21 = $20 + 8 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = _mp_obj_get_int($22) | 0;
 $24 = $23 & 65535;
 $25 = $4;
 $26 = $25 + 14 | 0;
 HEAP16[$26 >> 1] = $24;
 $27 = $4;
 $28 = $27 + 18 | 0;
 HEAP8[$28 >> 0] = 0;
 $29 = $2;
 $30 = $29 >>> 0 >= 4;
 if ($30) {
  $31 = $3;
  $32 = $31 + 12 | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = _mp_obj_get_int($33) | 0;
  $35 = $34 & 65535;
  $36 = $4;
  $37 = $36 + 16 | 0;
  HEAP16[$37 >> 1] = $35;
  $43 = $4;
  STACKTOP = sp;
  return $43 | 0;
 } else {
  $38 = $4;
  $39 = $38 + 12 | 0;
  $40 = HEAP16[$39 >> 1] | 0;
  $41 = $4;
  $42 = $41 + 16 | 0;
  HEAP16[$42 >> 1] = $40;
  $43 = $4;
  STACKTOP = sp;
  return $43 | 0;
 }
 return 0 | 0;
}

function _mp_import_all($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $1 = $0;
 $6 = $1;
 $7 = _mp_obj_module_get_globals($6) | 0;
 $8 = $7 + 4 | 0;
 $2 = $8;
 $3 = 0;
 while (1) {
  $9 = $3;
  $10 = $2;
  $11 = $10 + 4 | 0;
  $12 = HEAP32[$11 >> 2] | 0;
  $13 = $9 >>> 0 < $12 >>> 0;
  if (!$13) {
   break;
  }
  $14 = $2;
  $15 = $3;
  $16 = _mp_map_slot_is_filled($14, $15) | 0;
  if ($16) {
   $17 = $2;
   $18 = $17 + 8 | 0;
   $19 = HEAP32[$18 >> 2] | 0;
   $20 = $3;
   $21 = $19 + ($20 << 3) | 0;
   $22 = HEAP32[$21 >> 2] | 0;
   $23 = _mp_obj_str_get_str($22) | 0;
   $4 = $23;
   $24 = $4;
   $25 = HEAP8[$24 >> 0] | 0;
   $26 = $25 << 24 >> 24;
   $27 = ($26 | 0) != 95;
   if ($27) {
    $28 = $2;
    $29 = $28 + 8 | 0;
    $30 = HEAP32[$29 >> 2] | 0;
    $31 = $3;
    $32 = $30 + ($31 << 3) | 0;
    $33 = HEAP32[$32 >> 2] | 0;
    $34 = _mp_obj_str_get_qstr($33) | 0;
    $5 = $34;
    $35 = $5;
    $36 = $2;
    $37 = $36 + 8 | 0;
    $38 = HEAP32[$37 >> 2] | 0;
    $39 = $3;
    $40 = $38 + ($39 << 3) | 0;
    $41 = $40 + 4 | 0;
    $42 = HEAP32[$41 >> 2] | 0;
    _mp_store_name($35, $42);
   }
  }
  $43 = $3;
  $44 = $43 + 1 | 0;
  $3 = $44;
 }
 STACKTOP = sp;
 return;
}

function _bytes_it_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp + 4 | 0;
 $2 = $0;
 $7 = $2;
 $3 = $7;
 $8 = $3;
 $9 = $8 + 8 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = _mp_obj_is_qstr_1128($10) | 0;
 $12 = $3;
 $13 = $12 + 8 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 if ($11) {
  $15 = $14;
  $16 = $15 >>> 2;
  $17 = _qstr_data($16, $5) | 0;
  $4 = $17;
 } else {
  $18 = $14 + 8 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  HEAP32[$5 >> 2] = $19;
  $20 = $3;
  $21 = $20 + 8 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $22 + 12 | 0;
  $24 = HEAP32[$23 >> 2] | 0;
  $4 = $24;
 }
 $25 = $3;
 $26 = $25 + 12 | 0;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = HEAP32[$5 >> 2] | 0;
 $29 = $27 >>> 0 < $28 >>> 0;
 if ($29) {
  $30 = $4;
  $31 = $3;
  $32 = $31 + 12 | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = $30 + $33 | 0;
  $35 = HEAP8[$34 >> 0] | 0;
  $36 = $35 & 255;
  $37 = $36 << 1;
  $38 = $37 | 1;
  $39 = $38;
  $6 = $39;
  $40 = $3;
  $41 = $40 + 12 | 0;
  $42 = HEAP32[$41 >> 2] | 0;
  $43 = $42 + 1 | 0;
  HEAP32[$41 >> 2] = $43;
  $44 = $6;
  $1 = $44;
  $45 = $1;
  STACKTOP = sp;
  return $45 | 0;
 } else {
  $1 = 0;
  $45 = $1;
  STACKTOP = sp;
  return $45 | 0;
 }
 return 0 | 0;
}

function _apply_to_single_or_list($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $11 = $5;
 $12 = ($11 | 0) != 0;
 if ($12) {
  $13 = $5;
  $14 = $13 & 3;
  $15 = ($14 | 0) == 0;
  if ($15) {
   $16 = $5;
   $17 = $16;
   $18 = $17 + 4 | 0;
   $19 = HEAP32[$18 >> 2] | 0;
   $20 = $19 & 255;
   $21 = $6;
   $22 = ($20 | 0) == ($21 | 0);
   if ($22) {
    $23 = $5;
    $24 = $23;
    $8 = $24;
    $25 = $8;
    $26 = $25 + 4 | 0;
    $27 = HEAP32[$26 >> 2] | 0;
    $28 = $27 >>> 8;
    $9 = $28;
    $10 = 0;
    while (1) {
     $29 = $10;
     $30 = $9;
     $31 = ($29 | 0) < ($30 | 0);
     if (!$31) {
      break;
     }
     $32 = $7;
     $33 = $4;
     $34 = $8;
     $35 = $34 + 8 | 0;
     $36 = $10;
     $37 = $35 + ($36 << 2) | 0;
     $38 = HEAP32[$37 >> 2] | 0;
     FUNCTION_TABLE_vii[$32 & 1023]($33, $38);
     $39 = $10;
     $40 = $39 + 1 | 0;
     $10 = $40;
    }
    STACKTOP = sp;
    return;
   }
  }
 }
 $41 = $5;
 $42 = ($41 | 0) == 0;
 if ($42) {
  STACKTOP = sp;
  return;
 }
 $43 = $7;
 $44 = $4;
 $45 = $5;
 FUNCTION_TABLE_vii[$43 & 1023]($44, $45);
 STACKTOP = sp;
 return;
}

function __re1_5_classmatch($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $7 = $3;
 $8 = $7 + -1 | 0;
 $9 = HEAP8[$8 >> 0] | 0;
 $10 = $9 << 24 >> 24;
 $11 = ($10 | 0) == 3;
 $12 = $11 & 1;
 $5 = $12;
 $13 = $3;
 $14 = $13 + 1 | 0;
 $3 = $14;
 $15 = HEAP8[$13 >> 0] | 0;
 $16 = $15 << 24 >> 24;
 $6 = $16;
 while (1) {
  $17 = $6;
  $18 = $17 + -1 | 0;
  $6 = $18;
  $19 = ($17 | 0) != 0;
  if (!$19) {
   label = 7;
   break;
  }
  $20 = $4;
  $21 = HEAP8[$20 >> 0] | 0;
  $22 = $21 << 24 >> 24;
  $23 = $3;
  $24 = HEAP8[$23 >> 0] | 0;
  $25 = $24 << 24 >> 24;
  $26 = ($22 | 0) >= ($25 | 0);
  if ($26) {
   $27 = $4;
   $28 = HEAP8[$27 >> 0] | 0;
   $29 = $28 << 24 >> 24;
   $30 = $3;
   $31 = $30 + 1 | 0;
   $32 = HEAP8[$31 >> 0] | 0;
   $33 = $32 << 24 >> 24;
   $34 = ($29 | 0) <= ($33 | 0);
   if ($34) {
    label = 5;
    break;
   }
  }
  $36 = $3;
  $37 = $36 + 2 | 0;
  $3 = $37;
 }
 if ((label | 0) == 5) {
  $35 = $5;
  $2 = $35;
  $42 = $2;
  STACKTOP = sp;
  return $42 | 0;
 } else if ((label | 0) == 7) {
  $38 = $5;
  $39 = ($38 | 0) != 0;
  $40 = $39 ^ 1;
  $41 = $40 & 1;
  $2 = $41;
  $42 = $2;
  STACKTOP = sp;
  return $42 | 0;
 }
 return 0 | 0;
}

function _mpz_as_int_checked($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 16 | 0;
 $3 = $0;
 $4 = $1;
 $5 = 0;
 $7 = $3;
 $8 = $7 + 8 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $3;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $9 + ($12 << 1) | 0;
 $6 = $13;
 while (1) {
  $14 = $6;
  $15 = $14 + -2 | 0;
  $6 = $15;
  $16 = $3;
  $17 = $16 + 8 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = $14 >>> 0 > $18 >>> 0;
  if (!$19) {
   break;
  }
  $20 = $5;
  $21 = $20 >>> 0 > 32767;
  if ($21) {
   label = 4;
   break;
  }
  $22 = $5;
  $23 = $22 << 16;
  $24 = $6;
  $25 = HEAP16[$24 >> 1] | 0;
  $26 = $25 & 65535;
  $27 = $23 | $26;
  $5 = $27;
 }
 if ((label | 0) == 4) {
  $$expand_i1_val = 0;
  HEAP8[$2 >> 0] = $$expand_i1_val;
  $$pre_trunc = HEAP8[$2 >> 0] | 0;
  $36 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $36 | 0;
 }
 $28 = $3;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = $29 & 1;
 $31 = ($30 | 0) != 0;
 if ($31) {
  $32 = $5;
  $33 = 0 - $32 | 0;
  $5 = $33;
 }
 $34 = $5;
 $35 = $4;
 HEAP32[$35 >> 2] = $34;
 $$expand_i1_val2 = 1;
 HEAP8[$2 >> 0] = $$expand_i1_val2;
 $$pre_trunc = HEAP8[$2 >> 0] | 0;
 $36 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $36 | 0;
}

function _mp_set_remove_first($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = 0;
 while (1) {
  $5 = $3;
  $6 = $2;
  $7 = HEAP32[$6 >> 2] | 0;
  $8 = $5 >>> 0 < $7 >>> 0;
  if (!$8) {
   label = 9;
   break;
  }
  $9 = $2;
  $10 = $3;
  $11 = _mp_set_slot_is_filled($9, $10) | 0;
  if ($11) {
   break;
  }
  $39 = $3;
  $40 = $39 + 1 | 0;
  $3 = $40;
 }
 if ((label | 0) == 9) {
  $1 = 0;
  $41 = $1;
  STACKTOP = sp;
  return $41 | 0;
 }
 $12 = $2;
 $13 = $12 + 8 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $3;
 $16 = $14 + ($15 << 2) | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $4 = $17;
 $18 = $2;
 $19 = $18 + 4 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = $20 + -1 | 0;
 HEAP32[$19 >> 2] = $21;
 $22 = $2;
 $23 = $22 + 8 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $3;
 $26 = $25 + 1 | 0;
 $27 = $2;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = ($26 >>> 0) % ($28 >>> 0) & -1;
 $30 = $24 + ($29 << 2) | 0;
 $31 = HEAP32[$30 >> 2] | 0;
 $32 = ($31 | 0) == (0 | 0);
 $33 = $2;
 $34 = $33 + 8 | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 $36 = $3;
 $37 = $35 + ($36 << 2) | 0;
 if ($32) {
  HEAP32[$37 >> 2] = 0;
 } else {
  HEAP32[$37 >> 2] = 4;
 }
 $38 = $4;
 $1 = $38;
 $41 = $1;
 STACKTOP = sp;
 return $41 | 0;
}

function _mp_load_global($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $vararg_buffer = sp;
 $2 = $0;
 $4 = _mp_globals_get() | 0;
 $5 = $4 + 4 | 0;
 $6 = $2;
 $7 = $6 << 2;
 $8 = $7 | 2;
 $9 = $8;
 $10 = _mp_map_lookup($5, $9, 0) | 0;
 $3 = $10;
 $11 = $3;
 $12 = ($11 | 0) == (0 | 0);
 if ($12) {
  $13 = HEAP32[40684 >> 2] | 0;
  $14 = ($13 | 0) != (0 | 0);
  if ($14) {
   $15 = HEAP32[40684 >> 2] | 0;
   $16 = $15 + 4 | 0;
   $17 = $2;
   $18 = $17 << 2;
   $19 = $18 | 2;
   $20 = $19;
   $21 = _mp_map_lookup($16, $20, 0) | 0;
   $3 = $21;
   $22 = $3;
   $23 = ($22 | 0) != (0 | 0);
   if ($23) {
    $24 = $3;
    $25 = $24 + 4 | 0;
    $26 = HEAP32[$25 >> 2] | 0;
    $1 = $26;
    $39 = $1;
    STACKTOP = sp;
    return $39 | 0;
   }
  }
  $27 = $2;
  $28 = $27 << 2;
  $29 = $28 | 2;
  $30 = $29;
  $31 = _mp_map_lookup(19848, $30, 0) | 0;
  $3 = $31;
  $32 = $3;
  $33 = ($32 | 0) == (0 | 0);
  if ($33) {
   $34 = $2;
   HEAP32[$vararg_buffer >> 2] = $34;
   $35 = _mp_obj_new_exception_msg_varg(15712, 29560, $vararg_buffer) | 0;
   _nlr_jump($35);
  }
 }
 $36 = $3;
 $37 = $36 + 4 | 0;
 $38 = HEAP32[$37 >> 2] | 0;
 $1 = $38;
 $39 = $1;
 STACKTOP = sp;
 return $39 | 0;
}

function _range_it_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $5 = $2;
 $3 = $5;
 $6 = $3;
 $7 = $6 + 12 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) > 0;
 if ($9) {
  $10 = $3;
  $11 = $10 + 4 | 0;
  $12 = HEAP32[$11 >> 2] | 0;
  $13 = $3;
  $14 = $13 + 8 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = ($12 | 0) < ($15 | 0);
  if (!$16) {
   label = 3;
  }
 } else {
  label = 3;
 }
 do {
  if ((label | 0) == 3) {
   $17 = $3;
   $18 = $17 + 12 | 0;
   $19 = HEAP32[$18 >> 2] | 0;
   $20 = ($19 | 0) < 0;
   if ($20) {
    $21 = $3;
    $22 = $21 + 4 | 0;
    $23 = HEAP32[$22 >> 2] | 0;
    $24 = $3;
    $25 = $24 + 8 | 0;
    $26 = HEAP32[$25 >> 2] | 0;
    $27 = ($23 | 0) > ($26 | 0);
    if ($27) {
     break;
    }
   }
   $1 = 0;
   $42 = $1;
   STACKTOP = sp;
   return $42 | 0;
  }
 } while (0);
 $28 = $3;
 $29 = $28 + 4 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = $30 << 1;
 $32 = $31 | 1;
 $33 = $32;
 $4 = $33;
 $34 = $3;
 $35 = $34 + 12 | 0;
 $36 = HEAP32[$35 >> 2] | 0;
 $37 = $3;
 $38 = $37 + 4 | 0;
 $39 = HEAP32[$38 >> 2] | 0;
 $40 = $39 + $36 | 0;
 HEAP32[$38 >> 2] = $40;
 $41 = $4;
 $1 = $41;
 $42 = $1;
 STACKTOP = sp;
 return $42 | 0;
}

function _mod_binascii_sextet($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $2;
 $4 = $3 & 255;
 $5 = ($4 | 0) >= 65;
 if ($5) {
  $6 = $2;
  $7 = $6 & 255;
  $8 = ($7 | 0) <= 90;
  if ($8) {
   $9 = $2;
   $10 = $9 & 255;
   $11 = $10 - 65 | 0;
   $1 = $11;
  } else {
   label = 4;
  }
 } else {
  label = 4;
 }
 do {
  if ((label | 0) == 4) {
   $12 = $2;
   $13 = $12 & 255;
   $14 = ($13 | 0) >= 97;
   if ($14) {
    $15 = $2;
    $16 = $15 & 255;
    $17 = ($16 | 0) <= 122;
    if ($17) {
     $18 = $2;
     $19 = $18 & 255;
     $20 = $19 - 97 | 0;
     $21 = $20 + 26 | 0;
     $1 = $21;
     break;
    }
   }
   $22 = $2;
   $23 = $22 & 255;
   $24 = ($23 | 0) >= 48;
   if ($24) {
    $25 = $2;
    $26 = $25 & 255;
    $27 = ($26 | 0) <= 57;
    if ($27) {
     $28 = $2;
     $29 = $28 & 255;
     $30 = $29 - 48 | 0;
     $31 = $30 + 52 | 0;
     $1 = $31;
     break;
    }
   }
   $32 = $2;
   $33 = $32 & 255;
   $34 = ($33 | 0) == 43;
   if ($34) {
    $1 = 62;
    break;
   }
   $35 = $2;
   $36 = $35 & 255;
   $37 = ($36 | 0) == 47;
   if ($37) {
    $1 = 63;
    break;
   } else {
    $1 = -1;
    break;
   }
  }
 } while (0);
 $38 = $1;
 STACKTOP = sp;
 return $38 | 0;
}

function _mp_set_rehash($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $5 = $1;
 $6 = HEAP32[$5 >> 2] | 0;
 $2 = $6;
 $7 = $1;
 $8 = $7 + 8 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $3 = $9;
 $10 = $1;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $11 + 1 | 0;
 $13 = _get_hash_alloc_greater_or_equal_to($12) | 0;
 $14 = $1;
 HEAP32[$14 >> 2] = $13;
 $15 = $1;
 $16 = $15 + 4 | 0;
 HEAP32[$16 >> 2] = 0;
 $17 = $1;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $18 << 2;
 $20 = _m_malloc0($19) | 0;
 $21 = $1;
 $22 = $21 + 8 | 0;
 HEAP32[$22 >> 2] = $20;
 $4 = 0;
 while (1) {
  $23 = $4;
  $24 = $2;
  $25 = $23 >>> 0 < $24 >>> 0;
  if (!$25) {
   break;
  }
  $26 = $3;
  $27 = $4;
  $28 = $26 + ($27 << 2) | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  $30 = ($29 | 0) != (0 | 0);
  if ($30) {
   $31 = $3;
   $32 = $4;
   $33 = $31 + ($32 << 2) | 0;
   $34 = HEAP32[$33 >> 2] | 0;
   $35 = ($34 | 0) != (4 | 0);
   if ($35) {
    $36 = $1;
    $37 = $3;
    $38 = $4;
    $39 = $37 + ($38 << 2) | 0;
    $40 = HEAP32[$39 >> 2] | 0;
    _mp_set_lookup($36, $40, 1) | 0;
   }
  }
  $41 = $4;
  $42 = $41 + 1 | 0;
  $4 = $42;
 }
 $43 = $3;
 _m_free($43);
 STACKTOP = sp;
 return;
}

function _mp_seq_extract_slice($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $10 = $5;
 $11 = HEAP32[$10 >> 2] | 0;
 $6 = $11;
 $12 = $5;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $7 = $14;
 $15 = $5;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $8 = $17;
 $18 = _mp_obj_new_list(0, 0) | 0;
 $9 = $18;
 $19 = $8;
 $20 = ($19 | 0) < 0;
 if ($20) {
  while (1) {
   $21 = $6;
   $22 = $7;
   $23 = ($21 | 0) >= ($22 | 0);
   if (!$23) {
    break;
   }
   $24 = $9;
   $25 = $4;
   $26 = $6;
   $27 = $25 + ($26 << 2) | 0;
   $28 = HEAP32[$27 >> 2] | 0;
   _mp_obj_list_append($24, $28) | 0;
   $29 = $8;
   $30 = $6;
   $31 = $30 + $29 | 0;
   $6 = $31;
  }
  $43 = $9;
  STACKTOP = sp;
  return $43 | 0;
 } else {
  while (1) {
   $32 = $6;
   $33 = $7;
   $34 = ($32 | 0) < ($33 | 0);
   if (!$34) {
    break;
   }
   $35 = $9;
   $36 = $4;
   $37 = $6;
   $38 = $36 + ($37 << 2) | 0;
   $39 = HEAP32[$38 >> 2] | 0;
   _mp_obj_list_append($35, $39) | 0;
   $40 = $8;
   $41 = $6;
   $42 = $41 + $40 | 0;
   $6 = $42;
  }
  $43 = $9;
  STACKTOP = sp;
  return $43 | 0;
 }
 return 0 | 0;
}

function _mod_uheapq_heappop($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $4 = $1;
 $5 = _get_heap($4) | 0;
 $2 = $5;
 $6 = $2;
 $7 = $6 + 8 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) == 0;
 if ($9) {
  $10 = _mp_obj_new_exception_msg(15532, 34938) | 0;
  _nlr_jump($10);
 }
 $11 = $2;
 $12 = $11 + 12 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $3 = $14;
 $15 = $2;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $17 - 1 | 0;
 HEAP32[$16 >> 2] = $18;
 $19 = $2;
 $20 = $19 + 12 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $2;
 $23 = $22 + 8 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $21 + ($24 << 2) | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = $2;
 $28 = $27 + 12 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 HEAP32[$29 >> 2] = $26;
 $30 = $2;
 $31 = $30 + 12 | 0;
 $32 = HEAP32[$31 >> 2] | 0;
 $33 = $2;
 $34 = $33 + 8 | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 $36 = $32 + ($35 << 2) | 0;
 HEAP32[$36 >> 2] = 0;
 $37 = $2;
 $38 = $37 + 8 | 0;
 $39 = HEAP32[$38 >> 2] | 0;
 $40 = ($39 | 0) != 0;
 if (!$40) {
  $42 = $3;
  STACKTOP = sp;
  return $42 | 0;
 }
 $41 = $2;
 _heap_siftup($41, 0);
 $42 = $3;
 STACKTOP = sp;
 return $42 | 0;
}

function _str_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_ptr1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $7 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $4;
 $10 = _mp_obj_is_qstr_1128($9) | 0;
 $11 = $4;
 if ($10) {
  $12 = $11;
  $13 = $12 >>> 2;
  $14 = _qstr_data($13, $7) | 0;
  $6 = $14;
 } else {
  $15 = $11 + 8 | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  HEAP32[$7 >> 2] = $16;
  $17 = $4;
  $18 = $17 + 12 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $6 = $19;
 }
 $20 = $5;
 $21 = ($20 | 0) == 3;
 if ($21) {
  $22 = $3;
  $23 = $6;
  $24 = HEAP32[$7 >> 2] | 0;
  _mp_str_print_json($22, $23, $24);
  STACKTOP = sp;
  return;
 }
 $8 = 1;
 $25 = $5;
 $26 = ($25 | 0) == 4;
 if ($26) {
  $27 = $3;
  $28 = HEAP32[$7 >> 2] | 0;
  $29 = $6;
  HEAP32[$vararg_buffer >> 2] = $28;
  $vararg_ptr1 = $vararg_buffer + 4 | 0;
  HEAP32[$vararg_ptr1 >> 2] = $29;
  _mp_printf($27, 32823, $vararg_buffer) | 0;
  STACKTOP = sp;
  return;
 }
 $30 = $8;
 $31 = $30 & 1;
 if ($31) {
  $32 = $3;
  _mp_print_str($32, 32753) | 0;
 }
 $33 = $3;
 $34 = $6;
 $35 = HEAP32[$7 >> 2] | 0;
 $36 = $8;
 $37 = $36 & 1;
 _mp_str_print_quoted($33, $34, $35, $37);
 STACKTOP = sp;
 return;
}

function _mp_obj_exception_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $spec$store$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $5;
 $11 = $6;
 _mp_arg_check_num_904($10, $11, 0, 65535, 0);
 $12 = _m_malloc_maybe(16) | 0;
 $8 = $12;
 $13 = $8;
 $14 = ($13 | 0) == (0 | 0);
 $spec$store$select = $14 ? 40576 : $12;
 $8 = $spec$store$select;
 $15 = $4;
 $16 = $8;
 HEAP32[$16 >> 2] = $15;
 $17 = $8;
 $18 = $17 + 8 | 0;
 HEAP32[$18 >> 2] = 0;
 $19 = $5;
 $20 = ($19 | 0) == 0;
 do {
  if ($20) {
   $9 = 18944;
  } else {
   $21 = $5;
   $22 = $21 << 2;
   $23 = 8 + $22 | 0;
   $24 = _m_malloc_maybe($23) | 0;
   $9 = $24;
   $25 = $9;
   $26 = ($25 | 0) == (0 | 0);
   if ($26) {
    $9 = 18944;
    break;
   } else {
    $27 = $9;
    HEAP32[$27 >> 2] = 18952;
    $28 = $5;
    $29 = $9;
    $30 = $29 + 4 | 0;
    HEAP32[$30 >> 2] = $28;
    $31 = $9;
    $32 = $31 + 8 | 0;
    $33 = $7;
    $34 = $5;
    $35 = $34 << 2;
    _memcpy($32 | 0, $33 | 0, $35 | 0) | 0;
    break;
   }
  }
 } while (0);
 $36 = $9;
 $37 = $8;
 $38 = $37 + 12 | 0;
 HEAP32[$38 >> 2] = $36;
 $39 = $8;
 STACKTOP = sp;
 return $39 | 0;
}

function _bytearray_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $11 = $6;
 $12 = $7;
 _mp_arg_check_num($11, $12, 0, 3, 0);
 $13 = $6;
 $14 = ($13 | 0) == 0;
 if ($14) {
  $15 = _array_new(1, 0) | 0;
  $4 = $15;
  $39 = $4;
  STACKTOP = sp;
  return $39 | 0;
 }
 $16 = $8;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = _mp_obj_is_small_int_831($17) | 0;
 do {
  if (!$18) {
   $19 = $8;
   $20 = HEAP32[$19 >> 2] | 0;
   $21 = _mp_obj_is_obj_817($20) | 0;
   if ($21) {
    $22 = $8;
    $23 = HEAP32[$22 >> 2] | 0;
    $24 = HEAP32[$23 >> 2] | 0;
    $25 = ($24 | 0) == (16904 | 0);
    if ($25) {
     break;
    }
   }
   $36 = $8;
   $37 = HEAP32[$36 >> 2] | 0;
   $38 = _array_construct(1, $37) | 0;
   $4 = $38;
   $39 = $4;
   STACKTOP = sp;
   return $39 | 0;
  }
 } while (0);
 $26 = $8;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = _mp_obj_get_int($27) | 0;
 $9 = $28;
 $29 = $9;
 $30 = _array_new(1, $29) | 0;
 $10 = $30;
 $31 = $10;
 $32 = $31 + 12 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = $9;
 _memset($33 | 0, 0, $34 | 0) | 0;
 $35 = $10;
 $4 = $35;
 $39 = $4;
 STACKTOP = sp;
 return $39 | 0;
}

function _stream_seek($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = sp + 16 | 0;
 $6 = sp + 4 | 0;
 $2 = $0;
 $3 = $1;
 $8 = $3;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = _mp_obj_get_int($10) | 0;
 HEAP32[$4 >> 2] = $11;
 $12 = $4 + 4 | 0;
 HEAP32[$12 >> 2] = 0;
 $13 = $2;
 $14 = ($13 | 0) == 3;
 if ($14) {
  $15 = $3;
  $16 = $15 + 8 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = _mp_obj_get_int($17) | 0;
  $19 = $4 + 4 | 0;
  HEAP32[$19 >> 2] = $18;
 }
 $20 = $4 + 4 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = ($21 | 0) == 0;
 if ($22) {
  $23 = HEAP32[$4 >> 2] | 0;
  $24 = ($23 | 0) < 0;
  if ($24) {
   _mp_raise_OSError(22);
  }
 }
 $25 = $3;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = _mp_get_stream($26) | 0;
 $5 = $27;
 $28 = $5;
 $29 = $28 + 8 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = $3;
 $32 = HEAP32[$31 >> 2] | 0;
 $33 = $4;
 $34 = FUNCTION_TABLE_iiiii[$30 & 1023]($32, 2, $33, $6) | 0;
 $7 = $34;
 $35 = $7;
 $36 = ($35 | 0) == -1;
 if ($36) {
  $37 = HEAP32[$6 >> 2] | 0;
  _mp_raise_OSError($37);
 } else {
  $38 = HEAP32[$4 >> 2] | 0;
  $39 = _mp_obj_new_int_from_uint($38) | 0;
  STACKTOP = sp;
  return $39 | 0;
 }
 return 0 | 0;
}

function _mpz_clone($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = _m_malloc(12) | 0;
 $2 = $3;
 $4 = $1;
 $5 = HEAP32[$4 >> 2] | 0;
 $6 = $5 & 1;
 $7 = $2;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $6 & 1;
 $10 = $8 & -2;
 $11 = $10 | $9;
 HEAP32[$7 >> 2] = $11;
 $12 = $2;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $13 & -3;
 HEAP32[$12 >> 2] = $14;
 $15 = $1;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $16 >>> 2;
 $18 = $2;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $17 & 1073741823;
 $21 = $20 << 2;
 $22 = $19 & 3;
 $23 = $22 | $21;
 HEAP32[$18 >> 2] = $23;
 $24 = $1;
 $25 = $24 + 4 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = $2;
 $28 = $27 + 4 | 0;
 HEAP32[$28 >> 2] = $26;
 $29 = $2;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = $30 >>> 2;
 $32 = $31 << 1;
 $33 = _m_malloc($32) | 0;
 $34 = $2;
 $35 = $34 + 8 | 0;
 HEAP32[$35 >> 2] = $33;
 $36 = $2;
 $37 = $36 + 8 | 0;
 $38 = HEAP32[$37 >> 2] | 0;
 $39 = $1;
 $40 = $39 + 8 | 0;
 $41 = HEAP32[$40 >> 2] | 0;
 $42 = $1;
 $43 = HEAP32[$42 >> 2] | 0;
 $44 = $43 >>> 2;
 $45 = $44 << 1;
 _memcpy($38 | 0, $41 | 0, $45 | 0) | 0;
 $46 = $2;
 STACKTOP = sp;
 return $46 | 0;
}

function _map_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $7 = $2;
 $3 = $7;
 $8 = $3;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $10 << 2;
 $12 = _m_malloc($11) | 0;
 $4 = $12;
 $5 = 0;
 while (1) {
  $13 = $5;
  $14 = $3;
  $15 = $14 + 4 | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  $17 = $13 >>> 0 < $16 >>> 0;
  $18 = $3;
  if (!$17) {
   label = 6;
   break;
  }
  $19 = $18 + 12 | 0;
  $20 = $5;
  $21 = $19 + ($20 << 2) | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = _mp_iternext($22) | 0;
  $6 = $23;
  $24 = $6;
  $25 = ($24 | 0) == (0 | 0);
  if ($25) {
   label = 4;
   break;
  }
  $27 = $6;
  $28 = $4;
  $29 = $5;
  $30 = $28 + ($29 << 2) | 0;
  HEAP32[$30 >> 2] = $27;
  $31 = $5;
  $32 = $31 + 1 | 0;
  $5 = $32;
 }
 if ((label | 0) == 4) {
  $26 = $4;
  _m_free($26);
  $1 = 0;
  $40 = $1;
  STACKTOP = sp;
  return $40 | 0;
 } else if ((label | 0) == 6) {
  $33 = $18 + 8 | 0;
  $34 = HEAP32[$33 >> 2] | 0;
  $35 = $3;
  $36 = $35 + 4 | 0;
  $37 = HEAP32[$36 >> 2] | 0;
  $38 = $4;
  $39 = _mp_call_function_n_kw($34, $37, 0, $38) | 0;
  $1 = $39;
  $40 = $1;
  STACKTOP = sp;
  return $40 | 0;
 }
 return 0 | 0;
}

function _mpz_cmp($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $3;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) == 0;
 if ($9) {
  $10 = $4;
  $11 = $10 + 4 | 0;
  $12 = HEAP32[$11 >> 2] | 0;
  $13 = ($12 | 0) == 0;
  if ($13) {
   $2 = 0;
   $44 = $2;
   STACKTOP = sp;
   return $44 | 0;
  }
 }
 $14 = $4;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $15 & 1;
 $17 = $3;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $18 & 1;
 $20 = $16 - $19 | 0;
 $5 = $20;
 $21 = $5;
 $22 = ($21 | 0) != 0;
 if ($22) {
  $23 = $5;
  $2 = $23;
  $44 = $2;
  STACKTOP = sp;
  return $44 | 0;
 }
 $24 = $3;
 $25 = $24 + 8 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = $3;
 $28 = $27 + 4 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = $4;
 $31 = $30 + 8 | 0;
 $32 = HEAP32[$31 >> 2] | 0;
 $33 = $4;
 $34 = $33 + 4 | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 $36 = _mpn_cmp($26, $29, $32, $35) | 0;
 $5 = $36;
 $37 = $3;
 $38 = HEAP32[$37 >> 2] | 0;
 $39 = $38 & 1;
 $40 = ($39 | 0) != 0;
 if ($40) {
  $41 = $5;
  $42 = 0 - $41 | 0;
  $5 = $42;
 }
 $43 = $5;
 $2 = $43;
 $44 = $2;
 STACKTOP = sp;
 return $44 | 0;
}

function _zip_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $7 = $2;
 $3 = $7;
 $8 = $3;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = ($10 | 0) == 0;
 if ($11) {
  $1 = 0;
  $38 = $1;
  STACKTOP = sp;
  return $38 | 0;
 }
 $12 = $3;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = _mp_obj_new_tuple($14, 0) | 0;
 $4 = $15;
 $5 = 0;
 while (1) {
  $16 = $5;
  $17 = $3;
  $18 = $17 + 4 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = $16 >>> 0 < $19 >>> 0;
  if (!$20) {
   label = 8;
   break;
  }
  $21 = $3;
  $22 = $21 + 8 | 0;
  $23 = $5;
  $24 = $22 + ($23 << 2) | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = _mp_iternext($25) | 0;
  $6 = $26;
  $27 = $6;
  $28 = ($27 | 0) == (0 | 0);
  if ($28) {
   label = 6;
   break;
  }
  $30 = $6;
  $31 = $4;
  $32 = $31 + 8 | 0;
  $33 = $5;
  $34 = $32 + ($33 << 2) | 0;
  HEAP32[$34 >> 2] = $30;
  $35 = $5;
  $36 = $35 + 1 | 0;
  $5 = $36;
 }
 if ((label | 0) == 6) {
  $29 = $4;
  _mp_obj_tuple_del($29);
  $1 = 0;
  $38 = $1;
  STACKTOP = sp;
  return $38 | 0;
 } else if ((label | 0) == 8) {
  $37 = $4;
  $1 = $37;
  $38 = $1;
  STACKTOP = sp;
  return $38 | 0;
 }
 return 0 | 0;
}

function _mp_emit_common_id_op($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $6;
 $10 = $7;
 $11 = _scope_find($9, $10) | 0;
 $8 = $11;
 $12 = $8;
 $13 = HEAP8[$12 >> 0] | 0;
 $14 = $13 & 255;
 $15 = ($14 | 0) == 1;
 if ($15) {
  $16 = $5;
  $17 = $16 + 4 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = $4;
  $20 = $7;
  FUNCTION_TABLE_viii[$18 & 1023]($19, $20, 0);
  STACKTOP = sp;
  return;
 }
 $21 = $8;
 $22 = HEAP8[$21 >> 0] | 0;
 $23 = $22 & 255;
 $24 = ($23 | 0) == 2;
 if ($24) {
  $25 = $5;
  $26 = $25 + 4 | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $28 = $4;
  $29 = $7;
  FUNCTION_TABLE_viii[$27 & 1023]($28, $29, 1);
  STACKTOP = sp;
  return;
 }
 $30 = $8;
 $31 = HEAP8[$30 >> 0] | 0;
 $32 = $31 & 255;
 $33 = ($32 | 0) == 3;
 $34 = $5;
 $35 = HEAP32[$34 >> 2] | 0;
 $36 = $4;
 $37 = $7;
 $38 = $8;
 $39 = $38 + 2 | 0;
 $40 = HEAP16[$39 >> 1] | 0;
 $41 = $40 & 65535;
 if ($33) {
  FUNCTION_TABLE_viiii[$35 & 1023]($36, $37, $41, 0);
  STACKTOP = sp;
  return;
 } else {
  FUNCTION_TABLE_viiii[$35 & 1023]($36, $37, $41, 1);
  STACKTOP = sp;
  return;
 }
}

function _mpn_mul_dig_add_dig($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $4;
 $8 = $10;
 $11 = $7;
 $12 = $11 & 65535;
 $9 = $12;
 while (1) {
  $13 = $5;
  $14 = $13 >>> 0 > 0;
  if (!$14) {
   break;
  }
  $15 = $4;
  $16 = HEAP16[$15 >> 1] | 0;
  $17 = $16 & 65535;
  $18 = $6;
  $19 = $18 & 65535;
  $20 = Math_imul($17, $19) | 0;
  $21 = $9;
  $22 = $21 + $20 | 0;
  $9 = $22;
  $23 = $9;
  $24 = $23 & 65535;
  $25 = $24 & 65535;
  $26 = $4;
  HEAP16[$26 >> 1] = $25;
  $27 = $9;
  $28 = $27 >>> 16;
  $9 = $28;
  $29 = $5;
  $30 = $29 + -1 | 0;
  $5 = $30;
  $31 = $4;
  $32 = $31 + 2 | 0;
  $4 = $32;
 }
 $33 = $9;
 $34 = ($33 | 0) != 0;
 if (!$34) {
  $39 = $4;
  $40 = $8;
  $41 = $39;
  $42 = $40;
  $43 = $41 - $42 | 0;
  $44 = ($43 | 0) / 2 & -1;
  STACKTOP = sp;
  return $44 | 0;
 }
 $35 = $9;
 $36 = $35 & 65535;
 $37 = $4;
 $38 = $37 + 2 | 0;
 $4 = $38;
 HEAP16[$37 >> 1] = $36;
 $39 = $4;
 $40 = $8;
 $41 = $39;
 $42 = $40;
 $43 = $41 - $42 | 0;
 $44 = ($43 | 0) / 2 & -1;
 STACKTOP = sp;
 return $44 | 0;
}

function _instance_getiter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $6 = sp + 24 | 0;
 $7 = sp + 4 | 0;
 $3 = $0;
 $4 = $1;
 $9 = $3;
 $5 = $9;
 HEAP32[$6 >> 2] = 0 | 0;
 HEAP32[$6 + 4 >> 2] = 0 | 0;
 $10 = $5;
 HEAP32[$7 >> 2] = $10;
 $11 = $7 + 4 | 0;
 HEAP32[$11 >> 2] = 19;
 $12 = $7 + 8 | 0;
 HEAP32[$12 >> 2] = 36;
 $13 = $7 + 12 | 0;
 HEAP32[$13 >> 2] = $6;
 $14 = $7 + 16 | 0;
 HEAP8[$14 >> 0] = 0;
 $15 = $5;
 $16 = HEAP32[$15 >> 2] | 0;
 _mp_obj_class_lookup($7, $16);
 $17 = HEAP32[$6 >> 2] | 0;
 $18 = ($17 | 0) == (0 | 0);
 if ($18) {
  $2 = 0;
  $34 = $2;
  STACKTOP = sp;
  return $34 | 0;
 }
 $19 = HEAP32[$6 >> 2] | 0;
 $20 = ($19 | 0) == (4 | 0);
 if ($20) {
  $21 = $5;
  $22 = $21 + 16 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = _mp_obj_get_type($23) | 0;
  $8 = $24;
  $25 = $8;
  $26 = $25 + 36 | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $28 = $5;
  $29 = $28 + 16 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = $4;
  $32 = FUNCTION_TABLE_iii[$27 & 1023]($30, $31) | 0;
  $2 = $32;
  $34 = $2;
  STACKTOP = sp;
  return $34 | 0;
 } else {
  $33 = _mp_call_method_n_kw(0, 0, $6) | 0;
  $2 = $33;
  $34 = $2;
  STACKTOP = sp;
  return $34 | 0;
 }
 return 0 | 0;
}

function _tinf_decode_symbol($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = 0;
 $6 = 0;
 $7 = 0;
 while (1) {
  $8 = $6;
  $9 = $8 << 1;
  $10 = $3;
  $11 = _tinf_getbit($10) | 0;
  $12 = $9 + $11 | 0;
  $6 = $12;
  $13 = $7;
  $14 = $13 + 1 | 0;
  $7 = $14;
  $15 = ($14 | 0) == 16;
  if ($15) {
   label = 3;
   break;
  }
  $16 = $4;
  $17 = $7;
  $18 = $16 + ($17 << 1) | 0;
  $19 = HEAP16[$18 >> 1] | 0;
  $20 = $19 & 65535;
  $21 = $5;
  $22 = $21 + $20 | 0;
  $5 = $22;
  $23 = $4;
  $24 = $7;
  $25 = $23 + ($24 << 1) | 0;
  $26 = HEAP16[$25 >> 1] | 0;
  $27 = $26 & 65535;
  $28 = $6;
  $29 = $28 - $27 | 0;
  $6 = $29;
  $30 = $6;
  $31 = ($30 | 0) >= 0;
  if (!$31) {
   label = 5;
   break;
  }
 }
 if ((label | 0) == 3) {
  $2 = -3;
  $41 = $2;
  STACKTOP = sp;
  return $41 | 0;
 } else if ((label | 0) == 5) {
  $32 = $6;
  $33 = $5;
  $34 = $33 + $32 | 0;
  $5 = $34;
  $35 = $4;
  $36 = $35 + 32 | 0;
  $37 = $5;
  $38 = $36 + ($37 << 1) | 0;
  $39 = HEAP16[$38 >> 1] | 0;
  $40 = $39 & 65535;
  $2 = $40;
  $41 = $2;
  STACKTOP = sp;
  return $41 | 0;
 }
 return 0 | 0;
}

function _mp_builtin___build_class__($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $8 = sp + 4 | 0;
 $2 = $0;
 $3 = $1;
 $10 = _mp_locals_get_1382() | 0;
 $4 = $10;
 $11 = _mp_obj_new_dict(0) | 0;
 $5 = $11;
 $12 = $5;
 _mp_locals_set_1383($12);
 $13 = $3;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = _mp_call_function_0($14) | 0;
 $6 = $15;
 $16 = $4;
 _mp_locals_set_1383($16);
 $17 = $2;
 $18 = ($17 | 0) == 2;
 if ($18) {
  $7 = 19048;
 } else {
  $19 = $3;
  $20 = $19 + 8 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  $22 = _mp_obj_get_type($21) | 0;
  $7 = $22;
 }
 $23 = $3;
 $24 = $23 + 4 | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 HEAP32[$8 >> 2] = $25;
 $26 = $2;
 $27 = $26 - 2 | 0;
 $28 = $3;
 $29 = $28 + 8 | 0;
 $30 = _mp_obj_new_tuple($27, $29) | 0;
 $31 = $8 + 4 | 0;
 HEAP32[$31 >> 2] = $30;
 $32 = $5;
 $33 = $8 + 8 | 0;
 HEAP32[$33 >> 2] = $32;
 $34 = $7;
 $35 = _mp_call_function_n_kw($34, 3, 0, $8) | 0;
 $9 = $35;
 $36 = $6;
 $37 = ($36 | 0) != (17668 | 0);
 if (!$37) {
  $40 = $9;
  STACKTOP = sp;
  return $40 | 0;
 }
 $38 = $6;
 $39 = $9;
 _mp_obj_cell_set($38, $39);
 $40 = $9;
 STACKTOP = sp;
 return $40 | 0;
}

function _decompio_read($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $11 = $5;
 $9 = $11;
 $12 = $9;
 $13 = $12 + 1292 | 0;
 $14 = HEAP8[$13 >> 0] | 0;
 $15 = $14 & 1;
 if ($15) {
  $4 = 0;
  $44 = $4;
  STACKTOP = sp;
  return $44 | 0;
 }
 $16 = $6;
 $17 = $9;
 $18 = $17 + 8 | 0;
 $19 = $18 + 24 | 0;
 HEAP32[$19 >> 2] = $16;
 $20 = $6;
 $21 = $7;
 $22 = $20 + $21 | 0;
 $23 = $9;
 $24 = $23 + 8 | 0;
 $25 = $24 + 28 | 0;
 HEAP32[$25 >> 2] = $22;
 $26 = $9;
 $27 = $26 + 8 | 0;
 $28 = _uzlib_uncompress_chksum($27) | 0;
 $10 = $28;
 $29 = $10;
 $30 = ($29 | 0) == 1;
 if ($30) {
  $31 = $9;
  $32 = $31 + 1292 | 0;
  HEAP8[$32 >> 0] = 1;
 }
 $33 = $10;
 $34 = ($33 | 0) < 0;
 if ($34) {
  $35 = $8;
  HEAP32[$35 >> 2] = 22;
  $4 = -1;
  $44 = $4;
  STACKTOP = sp;
  return $44 | 0;
 } else {
  $36 = $9;
  $37 = $36 + 8 | 0;
  $38 = $37 + 24 | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  $40 = $6;
  $41 = $39;
  $42 = $40;
  $43 = $41 - $42 | 0;
  $4 = $43;
  $44 = $4;
  STACKTOP = sp;
  return $44 | 0;
 }
 return 0 | 0;
}

function _compile_test_if_expr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $7 = $3;
 $8 = $7 + 8 | 0;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $10;
 $4 = $11;
 $12 = $2;
 $13 = _comp_next_label($12) | 0;
 $5 = $13;
 $14 = $2;
 $15 = _comp_next_label($14) | 0;
 $6 = $15;
 $16 = $2;
 $17 = $4;
 $18 = $17 + 8 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $5;
 _c_if_cond($16, $19, 0, $20);
 $21 = $2;
 $22 = $3;
 $23 = $22 + 8 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 _compile_node($21, $24);
 $25 = $2;
 $26 = $25 + 40 | 0;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = $6;
 _mp_emit_bc_jump($27, $28);
 $29 = $2;
 $30 = $29 + 40 | 0;
 $31 = HEAP32[$30 >> 2] | 0;
 $32 = $5;
 _mp_emit_bc_label_assign($31, $32);
 $33 = $2;
 $34 = $33 + 40 | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 _mp_emit_bc_adjust_stack_size($35, -1);
 $36 = $2;
 $37 = $4;
 $38 = $37 + 8 | 0;
 $39 = $38 + 4 | 0;
 $40 = HEAP32[$39 >> 2] | 0;
 _compile_node($36, $40);
 $41 = $2;
 $42 = $41 + 40 | 0;
 $43 = HEAP32[$42 >> 2] | 0;
 $44 = $6;
 _mp_emit_bc_label_assign($43, $44);
 STACKTOP = sp;
 return;
}

function _heap_siftdown($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $3;
 $10 = $9 + 12 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $5;
 $13 = $11 + ($12 << 2) | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $6 = $14;
 while (1) {
  $15 = $5;
  $16 = $4;
  $17 = $15 >>> 0 > $16 >>> 0;
  if (!$17) {
   label = 5;
   break;
  }
  $18 = $5;
  $19 = $18 - 1 | 0;
  $20 = $19 >>> 1;
  $7 = $20;
  $21 = $3;
  $22 = $21 + 12 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = $7;
  $25 = $23 + ($24 << 2) | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $8 = $26;
  $27 = $6;
  $28 = $8;
  $29 = _mp_binary_op(0, $27, $28) | 0;
  $30 = ($29 | 0) == (13864 | 0);
  if (!$30) {
   label = 5;
   break;
  }
  $31 = $8;
  $32 = $3;
  $33 = $32 + 12 | 0;
  $34 = HEAP32[$33 >> 2] | 0;
  $35 = $5;
  $36 = $34 + ($35 << 2) | 0;
  HEAP32[$36 >> 2] = $31;
  $37 = $7;
  $5 = $37;
 }
 if ((label | 0) == 5) {
  $38 = $6;
  $39 = $3;
  $40 = $39 + 12 | 0;
  $41 = HEAP32[$40 >> 2] | 0;
  $42 = $5;
  $43 = $41 + ($42 << 2) | 0;
  HEAP32[$43 >> 2] = $38;
  STACKTOP = sp;
  return;
 }
}

function _uctypes_struct_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $10 = $4;
 $5 = $10;
 $11 = $3;
 $cond = ($11 | 0) == 8;
 if ($cond) {
  $12 = $5;
  $13 = $12 + 4 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = _mp_obj_is_obj_1471($14) | 0;
  if ($15) {
   $16 = $5;
   $17 = $16 + 4 | 0;
   $18 = HEAP32[$17 >> 2] | 0;
   $19 = HEAP32[$18 >> 2] | 0;
   $20 = ($19 | 0) == (18952 | 0);
   if ($20) {
    $21 = $5;
    $22 = $21 + 4 | 0;
    $23 = HEAP32[$22 >> 2] | 0;
    $6 = $23;
    $24 = $6;
    $25 = $24 + 8 | 0;
    $26 = HEAP32[$25 >> 2] | 0;
    $27 = $26;
    $28 = $27 >> 1;
    $7 = $28;
    $29 = $7;
    $30 = $29 >> 29;
    $31 = $30 & 3;
    $8 = $31;
    $32 = $8;
    $33 = ($32 | 0) == 1;
    if ($33) {
     $34 = $5;
     $35 = $34 + 8 | 0;
     $36 = HEAP32[$35 >> 2] | 0;
     $37 = HEAP32[$36 >> 2] | 0;
     $9 = $37;
     $38 = $9;
     $39 = $38;
     $40 = _mp_obj_new_int($39) | 0;
     $2 = $40;
     $41 = $2;
     STACKTOP = sp;
     return $41 | 0;
    }
   }
  }
 }
 $2 = 0;
 $41 = $2;
 STACKTOP = sp;
 return $41 | 0;
}

function _module_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, $vararg_ptr1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $4;
 $6 = $9;
 $7 = 41653;
 $10 = $6;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $12 + 4 | 0;
 $14 = _mp_map_lookup($13, 94, 0) | 0;
 $8 = $14;
 $15 = $8;
 $16 = ($15 | 0) != (0 | 0);
 if ($16) {
  $17 = $8;
  $18 = $17 + 4 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = _mp_obj_str_get_str($19) | 0;
  $7 = $20;
 }
 $21 = $6;
 $22 = $21 + 4 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $23 + 4 | 0;
 $25 = _mp_map_lookup($24, 722, 0) | 0;
 $8 = $25;
 $26 = $8;
 $27 = ($26 | 0) != (0 | 0);
 $28 = $3;
 $29 = $7;
 if ($27) {
  $30 = $8;
  $31 = $30 + 4 | 0;
  $32 = HEAP32[$31 >> 2] | 0;
  $33 = _mp_obj_str_get_str($32) | 0;
  HEAP32[$vararg_buffer >> 2] = $29;
  $vararg_ptr1 = $vararg_buffer + 4 | 0;
  HEAP32[$vararg_ptr1 >> 2] = $33;
  _mp_printf($28, 31527, $vararg_buffer) | 0;
  STACKTOP = sp;
  return;
 } else {
  HEAP32[$vararg_buffer2 >> 2] = $29;
  _mp_printf($28, 31551, $vararg_buffer2) | 0;
  STACKTOP = sp;
  return;
 }
}

function _vstr_cut_out_bytes($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $4;
 $7 = $3;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $6 >>> 0 >= $9 >>> 0;
 if ($10) {
  STACKTOP = sp;
  return;
 }
 $11 = $4;
 $12 = $5;
 $13 = $11 + $12 | 0;
 $14 = $3;
 $15 = $14 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $13 >>> 0 >= $16 >>> 0;
 if ($17) {
  $18 = $4;
  $19 = $3;
  $20 = $19 + 4 | 0;
  HEAP32[$20 >> 2] = $18;
  STACKTOP = sp;
  return;
 } else {
  $21 = $3;
  $22 = $21 + 8 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = $4;
  $25 = $23 + $24 | 0;
  $26 = $3;
  $27 = $26 + 8 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = $4;
  $30 = $28 + $29 | 0;
  $31 = $5;
  $32 = $30 + $31 | 0;
  $33 = $3;
  $34 = $33 + 4 | 0;
  $35 = HEAP32[$34 >> 2] | 0;
  $36 = $4;
  $37 = $35 - $36 | 0;
  $38 = $5;
  $39 = $37 - $38 | 0;
  _memmove($25 | 0, $32 | 0, $39 | 0) | 0;
  $40 = $5;
  $41 = $3;
  $42 = $41 + 4 | 0;
  $43 = HEAP32[$42 >> 2] | 0;
  $44 = $43 - $40 | 0;
  HEAP32[$42 >> 2] = $44;
  STACKTOP = sp;
  return;
 }
}

function _vsnprintf($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $$0 = 0, $$014 = 0, $$015 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $spec$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 160 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(160 | 0);
 $4 = sp + 144 | 0;
 $5 = sp;
 _memcpy($5 | 0, 11136 | 0, 144) | 0;
 $6 = $1 + -1 | 0;
 $7 = $6 >>> 0 > 2147483646;
 if ($7) {
  $8 = ($1 | 0) == 0;
  if ($8) {
   $$014 = $4;
   $$015 = 1;
   label = 4;
  } else {
   $9 = ___errno_location() | 0;
   HEAP32[$9 >> 2] = 75;
   $$0 = -1;
  }
 } else {
  $$014 = $0;
  $$015 = $1;
  label = 4;
 }
 if ((label | 0) == 4) {
  $10 = $$014;
  $11 = -2 - $10 | 0;
  $12 = $$015 >>> 0 > $11 >>> 0;
  $spec$select = $12 ? $11 : $$015;
  $13 = $5 + 48 | 0;
  HEAP32[$13 >> 2] = $spec$select;
  $14 = $5 + 20 | 0;
  HEAP32[$14 >> 2] = $$014;
  $15 = $5 + 44 | 0;
  HEAP32[$15 >> 2] = $$014;
  $16 = $$014 + $spec$select | 0;
  $17 = $5 + 16 | 0;
  HEAP32[$17 >> 2] = $16;
  $18 = $5 + 28 | 0;
  HEAP32[$18 >> 2] = $16;
  $19 = _vfprintf($5, $2, $3) | 0;
  $20 = ($spec$select | 0) == 0;
  if ($20) {
   $$0 = $19;
  } else {
   $21 = HEAP32[$14 >> 2] | 0;
   $22 = HEAP32[$17 >> 2] | 0;
   $23 = ($21 | 0) == ($22 | 0);
   $24 = $23 << 31 >> 31;
   $25 = $21 + $24 | 0;
   HEAP8[$25 >> 0] = 0;
   $$0 = $19;
  }
 }
 STACKTOP = sp;
 return $$0 | 0;
}

function _float_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0.0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0, $22 = 0.0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0.0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $4;
 $7 = +_mp_obj_float_get($6);
 $5 = $7;
 $8 = $3;
 L1 : do {
  switch ($8 | 0) {
  case 4:
   {
    $9 = $5;
    $10 = $9 != 0.0;
    $11 = $10 & 1;
    $12 = _mp_obj_new_bool_971($11) | 0;
    $2 = $12;
    break;
   }
  case 6:
   {
    $13 = $5;
    $14 = _mp_float_hash_972($13) | 0;
    $15 = $14 << 1;
    $16 = $15 | 1;
    $17 = $16;
    $2 = $17;
    break;
   }
  case 0:
   {
    $18 = $4;
    $2 = $18;
    break;
   }
  case 1:
   {
    $19 = $5;
    $20 = -$19;
    $21 = _mp_obj_new_float($20) | 0;
    $2 = $21;
    break;
   }
  case 7:
   {
    $22 = $5;
    $23 = ___DOUBLE_BITS_968($22) | 0;
    $24 = getTempRet0() | 0;
    $25 = _bitshift64Lshr($23 | 0, $24 | 0, 63) | 0;
    $26 = getTempRet0() | 0;
    $27 = ($25 | 0) != 0;
    if ($27) {
     $28 = $5;
     $29 = -$28;
     $30 = _mp_obj_new_float($29) | 0;
     $2 = $30;
     break L1;
    } else {
     $31 = $4;
     $2 = $31;
     break L1;
    }
    break;
   }
  default:
   {
    $2 = 0;
   }
  }
 } while (0);
 $32 = $2;
 STACKTOP = sp;
 return $32 | 0;
}

function _strlen($0) {
 $0 = $0 | 0;
 var $$0 = 0, $$014 = 0, $$015$lcssa = 0, $$01518 = 0, $$1$lcssa = 0, $$pn = 0, $$pn29 = 0, $$pre = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = $0;
 $2 = $1 & 3;
 $3 = ($2 | 0) == 0;
 L1 : do {
  if ($3) {
   $$015$lcssa = $0;
   label = 5;
  } else {
   $$01518 = $0;
   $22 = $1;
   while (1) {
    $4 = HEAP8[$$01518 >> 0] | 0;
    $5 = $4 << 24 >> 24 == 0;
    if ($5) {
     $$pn = $22;
     break L1;
    }
    $6 = $$01518 + 1 | 0;
    $7 = $6;
    $8 = $7 & 3;
    $9 = ($8 | 0) == 0;
    if ($9) {
     $$015$lcssa = $6;
     label = 5;
     break;
    } else {
     $$01518 = $6;
     $22 = $7;
    }
   }
  }
 } while (0);
 if ((label | 0) == 5) {
  $$0 = $$015$lcssa;
  while (1) {
   $10 = HEAP32[$$0 >> 2] | 0;
   $11 = $10 + -16843009 | 0;
   $12 = $10 & -2139062144;
   $13 = $12 ^ -2139062144;
   $14 = $13 & $11;
   $15 = ($14 | 0) == 0;
   $16 = $$0 + 4 | 0;
   if ($15) {
    $$0 = $16;
   } else {
    break;
   }
  }
  $17 = $10 & 255;
  $18 = $17 << 24 >> 24 == 0;
  if ($18) {
   $$1$lcssa = $$0;
  } else {
   $$pn29 = $$0;
   while (1) {
    $19 = $$pn29 + 1 | 0;
    $$pre = HEAP8[$19 >> 0] | 0;
    $20 = $$pre << 24 >> 24 == 0;
    if ($20) {
     $$1$lcssa = $19;
     break;
    } else {
     $$pn29 = $19;
    }
   }
  }
  $21 = $$1$lcssa;
  $$pn = $21;
 }
 $$014 = $$pn - $1 | 0;
 return $$014 | 0;
}

function _float_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0.0, $33 = 0, $34 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $9 = sp;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $6;
 $11 = $7;
 _mp_arg_check_num_973($10, $11, 0, 1, 0);
 $12 = $6;
 $cond = ($12 | 0) == 0;
 if ($cond) {
  $13 = _mp_obj_new_float(0.0) | 0;
  $4 = $13;
  $34 = $4;
  STACKTOP = sp;
  return $34 | 0;
 }
 $14 = $8;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = _mp_get_buffer($15, $9, 1) | 0;
 if ($16) {
  $17 = HEAP32[$9 >> 2] | 0;
  $18 = $9 + 4 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = _mp_parse_num_decimal($17, $19, 0, 0, 0) | 0;
  $4 = $20;
  $34 = $4;
  STACKTOP = sp;
  return $34 | 0;
 }
 $21 = $8;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = _mp_obj_is_obj_963($22) | 0;
 if ($23) {
  $24 = $8;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = ($26 | 0) == (16252 | 0);
  if ($27) {
   $28 = $8;
   $29 = HEAP32[$28 >> 2] | 0;
   $4 = $29;
   $34 = $4;
   STACKTOP = sp;
   return $34 | 0;
  }
 }
 $30 = $8;
 $31 = HEAP32[$30 >> 2] | 0;
 $32 = +_mp_obj_get_float($31);
 $33 = _mp_obj_new_float($32) | 0;
 $4 = $33;
 $34 = $4;
 STACKTOP = sp;
 return $34 | 0;
}

function _gen_wrap_call($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $12 = $4;
 $8 = $12;
 $13 = $8;
 $14 = $13 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = _mp_decode_uint_value($15) | 0;
 $9 = $16;
 $17 = $8;
 $18 = $17 + 8 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = _mp_decode_uint_skip($19) | 0;
 $21 = _mp_decode_uint_value($20) | 0;
 $10 = $21;
 $22 = $9;
 $23 = $22 << 2;
 $24 = $10;
 $25 = $24 * 12 | 0;
 $26 = $23 + $25 | 0;
 $27 = $26;
 $28 = 28 + $27 | 0;
 $29 = _m_malloc($28) | 0;
 $11 = $29;
 $30 = $11;
 HEAP32[$30 >> 2] = 16732;
 $31 = $8;
 $32 = $31 + 4 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = $11;
 $35 = $34 + 4 | 0;
 HEAP32[$35 >> 2] = $33;
 $36 = $8;
 $37 = $11;
 $38 = $37 + 8 | 0;
 HEAP32[$38 >> 2] = $36;
 $39 = $11;
 $40 = $39 + 8 | 0;
 $41 = $40 + 4 | 0;
 HEAP32[$41 >> 2] = 0;
 $42 = $11;
 $43 = $42 + 8 | 0;
 $44 = $5;
 $45 = $6;
 $46 = $7;
 _mp_setup_code_state($43, $44, $45, $46);
 $47 = $11;
 STACKTOP = sp;
 return $47 | 0;
}

function _str_caseconv($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = sp + 24 | 0;
 $6 = sp + 8 | 0;
 $2 = $0;
 $3 = $1;
 $9 = $3;
 $10 = _mp_obj_is_qstr_1128($9) | 0;
 $11 = $3;
 if ($10) {
  $12 = $11;
  $13 = $12 >>> 2;
  $14 = _qstr_data($13, $5) | 0;
  $4 = $14;
 } else {
  $15 = $11 + 8 | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  HEAP32[$5 >> 2] = $16;
  $17 = $3;
  $18 = $17 + 12 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $4 = $19;
 }
 $20 = HEAP32[$5 >> 2] | 0;
 _vstr_init_len($6, $20);
 $21 = $6 + 8 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $7 = $22;
 $8 = 0;
 while (1) {
  $23 = $8;
  $24 = HEAP32[$5 >> 2] | 0;
  $25 = $23 >>> 0 < $24 >>> 0;
  if (!$25) {
   break;
  }
  $26 = $2;
  $27 = $4;
  $28 = $27 + 1 | 0;
  $4 = $28;
  $29 = HEAP8[$27 >> 0] | 0;
  $30 = $29 & 255;
  $31 = FUNCTION_TABLE_ii[$26 & 1023]($30) | 0;
  $32 = $31 & 255;
  $33 = $7;
  $34 = $33 + 1 | 0;
  $7 = $34;
  HEAP8[$33 >> 0] = $32;
  $35 = $8;
  $36 = $35 + 1 | 0;
  $8 = $36;
 }
 $37 = $3;
 $38 = _mp_obj_get_type($37) | 0;
 $39 = _mp_obj_new_str_from_vstr($38, $6) | 0;
 STACKTOP = sp;
 return $39 | 0;
}

function _scope_new_and_link($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $5;
 $11 = $6;
 $12 = $4;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $7;
 $15 = _scope_new($10, $11, $13, $14) | 0;
 $8 = $15;
 $16 = $4;
 $17 = $16 + 36 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $8;
 $20 = $19 + 4 | 0;
 HEAP32[$20 >> 2] = $18;
 $21 = $8;
 $22 = $21 + 8 | 0;
 HEAP32[$22 >> 2] = 0;
 $23 = $4;
 $24 = $23 + 32 | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = ($25 | 0) == (0 | 0);
 if ($26) {
  $27 = $8;
  $28 = $4;
  $29 = $28 + 32 | 0;
  HEAP32[$29 >> 2] = $27;
  $43 = $8;
  STACKTOP = sp;
  return $43 | 0;
 }
 $30 = $4;
 $31 = $30 + 32 | 0;
 $32 = HEAP32[$31 >> 2] | 0;
 $9 = $32;
 while (1) {
  $33 = $9;
  $34 = $33 + 8 | 0;
  $35 = HEAP32[$34 >> 2] | 0;
  $36 = ($35 | 0) != (0 | 0);
  if (!$36) {
   break;
  }
  $37 = $9;
  $38 = $37 + 8 | 0;
  $39 = HEAP32[$38 >> 2] | 0;
  $9 = $39;
 }
 $40 = $8;
 $41 = $9;
 $42 = $41 + 8 | 0;
 HEAP32[$42 >> 2] = $40;
 $43 = $8;
 STACKTOP = sp;
 return $43 | 0;
}

function _list_reverse($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $1 = $0;
 $6 = $1;
 $2 = $6;
 $7 = $2;
 $8 = $7 + 8 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $3 = $9;
 $4 = 0;
 while (1) {
  $10 = $4;
  $11 = $3;
  $12 = ($11 | 0) / 2 & -1;
  $13 = ($10 | 0) < ($12 | 0);
  if (!$13) {
   break;
  }
  $14 = $2;
  $15 = $14 + 12 | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  $17 = $4;
  $18 = $16 + ($17 << 2) | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $5 = $19;
  $20 = $2;
  $21 = $20 + 12 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $3;
  $24 = $4;
  $25 = $23 - $24 | 0;
  $26 = $25 - 1 | 0;
  $27 = $22 + ($26 << 2) | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = $2;
  $30 = $29 + 12 | 0;
  $31 = HEAP32[$30 >> 2] | 0;
  $32 = $4;
  $33 = $31 + ($32 << 2) | 0;
  HEAP32[$33 >> 2] = $28;
  $34 = $5;
  $35 = $2;
  $36 = $35 + 12 | 0;
  $37 = HEAP32[$36 >> 2] | 0;
  $38 = $3;
  $39 = $4;
  $40 = $38 - $39 | 0;
  $41 = $40 - 1 | 0;
  $42 = $37 + ($41 << 2) | 0;
  HEAP32[$42 >> 2] = $34;
  $43 = $4;
  $44 = $43 + 1 | 0;
  $4 = $44;
 }
 STACKTOP = sp;
 return 17668 | 0;
}

function _vstr_ins_blank_bytes($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $6 = $9;
 $10 = $4;
 $11 = $6;
 $12 = $10 >>> 0 > $11 >>> 0;
 if ($12) {
  $13 = $6;
  $4 = $13;
 }
 $14 = $5;
 $15 = $14 >>> 0 > 0;
 if (!$15) {
  $38 = $3;
  $39 = $38 + 8 | 0;
  $40 = HEAP32[$39 >> 2] | 0;
  $41 = $4;
  $42 = $40 + $41 | 0;
  STACKTOP = sp;
  return $42 | 0;
 }
 $16 = $3;
 $17 = $5;
 _vstr_ensure_extra($16, $17);
 $18 = $3;
 $19 = $18 + 8 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = $4;
 $22 = $20 + $21 | 0;
 $23 = $5;
 $24 = $22 + $23 | 0;
 $25 = $3;
 $26 = $25 + 8 | 0;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = $4;
 $29 = $27 + $28 | 0;
 $30 = $6;
 $31 = $4;
 $32 = $30 - $31 | 0;
 _memmove($24 | 0, $29 | 0, $32 | 0) | 0;
 $33 = $5;
 $34 = $3;
 $35 = $34 + 4 | 0;
 $36 = HEAP32[$35 >> 2] | 0;
 $37 = $36 + $33 | 0;
 HEAP32[$35 >> 2] = $37;
 $38 = $3;
 $39 = $38 + 8 | 0;
 $40 = HEAP32[$39 >> 2] | 0;
 $41 = $4;
 $42 = $40 + $41 | 0;
 STACKTOP = sp;
 return $42 | 0;
}

function _compile_built_in_decorator($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$expand_i1_val4 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = sp + 20 | 0;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $7;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $11 >>> 4;
 $13 = ($12 | 0) != 115;
 do {
  if ($13) {
   $$expand_i1_val = 0;
   HEAP8[$4 >> 0] = $$expand_i1_val;
  } else {
   $14 = $6;
   $15 = ($14 | 0) != 2;
   if ($15) {
    $16 = $5;
    $17 = $7;
    $18 = HEAP32[$17 >> 2] | 0;
    _compile_syntax_error($16, $18, 29429);
    $$expand_i1_val2 = 1;
    HEAP8[$4 >> 0] = $$expand_i1_val2;
    break;
   }
   $19 = $7;
   $20 = $19 + 4 | 0;
   $21 = HEAP32[$20 >> 2] | 0;
   $22 = $21 >>> 4;
   $9 = $22;
   $23 = $9;
   $24 = ($23 | 0) == 65;
   if ($24) {
    $25 = $8;
    HEAP32[$25 >> 2] = 1;
   } else {
    $26 = $5;
    $27 = $7;
    $28 = $27 + 4 | 0;
    $29 = HEAP32[$28 >> 2] | 0;
    _compile_syntax_error($26, $29, 29429);
   }
   $$expand_i1_val4 = 1;
   HEAP8[$4 >> 0] = $$expand_i1_val4;
  }
 } while (0);
 $$pre_trunc = HEAP8[$4 >> 0] | 0;
 $30 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $30 | 0;
}

function _rgb565_fill_rect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 $14 = $6;
 $15 = $14 + 8 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $7;
 $18 = $8;
 $19 = $6;
 $20 = $19 + 16 | 0;
 $21 = HEAP16[$20 >> 1] | 0;
 $22 = $21 & 65535;
 $23 = Math_imul($18, $22) | 0;
 $24 = $17 + $23 | 0;
 $25 = $16 + ($24 << 1) | 0;
 $12 = $25;
 while (1) {
  $26 = $10;
  $27 = $26 + -1 | 0;
  $10 = $27;
  $28 = ($26 | 0) != 0;
  if (!$28) {
   break;
  }
  $29 = $9;
  $13 = $29;
  while (1) {
   $30 = $13;
   $31 = ($30 | 0) != 0;
   if (!$31) {
    break;
   }
   $32 = $11;
   $33 = $32 & 65535;
   $34 = $12;
   $35 = $34 + 2 | 0;
   $12 = $35;
   HEAP16[$34 >> 1] = $33;
   $36 = $13;
   $37 = $36 + -1 | 0;
   $13 = $37;
  }
  $38 = $6;
  $39 = $38 + 16 | 0;
  $40 = HEAP16[$39 >> 1] | 0;
  $41 = $40 & 65535;
  $42 = $9;
  $43 = $41 - $42 | 0;
  $44 = $12;
  $45 = $44 + ($43 << 1) | 0;
  $12 = $45;
 }
 STACKTOP = sp;
 return;
}

function _compile_or_and_test($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $8 = $3;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $10 & 255;
 $12 = ($11 | 0) == 29;
 $13 = $12 & 1;
 $4 = $13;
 $14 = $2;
 $15 = _comp_next_label($14) | 0;
 $5 = $15;
 $16 = $3;
 $17 = $16 + 4 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $18 >>> 8;
 $6 = $19;
 $7 = 0;
 while (1) {
  $20 = $7;
  $21 = $6;
  $22 = ($20 | 0) < ($21 | 0);
  $23 = $2;
  if (!$22) {
   break;
  }
  $24 = $3;
  $25 = $24 + 8 | 0;
  $26 = $7;
  $27 = $25 + ($26 << 2) | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  _compile_node($23, $28);
  $29 = $7;
  $30 = $29 + 1 | 0;
  $31 = $6;
  $32 = ($30 | 0) < ($31 | 0);
  if ($32) {
   $33 = $2;
   $34 = $33 + 40 | 0;
   $35 = HEAP32[$34 >> 2] | 0;
   $36 = $4;
   $37 = $36 & 1;
   $38 = $5;
   _mp_emit_bc_jump_if_or_pop($35, $37, $38);
  }
  $39 = $7;
  $40 = $39 + 1 | 0;
  $7 = $40;
 }
 $41 = $23 + 40 | 0;
 $42 = HEAP32[$41 >> 2] | 0;
 $43 = $5;
 _mp_emit_bc_label_assign($42, $43);
 STACKTOP = sp;
 return;
}

function _mpz_shl_inpl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $4;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) == 0;
 $10 = $5;
 $11 = ($10 | 0) == 0;
 $or$cond = $9 | $11;
 $12 = $3;
 $13 = $4;
 if ($or$cond) {
  _mpz_set($12, $13);
  STACKTOP = sp;
  return;
 } else {
  $14 = $13 + 4 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $5;
  $17 = $16 + 16 | 0;
  $18 = $17 - 1 | 0;
  $19 = ($18 >>> 0) / 16 & -1;
  $20 = $15 + $19 | 0;
  _mpz_need_dig($12, $20);
  $21 = $3;
  $22 = $21 + 8 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = $4;
  $25 = $24 + 8 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $4;
  $28 = $27 + 4 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  $30 = $5;
  $31 = _mpn_shl($23, $26, $29, $30) | 0;
  $32 = $3;
  $33 = $32 + 4 | 0;
  HEAP32[$33 >> 2] = $31;
  $34 = $4;
  $35 = HEAP32[$34 >> 2] | 0;
  $36 = $35 & 1;
  $37 = $3;
  $38 = HEAP32[$37 >> 2] | 0;
  $39 = $36 & 1;
  $40 = $38 & -2;
  $41 = $40 | $39;
  HEAP32[$37 >> 2] = $41;
  STACKTOP = sp;
  return;
 }
}

function _mp_obj_instance_call($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer = sp;
 $9 = sp + 16 | 0;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 HEAP32[$9 >> 2] = 0 | 0;
 HEAP32[$9 + 4 >> 2] = 0 | 0;
 $12 = $5;
 $13 = _mp_obj_instance_get_call($12, $9) | 0;
 $10 = $13;
 $14 = $10;
 $15 = ($14 | 0) == (0 | 0);
 $16 = $5;
 if ($15) {
  $17 = _mp_obj_get_type_str($16) | 0;
  HEAP32[$vararg_buffer >> 2] = $17;
  $18 = _mp_obj_new_exception_msg_varg(16012, 33260, $vararg_buffer) | 0;
  _nlr_jump($18);
 }
 $11 = $16;
 $19 = $10;
 $20 = ($19 | 0) == (4 | 0);
 if ($20) {
  $21 = $11;
  $22 = $21 + 16 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = $6;
  $25 = $7;
  $26 = $8;
  $27 = _mp_call_function_n_kw($23, $24, $25, $26) | 0;
  $4 = $27;
  $35 = $4;
  STACKTOP = sp;
  return $35 | 0;
 } else {
  $28 = HEAP32[$9 >> 2] | 0;
  $29 = $9 + 4 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = $6;
  $32 = $7;
  $33 = $8;
  $34 = _mp_call_method_self_n_kw($28, $30, $31, $32, $33) | 0;
  $4 = $34;
  $35 = $4;
  STACKTOP = sp;
  return $35 | 0;
 }
 return 0 | 0;
}

function _mp_obj_tuple_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $4;
 $6 = $8;
 $9 = $5;
 $10 = ($9 | 0) == 3;
 $11 = $3;
 if ($10) {
  _mp_print_str($11, 32983) | 0;
 } else {
  _mp_print_str($11, 32985) | 0;
  $5 = 1;
 }
 $7 = 0;
 while (1) {
  $12 = $7;
  $13 = $6;
  $14 = $13 + 4 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $12 >>> 0 < $15 >>> 0;
  if (!$16) {
   break;
  }
  $17 = $7;
  $18 = $17 >>> 0 > 0;
  if ($18) {
   $19 = $3;
   _mp_print_str($19, 33327) | 0;
  }
  $20 = $3;
  $21 = $6;
  $22 = $21 + 8 | 0;
  $23 = $7;
  $24 = $22 + ($23 << 2) | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = $5;
  _mp_obj_print_helper($20, $25, $26);
  $27 = $7;
  $28 = $27 + 1 | 0;
  $7 = $28;
 }
 $29 = $5;
 $30 = ($29 | 0) == 3;
 if ($30) {
  $31 = $3;
  _mp_print_str($31, 32987) | 0;
  STACKTOP = sp;
  return;
 }
 $32 = $6;
 $33 = $32 + 4 | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = ($34 | 0) == 1;
 if ($35) {
  $36 = $3;
  _mp_print_str($36, 32989) | 0;
 }
 $37 = $3;
 _mp_print_str($37, 32991) | 0;
 STACKTOP = sp;
 return;
}

function _mono_horiz_setpixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $5;
 $11 = $6;
 $12 = $4;
 $13 = $12 + 16 | 0;
 $14 = HEAP16[$13 >> 1] | 0;
 $15 = $14 & 65535;
 $16 = Math_imul($11, $15) | 0;
 $17 = $10 + $16 | 0;
 $18 = $17 >> 3;
 $8 = $18;
 $19 = $4;
 $20 = $19 + 18 | 0;
 $21 = HEAP8[$20 >> 0] | 0;
 $22 = $21 & 255;
 $23 = ($22 | 0) == 4;
 $24 = $5;
 $25 = $24 & 7;
 $26 = 7 - $25 | 0;
 $27 = $23 ? $25 : $26;
 $9 = $27;
 $28 = $4;
 $29 = $28 + 8 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = $8;
 $32 = $30 + $31 | 0;
 $33 = HEAP8[$32 >> 0] | 0;
 $34 = $33 & 255;
 $35 = $9;
 $36 = 1 << $35;
 $37 = $36 ^ -1;
 $38 = $34 & $37;
 $39 = $7;
 $40 = ($39 | 0) != 0;
 $41 = $40 & 1;
 $42 = $9;
 $43 = $41 << $42;
 $44 = $38 | $43;
 $45 = $44 & 255;
 $46 = $4;
 $47 = $46 + 8 | 0;
 $48 = HEAP32[$47 >> 2] | 0;
 $49 = $8;
 $50 = $48 + $49 | 0;
 HEAP8[$50 >> 0] = $45;
 STACKTOP = sp;
 return;
}

function _compile_try_finally($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 $13 = $6;
 $14 = _comp_next_label($13) | 0;
 $12 = $14;
 $15 = $6;
 $16 = $12;
 _compile_increase_except_level($15, $16, 3);
 $17 = $8;
 $18 = ($17 | 0) == 0;
 $19 = $6;
 if ($18) {
  $20 = $19 + 40 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  _mp_emit_bc_adjust_stack_size($21, 3);
  $22 = $6;
  $23 = $7;
  _compile_node($22, $23);
  $24 = $6;
  $25 = $24 + 40 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  _mp_emit_bc_adjust_stack_size($26, -3);
 } else {
  $27 = $7;
  $28 = $8;
  $29 = $9;
  $30 = $10;
  _compile_try_except($19, $27, $28, $29, $30);
 }
 $31 = $6;
 $32 = $31 + 40 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 _mp_emit_bc_load_const_tok($33, 14);
 $34 = $6;
 $35 = $34 + 40 | 0;
 $36 = HEAP32[$35 >> 2] | 0;
 $37 = $12;
 _mp_emit_bc_label_assign($36, $37);
 $38 = $6;
 $39 = $11;
 _compile_node($38, $39);
 $40 = $6;
 _compile_decrease_except_level($40);
 STACKTOP = sp;
 return;
}

function _set_diff_int($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $3 = $0;
 $4 = $1;
 $12 = $2 & 1;
 $5 = $12;
 $13 = $5;
 $14 = $13 & 1;
 $15 = $4;
 $16 = HEAP32[$15 >> 2] | 0;
 if ($14) {
  $6 = $16;
 } else {
  $17 = _set_copy($16) | 0;
  $6 = $17;
 }
 $7 = 1;
 while (1) {
  $18 = $7;
  $19 = $3;
  $20 = $18 >>> 0 < $19 >>> 0;
  if (!$20) {
   break;
  }
  $21 = $4;
  $22 = $7;
  $23 = $21 + ($22 << 2) | 0;
  $24 = HEAP32[$23 >> 2] | 0;
  $8 = $24;
  $25 = $6;
  $26 = $8;
  $27 = ($25 | 0) == ($26 | 0);
  $28 = $6;
  L8 : do {
   if ($27) {
    _set_clear($28) | 0;
   } else {
    $29 = $28 + 4 | 0;
    $9 = $29;
    $30 = $8;
    $31 = _mp_getiter($30, 0) | 0;
    $10 = $31;
    while (1) {
     $32 = $10;
     $33 = _mp_iternext($32) | 0;
     $11 = $33;
     $34 = ($33 | 0) != (0 | 0);
     if (!$34) {
      break L8;
     }
     $35 = $9;
     $36 = $11;
     _mp_set_lookup($35, $36, 2) | 0;
    }
   }
  } while (0);
  $37 = $7;
  $38 = $37 + 1 | 0;
  $7 = $38;
 }
 $39 = $6;
 STACKTOP = sp;
 return $39 | 0;
}

function _mp_obj_get_int_maybe($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $3;
 $6 = ($5 | 0) == (13856 | 0);
 do {
  if ($6) {
   $7 = $4;
   HEAP32[$7 >> 2] = 0;
  } else {
   $8 = $3;
   $9 = ($8 | 0) == (13864 | 0);
   if ($9) {
    $10 = $4;
    HEAP32[$10 >> 2] = 1;
    break;
   }
   $11 = $3;
   $12 = _mp_obj_is_small_int_784($11) | 0;
   $13 = $3;
   if ($12) {
    $14 = $13;
    $15 = $14 >> 1;
    $16 = $4;
    HEAP32[$16 >> 2] = $15;
    break;
   }
   $17 = _mp_obj_is_obj_786($13) | 0;
   if ($17) {
    $18 = $3;
    $19 = HEAP32[$18 >> 2] | 0;
    $20 = ($19 | 0) == (16904 | 0);
    if ($20) {
     $21 = $3;
     $22 = _mp_obj_int_get_checked($21) | 0;
     $23 = $4;
     HEAP32[$23 >> 2] = $22;
     break;
    }
   }
   $$expand_i1_val = 0;
   HEAP8[$2 >> 0] = $$expand_i1_val;
   $$pre_trunc = HEAP8[$2 >> 0] | 0;
   $24 = $$pre_trunc & 1;
   STACKTOP = sp;
   return $24 | 0;
  }
 } while (0);
 $$expand_i1_val2 = 1;
 HEAP8[$2 >> 0] = $$expand_i1_val2;
 $$pre_trunc = HEAP8[$2 >> 0] | 0;
 $24 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $24 | 0;
}

function _scalbn($0, $1) {
 $0 = +$0;
 $1 = $1 | 0;
 var $$0 = 0.0, $$020 = 0, $10 = 0.0, $11 = 0, $12 = 0, $13 = 0.0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0.0, $2 = 0, $20 = 0.0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0, $8 = 0, $9 = 0, $spec$select = 0, $spec$select21 = 0.0, $spec$select22 = 0, $spec$select23 = 0.0, $spec$store$select = 0, $spec$store$select1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = ($1 | 0) > 1023;
 if ($2) {
  $3 = $0 * 8988465674311579538646525.0e283;
  $4 = $1 + -1023 | 0;
  $5 = ($1 | 0) > 2046;
  $6 = $3 * 8988465674311579538646525.0e283;
  $7 = $1 + -2046 | 0;
  $8 = ($7 | 0) < 1023;
  $spec$store$select = $8 ? $7 : 1023;
  $spec$select = $5 ? $spec$store$select : $4;
  $spec$select21 = $5 ? $6 : $3;
  $$0 = $spec$select21;
  $$020 = $spec$select;
 } else {
  $9 = ($1 | 0) < -1022;
  if ($9) {
   $10 = $0 * 2.2250738585072014e-308;
   $11 = $1 + 1022 | 0;
   $12 = ($1 | 0) < -2044;
   $13 = $10 * 2.2250738585072014e-308;
   $14 = $1 + 2044 | 0;
   $15 = ($14 | 0) > -1022;
   $spec$store$select1 = $15 ? $14 : -1022;
   $spec$select22 = $12 ? $spec$store$select1 : $11;
   $spec$select23 = $12 ? $13 : $10;
   $$0 = $spec$select23;
   $$020 = $spec$select22;
  } else {
   $$0 = $0;
   $$020 = $1;
  }
 }
 $16 = $$020 + 1023 | 0;
 $17 = _bitshift64Shl($16 | 0, 0, 52) | 0;
 $18 = getTempRet0() | 0;
 HEAP32[tempDoublePtr >> 2] = $17;
 HEAP32[tempDoublePtr + 4 >> 2] = $18;
 $19 = +HEAPF64[tempDoublePtr >> 3];
 $20 = $$0 * $19;
 return +$20;
}

function _mp_obj_exception_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $6 = $7;
 $8 = $5;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) != (0 | 0);
 $11 = $4;
 if ($10) {
  $12 = ($11 | 0) == 202;
  if (!$12) {
   STACKTOP = sp;
   return;
  }
  $13 = $5;
  $14 = $13 + 4 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = ($15 | 0) == (17668 | 0);
  if (!$16) {
   STACKTOP = sp;
   return;
  }
  $17 = $6;
  $18 = $17 + 4 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = $19 & 65535;
  HEAP32[$18 >> 2] = $20;
  $21 = $5;
  HEAP32[$21 >> 2] = 0;
  STACKTOP = sp;
  return;
 }
 $22 = ($11 | 0) == 61;
 $23 = $6;
 if ($22) {
  $24 = $23 + 12 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = $5;
  HEAP32[$26 >> 2] = $25;
  STACKTOP = sp;
  return;
 }
 $27 = HEAP32[$23 >> 2] | 0;
 $28 = ($27 | 0) == (14676 | 0);
 $29 = $4;
 $30 = ($29 | 0) == 162;
 $or$cond = $28 & $30;
 if (!$or$cond) {
  STACKTOP = sp;
  return;
 }
 $31 = $3;
 $32 = _mp_obj_exception_get_value($31) | 0;
 $33 = $5;
 HEAP32[$33 >> 2] = $32;
 STACKTOP = sp;
 return;
}

function _map_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $5;
 $11 = $6;
 _mp_arg_check_num_1073($10, $11, 2, 65535, 0);
 $12 = $5;
 $13 = $12 - 1 | 0;
 $14 = $13 << 2;
 $15 = 12 + $14 | 0;
 $16 = _m_malloc($15) | 0;
 $8 = $16;
 $17 = $4;
 $18 = $8;
 HEAP32[$18 >> 2] = $17;
 $19 = $5;
 $20 = $19 - 1 | 0;
 $21 = $8;
 $22 = $21 + 4 | 0;
 HEAP32[$22 >> 2] = $20;
 $23 = $7;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $8;
 $26 = $25 + 8 | 0;
 HEAP32[$26 >> 2] = $24;
 $9 = 0;
 while (1) {
  $27 = $9;
  $28 = $5;
  $29 = $28 - 1 | 0;
  $30 = $27 >>> 0 < $29 >>> 0;
  if (!$30) {
   break;
  }
  $31 = $7;
  $32 = $9;
  $33 = $32 + 1 | 0;
  $34 = $31 + ($33 << 2) | 0;
  $35 = HEAP32[$34 >> 2] | 0;
  $36 = _mp_getiter($35, 0) | 0;
  $37 = $8;
  $38 = $37 + 12 | 0;
  $39 = $9;
  $40 = $38 + ($39 << 2) | 0;
  HEAP32[$40 >> 2] = $36;
  $41 = $9;
  $42 = $41 + 1 | 0;
  $9 = $42;
 }
 $43 = $8;
 STACKTOP = sp;
 return $43 | 0;
}

function _yasmarang() {
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP8[41652] | 0;
 $1 = $0 & 255;
 $2 = HEAP32[5447] | 0;
 $3 = HEAP32[5448] | 0;
 $4 = Math_imul($2, $3) | 0;
 $5 = $1 + $4 | 0;
 $6 = HEAP32[5449] | 0;
 $7 = $6 + $5 | 0;
 HEAP32[5449] = $7;
 $8 = HEAP32[5449] | 0;
 $9 = $8 << 3;
 $10 = HEAP32[5449] | 0;
 $11 = $10 >>> 29;
 $12 = $9 + $11 | 0;
 HEAP32[5449] = $12;
 $13 = HEAP32[5449] | 0;
 $14 = $13 | 2;
 HEAP32[5448] = $14;
 $15 = HEAP32[5449] | 0;
 $16 = $15 << 31;
 $17 = HEAP32[5449] | 0;
 $18 = $17 >>> 1;
 $19 = $16 + $18 | 0;
 $20 = HEAP32[5447] | 0;
 $21 = $20 ^ $19;
 HEAP32[5447] = $21;
 $22 = HEAP32[5449] | 0;
 $23 = $22 & 255;
 $24 = $23 << 24 >> 24;
 $25 = HEAP32[5447] | 0;
 $26 = $25 >>> 8;
 $27 = $24 ^ $26;
 $28 = $27 ^ 1;
 $29 = HEAP8[41652] | 0;
 $30 = $29 & 255;
 $31 = $30 ^ $28;
 $32 = $31 & 255;
 HEAP8[41652] = $32;
 $33 = HEAP32[5449] | 0;
 $34 = HEAP32[5447] | 0;
 $35 = $34 << 5;
 $36 = $33 ^ $35;
 $37 = HEAP32[5449] | 0;
 $38 = $37 >>> 18;
 $39 = $36 ^ $38;
 $40 = HEAP8[41652] | 0;
 $41 = $40 & 255;
 $42 = $41 << 1;
 $43 = $39 ^ $42;
 return $43 | 0;
}

function _mp_load_method($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, $vararg_ptr1 = 0, $vararg_ptr5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $4;
 $8 = $5;
 _mp_load_method_maybe($6, $7, $8);
 $9 = $5;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = ($10 | 0) == (0 | 0);
 if (!$11) {
  STACKTOP = sp;
  return;
 }
 $12 = $3;
 $13 = _mp_obj_is_obj_729($12) | 0;
 if ($13) {
  $14 = $3;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = ($15 | 0) == (19048 | 0);
  if ($16) {
   $17 = $3;
   $18 = $17 + 6 | 0;
   $19 = HEAP16[$18 >> 1] | 0;
   $20 = $19 & 65535;
   $21 = $4;
   HEAP32[$vararg_buffer >> 2] = $20;
   $vararg_ptr1 = $vararg_buffer + 4 | 0;
   HEAP32[$vararg_ptr1 >> 2] = $21;
   $22 = _mp_obj_new_exception_msg_varg(15292, 29756, $vararg_buffer) | 0;
   _nlr_jump($22);
  }
 }
 $23 = $3;
 $24 = _mp_obj_get_type_str($23) | 0;
 $25 = $4;
 HEAP32[$vararg_buffer2 >> 2] = $24;
 $vararg_ptr5 = $vararg_buffer2 + 4 | 0;
 HEAP32[$vararg_ptr5 >> 2] = $25;
 $26 = _mp_obj_new_exception_msg_varg(15292, 29795, $vararg_buffer2) | 0;
 _nlr_jump($26);
}

function _mp_obj_int_formatted_impl($0, $1, $2, $3, $4, $5, $6, $7) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 $6 = $6 | 0;
 $7 = $7 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $8 = $0;
 $9 = $1;
 $10 = $2;
 $11 = $3;
 $12 = $4;
 $13 = $5;
 $14 = $6;
 $15 = $7;
 $19 = $11;
 $16 = $19;
 $20 = $16;
 $21 = $20 + 4 | 0;
 $22 = _mpz_max_num_bits($21) | 0;
 $23 = $12;
 $24 = $13;
 $25 = $15;
 $26 = _mp_int_format_size($22, $23, $24, $25) | 0;
 $17 = $26;
 $27 = $17;
 $28 = $9;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = $27 >>> 0 > $29 >>> 0;
 if ($30) {
  $31 = $17;
  $32 = $31;
  $33 = _m_malloc($32) | 0;
  $34 = $8;
  HEAP32[$34 >> 2] = $33;
  $35 = $17;
  $36 = $9;
  HEAP32[$36 >> 2] = $35;
 }
 $37 = $8;
 $38 = HEAP32[$37 >> 2] | 0;
 $18 = $38;
 $39 = $16;
 $40 = $39 + 4 | 0;
 $41 = $12;
 $42 = $13;
 $43 = $14;
 $44 = $15;
 $45 = $18;
 $46 = _mpz_as_str_inpl($40, $41, $42, $43, $44, $45) | 0;
 $47 = $10;
 HEAP32[$47 >> 2] = $46;
 $48 = $18;
 STACKTOP = sp;
 return $48 | 0;
}

function _memoryview_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $8 = sp + 4 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $5;
 $11 = $6;
 _mp_arg_check_num($10, $11, 1, 1, 0);
 $12 = $7;
 $13 = HEAP32[$12 >> 2] | 0;
 _mp_get_buffer_raise($13, $8, 1);
 $14 = $8 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $15 & 255;
 $17 = $8 + 4 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $8 + 8 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = $20 & 255;
 $22 = _mp_binary_get_size(64, $21, 0) | 0;
 $23 = ($18 >>> 0) / ($22 >>> 0) & -1;
 $24 = HEAP32[$8 >> 2] | 0;
 $25 = _mp_obj_new_memoryview($16, $23, $24) | 0;
 $9 = $25;
 $26 = $7;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = _mp_get_buffer($27, $8, 3) | 0;
 if (!$28) {
  $38 = $9;
  STACKTOP = sp;
  return $38 | 0;
 }
 $29 = $9;
 $30 = $29 + 4 | 0;
 $31 = HEAP32[$30 >> 2] | 0;
 $32 = $31 & 255;
 $33 = $32 | 128;
 $34 = HEAP32[$30 >> 2] | 0;
 $35 = $33 & 255;
 $36 = $34 & -256;
 $37 = $36 | $35;
 HEAP32[$30 >> 2] = $37;
 $38 = $9;
 STACKTOP = sp;
 return $38 | 0;
}

function _find_subbytes($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $40 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $13 = $7;
 $14 = $9;
 $15 = $13 >>> 0 >= $14 >>> 0;
 L1 : do {
  if ($15) {
   $16 = $10;
   $17 = ($16 | 0) > 0;
   if ($17) {
    $11 = 0;
    $18 = $7;
    $19 = $9;
    $20 = $18 - $19 | 0;
    $12 = $20;
   } else {
    $21 = $7;
    $22 = $9;
    $23 = $21 - $22 | 0;
    $11 = $23;
    $12 = 0;
   }
   while (1) {
    $24 = $6;
    $25 = $11;
    $26 = $24 + $25 | 0;
    $27 = $8;
    $28 = $9;
    $29 = _memcmp($26, $27, $28) | 0;
    $30 = ($29 | 0) == 0;
    if ($30) {
     break;
    }
    $34 = $11;
    $35 = $12;
    $36 = ($34 | 0) == ($35 | 0);
    if ($36) {
     break L1;
    }
    $37 = $10;
    $38 = $11;
    $39 = $38 + $37 | 0;
    $11 = $39;
   }
   $31 = $6;
   $32 = $11;
   $33 = $31 + $32 | 0;
   $5 = $33;
   $40 = $5;
   STACKTOP = sp;
   return $40 | 0;
  }
 } while (0);
 $5 = 0;
 $40 = $5;
 STACKTOP = sp;
 return $40 | 0;
}

function _c_tuple($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = 0;
 $9 = $4;
 $10 = ($9 | 0) == 0;
 if (!$10) {
  $11 = $3;
  $12 = $4;
  _compile_node($11, $12);
  $13 = $6;
  $14 = $13 + 1 | 0;
  $6 = $14;
 }
 $15 = $5;
 $16 = ($15 | 0) != (0 | 0);
 if (!$16) {
  $35 = $3;
  $36 = $35 + 40 | 0;
  $37 = HEAP32[$36 >> 2] | 0;
  $38 = $6;
  _mp_emit_bc_build($37, $38, 0);
  STACKTOP = sp;
  return;
 }
 $17 = $5;
 $18 = $17 + 4 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $19 >>> 8;
 $7 = $20;
 $8 = 0;
 while (1) {
  $21 = $8;
  $22 = $7;
  $23 = ($21 | 0) < ($22 | 0);
  if (!$23) {
   break;
  }
  $24 = $3;
  $25 = $5;
  $26 = $25 + 8 | 0;
  $27 = $8;
  $28 = $26 + ($27 << 2) | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  _compile_node($24, $29);
  $30 = $8;
  $31 = $30 + 1 | 0;
  $8 = $31;
 }
 $32 = $7;
 $33 = $6;
 $34 = $33 + $32 | 0;
 $6 = $34;
 $35 = $3;
 $36 = $35 + 40 | 0;
 $37 = HEAP32[$36 >> 2] | 0;
 $38 = $6;
 _mp_emit_bc_build($37, $38, 0);
 STACKTOP = sp;
 return;
}

function _tuple_cmp_helper($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $10 = $6;
 $11 = _mp_obj_get_type($10) | 0;
 $7 = $11;
 $12 = $5;
 $8 = $12;
 $13 = $7;
 $14 = $13 + 36 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = ($15 | 0) != (71 | 0);
 if ($16) {
  $17 = $6;
  $18 = _mp_instance_cast_to_native_base($17, 18952) | 0;
  $6 = $18;
  $19 = $6;
  $20 = ($19 | 0) == (0 | 0);
  if ($20) {
   $21 = $4;
   $22 = ($21 | 0) == 2;
   if ($22) {
    $3 = 13856;
    $38 = $3;
    STACKTOP = sp;
    return $38 | 0;
   } else {
    $3 = 0;
    $38 = $3;
    STACKTOP = sp;
    return $38 | 0;
   }
  }
 }
 $23 = $6;
 $9 = $23;
 $24 = $4;
 $25 = $8;
 $26 = $25 + 8 | 0;
 $27 = $8;
 $28 = $27 + 4 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = $9;
 $31 = $30 + 8 | 0;
 $32 = $9;
 $33 = $32 + 4 | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = _mp_seq_cmp_objs($24, $26, $29, $31, $34) | 0;
 $36 = $35 & 1;
 $37 = _mp_obj_new_bool_1243($36) | 0;
 $3 = $37;
 $38 = $3;
 STACKTOP = sp;
 return $38 | 0;
}

function _set_it_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $7 = $2;
 $3 = $7;
 $8 = $3;
 $9 = $8 + 8 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $4 = $12;
 $13 = $3;
 $14 = $13 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $15 + 4 | 0;
 $5 = $16;
 $17 = $3;
 $18 = $17 + 12 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $6 = $19;
 while (1) {
  $20 = $6;
  $21 = $4;
  $22 = $20 >>> 0 < $21 >>> 0;
  if (!$22) {
   label = 6;
   break;
  }
  $23 = $5;
  $24 = $6;
  $25 = _mp_set_slot_is_filled_1104($23, $24) | 0;
  $26 = $6;
  $27 = $26 + 1 | 0;
  if ($25) {
   label = 4;
   break;
  }
  $6 = $27;
 }
 if ((label | 0) == 4) {
  $28 = $3;
  $29 = $28 + 12 | 0;
  HEAP32[$29 >> 2] = $27;
  $30 = $5;
  $31 = $30 + 8 | 0;
  $32 = HEAP32[$31 >> 2] | 0;
  $33 = $6;
  $34 = $32 + ($33 << 2) | 0;
  $35 = HEAP32[$34 >> 2] | 0;
  $1 = $35;
  $36 = $1;
  STACKTOP = sp;
  return $36 | 0;
 } else if ((label | 0) == 6) {
  $1 = 0;
  $36 = $1;
  STACKTOP = sp;
  return $36 | 0;
 }
 return 0 | 0;
}

function _compile_assert_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = HEAP32[40736 >> 2] | 0;
 $6 = ($5 | 0) != 0;
 if ($6) {
  STACKTOP = sp;
  return;
 }
 $7 = $2;
 $8 = _comp_next_label($7) | 0;
 $4 = $8;
 $9 = $2;
 $10 = $3;
 $11 = $10 + 8 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $4;
 _c_if_cond($9, $12, 1, $13);
 $14 = $2;
 $15 = $14 + 40 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 _mp_emit_bc_load_global($16, 31, 1);
 $17 = $3;
 $18 = $17 + 8 | 0;
 $19 = $18 + 4 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = ($20 | 0) == 0;
 if (!$21) {
  $22 = $2;
  $23 = $3;
  $24 = $23 + 8 | 0;
  $25 = $24 + 4 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  _compile_node($22, $26);
  $27 = $2;
  $28 = $27 + 40 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  _mp_emit_bc_call_function($29, 1, 0, 0);
 }
 $30 = $2;
 $31 = $30 + 40 | 0;
 $32 = HEAP32[$31 >> 2] | 0;
 _mp_emit_bc_raise_varargs($32, 1);
 $33 = $2;
 $34 = $33 + 40 | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 $36 = $4;
 _mp_emit_bc_label_assign($35, $36);
 STACKTOP = sp;
 return;
}

function _instance_get_buffer($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $8 = sp + 24 | 0;
 $9 = sp + 4 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $11 = $4;
 $7 = $11;
 HEAP32[$8 >> 2] = 0 | 0;
 HEAP32[$8 + 4 >> 2] = 0 | 0;
 $12 = $7;
 HEAP32[$9 >> 2] = $12;
 $13 = $9 + 4 | 0;
 HEAP32[$13 >> 2] = 1;
 $14 = $9 + 8 | 0;
 HEAP32[$14 >> 2] = 44;
 $15 = $9 + 12 | 0;
 HEAP32[$15 >> 2] = $8;
 $16 = $9 + 16 | 0;
 HEAP8[$16 >> 0] = 0;
 $17 = $7;
 $18 = HEAP32[$17 >> 2] | 0;
 _mp_obj_class_lookup($9, $18);
 $19 = HEAP32[$8 >> 2] | 0;
 $20 = ($19 | 0) == (4 | 0);
 if ($20) {
  $21 = $7;
  $22 = $21 + 16 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = _mp_obj_get_type($23) | 0;
  $10 = $24;
  $25 = $10;
  $26 = $25 + 44 | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $28 = $7;
  $29 = $28 + 16 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = $5;
  $32 = $6;
  $33 = FUNCTION_TABLE_iiii[$27 & 1023]($30, $31, $32) | 0;
  $3 = $33;
  $34 = $3;
  STACKTOP = sp;
  return $34 | 0;
 } else {
  $3 = 1;
  $34 = $3;
  STACKTOP = sp;
  return $34 | 0;
 }
 return 0 | 0;
}

function _gs2_hmsb_setpixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $47 = 0, $48 = 0, $49 = 0, $5 = 0, $50 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $12 = $4;
 $13 = $12 + 8 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $5;
 $16 = $6;
 $17 = $4;
 $18 = $17 + 16 | 0;
 $19 = HEAP16[$18 >> 1] | 0;
 $20 = $19 & 65535;
 $21 = Math_imul($16, $20) | 0;
 $22 = $15 + $21 | 0;
 $23 = $22 >> 2;
 $24 = $14 + $23 | 0;
 $8 = $24;
 $25 = $5;
 $26 = $25 & 3;
 $27 = $26 << 1;
 $28 = $27 & 255;
 $9 = $28;
 $29 = $9;
 $30 = $29 & 255;
 $31 = 3 << $30;
 $32 = $31 & 255;
 $10 = $32;
 $33 = $7;
 $34 = $33 & 3;
 $35 = $9;
 $36 = $35 & 255;
 $37 = $34 << $36;
 $38 = $37 & 255;
 $11 = $38;
 $39 = $11;
 $40 = $39 & 255;
 $41 = $8;
 $42 = HEAP8[$41 >> 0] | 0;
 $43 = $42 & 255;
 $44 = $10;
 $45 = $44 & 255;
 $46 = $45 ^ -1;
 $47 = $43 & $46;
 $48 = $40 | $47;
 $49 = $48 & 255;
 $50 = $8;
 HEAP8[$50 >> 0] = $49;
 STACKTOP = sp;
 return;
}

function _emit_write_uint($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = sp + 20 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $6 + 5 | 0;
 $7 = $9;
 while (1) {
  $10 = $5;
  $11 = $10 & 127;
  $12 = $11 & 255;
  $13 = $7;
  $14 = $13 + -1 | 0;
  $7 = $14;
  HEAP8[$14 >> 0] = $12;
  $15 = $5;
  $16 = $15 >>> 7;
  $5 = $16;
  $17 = $5;
  $18 = ($17 | 0) != 0;
  if (!$18) {
   break;
  }
 }
 $19 = $4;
 $20 = $3;
 $21 = $6 + 5 | 0;
 $22 = $7;
 $23 = $21;
 $24 = $22;
 $25 = $23 - $24 | 0;
 $26 = FUNCTION_TABLE_iii[$19 & 1023]($20, $25) | 0;
 $8 = $26;
 while (1) {
  $27 = $7;
  $28 = $6 + 5 | 0;
  $29 = $28 + -1 | 0;
  $30 = ($27 | 0) != ($29 | 0);
  $31 = $7;
  if (!$30) {
   break;
  }
  $32 = $31 + 1 | 0;
  $7 = $32;
  $33 = HEAP8[$31 >> 0] | 0;
  $34 = $33 & 255;
  $35 = $34 | 128;
  $36 = $35 & 255;
  $37 = $8;
  $38 = $37 + 1 | 0;
  $8 = $38;
  HEAP8[$37 >> 0] = $36;
 }
 $39 = HEAP8[$31 >> 0] | 0;
 $40 = $8;
 HEAP8[$40 >> 0] = $39;
 STACKTOP = sp;
 return;
}

function _dict_fromkeys($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $10 = $3;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = _mp_getiter($12, 0) | 0;
 $4 = $13;
 $5 = 17668;
 $6 = 0;
 $14 = $2;
 $15 = $14 >>> 0 > 2;
 if ($15) {
  $16 = $3;
  $17 = $16 + 8 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $5 = $18;
 }
 $19 = $3;
 $20 = $19 + 4 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = _mp_obj_len_maybe($21) | 0;
 $8 = $22;
 $23 = $8;
 $24 = ($23 | 0) == (0 | 0);
 if ($24) {
  $25 = _mp_obj_new_dict(0) | 0;
  $7 = $25;
 } else {
  $26 = $8;
  $27 = $26;
  $28 = $27 >> 1;
  $29 = _mp_obj_new_dict($28) | 0;
  $7 = $29;
 }
 $30 = $7;
 $9 = $30;
 while (1) {
  $31 = $4;
  $32 = _mp_iternext($31) | 0;
  $6 = $32;
  $33 = ($32 | 0) != (0 | 0);
  if (!$33) {
   break;
  }
  $34 = $5;
  $35 = $9;
  $36 = $35 + 4 | 0;
  $37 = $6;
  $38 = _mp_map_lookup($36, $37, 1) | 0;
  $39 = $38 + 4 | 0;
  HEAP32[$39 >> 2] = $34;
 }
 $40 = $7;
 STACKTOP = sp;
 return $40 | 0;
}

function _mp_emit_bc_adjust_stack_size($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 5 | 0;
 $6 = HEAPU8[$5 >> 0] | HEAPU8[$5 + 1 >> 0] << 8;
 $7 = $6 & 255;
 $8 = $7 & 65535;
 $9 = ($8 | 0) == 1;
 if ($9) {
  STACKTOP = sp;
  return;
 }
 $10 = $3;
 $11 = $2;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $13 + $10 | 0;
 HEAP32[$12 >> 2] = $14;
 $15 = $2;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $2;
 $19 = $18 + 12 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = $20 + 36 | 0;
 $22 = HEAP16[$21 >> 1] | 0;
 $23 = $22 & 65535;
 $24 = ($17 | 0) > ($23 | 0);
 if ($24) {
  $25 = $2;
  $26 = $25 + 8 | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $28 = $27 & 65535;
  $29 = $2;
  $30 = $29 + 12 | 0;
  $31 = HEAP32[$30 >> 2] | 0;
  $32 = $31 + 36 | 0;
  HEAP16[$32 >> 1] = $28;
 }
 $33 = $2;
 $34 = $33 + 5 | 0;
 $35 = HEAPU8[$34 >> 0] | HEAPU8[$34 + 1 >> 0] << 8;
 $36 = $35 & 255;
 HEAP8[$34 >> 0] = $36 & 255;
 HEAP8[$34 + 1 >> 0] = $36 >> 8;
 STACKTOP = sp;
 return;
}

function _mp_parse_node_extract_list($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $8 = $4;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) == 0;
 if ($10) {
  $11 = $6;
  HEAP32[$11 >> 2] = 0;
  $3 = 0;
  $35 = $3;
  STACKTOP = sp;
  return $35 | 0;
 }
 $12 = $4;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $13 & 3;
 $15 = ($14 | 0) != 0;
 $16 = $4;
 if ($15) {
  $17 = $6;
  HEAP32[$17 >> 2] = $16;
  $3 = 1;
  $35 = $3;
  STACKTOP = sp;
  return $35 | 0;
 }
 $18 = HEAP32[$16 >> 2] | 0;
 $19 = $18;
 $7 = $19;
 $20 = $7;
 $21 = $20 + 4 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = $22 & 255;
 $24 = $5;
 $25 = ($23 | 0) != ($24 | 0);
 if ($25) {
  $26 = $4;
  $27 = $6;
  HEAP32[$27 >> 2] = $26;
  $3 = 1;
  $35 = $3;
  STACKTOP = sp;
  return $35 | 0;
 } else {
  $28 = $7;
  $29 = $28 + 8 | 0;
  $30 = $6;
  HEAP32[$30 >> 2] = $29;
  $31 = $7;
  $32 = $31 + 4 | 0;
  $33 = HEAP32[$32 >> 2] | 0;
  $34 = $33 >>> 8;
  $3 = $34;
  $35 = $3;
  STACKTOP = sp;
  return $35 | 0;
 }
 return 0 | 0;
}

function _uzlib_zlib_parse_header($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $5 = $2;
 $6 = _uzlib_get_byte($5) | 0;
 $3 = $6;
 $7 = $2;
 $8 = _uzlib_get_byte($7) | 0;
 $4 = $8;
 $9 = $3;
 $10 = $9 & 255;
 $11 = $10 << 8;
 $12 = $4;
 $13 = $12 & 255;
 $14 = $11 + $13 | 0;
 $15 = ($14 | 0) % 31 & -1;
 $16 = ($15 | 0) != 0;
 do {
  if ($16) {
   $1 = -3;
  } else {
   $17 = $3;
   $18 = $17 & 255;
   $19 = $18 & 15;
   $20 = ($19 | 0) != 8;
   if ($20) {
    $1 = -3;
    break;
   }
   $21 = $3;
   $22 = $21 & 255;
   $23 = $22 >> 4;
   $24 = ($23 | 0) > 7;
   if ($24) {
    $1 = -3;
    break;
   }
   $25 = $4;
   $26 = $25 & 255;
   $27 = $26 & 32;
   $28 = ($27 | 0) != 0;
   if ($28) {
    $1 = -3;
    break;
   } else {
    $29 = $2;
    $30 = $29 + 36 | 0;
    HEAP8[$30 >> 0] = 1;
    $31 = $2;
    $32 = $31 + 32 | 0;
    HEAP32[$32 >> 2] = 1;
    $33 = $3;
    $34 = $33 & 255;
    $35 = $34 >> 4;
    $1 = $35;
    break;
   }
  }
 } while (0);
 $36 = $1;
 STACKTOP = sp;
 return $36 | 0;
}

function _uni_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_ptr1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $7 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $4;
 $9 = _mp_obj_is_qstr_1200($8) | 0;
 $10 = $4;
 if ($9) {
  $11 = $10;
  $12 = $11 >>> 2;
  $13 = _qstr_data($12, $7) | 0;
  $6 = $13;
 } else {
  $14 = $10 + 8 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  HEAP32[$7 >> 2] = $15;
  $16 = $4;
  $17 = $16 + 12 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $6 = $18;
 }
 $19 = $5;
 $20 = ($19 | 0) == 3;
 if ($20) {
  $21 = $3;
  $22 = $6;
  $23 = HEAP32[$7 >> 2] | 0;
  _mp_str_print_json($21, $22, $23);
  STACKTOP = sp;
  return;
 }
 $24 = $5;
 $25 = ($24 | 0) == 0;
 $26 = $3;
 if ($25) {
  $27 = HEAP32[$7 >> 2] | 0;
  $28 = $6;
  HEAP32[$vararg_buffer >> 2] = $27;
  $vararg_ptr1 = $vararg_buffer + 4 | 0;
  HEAP32[$vararg_ptr1 >> 2] = $28;
  _mp_printf($26, 32823, $vararg_buffer) | 0;
  STACKTOP = sp;
  return;
 } else {
  $29 = $6;
  $30 = HEAP32[$7 >> 2] | 0;
  _uni_print_quoted($26, $29, $30);
  STACKTOP = sp;
  return;
 }
}

function _mp_get_stream_raise($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = _mp_obj_get_type($6) | 0;
 $4 = $7;
 $8 = $4;
 $9 = $8 + 48 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $5 = $10;
 $11 = $5;
 $12 = ($11 | 0) == (0 | 0);
 do {
  if (!$12) {
   $13 = $3;
   $14 = $13 & 1;
   $15 = ($14 | 0) != 0;
   if ($15) {
    $16 = $5;
    $17 = HEAP32[$16 >> 2] | 0;
    $18 = ($17 | 0) == (0 | 0);
    if ($18) {
     break;
    }
   }
   $19 = $3;
   $20 = $19 & 2;
   $21 = ($20 | 0) != 0;
   if ($21) {
    $22 = $5;
    $23 = $22 + 4 | 0;
    $24 = HEAP32[$23 >> 2] | 0;
    $25 = ($24 | 0) == (0 | 0);
    if ($25) {
     break;
    }
   }
   $26 = $3;
   $27 = $26 & 4;
   $28 = ($27 | 0) != 0;
   if (!$28) {
    $33 = $5;
    STACKTOP = sp;
    return $33 | 0;
   }
   $29 = $5;
   $30 = $29 + 8 | 0;
   $31 = HEAP32[$30 >> 2] | 0;
   $32 = ($31 | 0) == (0 | 0);
   if (!$32) {
    $33 = $5;
    STACKTOP = sp;
    return $33 | 0;
   }
  }
 } while (0);
 _mp_raise_msg(14796, 33471);
 return 0 | 0;
}

function _mod_re_compile($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $9 = $3;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = _mp_obj_str_get_str($10) | 0;
 $4 = $11;
 $12 = $4;
 $13 = _re1_5_sizecode($12) | 0;
 $5 = $13;
 $14 = $5;
 $15 = ($14 | 0) == -1;
 if ($15) {
  _mp_raise_ValueError(34703);
 }
 $16 = $5;
 $17 = $16;
 $18 = 16 + $17 | 0;
 $19 = _m_malloc($18) | 0;
 $6 = $19;
 $20 = $6;
 HEAP32[$20 >> 2] = 21216;
 $7 = 0;
 $21 = $2;
 $22 = $21 >>> 0 > 1;
 if ($22) {
  $23 = $3;
  $24 = $23 + 4 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = _mp_obj_get_int($25) | 0;
  $7 = $26;
 }
 $27 = $6;
 $28 = $27 + 4 | 0;
 $29 = $4;
 $30 = _re1_5_compilecode($28, $29) | 0;
 $8 = $30;
 $31 = $8;
 $32 = ($31 | 0) != 0;
 if ($32) {
  _mp_raise_ValueError(34703);
 }
 $33 = $7;
 $34 = $33 & 4096;
 $35 = ($34 | 0) != 0;
 if (!$35) {
  $38 = $6;
  STACKTOP = sp;
  return $38 | 0;
 }
 $36 = $6;
 $37 = $36 + 4 | 0;
 _re1_5_dumpcode($37);
 $38 = $6;
 STACKTOP = sp;
 return $38 | 0;
}

function _mp_builtin_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $6 = sp + 24 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $12 = $5;
 _mp_arg_parse_all(0, 0, $12, 2, 5120, $6);
 $13 = HEAP32[$6 >> 2] | 0;
 $7 = $13;
 $14 = $6 + 4 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $8 = $15;
 $16 = $7;
 $17 = _mp_obj_str_get_data($16, $6) | 0;
 $9 = $17;
 $18 = $8;
 $19 = $6 + 4 | 0;
 $20 = _mp_obj_str_get_data($18, $19) | 0;
 $10 = $20;
 $11 = 0;
 while (1) {
  $21 = $11;
  $22 = $3;
  $23 = $21 >>> 0 < $22 >>> 0;
  if (!$23) {
   break;
  }
  $24 = $11;
  $25 = $24 >>> 0 > 0;
  if ($25) {
   $26 = $9;
   $27 = HEAP32[$6 >> 2] | 0;
   _mp_print_strn(13344, $26, $27, 0, 0, 0) | 0;
  }
  $28 = $4;
  $29 = $11;
  $30 = $28 + ($29 << 2) | 0;
  $31 = HEAP32[$30 >> 2] | 0;
  _mp_obj_print_helper(13344, $31, 0);
  $32 = $11;
  $33 = $32 + 1 | 0;
  $11 = $33;
 }
 $34 = $10;
 $35 = $6 + 4 | 0;
 $36 = HEAP32[$35 >> 2] | 0;
 _mp_print_strn(13344, $34, $36, 0, 0, 0) | 0;
 STACKTOP = sp;
 return 17668 | 0;
}

function _yasmarang_float() {
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0.0, $4 = 0, $40 = 0.0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $0 = sp;
 $1 = $0;
 $2 = $1;
 $3 = HEAP32[$2 >> 2] | 0;
 $4 = $1 + 4 | 0;
 $5 = $4;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $6 & 2147483647;
 $8 = $0;
 $9 = $8;
 HEAP32[$9 >> 2] = $3;
 $10 = $8 + 4 | 0;
 $11 = $10;
 HEAP32[$11 >> 2] = $7;
 $12 = $0;
 $13 = $12;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $12 + 4 | 0;
 $16 = $15;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $17 & -2146435073;
 $19 = $18 | 1072693248;
 $20 = $0;
 $21 = $20;
 HEAP32[$21 >> 2] = $14;
 $22 = $20 + 4 | 0;
 $23 = $22;
 HEAP32[$23 >> 2] = $19;
 $24 = _yasmarang() | 0;
 $25 = _yasmarang() | 0;
 $26 = $0;
 $27 = $26;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = $26 + 4 | 0;
 $30 = $29;
 $31 = HEAP32[$30 >> 2] | 0;
 $32 = $24 & 1048575;
 $33 = $31 & -1048576;
 $34 = $33 | $32;
 $35 = $0;
 $36 = $35;
 HEAP32[$36 >> 2] = $25;
 $37 = $35 + 4 | 0;
 $38 = $37;
 HEAP32[$38 >> 2] = $34;
 $39 = +HEAPF64[$0 >> 3];
 $40 = $39 - 1.0;
 STACKTOP = sp;
 return +$40;
}

function _mp_obj_len_maybe($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $5 = $2;
 $6 = _mp_obj_is_obj_786($5) | 0;
 if ($6) {
  $7 = $2;
  $8 = HEAP32[$7 >> 2] | 0;
  $9 = ($8 | 0) == (18304 | 0);
  if ($9) {
   $10 = $2;
   $11 = _mp_obj_is_qstr_785($10) | 0;
   $12 = $2;
   if ($11) {
    $13 = $12;
    $14 = $13 >>> 2;
    $15 = _qstr_len($14) | 0;
    $3 = $15;
   } else {
    $16 = $12 + 8 | 0;
    $17 = HEAP32[$16 >> 2] | 0;
    $3 = $17;
   }
   $18 = $3;
   $19 = $18 << 1;
   $20 = $19 | 1;
   $21 = $20;
   $1 = $21;
   $33 = $1;
   STACKTOP = sp;
   return $33 | 0;
  }
 }
 $22 = $2;
 $23 = _mp_obj_get_type($22) | 0;
 $4 = $23;
 $24 = $4;
 $25 = $24 + 20 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = ($26 | 0) != (0 | 0);
 if ($27) {
  $28 = $4;
  $29 = $28 + 20 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = $2;
  $32 = FUNCTION_TABLE_iii[$30 & 1023](5, $31) | 0;
  $1 = $32;
  $33 = $1;
  STACKTOP = sp;
  return $33 | 0;
 } else {
  $1 = 0;
  $33 = $1;
  STACKTOP = sp;
  return $33 | 0;
 }
 return 0 | 0;
}

function _dict_view_it_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp;
 $2 = $0;
 $6 = $2;
 $3 = $6;
 $7 = $3;
 $8 = $7 + 8 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $3;
 $11 = $10 + 12 | 0;
 $12 = _dict_iter_next($9, $11) | 0;
 $4 = $12;
 $13 = $4;
 $14 = ($13 | 0) == (0 | 0);
 if ($14) {
  $1 = 0;
  $30 = $1;
  STACKTOP = sp;
  return $30 | 0;
 }
 $15 = $3;
 $16 = $15 + 4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 switch ($17 | 0) {
 case 2:
  {
   $27 = $4;
   $28 = $27 + 4 | 0;
   $29 = HEAP32[$28 >> 2] | 0;
   $1 = $29;
   $30 = $1;
   STACKTOP = sp;
   return $30 | 0;
   break;
  }
 case 1:
  {
   $25 = $4;
   $26 = HEAP32[$25 >> 2] | 0;
   $1 = $26;
   $30 = $1;
   STACKTOP = sp;
   return $30 | 0;
   break;
  }
 default:
  {
   $18 = $4;
   $19 = HEAP32[$18 >> 2] | 0;
   HEAP32[$5 >> 2] = $19;
   $20 = $5 + 4 | 0;
   $21 = $4;
   $22 = $21 + 4 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   HEAP32[$20 >> 2] = $23;
   $24 = _mp_obj_new_tuple(2, $5) | 0;
   $1 = $24;
   $30 = $1;
   STACKTOP = sp;
   return $30 | 0;
  }
 }
 return 0 | 0;
}

function _gs4_hmsb_setpixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $4;
 $10 = $9 + 8 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $5;
 $13 = $6;
 $14 = $4;
 $15 = $14 + 16 | 0;
 $16 = HEAP16[$15 >> 1] | 0;
 $17 = $16 & 65535;
 $18 = Math_imul($13, $17) | 0;
 $19 = $12 + $18 | 0;
 $20 = $19 >> 1;
 $21 = $11 + $20 | 0;
 $8 = $21;
 $22 = $5;
 $23 = ($22 | 0) % 2 & -1;
 $24 = ($23 | 0) != 0;
 $25 = $7;
 $26 = $25 & 255;
 $27 = $26 & 255;
 if ($24) {
  $28 = $27 & 15;
  $29 = $8;
  $30 = HEAP8[$29 >> 0] | 0;
  $31 = $30 & 255;
  $32 = $31 & 240;
  $33 = $28 | $32;
  $34 = $33 & 255;
  $35 = $8;
  HEAP8[$35 >> 0] = $34;
  STACKTOP = sp;
  return;
 } else {
  $36 = $27 << 4;
  $37 = $8;
  $38 = HEAP8[$37 >> 0] | 0;
  $39 = $38 & 255;
  $40 = $39 & 15;
  $41 = $36 | $40;
  $42 = $41 & 255;
  $43 = $8;
  HEAP8[$43 >> 0] = $42;
  STACKTOP = sp;
  return;
 }
}

function _mp_obj_attrtuple_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $10 = $5;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = ($11 | 0) == (0 | 0);
 if (!$12) {
  STACKTOP = sp;
  return;
 }
 $13 = $3;
 $6 = $13;
 $14 = $6;
 $15 = $14 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $7 = $16;
 $17 = $6;
 $18 = $17 + 8 | 0;
 $19 = $7;
 $20 = $18 + ($19 << 2) | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $8 = $21;
 $9 = 0;
 while (1) {
  $22 = $9;
  $23 = $7;
  $24 = $22 >>> 0 < $23 >>> 0;
  if (!$24) {
   label = 7;
   break;
  }
  $25 = $8;
  $26 = $9;
  $27 = $25 + ($26 << 2) | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = $4;
  $30 = ($28 | 0) == ($29 | 0);
  if ($30) {
   break;
  }
  $37 = $9;
  $38 = $37 + 1 | 0;
  $9 = $38;
 }
 if ((label | 0) == 7) {
  STACKTOP = sp;
  return;
 }
 $31 = $6;
 $32 = $31 + 8 | 0;
 $33 = $9;
 $34 = $32 + ($33 << 2) | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 $36 = $5;
 HEAP32[$36 >> 2] = $35;
 STACKTOP = sp;
 return;
}

function _pop_rule($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 - 1 | 0;
 HEAP32[$8 >> 2] = $10;
 $11 = $3;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $3;
 $15 = $14 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $13 + ($16 << 3) | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $18 >>> 24;
 $20 = $19 & 255;
 $6 = $20;
 $21 = $3;
 $22 = $21 + 8 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $3;
 $25 = $24 + 4 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = $23 + ($26 << 3) | 0;
 $28 = $27 + 4 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = $4;
 HEAP32[$30 >> 2] = $29;
 $31 = $3;
 $32 = $31 + 8 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = $3;
 $35 = $34 + 4 | 0;
 $36 = HEAP32[$35 >> 2] | 0;
 $37 = $33 + ($36 << 3) | 0;
 $38 = HEAP32[$37 >> 2] | 0;
 $39 = $38 & 16777215;
 $40 = $5;
 HEAP32[$40 >> 2] = $39;
 $41 = $6;
 STACKTOP = sp;
 return $41 | 0;
}

function _strncmp($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$0$lcssa = 0, $$01823 = 0, $$01925 = 0, $$01925$in = 0, $$020 = 0, $$024 = 0, $$lcssa = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond21 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $3 = ($2 | 0) == 0;
 if ($3) {
  $$020 = 0;
 } else {
  $4 = HEAP8[$0 >> 0] | 0;
  $5 = $4 << 24 >> 24 == 0;
  L3 : do {
   if ($5) {
    $$0$lcssa = $1;
    $$lcssa = 0;
   } else {
    $$01823 = $0;
    $$01925$in = $2;
    $$024 = $1;
    $9 = $4;
    while (1) {
     $$01925 = $$01925$in + -1 | 0;
     $6 = HEAP8[$$024 >> 0] | 0;
     $7 = $6 << 24 >> 24 != 0;
     $8 = ($$01925 | 0) != 0;
     $or$cond = $8 & $7;
     $10 = $9 << 24 >> 24 == $6 << 24 >> 24;
     $or$cond21 = $10 & $or$cond;
     if (!$or$cond21) {
      $$0$lcssa = $$024;
      $$lcssa = $9;
      break L3;
     }
     $11 = $$01823 + 1 | 0;
     $12 = $$024 + 1 | 0;
     $13 = HEAP8[$11 >> 0] | 0;
     $14 = $13 << 24 >> 24 == 0;
     if ($14) {
      $$0$lcssa = $12;
      $$lcssa = 0;
      break;
     } else {
      $$01823 = $11;
      $$01925$in = $$01925;
      $$024 = $12;
      $9 = $13;
     }
    }
   }
  } while (0);
  $15 = $$lcssa & 255;
  $16 = HEAP8[$$0$lcssa >> 0] | 0;
  $17 = $16 & 255;
  $18 = $15 - $17 | 0;
  $$020 = $18;
 }
 return $$020 | 0;
}

function _mp_builtin_compile($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $4 = sp + 24 | 0;
 $2 = $0;
 $3 = $1;
 $11 = $3;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = _mp_obj_str_get_data($12, $4) | 0;
 $5 = $13;
 $14 = $3;
 $15 = $14 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = _mp_obj_str_get_qstr($16) | 0;
 $6 = $17;
 $18 = $6;
 $19 = $5;
 $20 = HEAP32[$4 >> 2] | 0;
 $21 = _mp_lexer_new_from_str_len($18, $19, $20, 0) | 0;
 $7 = $21;
 $22 = $3;
 $23 = $22 + 8 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = _mp_obj_str_get_qstr($24) | 0;
 $8 = $25;
 $26 = $8;
 switch ($26 | 0) {
 case 463:
  {
   $9 = 0;
   break;
  }
 case 81:
  {
   $9 = 1;
   break;
  }
 case 80:
  {
   $9 = 2;
   break;
  }
 default:
  {
   _mp_raise_ValueError(33583);
  }
 }
 $27 = _m_malloc(8) | 0;
 $10 = $27;
 $28 = $10;
 HEAP32[$28 >> 2] = 19508;
 $29 = $7;
 $30 = $9;
 $31 = _mp_parse_compile_execute($29, $30, 0, 0) | 0;
 $32 = $10;
 $33 = $32 + 4 | 0;
 HEAP32[$33 >> 2] = $31;
 $34 = $10;
 STACKTOP = sp;
 return $34 | 0;
}

function _array_it_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $3 = $4;
 $5 = $3;
 $6 = $5 + 12 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $3;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $10 + 8 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $7 >>> 0 < $12 >>> 0;
 if ($13) {
  $14 = $3;
  $15 = $14 + 4 | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  $17 = $16 + 4 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = $18 & 255;
  $20 = $19 & 127;
  $21 = $20 & 255;
  $22 = $3;
  $23 = $22 + 4 | 0;
  $24 = HEAP32[$23 >> 2] | 0;
  $25 = $24 + 12 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $3;
  $28 = $27 + 8 | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  $30 = $3;
  $31 = $30 + 12 | 0;
  $32 = HEAP32[$31 >> 2] | 0;
  $33 = $32 + 1 | 0;
  HEAP32[$31 >> 2] = $33;
  $34 = $29 + $32 | 0;
  $35 = _mp_binary_get_val_array($21, $26, $34) | 0;
  $1 = $35;
  $36 = $1;
  STACKTOP = sp;
  return $36 | 0;
 } else {
  $1 = 0;
  $36 = $1;
  STACKTOP = sp;
  return $36 | 0;
 }
 return 0 | 0;
}

function _asinh($0) {
 $0 = +$0;
 var $$0 = 0.0, $1 = 0, $10 = 0.0, $11 = 0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0, $29 = 0.0, $3 = 0, $30 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = _bitshift64Lshr($1 | 0, $2 | 0, 52) | 0;
 $4 = getTempRet0() | 0;
 $5 = $3 & 2047;
 $6 = $2 & 2147483647;
 HEAP32[tempDoublePtr >> 2] = $1;
 HEAP32[tempDoublePtr + 4 >> 2] = $6;
 $7 = +HEAPF64[tempDoublePtr >> 3];
 $8 = $5 >>> 0 > 1048;
 do {
  if ($8) {
   $9 = +_log($7);
   $10 = $9 + .6931471805599453;
   $$0 = $10;
  } else {
   $11 = $5 >>> 0 > 1023;
   if ($11) {
    $12 = $7 * 2.0;
    $13 = $7 * $7;
    $14 = $13 + 1.0;
    $15 = +Math_sqrt(+$14);
    $16 = $15 + $7;
    $17 = 1.0 / $16;
    $18 = $12 + $17;
    $19 = +_log($18);
    $$0 = $19;
    break;
   }
   $20 = $5 >>> 0 > 996;
   if ($20) {
    $21 = $7 * $7;
    $22 = $21 + 1.0;
    $23 = +Math_sqrt(+$22);
    $24 = $23 + 1.0;
    $25 = $21 / $24;
    $26 = $25 + $7;
    $27 = +_log1p($26);
    $$0 = $27;
   } else {
    $$0 = $7;
   }
  }
 } while (0);
 $28 = ($2 | 0) < 0;
 $29 = -$$0;
 $30 = $28 ? $29 : $$0;
 return +$30;
}

function _dict_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $10 = sp + 16 | 0;
 $11 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $12 = _mp_obj_new_dict(0) | 0;
 $8 = $12;
 $13 = $8;
 $9 = $13;
 $14 = $4;
 $15 = $9;
 HEAP32[$15 >> 2] = $14;
 $16 = $4;
 $17 = ($16 | 0) == (14436 | 0);
 if ($17) {
  $18 = $9;
  $19 = $18 + 4 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = $20 & -5;
  $22 = $21 | 4;
  HEAP32[$19 >> 2] = $22;
 }
 $23 = $5;
 $24 = $23 >>> 0 > 0;
 $25 = $6;
 $26 = $25 >>> 0 > 0;
 $or$cond = $24 | $26;
 if (!$or$cond) {
  $37 = $8;
  STACKTOP = sp;
  return $37 | 0;
 }
 $27 = $8;
 HEAP32[$10 >> 2] = $27;
 $28 = $10 + 4 | 0;
 $29 = $7;
 $30 = HEAP32[$29 >> 2] | 0;
 HEAP32[$28 >> 2] = $30;
 $31 = $6;
 $32 = $7;
 $33 = $5;
 $34 = $32 + ($33 << 2) | 0;
 _mp_map_init_fixed_table($11, $31, $34);
 $35 = $5;
 $36 = $35 + 1 | 0;
 _dict_update($36, $10, $11) | 0;
 $37 = $8;
 STACKTOP = sp;
 return $37 | 0;
}

function _get_hex($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = sp + 20 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = 0;
 while (1) {
  $9 = $5;
  $10 = $9 + -1 | 0;
  $5 = $10;
  $11 = ($9 | 0) != 0;
  if (!$11) {
   label = 6;
   break;
  }
  $12 = $4;
  _next_char($12);
  $13 = $4;
  $14 = $13 + 16 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $8 = $15;
  $16 = $8;
  $17 = _unichar_isxdigit($16) | 0;
  if (!$17) {
   label = 4;
   break;
  }
  $18 = $7;
  $19 = $18 << 4;
  $20 = $8;
  $21 = _unichar_xdigit_value($20) | 0;
  $22 = $19 + $21 | 0;
  $7 = $22;
 }
 if ((label | 0) == 4) {
  $$expand_i1_val = 0;
  HEAP8[$3 >> 0] = $$expand_i1_val;
  $$pre_trunc = HEAP8[$3 >> 0] | 0;
  $25 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $25 | 0;
 } else if ((label | 0) == 6) {
  $23 = $7;
  $24 = $6;
  HEAP32[$24 >> 2] = $23;
  $$expand_i1_val2 = 1;
  HEAP8[$3 >> 0] = $$expand_i1_val2;
  $$pre_trunc = HEAP8[$3 >> 0] | 0;
  $25 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $25 | 0;
 }
 return 0 | 0;
}

function _mp_obj_str_get_data($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $5 = sp;
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = _mp_obj_is_qstr_1128($6) | 0;
 if (!$7) {
  $8 = $2;
  $9 = _mp_obj_is_obj_1154($8) | 0;
  if (!$9) {
   $29 = $2;
   _bad_implicit_conversion($29);
  }
  $10 = $2;
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = $11 + 24 | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = ($13 | 0) == (206 | 0);
  if (!$14) {
   $29 = $2;
   _bad_implicit_conversion($29);
  }
 }
 $15 = $2;
 $16 = _mp_obj_is_qstr_1128($15) | 0;
 $17 = $2;
 if ($16) {
  $18 = $17;
  $19 = $18 >>> 2;
  $20 = _qstr_data($19, $5) | 0;
  $4 = $20;
  $26 = HEAP32[$5 >> 2] | 0;
  $27 = $3;
  HEAP32[$27 >> 2] = $26;
  $28 = $4;
  STACKTOP = sp;
  return $28 | 0;
 } else {
  $21 = $17 + 8 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  HEAP32[$5 >> 2] = $22;
  $23 = $2;
  $24 = $23 + 12 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $4 = $25;
  $26 = HEAP32[$5 >> 2] | 0;
  $27 = $3;
  HEAP32[$27 >> 2] = $26;
  $28 = $4;
  STACKTOP = sp;
  return $28 | 0;
 }
 return 0 | 0;
}

function _fun_builtin_var_call($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $10 = sp;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $11 = $5;
 $9 = $11;
 $12 = $6;
 $13 = $7;
 $14 = $9;
 $15 = $14 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 _mp_arg_check_num_sig($12, $13, $16);
 $17 = $9;
 $18 = $17 + 4 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $19 & 1;
 $21 = ($20 | 0) != 0;
 if ($21) {
  $22 = $7;
  $23 = $8;
  $24 = $6;
  $25 = $23 + ($24 << 2) | 0;
  _mp_map_init_fixed_table($10, $22, $25);
  $26 = $9;
  $27 = $26 + 8 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = $6;
  $30 = $8;
  $31 = FUNCTION_TABLE_iiii[$28 & 1023]($29, $30, $10) | 0;
  $4 = $31;
  $38 = $4;
  STACKTOP = sp;
  return $38 | 0;
 } else {
  $32 = $9;
  $33 = $32 + 8 | 0;
  $34 = HEAP32[$33 >> 2] | 0;
  $35 = $6;
  $36 = $8;
  $37 = FUNCTION_TABLE_iii[$34 & 1023]($35, $36) | 0;
  $4 = $37;
  $38 = $4;
  STACKTOP = sp;
  return $38 | 0;
 }
 return 0 | 0;
}

function _mvlsb_setpixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $39 = 0, $4 = 0, $40 = 0, $41 = 0, $42 = 0, $43 = 0, $44 = 0, $45 = 0, $46 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $6;
 $11 = $10 >> 3;
 $12 = $4;
 $13 = $12 + 16 | 0;
 $14 = HEAP16[$13 >> 1] | 0;
 $15 = $14 & 65535;
 $16 = Math_imul($11, $15) | 0;
 $17 = $5;
 $18 = $16 + $17 | 0;
 $8 = $18;
 $19 = $6;
 $20 = $19 & 7;
 $21 = $20 & 255;
 $9 = $21;
 $22 = $4;
 $23 = $22 + 8 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $8;
 $26 = $24 + $25 | 0;
 $27 = HEAP8[$26 >> 0] | 0;
 $28 = $27 & 255;
 $29 = $9;
 $30 = $29 & 255;
 $31 = 1 << $30;
 $32 = $31 ^ -1;
 $33 = $28 & $32;
 $34 = $7;
 $35 = ($34 | 0) != 0;
 $36 = $35 & 1;
 $37 = $9;
 $38 = $37 & 255;
 $39 = $36 << $38;
 $40 = $33 | $39;
 $41 = $40 & 255;
 $42 = $4;
 $43 = $42 + 8 | 0;
 $44 = HEAP32[$43 >> 2] | 0;
 $45 = $8;
 $46 = $44 + $45 | 0;
 HEAP8[$46 >> 0] = $41;
 STACKTOP = sp;
 return;
}

function _mpz_set_from_int($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $6 = ($5 | 0) == 0;
 $7 = $2;
 if ($6) {
  $8 = $7 + 4 | 0;
  HEAP32[$8 >> 2] = 0;
  STACKTOP = sp;
  return;
 }
 _mpz_need_dig($7, 2);
 $9 = $3;
 $10 = ($9 | 0) < 0;
 $11 = $2;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $12 & -2;
 if ($10) {
  $14 = $13 | 1;
  HEAP32[$11 >> 2] = $14;
  $15 = $3;
  $16 = 0 - $15 | 0;
  $4 = $16;
 } else {
  HEAP32[$11 >> 2] = $13;
  $17 = $3;
  $4 = $17;
 }
 $18 = $2;
 $19 = $18 + 4 | 0;
 HEAP32[$19 >> 2] = 0;
 while (1) {
  $20 = $4;
  $21 = $20 >>> 0 > 0;
  if (!$21) {
   break;
  }
  $22 = $4;
  $23 = $22 & 65535;
  $24 = $23 & 65535;
  $25 = $2;
  $26 = $25 + 8 | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $28 = $2;
  $29 = $28 + 4 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  $31 = $30 + 1 | 0;
  HEAP32[$29 >> 2] = $31;
  $32 = $27 + ($30 << 1) | 0;
  HEAP16[$32 >> 1] = $24;
  $33 = $4;
  $34 = $33 >>> 16;
  $4 = $34;
 }
 STACKTOP = sp;
 return;
}

function _mp_obj_list_sort($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $3;
 $9 = $8 - 1 | 0;
 $10 = $4;
 $11 = $10 + 4 | 0;
 $12 = $5;
 _mp_arg_parse_all($9, $11, $12, 2, 3440, $6);
 $13 = $4;
 $14 = HEAP32[$13 >> 2] | 0;
 $7 = $14;
 $15 = $7;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $17 >>> 0 > 1;
 if (!$18) {
  STACKTOP = sp;
  return 17668 | 0;
 }
 $19 = $7;
 $20 = $19 + 12 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $7;
 $23 = $22 + 12 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $7;
 $26 = $25 + 8 | 0;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = $24 + ($27 << 2) | 0;
 $29 = $28 + -4 | 0;
 $30 = HEAP32[$6 >> 2] | 0;
 $31 = ($30 | 0) == (17668 | 0);
 $32 = HEAP32[$6 >> 2] | 0;
 $33 = $31 ? 0 : $32;
 $34 = $6 + 4 | 0;
 $35 = HEAP8[$34 >> 0] | 0;
 $36 = $35 & 1;
 $37 = $36 ? 13856 : 13864;
 _mp_quicksort($21, $29, $33, $37);
 STACKTOP = sp;
 return 17668 | 0;
}

function _utf8_get_char($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $5 = $2;
 $6 = $5 + 1 | 0;
 $2 = $6;
 $7 = HEAP8[$5 >> 0] | 0;
 $8 = $7 & 255;
 $3 = $8;
 $9 = $3;
 $10 = $9 & 128;
 $11 = ($10 | 0) != 0;
 $12 = $3;
 if (!$11) {
  $1 = $12;
  $37 = $1;
  STACKTOP = sp;
  return $37 | 0;
 }
 $13 = $12 & 127;
 $3 = $13;
 $4 = 64;
 while (1) {
  $14 = $3;
  $15 = $4;
  $16 = $14 & $15;
  $17 = ($16 | 0) != 0;
  if (!$17) {
   break;
  }
  $18 = $4;
  $19 = $18 ^ -1;
  $20 = $3;
  $21 = $20 & $19;
  $3 = $21;
  $22 = $4;
  $23 = $22 >>> 1;
  $4 = $23;
 }
 while (1) {
  $24 = $2;
  $25 = HEAP8[$24 >> 0] | 0;
  $26 = $25 & 255;
  $27 = $26 & 192;
  $28 = ($27 | 0) == 128;
  $29 = $3;
  if (!$28) {
   break;
  }
  $30 = $29 << 6;
  $31 = $2;
  $32 = $31 + 1 | 0;
  $2 = $32;
  $33 = HEAP8[$31 >> 0] | 0;
  $34 = $33 & 255;
  $35 = $34 & 63;
  $36 = $30 | $35;
  $3 = $36;
 }
 $1 = $29;
 $37 = $1;
 STACKTOP = sp;
 return $37 | 0;
}

function _stringio_copy_on_write($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = $3 + 4 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 $6 = $5 + 8 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $2 = $7;
 $8 = $1;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $12;
 $14 = _m_malloc($13) | 0;
 $15 = $1;
 $16 = $15 + 4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $17 + 8 | 0;
 HEAP32[$18 >> 2] = $14;
 $19 = $1;
 $20 = $19 + 4 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $21 + 8 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $2;
 $25 = $1;
 $26 = $25 + 4 | 0;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = $27 + 4 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 _memcpy($23 | 0, $24 | 0, $29 | 0) | 0;
 $30 = $1;
 $31 = $30 + 4 | 0;
 $32 = HEAP32[$31 >> 2] | 0;
 $33 = $32 + 12 | 0;
 $34 = HEAP8[$33 >> 0] | 0;
 $35 = $34 & -2;
 HEAP8[$33 >> 0] = $35;
 $36 = $1;
 $37 = $36 + 12 | 0;
 HEAP32[$37 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _uzlib_get_byte($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $5 = HEAP32[$4 >> 2] | 0;
 $6 = $2;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $5 >>> 0 < $8 >>> 0;
 $10 = $2;
 if ($9) {
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = $11 + 1 | 0;
  HEAP32[$10 >> 2] = $12;
  $13 = HEAP8[$11 >> 0] | 0;
  $1 = $13;
  $32 = $1;
  STACKTOP = sp;
  return $32 | 0;
 }
 $14 = $10 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = ($15 | 0) != (0 | 0);
 if ($16) {
  $17 = $2;
  $18 = $17 + 37 | 0;
  $19 = HEAP8[$18 >> 0] | 0;
  $20 = $19 & 1;
  if (!$20) {
   $21 = $2;
   $22 = $21 + 8 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   $24 = $2;
   $25 = FUNCTION_TABLE_ii[$23 & 1023]($24) | 0;
   $3 = $25;
   $26 = $3;
   $27 = ($26 | 0) >= 0;
   if ($27) {
    $28 = $3;
    $29 = $28 & 255;
    $1 = $29;
    $32 = $1;
    STACKTOP = sp;
    return $32 | 0;
   }
  }
 }
 $30 = $2;
 $31 = $30 + 37 | 0;
 HEAP8[$31 >> 0] = 1;
 $1 = 0;
 $32 = $1;
 STACKTOP = sp;
 return $32 | 0;
}

function _S($0) {
 $0 = +$0;
 var $$02330 = 0.0, $$02529 = 0.0, $$031 = 0, $$12433 = 0.0, $$12632 = 0.0, $$134 = 0, $$2 = 0.0, $$227 = 0.0, $1 = 0, $10 = 0, $11 = 0, $12 = 0.0, $13 = 0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0, $18 = 0.0, $19 = 0.0, $2 = 0.0, $20 = 0, $21 = 0.0, $3 = 0, $4 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0, $8 = 0.0, $9 = 0.0, $exitcond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = $0 < 8.0;
 if ($1) {
  $$02330 = 0.0;
  $$02529 = 0.0;
  $$031 = 12;
  while (1) {
   $2 = $$02529 * $0;
   $3 = 9776 + ($$031 << 3) | 0;
   $4 = +HEAPF64[$3 >> 3];
   $5 = $2 + $4;
   $6 = $$02330 * $0;
   $7 = 9888 + ($$031 << 3) | 0;
   $8 = +HEAPF64[$7 >> 3];
   $9 = $6 + $8;
   $10 = $$031 + -1 | 0;
   $11 = ($$031 | 0) == 0;
   if ($11) {
    $$2 = $9;
    $$227 = $5;
    break;
   } else {
    $$02330 = $9;
    $$02529 = $5;
    $$031 = $10;
   }
  }
 } else {
  $$12433 = 0.0;
  $$12632 = 0.0;
  $$134 = 0;
  while (1) {
   $12 = $$12632 / $0;
   $13 = 9776 + ($$134 << 3) | 0;
   $14 = +HEAPF64[$13 >> 3];
   $15 = $12 + $14;
   $16 = $$12433 / $0;
   $17 = 9888 + ($$134 << 3) | 0;
   $18 = +HEAPF64[$17 >> 3];
   $19 = $16 + $18;
   $20 = $$134 + 1 | 0;
   $exitcond = ($20 | 0) == 13;
   if ($exitcond) {
    $$2 = $19;
    $$227 = $15;
    break;
   } else {
    $$12433 = $19;
    $$12632 = $15;
    $$134 = $20;
   }
  }
 }
 $21 = $$227 / $$2;
 return +$21;
}

function ___stdio_seek($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_ptr1 = 0, $vararg_ptr2 = 0, $vararg_ptr3 = 0, $vararg_ptr4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp + 8 | 0;
 $4 = sp;
 $5 = $0 + 60 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $4;
 HEAP32[$vararg_buffer >> 2] = $6;
 $vararg_ptr1 = $vararg_buffer + 4 | 0;
 HEAP32[$vararg_ptr1 >> 2] = $2;
 $vararg_ptr2 = $vararg_buffer + 8 | 0;
 HEAP32[$vararg_ptr2 >> 2] = $1;
 $vararg_ptr3 = $vararg_buffer + 12 | 0;
 HEAP32[$vararg_ptr3 >> 2] = $7;
 $vararg_ptr4 = $vararg_buffer + 16 | 0;
 HEAP32[$vararg_ptr4 >> 2] = $3;
 $8 = ___syscall140(140, $vararg_buffer | 0) | 0;
 $9 = ___syscall_ret($8) | 0;
 $10 = ($9 | 0) < 0;
 if ($10) {
  $17 = $4;
  $18 = $17;
  HEAP32[$18 >> 2] = -1;
  $19 = $17 + 4 | 0;
  $20 = $19;
  HEAP32[$20 >> 2] = -1;
  $21 = -1;
  $22 = -1;
 } else {
  $11 = $4;
  $12 = $11;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = $11 + 4 | 0;
  $15 = $14;
  $16 = HEAP32[$15 >> 2] | 0;
  $21 = $16;
  $22 = $13;
 }
 setTempRet0($21 | 0);
 STACKTOP = sp;
 return $22 | 0;
}

function _emit_write_bytecode_byte_signed_label($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $3;
 $9 = $8 + 5 | 0;
 $10 = HEAPU8[$9 >> 0] | HEAPU8[$9 + 1 >> 0] << 8;
 $11 = $10 & 255;
 $12 = $11 & 65535;
 $13 = ($12 | 0) < 4;
 if ($13) {
  $6 = 0;
 } else {
  $14 = $3;
  $15 = $14 + 28 | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  $17 = $5;
  $18 = $16 + ($17 << 2) | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = $3;
  $21 = $20 + 40 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $19 - $22 | 0;
  $24 = $23 - 3 | 0;
  $25 = $24 + 32768 | 0;
  $6 = $25;
 }
 $26 = $3;
 $27 = _emit_get_cur_to_write_bytecode($26, 3) | 0;
 $7 = $27;
 $28 = $4;
 $29 = $7;
 HEAP8[$29 >> 0] = $28;
 $30 = $6;
 $31 = $30 & 255;
 $32 = $7;
 $33 = $32 + 1 | 0;
 HEAP8[$33 >> 0] = $31;
 $34 = $6;
 $35 = $34 >> 8;
 $36 = $35 & 255;
 $37 = $7;
 $38 = $37 + 2 | 0;
 HEAP8[$38 >> 0] = $36;
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_unwind_jump($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $5;
 $8 = ($7 | 0) == 0;
 $9 = $3;
 if (!$8) {
  $22 = $4;
  $23 = $22 & -32769;
  _emit_write_bytecode_byte_signed_label($9, 70, $23);
  $24 = $3;
  $25 = $4;
  $26 = $25 & 32768;
  $27 = ($26 | 0) != 0;
  $28 = $27 ? 128 : 0;
  $29 = $5;
  $30 = $28 | $29;
  $31 = $30 & 255;
  _emit_write_bytecode_byte($24, $31);
  STACKTOP = sp;
  return;
 }
 _emit_bc_pre($9, 0);
 $10 = $4;
 $11 = $10 & 32768;
 $12 = ($11 | 0) != 0;
 L5 : do {
  if ($12) {
   $13 = $3;
   _emit_write_bytecode_byte($13, 50);
   $6 = 0;
   while (1) {
    $14 = $6;
    $15 = $14 >>> 0 < 3;
    if (!$15) {
     break L5;
    }
    $16 = $3;
    _emit_write_bytecode_byte($16, 50);
    $17 = $6;
    $18 = $17 + 1 | 0;
    $6 = $18;
   }
  }
 } while (0);
 $19 = $3;
 $20 = $4;
 $21 = $20 & -32769;
 _emit_write_bytecode_byte_signed_label($19, 53, $21);
 STACKTOP = sp;
 return;
}

function _dict_popitem($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = sp + 20 | 0;
 $5 = sp + 8 | 0;
 $1 = $0;
 $7 = $1;
 $2 = $7;
 $8 = $2;
 _mp_ensure_not_fixed($8);
 HEAP32[$3 >> 2] = 0;
 $9 = $2;
 $10 = _dict_iter_next($9, $3) | 0;
 $4 = $10;
 $11 = $4;
 $12 = ($11 | 0) == (0 | 0);
 if ($12) {
  _mp_raise_msg(15592, 31055);
 } else {
  $13 = $2;
  $14 = $13 + 4 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $15 >>> 3;
  $17 = $16 + -1 | 0;
  $18 = HEAP32[$14 >> 2] | 0;
  $19 = $17 & 536870911;
  $20 = $19 << 3;
  $21 = $18 & 7;
  $22 = $21 | $20;
  HEAP32[$14 >> 2] = $22;
  $23 = $4;
  $24 = HEAP32[$23 >> 2] | 0;
  HEAP32[$5 >> 2] = $24;
  $25 = $5 + 4 | 0;
  $26 = $4;
  $27 = $26 + 4 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  HEAP32[$25 >> 2] = $28;
  $29 = $4;
  HEAP32[$29 >> 2] = 4;
  $30 = $4;
  $31 = $30 + 4 | 0;
  HEAP32[$31 >> 2] = 0;
  $32 = _mp_obj_new_tuple(2, $5) | 0;
  $6 = $32;
  $33 = $6;
  STACKTOP = sp;
  return $33 | 0;
 }
 return 0 | 0;
}

function _tanh($0) {
 $0 = +$0;
 var $$0 = 0.0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0, $26 = 0.0, $27 = 0.0, $3 = 0, $4 = 0.0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = $2 & 2147483647;
 HEAP32[tempDoublePtr >> 2] = $1;
 HEAP32[tempDoublePtr + 4 >> 2] = $3;
 $4 = +HEAPF64[tempDoublePtr >> 3];
 $5 = $3 >>> 0 > 1071748074;
 do {
  if ($5) {
   $6 = $3 >>> 0 > 1077149696;
   if ($6) {
    $7 = 0.0 / $4;
    $8 = 1.0 - $7;
    $$0 = $8;
    break;
   } else {
    $9 = $4 * 2.0;
    $10 = +_expm1($9);
    $11 = $10 + 2.0;
    $12 = 2.0 / $11;
    $13 = 1.0 - $12;
    $$0 = $13;
    break;
   }
  } else {
   $14 = $3 >>> 0 > 1070618798;
   if ($14) {
    $15 = $4 * 2.0;
    $16 = +_expm1($15);
    $17 = $16 + 2.0;
    $18 = $16 / $17;
    $$0 = $18;
    break;
   }
   $19 = $3 >>> 0 > 1048575;
   if ($19) {
    $20 = $4 * -2.0;
    $21 = +_expm1($20);
    $22 = -$21;
    $23 = $21 + 2.0;
    $24 = $22 / $23;
    $$0 = $24;
   } else {
    $$0 = $4;
   }
  }
 } while (0);
 $25 = ($2 | 0) < 0;
 $26 = -$$0;
 $27 = $25 ? $26 : $$0;
 return +$27;
}

function _mp_obj_str_get_buffer($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $8 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $9 = $6;
 $10 = ($9 | 0) == 1;
 if (!$10) {
  $29 = $5;
  HEAP32[$29 >> 2] = 0;
  $30 = $5;
  $31 = $30 + 4 | 0;
  HEAP32[$31 >> 2] = 0;
  $32 = $5;
  $33 = $32 + 8 | 0;
  HEAP32[$33 >> 2] = -1;
  $3 = 1;
  $34 = $3;
  STACKTOP = sp;
  return $34 | 0;
 }
 $11 = $4;
 $12 = _mp_obj_is_qstr_1128($11) | 0;
 $13 = $4;
 if ($12) {
  $14 = $13;
  $15 = $14 >>> 2;
  $16 = _qstr_data($15, $8) | 0;
  $7 = $16;
 } else {
  $17 = $13 + 8 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  HEAP32[$8 >> 2] = $18;
  $19 = $4;
  $20 = $19 + 12 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  $7 = $21;
 }
 $22 = $7;
 $23 = $5;
 HEAP32[$23 >> 2] = $22;
 $24 = HEAP32[$8 >> 2] | 0;
 $25 = $5;
 $26 = $25 + 4 | 0;
 HEAP32[$26 >> 2] = $24;
 $27 = $5;
 $28 = $27 + 8 | 0;
 HEAP32[$28 >> 2] = 66;
 $3 = 0;
 $34 = $3;
 STACKTOP = sp;
 return $34 | 0;
}

function _mp_obj_new_exception_msg($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = sp;
 $3 = $0;
 $4 = $1;
 $7 = _m_malloc_maybe(16) | 0;
 $5 = $7;
 $8 = $5;
 $9 = ($8 | 0) == (0 | 0);
 if ($9) {
  $10 = $3;
  $11 = _mp_obj_exception_make_new($10, 0, 0, 0) | 0;
  $2 = $11;
  $32 = $2;
  STACKTOP = sp;
  return $32 | 0;
 } else {
  $12 = $5;
  HEAP32[$12 >> 2] = 18680;
  $13 = $4;
  $14 = _strlen($13) | 0;
  $15 = $5;
  $16 = $15 + 8 | 0;
  HEAP32[$16 >> 2] = $14;
  $17 = $4;
  $18 = $5;
  $19 = $18 + 12 | 0;
  HEAP32[$19 >> 2] = $17;
  $20 = $5;
  $21 = $20 + 12 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $5;
  $24 = $23 + 8 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  $26 = _qstr_compute_hash($22, $25) | 0;
  $27 = $5;
  $28 = $27 + 4 | 0;
  HEAP32[$28 >> 2] = $26;
  $29 = $5;
  HEAP32[$6 >> 2] = $29;
  $30 = $3;
  $31 = _mp_obj_exception_make_new($30, 1, 0, $6) | 0;
  $2 = $31;
  $32 = $2;
  STACKTOP = sp;
  return $32 | 0;
 }
 return 0 | 0;
}

function _emit_get_cur_to_write_bytecode($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $3;
 $7 = $6 + 5 | 0;
 $8 = HEAPU8[$7 >> 0] | HEAPU8[$7 + 1 >> 0] << 8;
 $9 = $8 & 255;
 $10 = $9 & 65535;
 $11 = ($10 | 0) < 4;
 if ($11) {
  $12 = $4;
  $13 = $3;
  $14 = $13 + 40 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $15 + $12 | 0;
  HEAP32[$14 >> 2] = $16;
  $17 = $3;
  $2 = $17;
  $35 = $2;
  STACKTOP = sp;
  return $35 | 0;
 } else {
  $18 = $3;
  $19 = $18 + 48 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = $3;
  $22 = $21 + 36 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = $20 + $23 | 0;
  $25 = $3;
  $26 = $25 + 40 | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $28 = $24 + $27 | 0;
  $5 = $28;
  $29 = $4;
  $30 = $3;
  $31 = $30 + 40 | 0;
  $32 = HEAP32[$31 >> 2] | 0;
  $33 = $32 + $29 | 0;
  HEAP32[$31 >> 2] = $33;
  $34 = $5;
  $2 = $34;
  $35 = $2;
  STACKTOP = sp;
  return $35 | 0;
 }
 return 0 | 0;
}

function _mp_obj_new_module($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = 40612;
 $6 = $3;
 $7 = $2;
 $8 = $7 << 2;
 $9 = $8 | 2;
 $10 = $9;
 $11 = _mp_map_lookup($6, $10, 1) | 0;
 $4 = $11;
 $12 = $4;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = ($14 | 0) != (0 | 0);
 if ($15) {
  $16 = $4;
  $17 = $16 + 4 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $1 = $18;
  $35 = $1;
  STACKTOP = sp;
  return $35 | 0;
 } else {
  $19 = _m_malloc(8) | 0;
  $5 = $19;
  $20 = $5;
  HEAP32[$20 >> 2] = 17264;
  $21 = _mp_obj_new_dict(1) | 0;
  $22 = $5;
  $23 = $22 + 4 | 0;
  HEAP32[$23 >> 2] = $21;
  $24 = $5;
  $25 = $24 + 4 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $2;
  $28 = $27 << 2;
  $29 = $28 | 2;
  $30 = $29;
  _mp_obj_dict_store($26, 94, $30) | 0;
  $31 = $5;
  $32 = $4;
  $33 = $32 + 4 | 0;
  HEAP32[$33 >> 2] = $31;
  $34 = $5;
  $1 = $34;
  $35 = $1;
  STACKTOP = sp;
  return $35 | 0;
 }
 return 0 | 0;
}

function _array_new($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $38 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = _mp_binary_get_size(64, $6, 0) | 0;
 $4 = $7;
 $8 = _m_malloc(16) | 0;
 $5 = $8;
 $9 = $2;
 $10 = $9 << 24 >> 24;
 $11 = ($10 | 0) == 1;
 $12 = $11 ? 13584 : 13644;
 $13 = $5;
 HEAP32[$13 >> 2] = $12;
 $14 = $2;
 $15 = $14 << 24 >> 24;
 $16 = $5;
 $17 = $16 + 4 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $15 & 255;
 $20 = $18 & -256;
 $21 = $20 | $19;
 HEAP32[$17 >> 2] = $21;
 $22 = $5;
 $23 = $22 + 4 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $24 & 255;
 HEAP32[$23 >> 2] = $25;
 $26 = $3;
 $27 = $5;
 $28 = $27 + 8 | 0;
 HEAP32[$28 >> 2] = $26;
 $29 = $4;
 $30 = $5;
 $31 = $30 + 8 | 0;
 $32 = HEAP32[$31 >> 2] | 0;
 $33 = Math_imul($29, $32) | 0;
 $34 = $33;
 $35 = _m_malloc($34) | 0;
 $36 = $5;
 $37 = $36 + 12 | 0;
 HEAP32[$37 >> 2] = $35;
 $38 = $5;
 STACKTOP = sp;
 return $38 | 0;
}

function _push_result_node($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = $5 + 16 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $2;
 $9 = $8 + 12 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $7 >>> 0 >= $10 >>> 0;
 if ($11) {
  $12 = $2;
  $13 = $12 + 20 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = $2;
  $16 = $15 + 12 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = $17 + 16 | 0;
  $19 = $18 << 2;
  $20 = _m_realloc($14, $19) | 0;
  $4 = $20;
  $21 = $4;
  $22 = $2;
  $23 = $22 + 20 | 0;
  HEAP32[$23 >> 2] = $21;
  $24 = $2;
  $25 = $24 + 12 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $26 + 16 | 0;
  HEAP32[$25 >> 2] = $27;
 }
 $28 = $3;
 $29 = $2;
 $30 = $29 + 20 | 0;
 $31 = HEAP32[$30 >> 2] | 0;
 $32 = $2;
 $33 = $32 + 16 | 0;
 $34 = HEAP32[$33 >> 2] | 0;
 $35 = $34 + 1 | 0;
 HEAP32[$33 >> 2] = $35;
 $36 = $31 + ($34 << 2) | 0;
 HEAP32[$36 >> 2] = $28;
 STACKTOP = sp;
 return;
}

function _emit_write_bytecode_byte_unsigned_label($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $3;
 $9 = $8 + 5 | 0;
 $10 = HEAPU8[$9 >> 0] | HEAPU8[$9 + 1 >> 0] << 8;
 $11 = $10 & 255;
 $12 = $11 & 65535;
 $13 = ($12 | 0) < 4;
 if ($13) {
  $6 = 0;
 } else {
  $14 = $3;
  $15 = $14 + 28 | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  $17 = $5;
  $18 = $16 + ($17 << 2) | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = $3;
  $21 = $20 + 40 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $19 - $22 | 0;
  $24 = $23 - 3 | 0;
  $6 = $24;
 }
 $25 = $3;
 $26 = _emit_get_cur_to_write_bytecode($25, 3) | 0;
 $7 = $26;
 $27 = $4;
 $28 = $7;
 HEAP8[$28 >> 0] = $27;
 $29 = $6;
 $30 = $29 & 255;
 $31 = $7;
 $32 = $31 + 1 | 0;
 HEAP8[$32 >> 0] = $30;
 $33 = $6;
 $34 = $33 >>> 8;
 $35 = $34 & 255;
 $36 = $7;
 $37 = $36 + 2 | 0;
 HEAP8[$37 >> 0] = $35;
 STACKTOP = sp;
 return;
}

function _super_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $9 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $5;
 $11 = $6;
 _mp_arg_check_num_1267($10, $11, 2, 2, 0);
 $12 = $7;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = _mp_obj_is_obj_1260($13) | 0;
 if (!$14) {
  _mp_raise_TypeError(0);
 }
 $15 = $7;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = ($17 | 0) == (19048 | 0);
 if ($18) {
  $19 = _m_malloc(12) | 0;
  $8 = $19;
  $20 = $8;
  $21 = $4;
  HEAP32[$9 >> 2] = $21;
  $22 = $9 + 4 | 0;
  $23 = $7;
  $24 = HEAP32[$23 >> 2] | 0;
  HEAP32[$22 >> 2] = $24;
  $25 = $9 + 8 | 0;
  $26 = $7;
  $27 = $26 + 4 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  HEAP32[$25 >> 2] = $28;
  HEAP32[$20 >> 2] = HEAP32[$9 >> 2] | 0;
  HEAP32[$20 + 4 >> 2] = HEAP32[$9 + 4 >> 2] | 0;
  HEAP32[$20 + 8 >> 2] = HEAP32[$9 + 8 >> 2] | 0;
  $29 = $8;
  STACKTOP = sp;
  return $29 | 0;
 } else {
  _mp_raise_TypeError(0);
 }
 return 0 | 0;
}

function _mp_emit_bc_make_closure($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $9 = $4;
 $10 = $8;
 $11 = ($10 | 0) == 0;
 $12 = $9;
 $13 = ($12 | 0) == 0;
 $or$cond = $11 & $13;
 $14 = $5;
 $15 = $7;
 if ($or$cond) {
  $16 = 0 - $15 | 0;
  $17 = $16 + 1 | 0;
  _emit_bc_pre($14, $17);
  $18 = $5;
  $19 = $6;
  $20 = $19 + 16 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  _emit_write_bytecode_byte_raw_code($18, 98, $21);
  $22 = $5;
  $23 = $7;
  $24 = $23 & 255;
  _emit_write_bytecode_byte($22, $24);
  STACKTOP = sp;
  return;
 } else {
  $25 = -2 - $15 | 0;
  $26 = $25 + 1 | 0;
  _emit_bc_pre($14, $26);
  $27 = $5;
  $28 = $6;
  $29 = $28 + 16 | 0;
  $30 = HEAP32[$29 >> 2] | 0;
  _emit_write_bytecode_byte_raw_code($27, 99, $30);
  $31 = $5;
  $32 = $7;
  $33 = $32 & 255;
  _emit_write_bytecode_byte($31, $33);
  STACKTOP = sp;
  return;
 }
}

function _uni_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = sp;
 $3 = $0;
 $4 = $1;
 $7 = $4;
 $8 = _mp_obj_is_qstr_1200($7) | 0;
 $9 = $4;
 if ($8) {
  $10 = $9;
  $11 = $10 >>> 2;
  $12 = _qstr_data($11, $6) | 0;
  $5 = $12;
 } else {
  $13 = $9 + 8 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  HEAP32[$6 >> 2] = $14;
  $15 = $4;
  $16 = $15 + 12 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $5 = $17;
 }
 $18 = $3;
 switch ($18 | 0) {
 case 4:
  {
   $19 = HEAP32[$6 >> 2] | 0;
   $20 = ($19 | 0) != 0;
   $21 = $20 & 1;
   $22 = _mp_obj_new_bool_1208($21) | 0;
   $2 = $22;
   $29 = $2;
   STACKTOP = sp;
   return $29 | 0;
   break;
  }
 case 5:
  {
   $23 = $5;
   $24 = HEAP32[$6 >> 2] | 0;
   $25 = _utf8_charlen($23, $24) | 0;
   $26 = $25 << 1;
   $27 = $26 | 1;
   $28 = $27;
   $2 = $28;
   $29 = $2;
   STACKTOP = sp;
   return $29 | 0;
   break;
  }
 default:
  {
   $2 = 0;
   $29 = $2;
   STACKTOP = sp;
   return $29 | 0;
  }
 }
 return 0 | 0;
}

function _gc_free($0) {
 $0 = $0 | 0;
 var $$0 = 0, $$pre = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = HEAP16[41020 >> 1] | 0;
 $2 = $1 << 16 >> 16 != 0;
 $3 = ($0 | 0) == (0 | 0);
 $or$cond = $3 | $2;
 if ($or$cond) {
  return;
 }
 $4 = HEAP32[40752 >> 2] | 0;
 $5 = $0;
 $6 = $5 - $4 | 0;
 $7 = $6 >>> 4;
 $8 = $6 >>> 6;
 $9 = HEAP32[41032 >> 2] | 0;
 $10 = $8 >>> 0 < $9 >>> 0;
 if ($10) {
  HEAP32[41032 >> 2] = $8;
 }
 $$pre = HEAP32[40744 >> 2] | 0;
 $$0 = $7;
 $17 = $$pre;
 while (1) {
  $11 = $$0 << 1;
  $12 = $11 & 6;
  $13 = 3 << $12;
  $14 = $13 ^ 255;
  $15 = $$0 >>> 2;
  $16 = $17 + $15 | 0;
  $18 = HEAP8[$16 >> 0] | 0;
  $19 = $18 & 255;
  $20 = $14 & $19;
  $21 = $20 & 255;
  HEAP8[$16 >> 0] = $21;
  $22 = $$0 + 1 | 0;
  $23 = HEAP32[40744 >> 2] | 0;
  $24 = $22 >>> 2;
  $25 = $23 + $24 | 0;
  $26 = HEAP8[$25 >> 0] | 0;
  $27 = $26 & 255;
  $28 = $22 << 1;
  $29 = $28 & 6;
  $30 = $27 >>> $29;
  $31 = $30 & 3;
  $32 = ($31 | 0) == 2;
  if ($32) {
   $$0 = $22;
   $17 = $23;
  } else {
   break;
  }
 }
 return;
}

function _uctypes_struct_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $5;
 $10 = $6;
 _mp_arg_check_num_1479($9, $10, 2, 3, 0);
 $11 = _m_malloc(16) | 0;
 $8 = $11;
 $12 = $4;
 $13 = $8;
 HEAP32[$13 >> 2] = $12;
 $14 = $7;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = _mp_obj_int_get_truncated($15) | 0;
 $17 = $16;
 $18 = $8;
 $19 = $18 + 8 | 0;
 HEAP32[$19 >> 2] = $17;
 $20 = $7;
 $21 = $20 + 4 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = $8;
 $24 = $23 + 4 | 0;
 HEAP32[$24 >> 2] = $22;
 $25 = $8;
 $26 = $25 + 12 | 0;
 HEAP32[$26 >> 2] = 2;
 $27 = $5;
 $28 = ($27 | 0) == 3;
 if (!$28) {
  $35 = $8;
  STACKTOP = sp;
  return $35 | 0;
 }
 $29 = $7;
 $30 = $29 + 8 | 0;
 $31 = HEAP32[$30 >> 2] | 0;
 $32 = _mp_obj_get_int($31) | 0;
 $33 = $8;
 $34 = $33 + 12 | 0;
 HEAP32[$34 >> 2] = $32;
 $35 = $8;
 STACKTOP = sp;
 return $35 | 0;
}

function _mp_obj_new_tuple($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $7 = $3;
 $8 = ($7 | 0) == 0;
 if ($8) {
  $2 = 18944;
  $33 = $2;
  STACKTOP = sp;
  return $33 | 0;
 }
 $9 = $3;
 $10 = $9 << 2;
 $11 = 8 + $10 | 0;
 $12 = _m_malloc($11) | 0;
 $5 = $12;
 $13 = $5;
 HEAP32[$13 >> 2] = 18952;
 $14 = $3;
 $15 = $5;
 $16 = $15 + 4 | 0;
 HEAP32[$16 >> 2] = $14;
 $17 = $4;
 $18 = ($17 | 0) != (0 | 0);
 L5 : do {
  if ($18) {
   $6 = 0;
   while (1) {
    $19 = $6;
    $20 = $3;
    $21 = $19 >>> 0 < $20 >>> 0;
    if (!$21) {
     break L5;
    }
    $22 = $4;
    $23 = $6;
    $24 = $22 + ($23 << 2) | 0;
    $25 = HEAP32[$24 >> 2] | 0;
    $26 = $5;
    $27 = $26 + 8 | 0;
    $28 = $6;
    $29 = $27 + ($28 << 2) | 0;
    HEAP32[$29 >> 2] = $25;
    $30 = $6;
    $31 = $30 + 1 | 0;
    $6 = $31;
   }
  }
 } while (0);
 $32 = $5;
 $2 = $32;
 $33 = $2;
 STACKTOP = sp;
 return $33 | 0;
}

function _reversed_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $9 = sp + 8 | 0;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $11 = $6;
 $12 = $7;
 _mp_arg_check_num_1102($11, $12, 1, 1, 0);
 $13 = $8;
 $14 = HEAP32[$13 >> 2] | 0;
 _mp_load_method_maybe($14, 199, $9);
 $15 = HEAP32[$9 >> 2] | 0;
 $16 = ($15 | 0) != (0 | 0);
 if ($16) {
  $17 = _mp_call_method_n_kw(0, 0, $9) | 0;
  $4 = $17;
  $32 = $4;
  STACKTOP = sp;
  return $32 | 0;
 } else {
  $18 = _m_malloc(12) | 0;
  $10 = $18;
  $19 = $5;
  $20 = $10;
  HEAP32[$20 >> 2] = $19;
  $21 = $8;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $10;
  $24 = $23 + 4 | 0;
  HEAP32[$24 >> 2] = $22;
  $25 = $8;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = _mp_obj_len($26) | 0;
  $28 = _mp_obj_get_int($27) | 0;
  $29 = $10;
  $30 = $29 + 8 | 0;
  HEAP32[$30 >> 2] = $28;
  $31 = $10;
  $4 = $31;
  $32 = $4;
  STACKTOP = sp;
  return $32 | 0;
 }
 return 0 | 0;
}

function _gc_nbytes($0) {
 $0 = $0 | 0;
 var $$016 = 0, $$1 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = $0;
 $2 = $1 & 15;
 $3 = ($2 | 0) == 0;
 if (!$3) {
  $$1 = 0;
  return $$1 | 0;
 }
 $4 = HEAP32[40752 >> 2] | 0;
 $5 = $4 >>> 0 <= $0 >>> 0;
 $6 = HEAP32[40756 >> 2] | 0;
 $7 = $6 >>> 0 > $0 >>> 0;
 $or$cond = $5 & $7;
 if (!$or$cond) {
  $$1 = 0;
  return $$1 | 0;
 }
 $8 = $4;
 $9 = $1 - $8 | 0;
 $10 = $9 >>> 4;
 $11 = HEAP32[40744 >> 2] | 0;
 $12 = $9 >>> 6;
 $13 = $11 + $12 | 0;
 $14 = HEAP8[$13 >> 0] | 0;
 $15 = $14 & 255;
 $16 = $10 << 1;
 $17 = $16 & 6;
 $18 = $15 >>> $17;
 $19 = $18 & 3;
 $20 = ($19 | 0) == 1;
 if (!$20) {
  $$1 = 0;
  return $$1 | 0;
 }
 $$016 = 0;
 while (1) {
  $21 = $$016 + 1 | 0;
  $22 = $21 + $10 | 0;
  $23 = $22 >>> 2;
  $24 = $11 + $23 | 0;
  $25 = HEAP8[$24 >> 0] | 0;
  $26 = $25 & 255;
  $27 = $22 << 1;
  $28 = $27 & 6;
  $29 = $26 >>> $28;
  $30 = $29 & 3;
  $31 = ($30 | 0) == 2;
  if ($31) {
   $$016 = $21;
  } else {
   break;
  }
 }
 $32 = $21 << 4;
 $$1 = $32;
 return $$1 | 0;
}

function _compile_break_cont_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $8 & 255;
 $10 = ($9 | 0) == 9;
 $11 = $2;
 if ($10) {
  $12 = $11 + 24 | 0;
  $13 = HEAP16[$12 >> 1] | 0;
  $4 = $13;
  $5 = 29360;
 } else {
  $14 = $11 + 26 | 0;
  $15 = HEAP16[$14 >> 1] | 0;
  $4 = $15;
  $5 = 29381;
 }
 $16 = $4;
 $17 = $16 & 65535;
 $18 = ($17 | 0) == 65535;
 if ($18) {
  $19 = $2;
  $20 = $3;
  $21 = $20;
  $22 = $5;
  _compile_syntax_error($19, $21, $22);
 }
 $23 = $2;
 $24 = $23 + 40 | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = $4;
 $27 = $26 & 65535;
 $28 = $2;
 $29 = $28 + 28 | 0;
 $30 = HEAP16[$29 >> 1] | 0;
 $31 = $30 & 65535;
 $32 = $2;
 $33 = $32 + 30 | 0;
 $34 = HEAP16[$33 >> 1] | 0;
 $35 = $34 & 65535;
 $36 = $31 - $35 | 0;
 _mp_emit_bc_unwind_jump($25, $27, $36);
 STACKTOP = sp;
 return;
}

function _sha256_init($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 64 | 0;
 HEAP32[$3 >> 2] = 0;
 $4 = $1;
 $5 = $4 + 72 | 0;
 $6 = $5;
 $7 = $6;
 HEAP32[$7 >> 2] = 0;
 $8 = $6 + 4 | 0;
 $9 = $8;
 HEAP32[$9 >> 2] = 0;
 $10 = $1;
 $11 = $10 + 80 | 0;
 HEAP32[$11 >> 2] = 1779033703;
 $12 = $1;
 $13 = $12 + 80 | 0;
 $14 = $13 + 4 | 0;
 HEAP32[$14 >> 2] = -1150833019;
 $15 = $1;
 $16 = $15 + 80 | 0;
 $17 = $16 + 8 | 0;
 HEAP32[$17 >> 2] = 1013904242;
 $18 = $1;
 $19 = $18 + 80 | 0;
 $20 = $19 + 12 | 0;
 HEAP32[$20 >> 2] = -1521486534;
 $21 = $1;
 $22 = $21 + 80 | 0;
 $23 = $22 + 16 | 0;
 HEAP32[$23 >> 2] = 1359893119;
 $24 = $1;
 $25 = $24 + 80 | 0;
 $26 = $25 + 20 | 0;
 HEAP32[$26 >> 2] = -1694144372;
 $27 = $1;
 $28 = $27 + 80 | 0;
 $29 = $28 + 24 | 0;
 HEAP32[$29 >> 2] = 528734635;
 $30 = $1;
 $31 = $30 + 80 | 0;
 $32 = $31 + 28 | 0;
 HEAP32[$32 >> 2] = 1541459225;
 STACKTOP = sp;
 return;
}

function _mp_obj_str_format($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $7 = sp + 20 | 0;
 $8 = sp + 16 | 0;
 $9 = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $10 = $4;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = _mp_obj_is_qstr_1128($11) | 0;
 $13 = $4;
 $14 = HEAP32[$13 >> 2] | 0;
 if ($12) {
  $15 = $14;
  $16 = $15 >>> 2;
  $17 = _qstr_data($16, $7) | 0;
  $6 = $17;
 } else {
  $18 = $14 + 8 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  HEAP32[$7 >> 2] = $19;
  $20 = $4;
  $21 = HEAP32[$20 >> 2] | 0;
  $22 = $21 + 12 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $6 = $23;
 }
 HEAP32[$8 >> 2] = 0;
 $24 = $6;
 $25 = $6;
 $26 = HEAP32[$7 >> 2] | 0;
 $27 = $25 + $26 | 0;
 $28 = $3;
 $29 = $4;
 $30 = $5;
 _mp_obj_str_format_helper($9, $24, $27, $8, $28, $29, $30);
 $31 = $4;
 $32 = HEAP32[$31 >> 2] | 0;
 $33 = _mp_obj_get_type($32) | 0;
 $34 = _mp_obj_new_str_from_vstr($33, $9) | 0;
 STACKTOP = sp;
 return $34 | 0;
}

function _compile_async_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = $6 + 8 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $8;
 $4 = $9;
 $10 = $4;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $12 & 255;
 $14 = ($13 | 0) == 3;
 if ($14) {
  $15 = $2;
  $16 = $4;
  _compile_funcdef($15, $16);
  $17 = $4;
  $18 = $17 + 8 | 0;
  $19 = $18 + 16 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = $20;
  $5 = $21;
  $22 = $5;
  $23 = $22 + 24 | 0;
  $24 = HEAP16[$23 >> 1] | 0;
  $25 = $24 & 65535;
  $26 = $25 | 4;
  $27 = $26 & 65535;
  HEAP16[$23 >> 1] = $27;
  STACKTOP = sp;
  return;
 }
 $28 = $4;
 $29 = $28 + 4 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = $30 & 255;
 $32 = ($31 | 0) == 22;
 $33 = $2;
 $34 = $4;
 if ($32) {
  _compile_async_for_stmt($33, $34);
  STACKTOP = sp;
  return;
 } else {
  _compile_async_with_stmt($33, $34);
  STACKTOP = sp;
  return;
 }
}

function _indent_push($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 48 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $2;
 $8 = $7 + 44 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $6 >>> 0 >= $9 >>> 0;
 if ($10) {
  $11 = $2;
  $12 = $11 + 52 | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = $2;
  $15 = $14 + 44 | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  $17 = $16 + 8 | 0;
  $18 = $17 << 1;
  $19 = _m_realloc($13, $18) | 0;
  $20 = $2;
  $21 = $20 + 52 | 0;
  HEAP32[$21 >> 2] = $19;
  $22 = $2;
  $23 = $22 + 44 | 0;
  $24 = HEAP32[$23 >> 2] | 0;
  $25 = $24 + 8 | 0;
  HEAP32[$23 >> 2] = $25;
 }
 $26 = $3;
 $27 = $26 & 65535;
 $28 = $2;
 $29 = $28 + 52 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = $2;
 $32 = $31 + 48 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = $33 + 1 | 0;
 HEAP32[$32 >> 2] = $34;
 $35 = $30 + ($33 << 1) | 0;
 HEAP16[$35 >> 1] = $27;
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_set_source_line($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = HEAP32[40736 >> 2] | 0;
 $7 = $6 >>> 0 >= 3;
 if ($7) {
  STACKTOP = sp;
  return;
 }
 $8 = $3;
 $9 = $2;
 $10 = $9 + 20 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $8 >>> 0 > $11 >>> 0;
 if (!$12) {
  STACKTOP = sp;
  return;
 }
 $13 = $2;
 $14 = $13 + 40 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $2;
 $17 = $16 + 16 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $15 - $18 | 0;
 $4 = $19;
 $20 = $3;
 $21 = $2;
 $22 = $21 + 20 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $20 - $23 | 0;
 $5 = $24;
 $25 = $2;
 $26 = $4;
 $27 = $5;
 _emit_write_code_info_bytes_lines($25, $26, $27);
 $28 = $2;
 $29 = $28 + 40 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = $2;
 $32 = $31 + 16 | 0;
 HEAP32[$32 >> 2] = $30;
 $33 = $3;
 $34 = $2;
 $35 = $34 + 20 | 0;
 HEAP32[$35 >> 2] = $33;
 STACKTOP = sp;
 return;
}

function _gc_collect_root($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$019 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $exitcond = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = ($1 | 0) == 0;
 if ($2) {
  return;
 }
 $$019 = 0;
 while (1) {
  $3 = $0 + ($$019 << 2) | 0;
  $4 = HEAP32[$3 >> 2] | 0;
  $5 = $4;
  $6 = $5 & 15;
  $7 = ($6 | 0) == 0;
  if ($7) {
   $8 = HEAP32[40752 >> 2] | 0;
   $9 = $4 >>> 0 >= $8 >>> 0;
   $10 = HEAP32[40756 >> 2] | 0;
   $11 = $4 >>> 0 < $10 >>> 0;
   $or$cond = $9 & $11;
   if ($or$cond) {
    $12 = $8;
    $13 = $5 - $12 | 0;
    $14 = $13 >>> 4;
    $15 = HEAP32[40744 >> 2] | 0;
    $16 = $13 >>> 6;
    $17 = $15 + $16 | 0;
    $18 = HEAP8[$17 >> 0] | 0;
    $19 = $18 & 255;
    $20 = $14 << 1;
    $21 = $20 & 6;
    $22 = $19 >>> $21;
    $23 = $22 & 3;
    $24 = ($23 | 0) == 1;
    if ($24) {
     $25 = 3 << $21;
     $26 = $25 | $19;
     $27 = $26 & 255;
     HEAP8[$17 >> 0] = $27;
     _gc_mark_subtree($14);
    }
   }
  }
  $28 = $$019 + 1 | 0;
  $exitcond = ($28 | 0) == ($1 | 0);
  if ($exitcond) {
   break;
  } else {
   $$019 = $28;
  }
 }
 return;
}

function _vstr_ensure_extra($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $3;
 $10 = $8 + $9 | 0;
 $11 = $2;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $10 >>> 0 > $12 >>> 0;
 if (!$13) {
  STACKTOP = sp;
  return;
 }
 $14 = $2;
 $15 = $14 + 12 | 0;
 $16 = HEAP8[$15 >> 0] | 0;
 $17 = $16 & 1;
 $18 = $17 & 1;
 if ($18) {
  _mp_raise_msg(15772, 0);
 }
 $19 = $2;
 $20 = $19 + 4 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $3;
 $23 = $21 + $22 | 0;
 $24 = $23 + 16 | 0;
 $25 = $24 & -8;
 $26 = $25 + 8 | 0;
 $4 = $26;
 $27 = $2;
 $28 = $27 + 8 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = $4;
 $31 = $30;
 $32 = _m_realloc($29, $31) | 0;
 $5 = $32;
 $33 = $4;
 $34 = $2;
 HEAP32[$34 >> 2] = $33;
 $35 = $5;
 $36 = $2;
 $37 = $36 + 8 | 0;
 HEAP32[$37 >> 2] = $35;
 STACKTOP = sp;
 return;
}

function _range_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $5;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) != (0 | 0);
 if ($9) {
  STACKTOP = sp;
  return;
 }
 $10 = $3;
 $6 = $10;
 $11 = $4;
 $12 = ($11 | 0) == 146;
 if ($12) {
  $13 = $6;
  $14 = $13 + 4 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = _mp_obj_new_int($15) | 0;
  $17 = $5;
  HEAP32[$17 >> 2] = $16;
  STACKTOP = sp;
  return;
 }
 $18 = $4;
 $19 = ($18 | 0) == 150;
 if ($19) {
  $20 = $6;
  $21 = $20 + 8 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = _mp_obj_new_int($22) | 0;
  $24 = $5;
  HEAP32[$24 >> 2] = $23;
  STACKTOP = sp;
  return;
 }
 $25 = $4;
 $26 = ($25 | 0) == 149;
 if (!$26) {
  STACKTOP = sp;
  return;
 }
 $27 = $6;
 $28 = $27 + 12 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = _mp_obj_new_int($29) | 0;
 $31 = $5;
 HEAP32[$31 >> 2] = $30;
 STACKTOP = sp;
 return;
}

function _mp_get_buffer($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$expand_i1_val4 = 0, $$pre_trunc = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = sp + 20 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $9 = $4;
 $10 = _mp_obj_get_type($9) | 0;
 $7 = $10;
 $11 = $7;
 $12 = $11 + 44 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = ($13 | 0) == (0 | 0);
 do {
  if ($14) {
   $$expand_i1_val = 0;
   HEAP8[$3 >> 0] = $$expand_i1_val;
  } else {
   $15 = $7;
   $16 = $15 + 44 | 0;
   $17 = HEAP32[$16 >> 2] | 0;
   $18 = $4;
   $19 = $5;
   $20 = $6;
   $21 = FUNCTION_TABLE_iiii[$17 & 1023]($18, $19, $20) | 0;
   $8 = $21;
   $22 = $8;
   $23 = ($22 | 0) != 0;
   if ($23) {
    $$expand_i1_val2 = 0;
    HEAP8[$3 >> 0] = $$expand_i1_val2;
    break;
   } else {
    $$expand_i1_val4 = 1;
    HEAP8[$3 >> 0] = $$expand_i1_val4;
    break;
   }
  }
 } while (0);
 $$pre_trunc = HEAP8[$3 >> 0] | 0;
 $24 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $24 | 0;
}

function _compile_increase_except_level($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $6 + 40 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $4;
 $10 = $5;
 _mp_emit_bc_setup_block($8, $9, $10);
 $11 = $3;
 $12 = $11 + 28 | 0;
 $13 = HEAP16[$12 >> 1] | 0;
 $14 = $13 & 65535;
 $15 = $14 + 1 | 0;
 $16 = $15 & 65535;
 HEAP16[$12 >> 1] = $16;
 $17 = $3;
 $18 = $17 + 28 | 0;
 $19 = HEAP16[$18 >> 1] | 0;
 $20 = $19 & 65535;
 $21 = $3;
 $22 = $21 + 36 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $23 + 38 | 0;
 $25 = HEAP16[$24 >> 1] | 0;
 $26 = $25 & 65535;
 $27 = ($20 | 0) > ($26 | 0);
 if (!$27) {
  STACKTOP = sp;
  return;
 }
 $28 = $3;
 $29 = $28 + 28 | 0;
 $30 = HEAP16[$29 >> 1] | 0;
 $31 = $3;
 $32 = $31 + 36 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 $34 = $33 + 38 | 0;
 HEAP16[$34 >> 1] = $30;
 STACKTOP = sp;
 return;
}

function _mp_obj_attrtuple_print_helper($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 _mp_print_str($7, 32985) | 0;
 $6 = 0;
 while (1) {
  $8 = $6;
  $9 = $5;
  $10 = $9 + 4 | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = $8 >>> 0 < $11 >>> 0;
  if (!$12) {
   break;
  }
  $13 = $6;
  $14 = $13 >>> 0 > 0;
  if ($14) {
   $15 = $3;
   _mp_print_str($15, 33327) | 0;
  }
  $16 = $3;
  $17 = $4;
  $18 = $6;
  $19 = $17 + ($18 << 2) | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  HEAP32[$vararg_buffer >> 2] = $20;
  _mp_printf($16, 30852, $vararg_buffer) | 0;
  $21 = $3;
  $22 = $5;
  $23 = $22 + 8 | 0;
  $24 = $6;
  $25 = $23 + ($24 << 2) | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  _mp_obj_print_helper($21, $26, 1);
  $27 = $6;
  $28 = $27 + 1 | 0;
  $6 = $28;
 }
 $29 = $3;
 _mp_print_str($29, 32991) | 0;
 STACKTOP = sp;
 return;
}

function _readline_push_history($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $4 = $1;
 $5 = HEAP8[$4 >> 0] | 0;
 $6 = $5 << 24 >> 24;
 $7 = ($6 | 0) != 0;
 if (!$7) {
  STACKTOP = sp;
  return;
 }
 $8 = HEAP32[40688 >> 2] | 0;
 $9 = ($8 | 0) == (0 | 0);
 if (!$9) {
  $10 = HEAP32[40688 >> 2] | 0;
  $11 = $1;
  $12 = _strcmp($10, $11) | 0;
  $13 = ($12 | 0) != 0;
  if (!$13) {
   STACKTOP = sp;
   return;
  }
 }
 $14 = $1;
 $15 = _str_dup_maybe($14) | 0;
 $2 = $15;
 $16 = $2;
 $17 = ($16 | 0) != (0 | 0);
 if (!$17) {
  STACKTOP = sp;
  return;
 }
 $3 = 7;
 while (1) {
  $18 = $3;
  $19 = ($18 | 0) > 0;
  if (!$19) {
   break;
  }
  $20 = $3;
  $21 = $20 - 1 | 0;
  $22 = 40688 + ($21 << 2) | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = $3;
  $25 = 40688 + ($24 << 2) | 0;
  HEAP32[$25 >> 2] = $23;
  $26 = $3;
  $27 = $26 + -1 | 0;
  $3 = $27;
 }
 $28 = $2;
 HEAP32[40688 >> 2] = $28;
 STACKTOP = sp;
 return;
}

function _mp_store_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_ptr1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $7 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $3;
 $9 = _mp_obj_get_type($8) | 0;
 $6 = $9;
 $10 = $6;
 $11 = $10 + 28 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = ($12 | 0) != (0 | 0);
 if ($13) {
  HEAP32[$7 >> 2] = 4;
  $14 = $7 + 4 | 0;
  $15 = $5;
  HEAP32[$14 >> 2] = $15;
  $16 = $6;
  $17 = $16 + 28 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = $3;
  $20 = $4;
  FUNCTION_TABLE_viii[$18 & 1023]($19, $20, $7);
  $21 = HEAP32[$7 >> 2] | 0;
  $22 = ($21 | 0) == (0 | 0);
  if ($22) {
   STACKTOP = sp;
   return;
  }
 }
 $23 = $3;
 $24 = _mp_obj_get_type_str($23) | 0;
 $25 = $4;
 HEAP32[$vararg_buffer >> 2] = $24;
 $vararg_ptr1 = $vararg_buffer + 4 | 0;
 HEAP32[$vararg_ptr1 >> 2] = $25;
 $26 = _mp_obj_new_exception_msg_varg(15292, 29795, $vararg_buffer) | 0;
 _nlr_jump($26);
}

function _compile_binary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $7 = $3;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 & 255;
 $11 = 21 + $10 | 0;
 $12 = $11 - 34 | 0;
 $4 = $12;
 $13 = $3;
 $14 = $13 + 4 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $15 >>> 8;
 $5 = $16;
 $17 = $2;
 $18 = $3;
 $19 = $18 + 8 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 _compile_node($17, $20);
 $6 = 1;
 while (1) {
  $21 = $6;
  $22 = $5;
  $23 = ($21 | 0) < ($22 | 0);
  if (!$23) {
   break;
  }
  $24 = $2;
  $25 = $3;
  $26 = $25 + 8 | 0;
  $27 = $6;
  $28 = $26 + ($27 << 2) | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  _compile_node($24, $29);
  $30 = $2;
  $31 = $30 + 40 | 0;
  $32 = HEAP32[$31 >> 2] | 0;
  $33 = $4;
  _mp_emit_bc_binary_op($32, $33);
  $34 = $6;
  $35 = $34 + 1 | 0;
  $6 = $35;
 }
 STACKTOP = sp;
 return;
}

function _dict_iter_next($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $8 = $3;
 $9 = $8 + 4 | 0;
 $10 = $9 + 4 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $5 = $11;
 $12 = $3;
 $13 = $12 + 4 | 0;
 $6 = $13;
 $14 = $4;
 $15 = HEAP32[$14 >> 2] | 0;
 $7 = $15;
 while (1) {
  $16 = $7;
  $17 = $5;
  $18 = $16 >>> 0 < $17 >>> 0;
  if (!$18) {
   label = 6;
   break;
  }
  $19 = $6;
  $20 = $7;
  $21 = _mp_map_slot_is_filled_875($19, $20) | 0;
  $22 = $7;
  $23 = $22 + 1 | 0;
  if ($21) {
   label = 4;
   break;
  }
  $7 = $23;
 }
 if ((label | 0) == 4) {
  $24 = $4;
  HEAP32[$24 >> 2] = $23;
  $25 = $6;
  $26 = $25 + 8 | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $28 = $7;
  $29 = $27 + ($28 << 3) | 0;
  $2 = $29;
  $30 = $2;
  STACKTOP = sp;
  return $30 | 0;
 } else if ((label | 0) == 6) {
  $2 = 0;
  $30 = $2;
  STACKTOP = sp;
  return $30 | 0;
 }
 return 0 | 0;
}

function _memset(ptr, value, num) {
 ptr = ptr | 0;
 value = value | 0;
 num = num | 0;
 var end = 0, aligned_end = 0, block_aligned_end = 0, value4 = 0;
 end = ptr + num | 0;
 value = value & 255;
 if ((num | 0) >= 67) {
  while ((ptr & 3) != 0) {
   HEAP8[ptr >> 0] = value;
   ptr = ptr + 1 | 0;
  }
  aligned_end = end & -4 | 0;
  value4 = value | value << 8 | value << 16 | value << 24;
  block_aligned_end = aligned_end - 64 | 0;
  while ((ptr | 0) <= (block_aligned_end | 0)) {
   HEAP32[ptr >> 2] = value4;
   HEAP32[ptr + 4 >> 2] = value4;
   HEAP32[ptr + 8 >> 2] = value4;
   HEAP32[ptr + 12 >> 2] = value4;
   HEAP32[ptr + 16 >> 2] = value4;
   HEAP32[ptr + 20 >> 2] = value4;
   HEAP32[ptr + 24 >> 2] = value4;
   HEAP32[ptr + 28 >> 2] = value4;
   HEAP32[ptr + 32 >> 2] = value4;
   HEAP32[ptr + 36 >> 2] = value4;
   HEAP32[ptr + 40 >> 2] = value4;
   HEAP32[ptr + 44 >> 2] = value4;
   HEAP32[ptr + 48 >> 2] = value4;
   HEAP32[ptr + 52 >> 2] = value4;
   HEAP32[ptr + 56 >> 2] = value4;
   HEAP32[ptr + 60 >> 2] = value4;
   ptr = ptr + 64 | 0;
  }
  while ((ptr | 0) < (aligned_end | 0)) {
   HEAP32[ptr >> 2] = value4;
   ptr = ptr + 4 | 0;
  }
 }
 while ((ptr | 0) < (end | 0)) {
  HEAP8[ptr >> 0] = value;
  ptr = ptr + 1 | 0;
 }
 return end - num | 0;
}

function _compile_funcdef_helper($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $3;
 $9 = $8 + 5 | 0;
 $10 = HEAP8[$9 >> 0] | 0;
 $11 = $10 & 255;
 $12 = ($11 | 0) == 1;
 if ($12) {
  $13 = $3;
  $14 = $4;
  $15 = $14;
  $16 = $5;
  $17 = _scope_new_and_link($13, 7, $15, $16) | 0;
  $6 = $17;
  $18 = $6;
  $19 = $18;
  $20 = $4;
  $21 = $20 + 8 | 0;
  $22 = $21 + 16 | 0;
  HEAP32[$22 >> 2] = $19;
 }
 $23 = $4;
 $24 = $23 + 8 | 0;
 $25 = $24 + 16 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = $26;
 $7 = $27;
 $28 = $3;
 $29 = $7;
 $30 = $4;
 $31 = $30 + 8 | 0;
 $32 = $31 + 4 | 0;
 $33 = HEAP32[$32 >> 2] | 0;
 _compile_funcdef_lambdef($28, $29, $33, 67);
 $34 = $7;
 $35 = $34 + 22 | 0;
 $36 = HEAP16[$35 >> 1] | 0;
 $37 = $36 & 65535;
 STACKTOP = sp;
 return $37 | 0;
}

function _framebuf_fill_rect($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $10 = $3;
 $11 = HEAP32[$10 >> 2] | 0;
 $4 = $11;
 $12 = $3;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = _mp_obj_get_int($14) | 0;
 $5 = $15;
 $16 = $3;
 $17 = $16 + 8 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = _mp_obj_get_int($18) | 0;
 $6 = $19;
 $20 = $3;
 $21 = $20 + 12 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = _mp_obj_get_int($22) | 0;
 $7 = $23;
 $24 = $3;
 $25 = $24 + 16 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = _mp_obj_get_int($26) | 0;
 $8 = $27;
 $28 = $3;
 $29 = $28 + 20 | 0;
 $30 = HEAP32[$29 >> 2] | 0;
 $31 = _mp_obj_get_int($30) | 0;
 $9 = $31;
 $32 = $4;
 $33 = $5;
 $34 = $6;
 $35 = $7;
 $36 = $8;
 $37 = $9;
 _fill_rect($32, $33, $34, $35, $36, $37);
 STACKTOP = sp;
 return 17668 | 0;
}

function _mp_obj_new_str_copy($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = _m_malloc(16) | 0;
 $6 = $8;
 $9 = $3;
 $10 = $6;
 HEAP32[$10 >> 2] = $9;
 $11 = $5;
 $12 = $6;
 $13 = $12 + 8 | 0;
 HEAP32[$13 >> 2] = $11;
 $14 = $4;
 $15 = ($14 | 0) != (0 | 0);
 if (!$15) {
  $35 = $6;
  STACKTOP = sp;
  return $35 | 0;
 }
 $16 = $4;
 $17 = $5;
 $18 = _qstr_compute_hash($16, $17) | 0;
 $19 = $6;
 $20 = $19 + 4 | 0;
 HEAP32[$20 >> 2] = $18;
 $21 = $5;
 $22 = $21 + 1 | 0;
 $23 = $22;
 $24 = _m_malloc($23) | 0;
 $7 = $24;
 $25 = $7;
 $26 = $6;
 $27 = $26 + 12 | 0;
 HEAP32[$27 >> 2] = $25;
 $28 = $7;
 $29 = $4;
 $30 = $5;
 $31 = $30;
 _memcpy($28 | 0, $29 | 0, $31 | 0) | 0;
 $32 = $7;
 $33 = $5;
 $34 = $32 + $33 | 0;
 HEAP8[$34 >> 0] = 0;
 $35 = $6;
 STACKTOP = sp;
 return $35 | 0;
}

function _mp_map_init($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = ($4 | 0) == 0;
 if ($5) {
  $6 = $2;
  $7 = $6 + 4 | 0;
  HEAP32[$7 >> 2] = 0;
  $8 = $2;
  $9 = $8 + 8 | 0;
  HEAP32[$9 >> 2] = 0;
 } else {
  $10 = $3;
  $11 = $2;
  $12 = $11 + 4 | 0;
  HEAP32[$12 >> 2] = $10;
  $13 = $2;
  $14 = $13 + 4 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $15 << 3;
  $17 = _m_malloc0($16) | 0;
  $18 = $2;
  $19 = $18 + 8 | 0;
  HEAP32[$19 >> 2] = $17;
 }
 $20 = $2;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $21 & 7;
 HEAP32[$20 >> 2] = $22;
 $23 = $2;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $24 & -2;
 $26 = $25 | 1;
 HEAP32[$23 >> 2] = $26;
 $27 = $2;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = $28 & -3;
 HEAP32[$27 >> 2] = $29;
 $30 = $2;
 $31 = HEAP32[$30 >> 2] | 0;
 $32 = $31 & -5;
 HEAP32[$30 >> 2] = $32;
 STACKTOP = sp;
 return;
}

function _mp_math_log($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0.0, $11 = 0.0, $12 = 0, $13 = 0.0, $14 = 0.0, $15 = 0, $16 = 0, $17 = 0.0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0.0, $23 = 0.0, $24 = 0, $25 = 0.0, $26 = 0, $27 = 0.0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $31 = 0, $32 = 0, $4 = 0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $3 = $0;
 $4 = $1;
 $8 = $4;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = +_mp_obj_get_float($9);
 $5 = $10;
 $11 = $5;
 $12 = $11 <= 0.0;
 if ($12) {
  _math_error();
 }
 $13 = $5;
 $14 = +Math_log(+$13);
 $6 = $14;
 $15 = $3;
 $16 = ($15 | 0) == 1;
 if ($16) {
  $17 = $6;
  $18 = _mp_obj_new_float($17) | 0;
  $2 = $18;
  $32 = $2;
  STACKTOP = sp;
  return $32 | 0;
 }
 $19 = $4;
 $20 = $19 + 4 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = +_mp_obj_get_float($21);
 $7 = $22;
 $23 = $7;
 $24 = $23 <= 0.0;
 if ($24) {
  _math_error();
 }
 $25 = $7;
 $26 = $25 == 1.0;
 if ($26) {
  _mp_raise_msg(15172, 33845);
 }
 $27 = $6;
 $28 = $7;
 $29 = +Math_log(+$28);
 $30 = $27 / $29;
 $31 = _mp_obj_new_float($30) | 0;
 $2 = $31;
 $32 = $2;
 STACKTOP = sp;
 return $32 | 0;
}

function _emit_bc_call_function_method_helper($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 $12 = $11;
 $13 = ($12 | 0) != 0;
 $14 = $6;
 $15 = $7;
 $16 = $9;
 $17 = $15 - $16 | 0;
 $18 = $10;
 $19 = $18 << 1;
 $20 = $17 - $19 | 0;
 if ($13) {
  $21 = $20 - 2 | 0;
  _emit_bc_pre($14, $21);
  $22 = $6;
  $23 = $8;
  $24 = $23 + 1 | 0;
  $25 = $24 & 255;
  $26 = $10;
  $27 = $26 << 8;
  $28 = $9;
  $29 = $27 | $28;
  _emit_write_bytecode_byte_uint($22, $25, $29);
  STACKTOP = sp;
  return;
 } else {
  _emit_bc_pre($14, $20);
  $30 = $6;
  $31 = $8;
  $32 = $31 & 255;
  $33 = $10;
  $34 = $33 << 8;
  $35 = $9;
  $36 = $34 | $35;
  _emit_write_bytecode_byte_uint($30, $32, $36);
  STACKTOP = sp;
  return;
 }
}

function _filter_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = sp + 4 | 0;
 $2 = $0;
 $6 = $2;
 $3 = $6;
 while (1) {
  $7 = $3;
  $8 = $7 + 8 | 0;
  $9 = HEAP32[$8 >> 2] | 0;
  $10 = _mp_iternext($9) | 0;
  HEAP32[$4 >> 2] = $10;
  $11 = ($10 | 0) != (0 | 0);
  if (!$11) {
   label = 9;
   break;
  }
  $12 = $3;
  $13 = $12 + 4 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = ($14 | 0) != (17668 | 0);
  if ($15) {
   $16 = $3;
   $17 = $16 + 4 | 0;
   $18 = HEAP32[$17 >> 2] | 0;
   $19 = _mp_call_function_n_kw($18, 1, 0, $4) | 0;
   $5 = $19;
  } else {
   $20 = HEAP32[$4 >> 2] | 0;
   $5 = $20;
  }
  $21 = $5;
  $22 = _mp_obj_is_true($21) | 0;
  if ($22) {
   label = 7;
   break;
  }
 }
 if ((label | 0) == 7) {
  $23 = HEAP32[$4 >> 2] | 0;
  $1 = $23;
  $24 = $1;
  STACKTOP = sp;
  return $24 | 0;
 } else if ((label | 0) == 9) {
  $1 = 0;
  $24 = $1;
  STACKTOP = sp;
  return $24 | 0;
 }
 return 0 | 0;
}

function _gs8_fill_rect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $36 = 0, $37 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 $13 = $6;
 $14 = $13 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $7;
 $17 = $8;
 $18 = $6;
 $19 = $18 + 16 | 0;
 $20 = HEAP16[$19 >> 1] | 0;
 $21 = $20 & 65535;
 $22 = Math_imul($17, $21) | 0;
 $23 = $16 + $22 | 0;
 $24 = $15 + $23 | 0;
 $12 = $24;
 while (1) {
  $25 = $10;
  $26 = $25 + -1 | 0;
  $10 = $26;
  $27 = ($25 | 0) != 0;
  if (!$27) {
   break;
  }
  $28 = $12;
  $29 = $11;
  $30 = $29 & 255;
  $31 = $9;
  _memset($28 | 0, $30 | 0, $31 | 0) | 0;
  $32 = $6;
  $33 = $32 + 16 | 0;
  $34 = HEAP16[$33 >> 1] | 0;
  $35 = $34 & 65535;
  $36 = $12;
  $37 = $36 + $35 | 0;
  $12 = $37;
 }
 STACKTOP = sp;
 return;
}

function _zip_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $5;
 $11 = $6;
 _mp_arg_check_num_1294($10, $11, 0, 65535, 0);
 $12 = $5;
 $13 = $12 << 2;
 $14 = 8 + $13 | 0;
 $15 = _m_malloc($14) | 0;
 $8 = $15;
 $16 = $4;
 $17 = $8;
 HEAP32[$17 >> 2] = $16;
 $18 = $5;
 $19 = $8;
 $20 = $19 + 4 | 0;
 HEAP32[$20 >> 2] = $18;
 $9 = 0;
 while (1) {
  $21 = $9;
  $22 = $5;
  $23 = $21 >>> 0 < $22 >>> 0;
  if (!$23) {
   break;
  }
  $24 = $7;
  $25 = $9;
  $26 = $24 + ($25 << 2) | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $28 = _mp_getiter($27, 0) | 0;
  $29 = $8;
  $30 = $29 + 8 | 0;
  $31 = $9;
  $32 = $30 + ($31 << 2) | 0;
  HEAP32[$32 >> 2] = $28;
  $33 = $9;
  $34 = $33 + 1 | 0;
  $9 = $34;
 }
 $35 = $8;
 STACKTOP = sp;
 return $35 | 0;
}

function ___fflush_unlocked($0) {
 $0 = $0 | 0;
 var $$0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = $0 + 20 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 $3 = $0 + 28 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $2 >>> 0 > $4 >>> 0;
 if ($5) {
  $6 = $0 + 36 | 0;
  $7 = HEAP32[$6 >> 2] | 0;
  FUNCTION_TABLE_iiii[$7 & 1023]($0, 0, 0) | 0;
  $8 = HEAP32[$1 >> 2] | 0;
  $9 = ($8 | 0) == (0 | 0);
  if ($9) {
   $$0 = -1;
  } else {
   label = 3;
  }
 } else {
  label = 3;
 }
 if ((label | 0) == 3) {
  $10 = $0 + 4 | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = $0 + 8 | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = $11 >>> 0 < $13 >>> 0;
  if ($14) {
   $15 = $11;
   $16 = $13;
   $17 = $15 - $16 | 0;
   $18 = ($17 | 0) < 0;
   $19 = $18 << 31 >> 31;
   $20 = $0 + 40 | 0;
   $21 = HEAP32[$20 >> 2] | 0;
   FUNCTION_TABLE_iiiii[$21 & 1023]($0, $17, $19, 1) | 0;
   $22 = getTempRet0() | 0;
  }
  $23 = $0 + 16 | 0;
  HEAP32[$23 >> 2] = 0;
  HEAP32[$3 >> 2] = 0;
  HEAP32[$1 >> 2] = 0;
  HEAP32[$12 >> 2] = 0;
  HEAP32[$10 >> 2] = 0;
  $$0 = 0;
 }
 return $$0 | 0;
}

function _emit_get_cur_to_write_code_info($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $3;
 $7 = $6 + 5 | 0;
 $8 = HEAPU8[$7 >> 0] | HEAPU8[$7 + 1 >> 0] << 8;
 $9 = $8 & 255;
 $10 = $9 & 65535;
 $11 = ($10 | 0) < 4;
 if ($11) {
  $12 = $4;
  $13 = $3;
  $14 = $13 + 32 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $15 + $12 | 0;
  HEAP32[$14 >> 2] = $16;
  $17 = $3;
  $2 = $17;
  $31 = $2;
  STACKTOP = sp;
  return $31 | 0;
 } else {
  $18 = $3;
  $19 = $18 + 48 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = $3;
  $22 = $21 + 32 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = $20 + $23 | 0;
  $5 = $24;
  $25 = $4;
  $26 = $3;
  $27 = $26 + 32 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = $28 + $25 | 0;
  HEAP32[$27 >> 2] = $29;
  $30 = $5;
  $2 = $30;
  $31 = $2;
  STACKTOP = sp;
  return $31 | 0;
 }
 return 0 | 0;
}

function _qstr_dump_data() {
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $vararg_buffer = sp;
 $3 = HEAP32[40572 >> 2] | 0;
 $0 = $3;
 while (1) {
  $4 = $0;
  $5 = ($4 | 0) != (0 | 0);
  $6 = $0;
  $7 = ($6 | 0) != (11280 | 0);
  $8 = $5 ? $7 : 0;
  if (!$8) {
   break;
  }
  $9 = $0;
  $10 = $9 + 16 | 0;
  $1 = $10;
  $11 = $0;
  $12 = $11 + 16 | 0;
  $13 = $0;
  $14 = $13 + 12 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $12 + ($15 << 2) | 0;
  $2 = $16;
  while (1) {
   $17 = $1;
   $18 = $2;
   $19 = $17 >>> 0 < $18 >>> 0;
   if (!$19) {
    break;
   }
   $20 = $1;
   $21 = HEAP32[$20 >> 2] | 0;
   $22 = $21 + 2 | 0;
   $23 = $22 + 1 | 0;
   HEAP32[$vararg_buffer >> 2] = $23;
   _mp_printf(13344, 28389, $vararg_buffer) | 0;
   $24 = $1;
   $25 = $24 + 4 | 0;
   $1 = $25;
  }
  $26 = $0;
  $27 = HEAP32[$26 >> 2] | 0;
  $0 = $27;
 }
 STACKTOP = sp;
 return;
}

function _compile_lambdef($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = $6 + 5 | 0;
 $8 = HEAP8[$7 >> 0] | 0;
 $9 = $8 & 255;
 $10 = ($9 | 0) == 1;
 if ($10) {
  $11 = $2;
  $12 = $3;
  $13 = $12;
  $14 = $2;
  $15 = $14 + 36 | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  $17 = $16 + 26 | 0;
  $18 = HEAP16[$17 >> 1] | 0;
  $19 = $18 & 65535;
  $20 = _scope_new_and_link($11, 2, $13, $19) | 0;
  $4 = $20;
  $21 = $4;
  $22 = $21;
  $23 = $3;
  $24 = $23 + 8 | 0;
  $25 = $24 + 8 | 0;
  HEAP32[$25 >> 2] = $22;
 }
 $26 = $3;
 $27 = $26 + 8 | 0;
 $28 = $27 + 8 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = $29;
 $5 = $30;
 $31 = $2;
 $32 = $5;
 $33 = $3;
 $34 = $33 + 8 | 0;
 $35 = HEAP32[$34 >> 2] | 0;
 _compile_funcdef_lambdef($31, $32, $35, 75);
 STACKTOP = sp;
 return;
}

function _compile_generic_all_nodes($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $8 >>> 8;
 $4 = $9;
 $5 = 0;
 while (1) {
  $10 = $5;
  $11 = $4;
  $12 = ($10 | 0) < ($11 | 0);
  if (!$12) {
   label = 6;
   break;
  }
  $13 = $2;
  $14 = $3;
  $15 = $14 + 8 | 0;
  $16 = $5;
  $17 = $15 + ($16 << 2) | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  _compile_node($13, $18);
  $19 = $2;
  $20 = $19 + 8 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  $22 = ($21 | 0) != (0 | 0);
  if ($22) {
   break;
  }
  $29 = $5;
  $30 = $29 + 1 | 0;
  $5 = $30;
 }
 if ((label | 0) == 6) {
  STACKTOP = sp;
  return;
 }
 $23 = $2;
 $24 = $3;
 $25 = $24 + 8 | 0;
 $26 = $5;
 $27 = $25 + ($26 << 2) | 0;
 $28 = HEAP32[$27 >> 2] | 0;
 _compile_error_set_line($23, $28);
 STACKTOP = sp;
 return;
}

function _scope_find($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = 0;
 while (1) {
  $6 = $5;
  $7 = $3;
  $8 = $7 + 42 | 0;
  $9 = HEAP16[$8 >> 1] | 0;
  $10 = $9 & 65535;
  $11 = $6 >>> 0 < $10 >>> 0;
  if (!$11) {
   label = 6;
   break;
  }
  $12 = $3;
  $13 = $12 + 44 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = $5;
  $16 = $14 + ($15 << 3) | 0;
  $17 = $16 + 4 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = $4;
  $20 = ($18 | 0) == ($19 | 0);
  if ($20) {
   label = 4;
   break;
  }
  $26 = $5;
  $27 = $26 + 1 | 0;
  $5 = $27;
 }
 if ((label | 0) == 4) {
  $21 = $3;
  $22 = $21 + 44 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = $5;
  $25 = $23 + ($24 << 3) | 0;
  $2 = $25;
  $28 = $2;
  STACKTOP = sp;
  return $28 | 0;
 } else if ((label | 0) == 6) {
  $2 = 0;
  $28 = $2;
  STACKTOP = sp;
  return $28 | 0;
 }
 return 0 | 0;
}

function _set_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $13 = $6;
 $14 = $7;
 _mp_arg_check_num_1107($13, $14, 0, 1, 0);
 $15 = $6;
 $cond = ($15 | 0) == 0;
 $16 = _mp_obj_new_set(0, 0) | 0;
 if ($cond) {
  $9 = $16;
  $17 = $5;
  $18 = $9;
  HEAP32[$18 >> 2] = $17;
  $19 = $9;
  $4 = $19;
  $31 = $4;
  STACKTOP = sp;
  return $31 | 0;
 }
 $10 = $16;
 $20 = $8;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = _mp_getiter($21, 0) | 0;
 $11 = $22;
 while (1) {
  $23 = $11;
  $24 = _mp_iternext($23) | 0;
  $12 = $24;
  $25 = ($24 | 0) != (0 | 0);
  if (!$25) {
   break;
  }
  $26 = $10;
  $27 = $12;
  _mp_obj_set_store($26, $27);
 }
 $28 = $5;
 $29 = $10;
 HEAP32[$29 >> 2] = $28;
 $30 = $10;
 $4 = $30;
 $31 = $4;
 STACKTOP = sp;
 return $31 | 0;
}

function _mp_obj_new_namedtuple_type($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $8 = $5;
 $9 = _mp_obj_new_namedtuple_base($7, $8) | 0;
 $6 = $9;
 $10 = $6;
 HEAP32[$10 >> 2] = 19048;
 $11 = $3;
 $12 = $11 & 65535;
 $13 = $6;
 $14 = $13 + 6 | 0;
 HEAP16[$14 >> 1] = $12;
 $15 = $6;
 $16 = $15 + 8 | 0;
 HEAP32[$16 >> 2] = 516;
 $17 = $6;
 $18 = $17 + 12 | 0;
 HEAP32[$18 >> 2] = 517;
 $19 = $6;
 $20 = $19 + 20 | 0;
 HEAP32[$20 >> 2] = 67;
 $21 = $6;
 $22 = $21 + 24 | 0;
 HEAP32[$22 >> 2] = 68;
 $23 = $6;
 $24 = $23 + 28 | 0;
 HEAP32[$24 >> 2] = 518;
 $25 = $6;
 $26 = $25 + 32 | 0;
 HEAP32[$26 >> 2] = 70;
 $27 = $6;
 $28 = $27 + 36 | 0;
 HEAP32[$28 >> 2] = 71;
 $29 = $6;
 $30 = $29 + 52 | 0;
 HEAP32[$30 >> 2] = 18952;
 $31 = $6;
 STACKTOP = sp;
 return $31 | 0;
}

function _frexp($0, $1) {
 $0 = +$0;
 $1 = $1 | 0;
 var $$0 = 0.0, $$016 = 0.0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0.0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0.0, $9 = 0.0, $storemerge = 0, $trunc$clear = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $2 = HEAP32[tempDoublePtr >> 2] | 0;
 $3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $4 = _bitshift64Lshr($2 | 0, $3 | 0, 52) | 0;
 $5 = getTempRet0() | 0;
 $6 = $4 & 65535;
 $trunc$clear = $6 & 2047;
 switch ($trunc$clear << 16 >> 16) {
 case 0:
  {
   $7 = $0 != 0.0;
   if ($7) {
    $8 = $0 * 18446744073709551616.0;
    $9 = +_frexp($8, $1);
    $10 = HEAP32[$1 >> 2] | 0;
    $11 = $10 + -64 | 0;
    $$016 = $9;
    $storemerge = $11;
   } else {
    $$016 = $0;
    $storemerge = 0;
   }
   HEAP32[$1 >> 2] = $storemerge;
   $$0 = $$016;
   break;
  }
 case 2047:
  {
   $$0 = $0;
   break;
  }
 default:
  {
   $12 = $4 & 2047;
   $13 = $12 + -1022 | 0;
   HEAP32[$1 >> 2] = $13;
   $14 = $3 & -2146435073;
   $15 = $14 | 1071644672;
   HEAP32[tempDoublePtr >> 2] = $2;
   HEAP32[tempDoublePtr + 4 >> 2] = $15;
   $16 = +HEAPF64[tempDoublePtr >> 3];
   $$0 = $16;
  }
 }
 return +$$0;
}

function _mp_sched_schedule($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = 0;
 $7 = _mp_sched_full() | 0;
 if ($7) {
  $5 = 0;
  $28 = $5;
  $29 = $28 & 1;
  STACKTOP = sp;
  return $29 | 0;
 }
 $8 = HEAP16[40740 >> 1] | 0;
 $9 = $8 << 16 >> 16;
 $10 = ($9 | 0) == 1;
 if ($10) {
  HEAP16[40740 >> 1] = 0;
 }
 $11 = HEAP8[40743 >> 0] | 0;
 $12 = $11 & 255;
 $13 = HEAP8[40742 >> 0] | 0;
 $14 = $13 + 1 << 24 >> 24;
 HEAP8[40742 >> 0] = $14;
 $15 = $13 & 255;
 $16 = $12 + $15 | 0;
 $17 = $16 & 0;
 $18 = $17 & 255;
 $6 = $18;
 $19 = $2;
 $20 = $6;
 $21 = $20 & 255;
 $22 = 40628 + ($21 << 3) | 0;
 HEAP32[$22 >> 2] = $19;
 $23 = $3;
 $24 = $6;
 $25 = $24 & 255;
 $26 = 40628 + ($25 << 3) | 0;
 $27 = $26 + 4 | 0;
 HEAP32[$27 >> 2] = $23;
 $5 = 1;
 $28 = $5;
 $29 = $28 & 1;
 STACKTOP = sp;
 return $29 | 0;
}

function _dict_subscr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $9 = $6;
 $10 = ($9 | 0) == (0 | 0);
 if ($10) {
  $11 = $4;
  $12 = $5;
  _mp_obj_dict_delete($11, $12) | 0;
  $3 = 17668;
  $29 = $3;
  STACKTOP = sp;
  return $29 | 0;
 }
 $13 = $6;
 $14 = ($13 | 0) == (4 | 0);
 $15 = $4;
 if (!$14) {
  $27 = $5;
  $28 = $6;
  _mp_obj_dict_store($15, $27, $28) | 0;
  $3 = 17668;
  $29 = $3;
  STACKTOP = sp;
  return $29 | 0;
 }
 $7 = $15;
 $16 = $7;
 $17 = $16 + 4 | 0;
 $18 = $5;
 $19 = _mp_map_lookup($17, $18, 0) | 0;
 $8 = $19;
 $20 = $8;
 $21 = ($20 | 0) == (0 | 0);
 if ($21) {
  $22 = $5;
  $23 = _mp_obj_new_exception_arg1(15592, $22) | 0;
  _nlr_jump($23);
 }
 $24 = $8;
 $25 = $24 + 4 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $3 = $26;
 $29 = $3;
 STACKTOP = sp;
 return $29 | 0;
}

function _mp_obj_str_get_str($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = sp;
 $1 = $0;
 $4 = $1;
 $5 = _mp_obj_is_qstr_1128($4) | 0;
 if (!$5) {
  $6 = $1;
  $7 = _mp_obj_is_obj_1154($6) | 0;
  if (!$7) {
   $25 = $1;
   _bad_implicit_conversion($25);
  }
  $8 = $1;
  $9 = HEAP32[$8 >> 2] | 0;
  $10 = $9 + 24 | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = ($11 | 0) == (206 | 0);
  if (!$12) {
   $25 = $1;
   _bad_implicit_conversion($25);
  }
 }
 $13 = $1;
 $14 = _mp_obj_is_qstr_1128($13) | 0;
 $15 = $1;
 if ($14) {
  $16 = $15;
  $17 = $16 >>> 2;
  $18 = _qstr_data($17, $3) | 0;
  $2 = $18;
  $24 = $2;
  STACKTOP = sp;
  return $24 | 0;
 } else {
  $19 = $15 + 8 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  HEAP32[$3 >> 2] = $20;
  $21 = $1;
  $22 = $21 + 12 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $2 = $23;
  $24 = $2;
  STACKTOP = sp;
  return $24 | 0;
 }
 return 0 | 0;
}

function _sinh($0) {
 $0 = +$0;
 var $$0 = 0.0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $3 = 0, $4 = 0, $5 = 0.0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0, $spec$select = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = ($2 | 0) < 0;
 $spec$select = $3 ? -.5 : .5;
 $4 = $2 & 2147483647;
 HEAP32[tempDoublePtr >> 2] = $1;
 HEAP32[tempDoublePtr + 4 >> 2] = $4;
 $5 = +HEAPF64[tempDoublePtr >> 3];
 $6 = $4 >>> 0 < 1082535490;
 do {
  if ($6) {
   $7 = +_expm1($5);
   $8 = $4 >>> 0 < 1072693248;
   if (!$8) {
    $16 = $7 + 1.0;
    $17 = $7 / $16;
    $18 = $7 + $17;
    $19 = $spec$select * $18;
    $$0 = $19;
    break;
   }
   $9 = $4 >>> 0 < 1045430272;
   if ($9) {
    $$0 = $0;
   } else {
    $10 = $7 * 2.0;
    $11 = $7 * $7;
    $12 = $7 + 1.0;
    $13 = $11 / $12;
    $14 = $10 - $13;
    $15 = $spec$select * $14;
    $$0 = $15;
   }
  } else {
   $20 = $spec$select * 2.0;
   $21 = +___expo2($5);
   $22 = $20 * $21;
   $$0 = $22;
  }
 } while (0);
 return +$$0;
}

function _mp_obj_new_namedtuple_base($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, dest = 0, label = 0, sp = 0, stop = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = $6 << 2;
 $8 = 64 + $7 | 0;
 $9 = _m_malloc($8) | 0;
 $4 = $9;
 $10 = $4;
 dest = $10;
 stop = dest + 60 | 0;
 do {
  HEAP32[dest >> 2] = 0 | 0;
  dest = dest + 4 | 0;
 } while ((dest | 0) < (stop | 0));
 $11 = $2;
 $12 = $4;
 $13 = $12 + 60 | 0;
 HEAP32[$13 >> 2] = $11;
 $5 = 0;
 while (1) {
  $14 = $5;
  $15 = $2;
  $16 = $14 >>> 0 < $15 >>> 0;
  if (!$16) {
   break;
  }
  $17 = $3;
  $18 = $5;
  $19 = $17 + ($18 << 2) | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = _mp_obj_str_get_qstr($20) | 0;
  $22 = $4;
  $23 = $22 + 64 | 0;
  $24 = $5;
  $25 = $23 + ($24 << 2) | 0;
  HEAP32[$25 >> 2] = $21;
  $26 = $5;
  $27 = $26 + 1 | 0;
  $5 = $27;
 }
 $28 = $4;
 STACKTOP = sp;
 return $28 | 0;
}

function _uzlib_crc32($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $3;
 $6 = $8;
 $7 = 0;
 while (1) {
  $9 = $7;
  $10 = $4;
  $11 = $9 >>> 0 < $10 >>> 0;
  if (!$11) {
   break;
  }
  $12 = $6;
  $13 = $7;
  $14 = $12 + $13 | 0;
  $15 = HEAP8[$14 >> 0] | 0;
  $16 = $15 & 255;
  $17 = $5;
  $18 = $17 ^ $16;
  $5 = $18;
  $19 = $5;
  $20 = $19 & 15;
  $21 = 7600 + ($20 << 2) | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $5;
  $24 = $23 >>> 4;
  $25 = $22 ^ $24;
  $5 = $25;
  $26 = $5;
  $27 = $26 & 15;
  $28 = 7600 + ($27 << 2) | 0;
  $29 = HEAP32[$28 >> 2] | 0;
  $30 = $5;
  $31 = $30 >>> 4;
  $32 = $29 ^ $31;
  $5 = $32;
  $33 = $7;
  $34 = $33 + 1 | 0;
  $7 = $34;
 }
 $35 = $5;
 STACKTOP = sp;
 return $35 | 0;
}

function _mp_obj_exception_get_traceback($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $8 = _mp_obj_get_type($7) | 0;
 $9 = $8 + 12 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = ($10 | 0) == (108 | 0);
 $12 = $3;
 if ($11) {
  $6 = $12;
 } else {
  $13 = $12 + 16 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $6 = $14;
 }
 $15 = $6;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = ($17 | 0) == (0 | 0);
 if ($18) {
  $19 = $4;
  HEAP32[$19 >> 2] = 0;
  $20 = $5;
  HEAP32[$20 >> 2] = 0;
  STACKTOP = sp;
  return;
 } else {
  $21 = $6;
  $22 = $21 + 4 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = $23 >>> 16;
  $25 = $4;
  HEAP32[$25 >> 2] = $24;
  $26 = $6;
  $27 = $26 + 8 | 0;
  $28 = HEAP32[$27 >> 2] | 0;
  $29 = $5;
  HEAP32[$29 >> 2] = $28;
  STACKTOP = sp;
  return;
 }
}

function _mp_iternext_allow_raise($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $4 = sp + 8 | 0;
 $2 = $0;
 $5 = $2;
 $6 = _mp_obj_get_type($5) | 0;
 $3 = $6;
 $7 = $3;
 $8 = $7 + 40 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) != (0 | 0);
 if ($10) {
  $11 = $3;
  $12 = $11 + 40 | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = $2;
  $15 = FUNCTION_TABLE_ii[$13 & 1023]($14) | 0;
  $1 = $15;
  $23 = $1;
  STACKTOP = sp;
  return $23 | 0;
 }
 $16 = $2;
 _mp_load_method_maybe($16, 25, $4);
 $17 = HEAP32[$4 >> 2] | 0;
 $18 = ($17 | 0) != (0 | 0);
 if (!$18) {
  $20 = $2;
  $21 = _mp_obj_get_type_str($20) | 0;
  HEAP32[$vararg_buffer >> 2] = $21;
  $22 = _mp_obj_new_exception_msg_varg(16012, 29675, $vararg_buffer) | 0;
  _nlr_jump($22);
 }
 $19 = _mp_call_method_n_kw(0, 0, $4) | 0;
 $1 = $19;
 $23 = $1;
 STACKTOP = sp;
 return $23 | 0;
}

function _set_copy($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $4 = $1;
 $2 = $4;
 $5 = _m_malloc(16) | 0;
 $3 = $5;
 $6 = $2;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $3;
 HEAP32[$8 >> 2] = $7;
 $9 = $3;
 $10 = $9 + 4 | 0;
 $11 = $2;
 $12 = $11 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 _mp_set_init($10, $13);
 $14 = $2;
 $15 = $14 + 4 | 0;
 $16 = $15 + 4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $3;
 $19 = $18 + 4 | 0;
 $20 = $19 + 4 | 0;
 HEAP32[$20 >> 2] = $17;
 $21 = $3;
 $22 = $21 + 4 | 0;
 $23 = $22 + 8 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $2;
 $26 = $25 + 4 | 0;
 $27 = $26 + 8 | 0;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = $2;
 $30 = $29 + 4 | 0;
 $31 = HEAP32[$30 >> 2] | 0;
 $32 = $31 << 2;
 _memcpy($24 | 0, $28 | 0, $32 | 0) | 0;
 $33 = $3;
 STACKTOP = sp;
 return $33 | 0;
}

function _range_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_buffer2 = 0, $vararg_ptr1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer2 = sp + 8 | 0;
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $6 = $7;
 $8 = $3;
 $9 = $6;
 $10 = $9 + 4 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $6;
 $13 = $12 + 8 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 HEAP32[$vararg_buffer >> 2] = $11;
 $vararg_ptr1 = $vararg_buffer + 4 | 0;
 HEAP32[$vararg_ptr1 >> 2] = $14;
 _mp_printf($8, 31637, $vararg_buffer) | 0;
 $15 = $6;
 $16 = $15 + 12 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = ($17 | 0) == 1;
 $19 = $3;
 if ($18) {
  _mp_print_str($19, 32991) | 0;
  STACKTOP = sp;
  return;
 } else {
  $20 = $6;
  $21 = $20 + 12 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  HEAP32[$vararg_buffer2 >> 2] = $22;
  _mp_printf($19, 31650, $vararg_buffer2) | 0;
  STACKTOP = sp;
  return;
 }
}

function _dict_view_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $8 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $11 = $4;
 $6 = $11;
 $7 = 1;
 $12 = $3;
 $13 = $6;
 $14 = $13 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = 14412 + ($15 << 2) | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 _mp_print_str($12, $17) | 0;
 $18 = $3;
 _mp_print_str($18, 30978) | 0;
 $19 = $4;
 $20 = _dict_view_getiter($19, $8) | 0;
 $9 = $20;
 $10 = 0;
 while (1) {
  $21 = $9;
  $22 = _dict_view_it_iternext($21) | 0;
  $10 = $22;
  $23 = ($22 | 0) != (0 | 0);
  if (!$23) {
   break;
  }
  $24 = $7;
  $25 = $24 & 1;
  if (!$25) {
   $26 = $3;
   _mp_print_str($26, 33327) | 0;
  }
  $7 = 0;
  $27 = $3;
  $28 = $10;
  _mp_obj_print_helper($27, $28, 1);
 }
 $29 = $3;
 _mp_print_str($29, 30981) | 0;
 STACKTOP = sp;
 return;
}

function _list_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $4;
 $6 = $8;
 $9 = $5;
 $10 = ($9 | 0) == 3;
 if (!$10) {
  $5 = 1;
 }
 $11 = $3;
 _mp_print_str($11, 32983) | 0;
 $7 = 0;
 while (1) {
  $12 = $7;
  $13 = $6;
  $14 = $13 + 8 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $12 >>> 0 < $15 >>> 0;
  if (!$16) {
   break;
  }
  $17 = $7;
  $18 = $17 >>> 0 > 0;
  if ($18) {
   $19 = $3;
   _mp_print_str($19, 33327) | 0;
  }
  $20 = $3;
  $21 = $6;
  $22 = $21 + 12 | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $24 = $7;
  $25 = $23 + ($24 << 2) | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $5;
  _mp_obj_print_helper($20, $26, $27);
  $28 = $7;
  $29 = $28 + 1 | 0;
  $7 = $29;
 }
 $30 = $3;
 _mp_print_str($30, 32987) | 0;
 STACKTOP = sp;
 return;
}

function _mpz_need_dig($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $spec$store$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = $4 >>> 0 < 2;
 $spec$store$select = $5 ? 2 : $1;
 $3 = $spec$store$select;
 $6 = $2;
 $7 = $6 + 8 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) == (0 | 0);
 if (!$9) {
  $10 = $2;
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = $11 >>> 2;
  $13 = $3;
  $14 = $12 >>> 0 < $13 >>> 0;
  if (!$14) {
   STACKTOP = sp;
   return;
  }
 }
 $15 = $2;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $3;
 $19 = $18 << 1;
 $20 = _m_realloc($17, $19) | 0;
 $21 = $2;
 $22 = $21 + 8 | 0;
 HEAP32[$22 >> 2] = $20;
 $23 = $3;
 $24 = $2;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = $23 & 1073741823;
 $27 = $26 << 2;
 $28 = $25 & 3;
 $29 = $28 | $27;
 HEAP32[$24 >> 2] = $29;
 STACKTOP = sp;
 return;
}

function _mp_classify_fp_as_int($0) {
 $0 = +$0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0.0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $3 = 0, $4 = 0, $5 = 0.0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = sp;
 $2 = $0;
 $5 = $2;
 HEAPF64[$3 >> 3] = $5;
 $6 = $3 + 4 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $4 = $7;
 $8 = $4;
 $9 = $8 & -2147483648;
 $10 = ($9 | 0) != 0;
 do {
  if ($10) {
   $11 = HEAP32[$3 >> 2] | 0;
   $12 = ($11 | 0) != 0;
   $13 = $12 & 1;
   $14 = $4;
   $15 = $14 | $13;
   $4 = $15;
   $16 = $4;
   $17 = $16 & 2147483647;
   $18 = ($17 | 0) == 0;
   if ($18) {
    $4 = 0;
    break;
   } else {
    $19 = $4;
    $20 = $19 + 2146435072 | 0;
    $4 = $20;
    break;
   }
  } else {
   $21 = $4;
   $22 = $21 & -1048576;
   $4 = $22;
  }
 } while (0);
 $23 = $4;
 $24 = $23 >>> 0 <= 1103101952;
 if ($24) {
  $1 = 0;
  $25 = $1;
  STACKTOP = sp;
  return $25 | 0;
 } else {
  $1 = 1;
  $25 = $1;
  STACKTOP = sp;
  return $25 | 0;
 }
 return 0 | 0;
}

function _mpz_as_float($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0.0, $18 = 0.0, $19 = 0, $2 = 0.0, $20 = 0, $21 = 0, $22 = 0.0, $23 = 0.0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0.0, $29 = 0.0, $3 = 0, $30 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = 0.0;
 $4 = $1;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $1;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $6 + ($9 << 1) | 0;
 $3 = $10;
 while (1) {
  $11 = $3;
  $12 = $11 + -2 | 0;
  $3 = $12;
  $13 = $1;
  $14 = $13 + 8 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $11 >>> 0 > $15 >>> 0;
  if (!$16) {
   break;
  }
  $17 = $2;
  $18 = $17 * 65536.0;
  $19 = $3;
  $20 = HEAP16[$19 >> 1] | 0;
  $21 = $20 & 65535;
  $22 = +($21 | 0);
  $23 = $18 + $22;
  $2 = $23;
 }
 $24 = $1;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = $25 & 1;
 $27 = ($26 | 0) != 0;
 if (!$27) {
  $30 = $2;
  STACKTOP = sp;
  return +$30;
 }
 $28 = $2;
 $29 = -$28;
 $2 = $29;
 $30 = $2;
 STACKTOP = sp;
 return +$30;
}

function _mp_int_format_size($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $11 = $4;
 $12 = $5;
 $13 = $12 - 1 | 0;
 $14 = 3328 + $13 | 0;
 $15 = HEAP8[$14 >> 0] | 0;
 $16 = $15 & 255;
 $17 = ($11 >>> 0) / ($16 >>> 0) & -1;
 $18 = $17 + 1 | 0;
 $8 = $18;
 $19 = $7;
 $20 = $19 << 24 >> 24;
 $21 = ($20 | 0) != 0;
 if ($21) {
  $22 = $8;
  $23 = ($22 >>> 0) / 3 & -1;
  $24 = $23;
 } else {
  $24 = 0;
 }
 $9 = $24;
 $25 = $6;
 $26 = ($25 | 0) != (0 | 0);
 if ($26) {
  $27 = $6;
  $28 = _strlen($27) | 0;
  $29 = $28;
 } else {
  $29 = 0;
 }
 $10 = $29;
 $30 = $8;
 $31 = $9;
 $32 = $30 + $31 | 0;
 $33 = $10;
 $34 = $32 + $33 | 0;
 $35 = $34 + 2 | 0;
 STACKTOP = sp;
 return $35 | 0;
}

function _list_it_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $6 = $2;
 $3 = $6;
 $7 = $3;
 $8 = $7 + 8 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $4 = $9;
 $10 = $3;
 $11 = $10 + 12 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $4;
 $14 = $13 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $12 >>> 0 < $15 >>> 0;
 if ($16) {
  $17 = $4;
  $18 = $17 + 12 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = $3;
  $21 = $20 + 12 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $19 + ($22 << 2) | 0;
  $24 = HEAP32[$23 >> 2] | 0;
  $5 = $24;
  $25 = $3;
  $26 = $25 + 12 | 0;
  $27 = HEAP32[$26 >> 2] | 0;
  $28 = $27 + 1 | 0;
  HEAP32[$26 >> 2] = $28;
  $29 = $5;
  $1 = $29;
  $30 = $1;
  STACKTOP = sp;
  return $30 | 0;
 } else {
  $1 = 0;
  $30 = $1;
  STACKTOP = sp;
  return $30 | 0;
 }
 return 0 | 0;
}

function _mp_obj_get_array($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = _mp_obj_is_obj_786($6) | 0;
 if ($7) {
  $8 = $3;
  $9 = HEAP32[$8 >> 2] | 0;
  $10 = ($9 | 0) == (18952 | 0);
  if ($10) {
   $11 = $3;
   $12 = $4;
   $13 = $5;
   _mp_obj_tuple_get($11, $12, $13);
   STACKTOP = sp;
   return;
  }
 }
 $14 = $3;
 $15 = _mp_obj_is_obj_786($14) | 0;
 if ($15) {
  $16 = $3;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = ($17 | 0) == (17028 | 0);
  if ($18) {
   $19 = $3;
   $20 = $4;
   $21 = $5;
   _mp_obj_list_get($19, $20, $21);
   STACKTOP = sp;
   return;
  }
 }
 $22 = $3;
 $23 = _mp_obj_get_type_str($22) | 0;
 HEAP32[$vararg_buffer >> 2] = $23;
 $24 = _mp_obj_new_exception_msg_varg(16012, 30477, $vararg_buffer) | 0;
 _nlr_jump($24);
}

function _read_src_stream($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp + 4 | 0;
 $6 = sp + 24 | 0;
 $1 = $0;
 $8 = $1;
 $2 = $8;
 $9 = $2;
 $10 = $9 + -8 | 0;
 $2 = $10;
 $11 = $2;
 $3 = $11;
 $12 = $3;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = _mp_get_stream_1520($14) | 0;
 $4 = $15;
 $16 = $4;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $3;
 $19 = $18 + 4 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = FUNCTION_TABLE_iiiii[$17 & 1023]($20, $6, 1, $5) | 0;
 $7 = $21;
 $22 = $7;
 $23 = ($22 | 0) == -1;
 if ($23) {
  $24 = HEAP32[$5 >> 2] | 0;
  _mp_raise_OSError($24);
 }
 $25 = $7;
 $26 = ($25 | 0) == 0;
 if ($26) {
  $27 = _mp_obj_new_exception(15352) | 0;
  _nlr_jump($27);
 } else {
  $28 = HEAP8[$6 >> 0] | 0;
  $29 = $28 & 255;
  STACKTOP = sp;
  return $29 | 0;
 }
 return 0 | 0;
}

function _tuple_it_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $5 = $2;
 $3 = $5;
 $6 = $3;
 $7 = $6 + 12 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $3;
 $10 = $9 + 8 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $11 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $8 >>> 0 < $13 >>> 0;
 if ($14) {
  $15 = $3;
  $16 = $15 + 8 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = $17 + 8 | 0;
  $19 = $3;
  $20 = $19 + 12 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  $22 = $18 + ($21 << 2) | 0;
  $23 = HEAP32[$22 >> 2] | 0;
  $4 = $23;
  $24 = $3;
  $25 = $24 + 12 | 0;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $26 + 1 | 0;
  HEAP32[$25 >> 2] = $27;
  $28 = $4;
  $1 = $28;
  $29 = $1;
  STACKTOP = sp;
  return $29 | 0;
 } else {
  $1 = 0;
  $29 = $1;
  STACKTOP = sp;
  return $29 | 0;
 }
 return 0 | 0;
}

function _slice_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $5;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) != (0 | 0);
 if ($9) {
  STACKTOP = sp;
  return;
 }
 $10 = $3;
 $6 = $10;
 $11 = $4;
 $12 = ($11 | 0) == 146;
 if ($12) {
  $13 = $6;
  $14 = $13 + 4 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $5;
  HEAP32[$16 >> 2] = $15;
  STACKTOP = sp;
  return;
 }
 $17 = $4;
 $18 = ($17 | 0) == 150;
 if ($18) {
  $19 = $6;
  $20 = $19 + 8 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  $22 = $5;
  HEAP32[$22 >> 2] = $21;
  STACKTOP = sp;
  return;
 }
 $23 = $4;
 $24 = ($23 | 0) == 149;
 if (!$24) {
  STACKTOP = sp;
  return;
 }
 $25 = $6;
 $26 = $25 + 12 | 0;
 $27 = HEAP32[$26 >> 2] | 0;
 $28 = $5;
 HEAP32[$28 >> 2] = $27;
 STACKTOP = sp;
 return;
}

function _mp_obj_new_int_from_float($0) {
 $0 = +$0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0.0, $14 = 0, $15 = 0, $16 = 0, $17 = 0.0, $18 = 0, $19 = 0, $2 = 0.0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0.0, $26 = 0, $27 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $6 = $2;
 $7 = ___fpclassify($6) | 0;
 $3 = $7;
 $8 = $3;
 $9 = ($8 | 0) == 1;
 if ($9) {
  $10 = _mp_obj_new_exception_msg(15112, 31350) | 0;
  _nlr_jump($10);
 }
 $11 = $3;
 $12 = ($11 | 0) == 0;
 if ($12) {
  _mp_raise_ValueError(31375);
 }
 $13 = $2;
 $14 = _mp_classify_fp_as_int($13) | 0;
 $4 = $14;
 $15 = $4;
 $16 = ($15 | 0) == 0;
 if ($16) {
  $17 = $2;
  $18 = ~~$17;
  $19 = $18 << 1;
  $20 = $19 | 1;
  $21 = $20;
  $1 = $21;
  $27 = $1;
  STACKTOP = sp;
  return $27 | 0;
 } else {
  $22 = _mp_obj_int_new_mpz() | 0;
  $5 = $22;
  $23 = $5;
  $24 = $23 + 4 | 0;
  $25 = $2;
  _mpz_set_from_float($24, $25);
  $26 = $5;
  $1 = $26;
  $27 = $1;
  STACKTOP = sp;
  return $27 | 0;
 }
 return 0 | 0;
}

function _type_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $9 = $6;
 $10 = $7;
 _mp_arg_check_num_1267($9, $10, 1, 3, 0);
 $11 = $6;
 switch ($11 | 0) {
 case 1:
  {
   $12 = $8;
   $13 = HEAP32[$12 >> 2] | 0;
   $14 = _mp_obj_get_type($13) | 0;
   $4 = $14;
   $25 = $4;
   STACKTOP = sp;
   return $25 | 0;
   break;
  }
 case 3:
  {
   $15 = $8;
   $16 = HEAP32[$15 >> 2] | 0;
   $17 = _mp_obj_str_get_qstr($16) | 0;
   $18 = $8;
   $19 = $18 + 4 | 0;
   $20 = HEAP32[$19 >> 2] | 0;
   $21 = $8;
   $22 = $21 + 8 | 0;
   $23 = HEAP32[$22 >> 2] | 0;
   $24 = _mp_obj_new_type($17, $20, $23) | 0;
   $4 = $24;
   $25 = $4;
   STACKTOP = sp;
   return $25 | 0;
   break;
  }
 default:
  {
   _mp_raise_TypeError(33125);
  }
 }
 return 0 | 0;
}

function _mp_obj_list_init($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 HEAP32[$4 >> 2] = 17028;
 $5 = $3;
 $6 = $5 >>> 0 < 4;
 $7 = $3;
 $8 = $6 ? 4 : $7;
 $9 = $2;
 $10 = $9 + 4 | 0;
 HEAP32[$10 >> 2] = $8;
 $11 = $3;
 $12 = $2;
 $13 = $12 + 8 | 0;
 HEAP32[$13 >> 2] = $11;
 $14 = $2;
 $15 = $14 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $16 << 2;
 $18 = _m_malloc($17) | 0;
 $19 = $2;
 $20 = $19 + 12 | 0;
 HEAP32[$20 >> 2] = $18;
 $21 = $2;
 $22 = $21 + 12 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $3;
 $25 = $24 << 2;
 $26 = $23 + $25 | 0;
 $27 = $2;
 $28 = $27 + 4 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = $3;
 $31 = $29 - $30 | 0;
 $32 = $31 << 2;
 _memset($26 | 0, 0, $32 | 0) | 0;
 STACKTOP = sp;
 return;
}

function _mp_call_method_self_n_kw($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $9 = $4;
 $13 = $7;
 $14 = $8;
 $15 = $14 << 1;
 $16 = $13 + $15 | 0;
 $10 = $16;
 $11 = 0;
 $17 = $10;
 $18 = 1 + $17 | 0;
 $19 = $18 << 2;
 $20 = _mp_pystack_alloc($19) | 0;
 $11 = $20;
 $21 = $6;
 $22 = $11;
 HEAP32[$22 >> 2] = $21;
 $23 = $11;
 $24 = $23 + 4 | 0;
 $25 = $9;
 $26 = $10;
 $27 = $26 << 2;
 _memcpy($24 | 0, $25 | 0, $27 | 0) | 0;
 $28 = $5;
 $29 = $7;
 $30 = $29 + 1 | 0;
 $31 = $8;
 $32 = $11;
 $33 = _mp_call_function_n_kw($28, $30, $31, $32) | 0;
 $12 = $33;
 $34 = $11;
 _mp_pystack_free_847($34);
 $35 = $12;
 STACKTOP = sp;
 return $35 | 0;
}

function _mp_obj_int_sign($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $5 = $2;
 $6 = _mp_obj_is_small_int_1030($5) | 0;
 $7 = $2;
 do {
  if ($6) {
   $8 = $7;
   $9 = $8 >> 1;
   $3 = $9;
   $10 = $3;
   $11 = ($10 | 0) < 0;
   if ($11) {
    $1 = -1;
    break;
   }
   $12 = $3;
   $13 = ($12 | 0) > 0;
   if ($13) {
    $1 = 1;
    break;
   } else {
    $1 = 0;
    break;
   }
  } else {
   $4 = $7;
   $14 = $4;
   $15 = $14 + 4 | 0;
   $16 = $15 + 4 | 0;
   $17 = HEAP32[$16 >> 2] | 0;
   $18 = ($17 | 0) == 0;
   if ($18) {
    $1 = 0;
    break;
   }
   $19 = $4;
   $20 = $19 + 4 | 0;
   $21 = HEAP32[$20 >> 2] | 0;
   $22 = $21 & 1;
   $23 = ($22 | 0) == 0;
   if ($23) {
    $1 = 1;
    break;
   } else {
    $1 = -1;
    break;
   }
  }
 } while (0);
 $24 = $1;
 STACKTOP = sp;
 return $24 | 0;
}

function _mp_obj_get_int($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $5 = ($4 | 0) == (13856 | 0);
 do {
  if ($5) {
   $1 = 0;
  } else {
   $6 = $2;
   $7 = ($6 | 0) == (13864 | 0);
   if ($7) {
    $1 = 1;
    break;
   }
   $8 = $2;
   $9 = _mp_obj_is_small_int_784($8) | 0;
   $10 = $2;
   if ($9) {
    $11 = $10;
    $12 = $11 >> 1;
    $1 = $12;
    break;
   }
   $13 = _mp_obj_is_obj_786($10) | 0;
   if ($13) {
    $14 = $2;
    $15 = HEAP32[$14 >> 2] | 0;
    $16 = ($15 | 0) == (16904 | 0);
    if ($16) {
     $17 = $2;
     $18 = _mp_obj_int_get_checked($17) | 0;
     $1 = $18;
     break;
    }
   }
   $19 = $2;
   $20 = _mp_unary_op(8, $19) | 0;
   $3 = $20;
   $21 = $3;
   $22 = _mp_obj_int_get_checked($21) | 0;
   $1 = $22;
  }
 } while (0);
 $23 = $1;
 STACKTOP = sp;
 return $23 | 0;
}

function _compile_declare_nonlocal($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $5;
 $7 = HEAP8[$6 >> 0] | 0;
 $8 = $7 & 255;
 $9 = ($8 | 0) == 0;
 $10 = $5;
 if ($9) {
  HEAP8[$10 >> 0] = 1;
  $11 = $3;
  $12 = $11 + 36 | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = $5;
  _scope_check_to_close_over($13, $14);
  $15 = $5;
  $16 = HEAP8[$15 >> 0] | 0;
  $17 = $16 & 255;
  $18 = ($17 | 0) == 1;
  if (!$18) {
   STACKTOP = sp;
   return;
  }
  $19 = $3;
  $20 = $4;
  _compile_syntax_error($19, $20, 29240);
  STACKTOP = sp;
  return;
 } else {
  $21 = HEAP8[$10 >> 0] | 0;
  $22 = $21 & 255;
  $23 = ($22 | 0) != 5;
  if (!$23) {
   STACKTOP = sp;
   return;
  }
  $24 = $3;
  $25 = $4;
  _compile_syntax_error($24, $25, 29270);
  STACKTOP = sp;
  return;
 }
}

function _vstr_extend($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = $6 + 12 | 0;
 $8 = HEAP8[$7 >> 0] | 0;
 $9 = $8 & 1;
 $10 = $9 & 1;
 if ($10) {
  _mp_raise_msg(15772, 0);
 } else {
  $11 = $2;
  $12 = $11 + 8 | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = $2;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $3;
  $17 = $15 + $16 | 0;
  $18 = $17;
  $19 = _m_realloc($13, $18) | 0;
  $4 = $19;
  $20 = $4;
  $21 = $2;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = $20 + $22 | 0;
  $5 = $23;
  $24 = $3;
  $25 = $2;
  $26 = HEAP32[$25 >> 2] | 0;
  $27 = $26 + $24 | 0;
  HEAP32[$25 >> 2] = $27;
  $28 = $4;
  $29 = $2;
  $30 = $29 + 8 | 0;
  HEAP32[$30 >> 2] = $28;
  $31 = $5;
  STACKTOP = sp;
  return $31 | 0;
 }
 return 0 | 0;
}

function _new_namedtuple_type($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = sp + 12 | 0;
 $5 = sp + 4 | 0;
 $6 = sp;
 $2 = $0;
 HEAP32[$3 >> 2] = $1;
 $7 = $2;
 $8 = _mp_obj_str_get_qstr($7) | 0;
 $4 = $8;
 $9 = HEAP32[$3 >> 2] | 0;
 $10 = _mp_obj_is_qstr_1088($9) | 0;
 if ($10) {
  label = 4;
 } else {
  $11 = HEAP32[$3 >> 2] | 0;
  $12 = _mp_obj_is_obj_1089($11) | 0;
  if ($12) {
   $13 = HEAP32[$3 >> 2] | 0;
   $14 = HEAP32[$13 >> 2] | 0;
   $15 = ($14 | 0) == (18680 | 0);
   if ($15) {
    label = 4;
   }
  }
 }
 if ((label | 0) == 4) {
  $16 = _mp_obj_str_split(1, $3) | 0;
  HEAP32[$3 >> 2] = $16;
 }
 $17 = HEAP32[$3 >> 2] | 0;
 _mp_obj_get_array($17, $5, $6);
 $18 = $4;
 $19 = HEAP32[$5 >> 2] | 0;
 $20 = HEAP32[$6 >> 2] | 0;
 $21 = _mp_obj_new_namedtuple_type($18, $19, $20) | 0;
 STACKTOP = sp;
 return $21 | 0;
}

function _gs2_hmsb_fill_rect($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 $14 = $7;
 $12 = $14;
 while (1) {
  $15 = $12;
  $16 = $7;
  $17 = $9;
  $18 = $16 + $17 | 0;
  $19 = ($15 | 0) < ($18 | 0);
  if (!$19) {
   break;
  }
  $20 = $8;
  $13 = $20;
  while (1) {
   $21 = $13;
   $22 = $8;
   $23 = $10;
   $24 = $22 + $23 | 0;
   $25 = ($21 | 0) < ($24 | 0);
   if (!$25) {
    break;
   }
   $26 = $6;
   $27 = $12;
   $28 = $13;
   $29 = $11;
   _gs2_hmsb_setpixel($26, $27, $28, $29);
   $30 = $13;
   $31 = $30 + 1 | 0;
   $13 = $31;
  }
  $32 = $12;
  $33 = $32 + 1 | 0;
  $12 = $33;
 }
 STACKTOP = sp;
 return;
}

function _realloc($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = ($0 | 0) == (0 | 0);
 if ($2) {
  $3 = _malloc($1) | 0;
  $$1 = $3;
  return $$1 | 0;
 }
 $4 = $1 >>> 0 > 4294967231;
 if ($4) {
  $5 = ___errno_location() | 0;
  HEAP32[$5 >> 2] = 12;
  $$1 = 0;
  return $$1 | 0;
 }
 $6 = $1 >>> 0 < 11;
 $7 = $1 + 11 | 0;
 $8 = $7 & -8;
 $9 = $6 ? 16 : $8;
 $10 = $0 + -8 | 0;
 $11 = _try_realloc_chunk($10, $9) | 0;
 $12 = ($11 | 0) == (0 | 0);
 if (!$12) {
  $13 = $11 + 8 | 0;
  $$1 = $13;
  return $$1 | 0;
 }
 $14 = _malloc($1) | 0;
 $15 = ($14 | 0) == (0 | 0);
 if ($15) {
  $$1 = 0;
  return $$1 | 0;
 }
 $16 = $0 + -4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $17 & -8;
 $19 = $17 & 3;
 $20 = ($19 | 0) == 0;
 $21 = $20 ? 8 : 4;
 $22 = $18 - $21 | 0;
 $23 = $22 >>> 0 < $1 >>> 0;
 $24 = $23 ? $22 : $1;
 _memcpy($14 | 0, $0 | 0, $24 | 0) | 0;
 _free($0);
 $$1 = $14;
 return $$1 | 0;
}

function _mpz_hash($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = 0;
 $4 = $1;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $1;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $6 + ($9 << 1) | 0;
 $3 = $10;
 while (1) {
  $11 = $3;
  $12 = $11 + -2 | 0;
  $3 = $12;
  $13 = $1;
  $14 = $13 + 8 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $11 >>> 0 > $15 >>> 0;
  if (!$16) {
   break;
  }
  $17 = $2;
  $18 = $17 << 16;
  $19 = $3;
  $20 = HEAP16[$19 >> 1] | 0;
  $21 = $20 & 65535;
  $22 = $18 | $21;
  $2 = $22;
 }
 $23 = $1;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $24 & 1;
 $26 = ($25 | 0) != 0;
 if (!$26) {
  $29 = $2;
  STACKTOP = sp;
  return $29 | 0;
 }
 $27 = $2;
 $28 = 0 - $27 | 0;
 $2 = $28;
 $29 = $2;
 STACKTOP = sp;
 return $29 | 0;
}

function _atanh($0) {
 $0 = +$0;
 var $$0 = 0.0, $$sink19 = 0.0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0, $21 = 0.0, $22 = 0.0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = _bitshift64Lshr($1 | 0, $2 | 0, 52) | 0;
 $4 = getTempRet0() | 0;
 $5 = $3 & 2047;
 $6 = $2 & 2147483647;
 HEAP32[tempDoublePtr >> 2] = $1;
 HEAP32[tempDoublePtr + 4 >> 2] = $6;
 $7 = +HEAPF64[tempDoublePtr >> 3];
 $8 = $5 >>> 0 < 1022;
 if ($8) {
  $9 = $5 >>> 0 < 991;
  if ($9) {
   $$0 = $7;
  } else {
   $10 = $7 * 2.0;
   $11 = $10 * $7;
   $12 = 1.0 - $7;
   $13 = $11 / $12;
   $14 = $10 + $13;
   $$sink19 = $14;
   label = 5;
  }
 } else {
  $15 = 1.0 - $7;
  $16 = $7 / $15;
  $17 = $16 * 2.0;
  $$sink19 = $17;
  label = 5;
 }
 if ((label | 0) == 5) {
  $18 = +_log1p($$sink19);
  $19 = $18 * .5;
  $$0 = $19;
 }
 $20 = ($2 | 0) < 0;
 $21 = -$$0;
 $22 = $20 ? $21 : $$0;
 return +$22;
}

function _ujson_stream_next($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = $3 + 4 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 $6 = $1;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $1;
 $9 = $8 + 12 | 0;
 $10 = $1;
 $11 = $10 + 8 | 0;
 $12 = FUNCTION_TABLE_iiiii[$5 & 1023]($7, $9, 1, $11) | 0;
 $2 = $12;
 $13 = $1;
 $14 = $13 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = ($15 | 0) != 0;
 if ($16) {
  $17 = $1;
  $18 = $17 + 8 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  _mp_raise_OSError($19);
 }
 $20 = $2;
 $21 = ($20 | 0) == 0;
 if (!$21) {
  $24 = $1;
  $25 = $24 + 12 | 0;
  $26 = HEAP8[$25 >> 0] | 0;
  STACKTOP = sp;
  return $26 | 0;
 }
 $22 = $1;
 $23 = $22 + 12 | 0;
 HEAP8[$23 >> 0] = 0;
 $24 = $1;
 $25 = $24 + 12 | 0;
 $26 = HEAP8[$25 >> 0] | 0;
 STACKTOP = sp;
 return $26 | 0;
}

function _mono_horiz_getpixel($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $32 = 0, $33 = 0, $34 = 0, $35 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $4;
 $9 = $5;
 $10 = $3;
 $11 = $10 + 16 | 0;
 $12 = HEAP16[$11 >> 1] | 0;
 $13 = $12 & 65535;
 $14 = Math_imul($9, $13) | 0;
 $15 = $8 + $14 | 0;
 $16 = $15 >> 3;
 $6 = $16;
 $17 = $3;
 $18 = $17 + 18 | 0;
 $19 = HEAP8[$18 >> 0] | 0;
 $20 = $19 & 255;
 $21 = ($20 | 0) == 4;
 $22 = $4;
 $23 = $22 & 7;
 $24 = 7 - $23 | 0;
 $25 = $21 ? $23 : $24;
 $7 = $25;
 $26 = $3;
 $27 = $26 + 8 | 0;
 $28 = HEAP32[$27 >> 2] | 0;
 $29 = $6;
 $30 = $28 + $29 | 0;
 $31 = HEAP8[$30 >> 0] | 0;
 $32 = $31 & 255;
 $33 = $7;
 $34 = $32 >> $33;
 $35 = $34 & 1;
 STACKTOP = sp;
 return $35 | 0;
}

function _range_len($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $spec$store$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = $3 + 8 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 $6 = $1;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $5 - $8 | 0;
 $10 = $1;
 $11 = $10 + 12 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $9 + $12 | 0;
 $2 = $13;
 $14 = $1;
 $15 = $14 + 12 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($16 | 0) > 0;
 $18 = $2;
 if ($17) {
  $19 = $18 - 1 | 0;
  $2 = $19;
 } else {
  $20 = $18 + 1 | 0;
  $2 = $20;
 }
 $21 = $2;
 $22 = $1;
 $23 = $22 + 12 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = ($21 | 0) / ($24 | 0) & -1;
 $2 = $25;
 $26 = $2;
 $27 = ($26 | 0) < 0;
 $spec$store$select = $27 ? 0 : $25;
 $2 = $spec$store$select;
 $28 = $2;
 STACKTOP = sp;
 return $28 | 0;
}

function _mp_module_get($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = 40612;
 $5 = $3;
 $6 = $2;
 $7 = $6 << 2;
 $8 = $7 | 2;
 $9 = $8;
 $10 = _mp_map_lookup($5, $9, 0) | 0;
 $4 = $10;
 $11 = $4;
 $12 = ($11 | 0) == (0 | 0);
 do {
  if ($12) {
   $13 = $2;
   $14 = $13 << 2;
   $15 = $14 | 2;
   $16 = $15;
   $17 = _mp_map_lookup(17324, $16, 0) | 0;
   $4 = $17;
   $18 = $4;
   $19 = ($18 | 0) == (0 | 0);
   if (!$19) {
    $20 = $2;
    $21 = $4;
    $22 = $21 + 4 | 0;
    $23 = HEAP32[$22 >> 2] | 0;
    _mp_module_call_init($20, $23);
    break;
   }
   $1 = 0;
   $27 = $1;
   STACKTOP = sp;
   return $27 | 0;
  }
 } while (0);
 $24 = $4;
 $25 = $24 + 4 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $1 = $26;
 $27 = $1;
 STACKTOP = sp;
 return $27 | 0;
}

function _type_call($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $4;
 $8 = $10;
 $11 = $8;
 $12 = $11 + 12 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = ($13 | 0) == (0 | 0);
 $15 = $8;
 if ($14) {
  $16 = $15 + 6 | 0;
  $17 = HEAP16[$16 >> 1] | 0;
  $18 = $17 & 65535;
  HEAP32[$vararg_buffer >> 2] = $18;
  $19 = _mp_obj_new_exception_msg_varg(16012, 33096, $vararg_buffer) | 0;
  _nlr_jump($19);
 } else {
  $20 = $15 + 12 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  $22 = $8;
  $23 = $5;
  $24 = $6;
  $25 = $7;
  $26 = FUNCTION_TABLE_iiiii[$21 & 1023]($22, $23, $24, $25) | 0;
  $9 = $26;
  $27 = $9;
  STACKTOP = sp;
  return $27 | 0;
 }
 return 0 | 0;
}

function _framebuf_get_buffer($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $6 = $7;
 $8 = $6;
 $9 = $8 + 8 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $4;
 HEAP32[$11 >> 2] = $10;
 $12 = $6;
 $13 = $12 + 16 | 0;
 $14 = HEAP16[$13 >> 1] | 0;
 $15 = $14 & 65535;
 $16 = $6;
 $17 = $16 + 14 | 0;
 $18 = HEAP16[$17 >> 1] | 0;
 $19 = $18 & 65535;
 $20 = Math_imul($15, $19) | 0;
 $21 = $6;
 $22 = $21 + 18 | 0;
 $23 = HEAP8[$22 >> 0] | 0;
 $24 = $23 & 255;
 $25 = ($24 | 0) == 1;
 $26 = $25 ? 2 : 1;
 $27 = Math_imul($20, $26) | 0;
 $28 = $4;
 $29 = $28 + 4 | 0;
 HEAP32[$29 >> 2] = $27;
 $30 = $4;
 $31 = $30 + 8 | 0;
 HEAP32[$31 >> 2] = 66;
 STACKTOP = sp;
 return 0;
}

function _acosh($0) {
 $0 = +$0;
 var $$0 = 0.0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = _bitshift64Lshr($1 | 0, $2 | 0, 52) | 0;
 $4 = getTempRet0() | 0;
 $5 = $3 & 2047;
 $6 = $5 >>> 0 < 1024;
 do {
  if ($6) {
   $7 = $0 + -1.0;
   $8 = $7 * $7;
   $9 = $7 * 2.0;
   $10 = $8 + $9;
   $11 = +Math_sqrt(+$10);
   $12 = $7 + $11;
   $13 = +_log1p($12);
   $$0 = $13;
  } else {
   $14 = $5 >>> 0 < 1049;
   if ($14) {
    $15 = $0 * 2.0;
    $16 = $0 * $0;
    $17 = $16 + -1.0;
    $18 = +Math_sqrt(+$17);
    $19 = $18 + $0;
    $20 = 1.0 / $19;
    $21 = $15 - $20;
    $22 = +_log($21);
    $$0 = $22;
    break;
   } else {
    $23 = +_log($0);
    $24 = $23 + .6931471805599453;
    $$0 = $24;
    break;
   }
  }
 } while (0);
 return +$$0;
}

function _mpz_set($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = $5 + 4 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 _mpz_need_dig($4, $7);
 $8 = $3;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 & 1;
 $11 = $2;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $10 & 1;
 $14 = $12 & -2;
 $15 = $14 | $13;
 HEAP32[$11 >> 2] = $15;
 $16 = $3;
 $17 = $16 + 4 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $2;
 $20 = $19 + 4 | 0;
 HEAP32[$20 >> 2] = $18;
 $21 = $2;
 $22 = $21 + 8 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $3;
 $25 = $24 + 8 | 0;
 $26 = HEAP32[$25 >> 2] | 0;
 $27 = $3;
 $28 = $27 + 4 | 0;
 $29 = HEAP32[$28 >> 2] | 0;
 $30 = $29 << 1;
 _memcpy($23 | 0, $26 | 0, $30 | 0) | 0;
 STACKTOP = sp;
 return;
}

function _mp_map_init_fixed_table($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $4;
 $7 = $3;
 $8 = $7 + 4 | 0;
 HEAP32[$8 >> 2] = $6;
 $9 = $4;
 $10 = $3;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $9 & 536870911;
 $13 = $12 << 3;
 $14 = $11 & 7;
 $15 = $14 | $13;
 HEAP32[$10 >> 2] = $15;
 $16 = $3;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $17 & -2;
 $19 = $18 | 1;
 HEAP32[$16 >> 2] = $19;
 $20 = $3;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $21 & -3;
 $23 = $22 | 2;
 HEAP32[$20 >> 2] = $23;
 $24 = $3;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = $25 & -5;
 $27 = $26 | 4;
 HEAP32[$24 >> 2] = $27;
 $28 = $5;
 $29 = $3;
 $30 = $29 + 8 | 0;
 HEAP32[$30 >> 2] = $28;
 STACKTOP = sp;
 return;
}

function _compile_declare_global($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $5;
 $7 = HEAP8[$6 >> 0] | 0;
 $8 = $7 & 255;
 $9 = ($8 | 0) != 0;
 if ($9) {
  $10 = $5;
  $11 = HEAP8[$10 >> 0] | 0;
  $12 = $11 & 255;
  $13 = ($12 | 0) != 2;
  if ($13) {
   $14 = $3;
   $15 = $4;
   _compile_syntax_error($14, $15, 29303);
   STACKTOP = sp;
   return;
  }
 }
 $16 = $5;
 HEAP8[$16 >> 0] = 2;
 $17 = $3;
 $18 = $17 + 36 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $5;
 $21 = $20 + 4 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = _scope_find_global($19, $22) | 0;
 $5 = $23;
 $24 = $5;
 $25 = ($24 | 0) != (0 | 0);
 if (!$25) {
  STACKTOP = sp;
  return;
 }
 $26 = $5;
 HEAP8[$26 >> 0] = 2;
 STACKTOP = sp;
 return;
}

function _mp_call_function_n_kw($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $4;
 $10 = _mp_obj_get_type($9) | 0;
 $8 = $10;
 $11 = $8;
 $12 = $11 + 16 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = ($13 | 0) != (0 | 0);
 if ($14) {
  $15 = $8;
  $16 = $15 + 16 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = $4;
  $19 = $5;
  $20 = $6;
  $21 = $7;
  $22 = FUNCTION_TABLE_iiiii[$17 & 1023]($18, $19, $20, $21) | 0;
  STACKTOP = sp;
  return $22 | 0;
 } else {
  $23 = $4;
  $24 = _mp_obj_get_type_str($23) | 0;
  HEAP32[$vararg_buffer >> 2] = $24;
  $25 = _mp_obj_new_exception_msg_varg(16012, 33260, $vararg_buffer) | 0;
  _nlr_jump($25);
 }
 return 0 | 0;
}

function _mp_micropython_qstr_info($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_ptr1 = 0, $vararg_ptr2 = 0, $vararg_ptr3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $vararg_buffer = sp;
 $4 = sp + 28 | 0;
 $5 = sp + 24 | 0;
 $6 = sp + 20 | 0;
 $7 = sp + 16 | 0;
 $2 = $0;
 $3 = $1;
 _qstr_pool_info($4, $5, $6, $7);
 $8 = HEAP32[$4 >> 2] | 0;
 $9 = HEAP32[$5 >> 2] | 0;
 $10 = HEAP32[$6 >> 2] | 0;
 $11 = HEAP32[$7 >> 2] | 0;
 HEAP32[$vararg_buffer >> 2] = $8;
 $vararg_ptr1 = $vararg_buffer + 4 | 0;
 HEAP32[$vararg_ptr1 >> 2] = $9;
 $vararg_ptr2 = $vararg_buffer + 8 | 0;
 HEAP32[$vararg_ptr2 >> 2] = $10;
 $vararg_ptr3 = $vararg_buffer + 12 | 0;
 HEAP32[$vararg_ptr3 >> 2] = $11;
 _mp_printf(13344, 33880, $vararg_buffer) | 0;
 $12 = $2;
 $13 = ($12 | 0) == 1;
 if (!$13) {
  STACKTOP = sp;
  return 17668 | 0;
 }
 _qstr_dump_data();
 STACKTOP = sp;
 return 17668 | 0;
}

function _mp_obj_is_exception_type($0) {
 $0 = $0 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$pre_trunc = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = sp + 8 | 0;
 $2 = $0;
 $4 = $2;
 $5 = _mp_obj_is_obj_949($4) | 0;
 if ($5) {
  $6 = $2;
  $7 = HEAP32[$6 >> 2] | 0;
  $8 = ($7 | 0) == (19048 | 0);
  if ($8) {
   $9 = $2;
   $3 = $9;
   $10 = $3;
   $11 = $10 + 12 | 0;
   $12 = HEAP32[$11 >> 2] | 0;
   $13 = ($12 | 0) == (108 | 0);
   if ($13) {
    $$expand_i1_val = 1;
    HEAP8[$1 >> 0] = $$expand_i1_val;
    $$pre_trunc = HEAP8[$1 >> 0] | 0;
    $16 = $$pre_trunc & 1;
    STACKTOP = sp;
    return $16 | 0;
   }
  }
 }
 $14 = $2;
 $15 = _mp_obj_is_subclass_fast($14, 14616) | 0;
 $$expand_i1_val2 = $15 & 1;
 HEAP8[$1 >> 0] = $$expand_i1_val2;
 $$pre_trunc = HEAP8[$1 >> 0] | 0;
 $16 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $16 | 0;
}

function _get_hash_alloc_greater_or_equal_to($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = 0;
 while (1) {
  $4 = $3;
  $5 = $4 >>> 0 < 34;
  if (!$5) {
   label = 6;
   break;
  }
  $6 = $3;
  $7 = 3056 + ($6 << 1) | 0;
  $8 = HEAP16[$7 >> 1] | 0;
  $9 = $8 & 65535;
  $10 = $2;
  $11 = $9 >>> 0 >= $10 >>> 0;
  $12 = $3;
  if ($11) {
   label = 4;
   break;
  }
  $16 = $12 + 1 | 0;
  $3 = $16;
 }
 if ((label | 0) == 4) {
  $13 = 3056 + ($12 << 1) | 0;
  $14 = HEAP16[$13 >> 1] | 0;
  $15 = $14 & 65535;
  $1 = $15;
  $22 = $1;
  STACKTOP = sp;
  return $22 | 0;
 } else if ((label | 0) == 6) {
  $17 = $2;
  $18 = $2;
  $19 = ($18 >>> 0) / 2 & -1;
  $20 = $17 + $19 | 0;
  $21 = $20 | 1;
  $1 = $21;
  $22 = $1;
  STACKTOP = sp;
  return $22 | 0;
 }
 return 0 | 0;
}

function _erfc1($0) {
 $0 = +$0;
 var $1 = 0.0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0.0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $28 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = +Math_abs(+$0);
 $2 = $1 + -1.0;
 $3 = $2 * .002166375594868791;
 $4 = .035478304325618236 - $3;
 $5 = $2 * $4;
 $6 = $5 + -.11089469428239668;
 $7 = $2 * $6;
 $8 = $7 + .31834661990116175;
 $9 = $2 * $8;
 $10 = $9 + -.3722078760357013;
 $11 = $2 * $10;
 $12 = $11 + .41485611868374833;
 $13 = $2 * $12;
 $14 = $13 + -2.3621185607526594e-03;
 $15 = $2 * .011984499846799107;
 $16 = $15 + .01363708391202905;
 $17 = $2 * $16;
 $18 = $17 + .12617121980876164;
 $19 = $2 * $18;
 $20 = $19 + .07182865441419627;
 $21 = $2 * $20;
 $22 = $21 + .540397917702171;
 $23 = $2 * $22;
 $24 = $23 + .10642088040084423;
 $25 = $2 * $24;
 $26 = $25 + 1.0;
 $27 = $14 / $26;
 $28 = .15493708848953247 - $27;
 return +$28;
}

function _framebuf_vline($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $9 = $3;
 $10 = HEAP32[$9 >> 2] | 0;
 $4 = $10;
 $11 = $3;
 $12 = $11 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = _mp_obj_get_int($13) | 0;
 $5 = $14;
 $15 = $3;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = _mp_obj_get_int($17) | 0;
 $6 = $18;
 $19 = $3;
 $20 = $19 + 12 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = _mp_obj_get_int($21) | 0;
 $7 = $22;
 $23 = $3;
 $24 = $23 + 16 | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = _mp_obj_get_int($25) | 0;
 $8 = $26;
 $27 = $4;
 $28 = $5;
 $29 = $6;
 $30 = $7;
 $31 = $8;
 _fill_rect($27, $28, $29, 1, $30, $31);
 STACKTOP = sp;
 return 17668 | 0;
}

function _framebuf_hline($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $9 = $3;
 $10 = HEAP32[$9 >> 2] | 0;
 $4 = $10;
 $11 = $3;
 $12 = $11 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = _mp_obj_get_int($13) | 0;
 $5 = $14;
 $15 = $3;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = _mp_obj_get_int($17) | 0;
 $6 = $18;
 $19 = $3;
 $20 = $19 + 12 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = _mp_obj_get_int($21) | 0;
 $7 = $22;
 $23 = $3;
 $24 = $23 + 16 | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = _mp_obj_get_int($25) | 0;
 $8 = $26;
 $27 = $4;
 $28 = $5;
 $29 = $6;
 $30 = $7;
 $31 = $8;
 _fill_rect($27, $28, $29, $30, 1, $31);
 STACKTOP = sp;
 return 17668 | 0;
}

function _mp_load_attr_default($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $7 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $8 = $6;
 $9 = ($8 | 0) == (0 | 0);
 $10 = $9 ? 542 : 495;
 $11 = $4;
 $12 = $5;
 FUNCTION_TABLE_viii[$10 & 1023]($11, $12, $7);
 $13 = HEAP32[$7 >> 2] | 0;
 $14 = ($13 | 0) == (0 | 0);
 if ($14) {
  $15 = $6;
  $3 = $15;
  $23 = $3;
  STACKTOP = sp;
  return $23 | 0;
 }
 $16 = $7 + 4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = ($17 | 0) == (0 | 0);
 $19 = HEAP32[$7 >> 2] | 0;
 if ($18) {
  $3 = $19;
  $23 = $3;
  STACKTOP = sp;
  return $23 | 0;
 } else {
  $20 = $7 + 4 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  $22 = _mp_obj_new_bound_meth($19, $21) | 0;
  $3 = $22;
  $23 = $3;
  STACKTOP = sp;
  return $23 | 0;
 }
 return 0 | 0;
}

function _mp_stream_write($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $9 = sp + 4 | 0;
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $8;
 $15 = _mp_stream_rw($11, $12, $13, $9, $14) | 0;
 $10 = $15;
 $16 = HEAP32[$9 >> 2] | 0;
 $17 = ($16 | 0) != 0;
 if (!$17) {
  $23 = $10;
  $24 = $23 << 1;
  $25 = $24 | 1;
  $26 = $25;
  $4 = $26;
  $27 = $4;
  STACKTOP = sp;
  return $27 | 0;
 }
 $18 = HEAP32[$9 >> 2] | 0;
 $19 = ($18 | 0) == 11;
 $20 = HEAP32[$9 >> 2] | 0;
 $21 = ($20 | 0) == 11;
 $or$cond = $19 | $21;
 if (!$or$cond) {
  $22 = HEAP32[$9 >> 2] | 0;
  _mp_raise_OSError($22);
 }
 $4 = 17668;
 $27 = $4;
 STACKTOP = sp;
 return $27 | 0;
}

function _gen_resume_and_raise($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $7 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $8 = $4;
 $9 = $5;
 $10 = $6;
 $11 = _mp_obj_gen_resume($8, $9, $10, $7) | 0;
 switch ($11 | 0) {
 case 2:
  {
   $18 = HEAP32[$7 >> 2] | 0;
   _nlr_jump($18);
   break;
  }
 case 1:
  {
   $17 = HEAP32[$7 >> 2] | 0;
   $3 = $17;
   $19 = $3;
   STACKTOP = sp;
   return $19 | 0;
   break;
  }
 default:
  {
   $12 = HEAP32[$7 >> 2] | 0;
   $13 = ($12 | 0) == (17668 | 0);
   $14 = HEAP32[$7 >> 2] | 0;
   $15 = ($14 | 0) == (0 | 0);
   $or$cond = $13 | $15;
   if (!$or$cond) {
    $16 = _mp_obj_new_exception_args(14676, 1, $7) | 0;
    _nlr_jump($16);
   }
   $3 = 0;
   $19 = $3;
   STACKTOP = sp;
   return $19 | 0;
  }
 }
 return 0 | 0;
}

function _property_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $8 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $5;
 $11 = $6;
 $12 = $7;
 _mp_arg_parse_all_kw_array($10, $11, $12, 4, 3808, $8);
 $13 = _m_malloc(16) | 0;
 $9 = $13;
 $14 = $4;
 $15 = $9;
 HEAP32[$15 >> 2] = $14;
 $16 = HEAP32[$8 >> 2] | 0;
 $17 = $9;
 $18 = $17 + 4 | 0;
 HEAP32[$18 >> 2] = $16;
 $19 = $8 + 4 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = $9;
 $22 = $21 + 4 | 0;
 $23 = $22 + 4 | 0;
 HEAP32[$23 >> 2] = $20;
 $24 = $8 + 8 | 0;
 $25 = HEAP32[$24 >> 2] | 0;
 $26 = $9;
 $27 = $26 + 4 | 0;
 $28 = $27 + 8 | 0;
 HEAP32[$28 >> 2] = $25;
 $29 = $9;
 STACKTOP = sp;
 return $29 | 0;
}

function _compile_return_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 36 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = ($7 | 0) != 7;
 if ($8) {
  $9 = $2;
  $10 = $3;
  $11 = $10;
  _compile_syntax_error($9, $11, 29334);
  STACKTOP = sp;
  return;
 }
 $12 = $3;
 $13 = $12 + 8 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = ($14 | 0) == 0;
 $16 = $2;
 if ($15) {
  $17 = $16 + 40 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  _mp_emit_bc_load_const_tok($18, 14);
 } else {
  $19 = $3;
  $20 = $19 + 8 | 0;
  $21 = HEAP32[$20 >> 2] | 0;
  _compile_node($16, $21);
 }
 $22 = $2;
 $23 = $22 + 40 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 _mp_emit_bc_return_value($24);
 STACKTOP = sp;
 return;
}

function _mp_cmath_sqrt($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0, $3 = 0, $4 = 0.0, $5 = 0.0, $6 = 0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $2 = sp + 24 | 0;
 $3 = sp + 16 | 0;
 $1 = $0;
 $6 = $1;
 _mp_obj_get_complex($6, $2, $3);
 $7 = +HEAPF64[$2 >> 3];
 $8 = +HEAPF64[$2 >> 3];
 $9 = $7 * $8;
 $10 = +HEAPF64[$3 >> 3];
 $11 = +HEAPF64[$3 >> 3];
 $12 = $10 * $11;
 $13 = $9 + $12;
 $14 = +Math_pow(+$13, .25);
 $4 = $14;
 $15 = +HEAPF64[$3 >> 3];
 $16 = +HEAPF64[$2 >> 3];
 $17 = +_atan2($15, $16);
 $18 = .5 * $17;
 $5 = $18;
 $19 = $4;
 $20 = $5;
 $21 = +_llvm_cos_f64(+$20);
 $22 = $19 * $21;
 $23 = $4;
 $24 = $5;
 $25 = +_llvm_sin_f64(+$24);
 $26 = $23 * $25;
 $27 = _mp_obj_new_complex($22, $26) | 0;
 STACKTOP = sp;
 return $27 | 0;
}

function _gc_threshold($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $3;
 $7 = ($6 | 0) == 0;
 if ($7) {
  $8 = HEAP32[41028 >> 2] | 0;
  $9 = ($8 | 0) == -1;
  if ($9) {
   $2 = -1;
   $20 = $2;
   STACKTOP = sp;
   return $20 | 0;
  } else {
   $10 = HEAP32[41028 >> 2] | 0;
   $11 = $10 << 4;
   $12 = _mp_obj_new_int($11) | 0;
   $2 = $12;
   $20 = $2;
   STACKTOP = sp;
   return $20 | 0;
  }
 } else {
  $13 = $4;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = _mp_obj_get_int($14) | 0;
  $5 = $15;
  $16 = $5;
  $17 = ($16 | 0) < 0;
  if ($17) {
   HEAP32[41028 >> 2] = -1;
  } else {
   $18 = $5;
   $19 = ($18 >>> 0) / 16 & -1;
   HEAP32[41028 >> 2] = $19;
  }
  $2 = 17668;
  $20 = $2;
  STACKTOP = sp;
  return $20 | 0;
 }
 return 0 | 0;
}

function _gen_instance_throw($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $4 = $8;
 $9 = $2;
 $10 = $9 >>> 0 > 2;
 if ($10) {
  $11 = $3;
  $12 = $11 + 8 | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = ($13 | 0) != (17668 | 0);
  if ($14) {
   $15 = $3;
   $16 = $15 + 8 | 0;
   $17 = HEAP32[$16 >> 2] | 0;
   $4 = $17;
  }
 }
 $18 = $3;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $4;
 $21 = _gen_resume_and_raise($19, 17668, $20) | 0;
 $5 = $21;
 $22 = $5;
 $23 = ($22 | 0) == (0 | 0);
 if ($23) {
  $24 = _mp_obj_new_exception(14676) | 0;
  _nlr_jump($24);
 } else {
  $25 = $5;
  STACKTOP = sp;
  return $25 | 0;
 }
 return 0 | 0;
}

function _mp_emit_bc_label_assign($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 _emit_bc_pre($4, 0);
 $5 = $2;
 $6 = $5 + 5 | 0;
 $7 = HEAPU8[$6 >> 0] | HEAPU8[$6 + 1 >> 0] << 8;
 $8 = $7 & 255;
 $9 = $8 & 65535;
 $10 = ($9 | 0) == 1;
 if ($10) {
  STACKTOP = sp;
  return;
 }
 $11 = $2;
 $12 = $11 + 5 | 0;
 $13 = HEAPU8[$12 >> 0] | HEAPU8[$12 + 1 >> 0] << 8;
 $14 = $13 & 255;
 $15 = $14 & 65535;
 $16 = ($15 | 0) < 4;
 if (!$16) {
  STACKTOP = sp;
  return;
 }
 $17 = $2;
 $18 = $17 + 40 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $2;
 $21 = $20 + 28 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = $3;
 $24 = $22 + ($23 << 2) | 0;
 HEAP32[$24 >> 2] = $19;
 STACKTOP = sp;
 return;
}

function _mp_handle_pending_tail($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp;
 $1 = $0;
 HEAP16[40740 >> 1] = -1;
 $3 = _mp_sched_empty() | 0;
 if ($3) {
  _mp_sched_unlock();
  STACKTOP = sp;
  return;
 } else {
  $4 = HEAP8[40743 >> 0] | 0;
  $5 = $4 & 255;
  $6 = 40628 + ($5 << 3) | 0;
  HEAP32[$2 >> 2] = HEAP32[$6 >> 2] | 0;
  HEAP32[$2 + 4 >> 2] = HEAP32[$6 + 4 >> 2] | 0;
  $7 = HEAP8[40743 >> 0] | 0;
  $8 = $7 & 255;
  $9 = $8 + 1 | 0;
  $10 = $9 & 0;
  $11 = $10 & 255;
  HEAP8[40743 >> 0] = $11;
  $12 = HEAP8[40742 >> 0] | 0;
  $13 = $12 + -1 << 24 >> 24;
  HEAP8[40742 >> 0] = $13;
  $14 = HEAP32[$2 >> 2] | 0;
  $15 = $2 + 4 | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  _mp_call_function_1_protected($14, $16) | 0;
  _mp_sched_unlock();
  STACKTOP = sp;
  return;
 }
}

function _mpz_init_fixed_from_int($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $8 = $4;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 & -2;
 HEAP32[$8 >> 2] = $10;
 $11 = $4;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $12 & -3;
 $14 = $13 | 2;
 HEAP32[$11 >> 2] = $14;
 $15 = $6;
 $16 = $4;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $15 & 1073741823;
 $19 = $18 << 2;
 $20 = $17 & 3;
 $21 = $20 | $19;
 HEAP32[$16 >> 2] = $21;
 $22 = $4;
 $23 = $22 + 4 | 0;
 HEAP32[$23 >> 2] = 0;
 $24 = $5;
 $25 = $4;
 $26 = $25 + 8 | 0;
 HEAP32[$26 >> 2] = $24;
 $27 = $4;
 $28 = $7;
 _mpz_set_from_int($27, $28);
 STACKTOP = sp;
 return;
}

function _cosh($0) {
 $0 = +$0;
 var $$0 = 0.0, $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $2 = 0, $3 = 0, $4 = 0.0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = $2 & 2147483647;
 HEAP32[tempDoublePtr >> 2] = $1;
 HEAP32[tempDoublePtr + 4 >> 2] = $3;
 $4 = +HEAPF64[tempDoublePtr >> 3];
 $5 = $3 >>> 0 < 1072049730;
 do {
  if ($5) {
   $6 = $3 >>> 0 < 1045430272;
   if ($6) {
    $$0 = 1.0;
   } else {
    $7 = +_expm1($4);
    $8 = $7 * $7;
    $9 = $7 + 1.0;
    $10 = $9 * 2.0;
    $11 = $8 / $10;
    $12 = $11 + 1.0;
    $$0 = $12;
   }
  } else {
   $13 = $3 >>> 0 < 1082535490;
   if ($13) {
    $14 = +_exp($4);
    $15 = 1.0 / $14;
    $16 = $14 + $15;
    $17 = $16 * .5;
    $$0 = $17;
    break;
   } else {
    $18 = +___expo2($4);
    $$0 = $18;
    break;
   }
  }
 } while (0);
 return +$$0;
}

function _mp_call_method_n_kw_var($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $6 = sp + 4 | 0;
 $8 = $0 & 1;
 $3 = $8;
 $4 = $1;
 $5 = $2;
 $9 = $3;
 $10 = $9 & 1;
 $11 = $4;
 $12 = $5;
 _mp_call_prepare_args_n_kw_var($10, $11, $12, $6);
 $13 = HEAP32[$6 >> 2] | 0;
 $14 = $6 + 4 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $6 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $6 + 16 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = _mp_call_function_n_kw($13, $15, $17, $19) | 0;
 $7 = $20;
 $21 = $6 + 16 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = $6 + 12 | 0;
 $24 = HEAP32[$23 >> 2] | 0;
 $25 = $24 << 2;
 _mp_nonlocal_free($22, $25);
 $26 = $7;
 STACKTOP = sp;
 return $26 | 0;
}

function _mp_obj_print_helper($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $8 = _mp_obj_get_type($7) | 0;
 $6 = $8;
 $9 = $6;
 $10 = $9 + 8 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = ($11 | 0) != (0 | 0);
 if ($12) {
  $13 = $6;
  $14 = $13 + 8 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $3;
  $17 = $4;
  $18 = $5;
  FUNCTION_TABLE_viii[$15 & 1023]($16, $17, $18);
  STACKTOP = sp;
  return;
 } else {
  $19 = $3;
  $20 = $6;
  $21 = $20 + 6 | 0;
  $22 = HEAP16[$21 >> 1] | 0;
  $23 = $22 & 65535;
  HEAP32[$vararg_buffer >> 2] = $23;
  _mp_printf($19, 30352, $vararg_buffer) | 0;
  STACKTOP = sp;
  return;
 }
}

function _qstr_compute_hash($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = 5381;
 $6 = $2;
 $7 = $3;
 $8 = $6 + $7 | 0;
 $5 = $8;
 while (1) {
  $9 = $2;
  $10 = $5;
  $11 = $9 >>> 0 < $10 >>> 0;
  $12 = $4;
  if (!$11) {
   break;
  }
  $13 = $12 << 5;
  $14 = $4;
  $15 = $13 + $14 | 0;
  $16 = $2;
  $17 = HEAP8[$16 >> 0] | 0;
  $18 = $17 & 255;
  $19 = $15 ^ $18;
  $4 = $19;
  $20 = $2;
  $21 = $20 + 1 | 0;
  $2 = $21;
 }
 $22 = $12 & 65535;
 $4 = $22;
 $23 = $4;
 $24 = ($23 | 0) == 0;
 if (!$24) {
  $27 = $4;
  STACKTOP = sp;
  return $27 | 0;
 }
 $25 = $4;
 $26 = $25 + 1 | 0;
 $4 = $26;
 $27 = $4;
 STACKTOP = sp;
 return $27 | 0;
}

function _gs4_hmsb_getpixel($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $5;
 $8 = ($7 | 0) % 2 & -1;
 $9 = ($8 | 0) != 0;
 $10 = $4;
 $11 = $10 + 8 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $5;
 $14 = $6;
 $15 = $4;
 $16 = $15 + 16 | 0;
 $17 = HEAP16[$16 >> 1] | 0;
 $18 = $17 & 65535;
 $19 = Math_imul($14, $18) | 0;
 $20 = $13 + $19 | 0;
 $21 = $20 >> 1;
 $22 = $12 + $21 | 0;
 $23 = HEAP8[$22 >> 0] | 0;
 $24 = $23 & 255;
 if ($9) {
  $25 = $24 & 15;
  $3 = $25;
  $27 = $3;
  STACKTOP = sp;
  return $27 | 0;
 } else {
  $26 = $24 >> 4;
  $3 = $26;
  $27 = $3;
  STACKTOP = sp;
  return $27 | 0;
 }
 return 0 | 0;
}

function _mp_builtin_input($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = sp + 8 | 0;
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = ($6 | 0) == 1;
 if ($7) {
  $8 = $3;
  $9 = HEAP32[$8 >> 2] | 0;
  _mp_obj_print($9, 0);
 }
 _vstr_init($4, 16);
 $10 = _readline($4, 41653) | 0;
 $5 = $10;
 $11 = $5;
 $12 = ($11 | 0) == 3;
 if ($12) {
  $13 = _mp_obj_new_exception(14932) | 0;
  _nlr_jump($13);
 }
 $14 = $4 + 4 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = ($15 | 0) == 0;
 $17 = $5;
 $18 = ($17 | 0) == 4;
 $or$cond = $16 & $18;
 if ($or$cond) {
  $19 = _mp_obj_new_exception(15352) | 0;
  _nlr_jump($19);
 } else {
  $20 = _mp_obj_new_str_from_vstr(18680, $4) | 0;
  STACKTOP = sp;
  return $20 | 0;
 }
 return 0 | 0;
}

function _complex_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0.0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0.0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $5;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) != (0 | 0);
 if ($9) {
  STACKTOP = sp;
  return;
 }
 $10 = $3;
 $6 = $10;
 $11 = $4;
 $12 = ($11 | 0) == 449;
 if ($12) {
  $13 = $6;
  $14 = $13 + 8 | 0;
  $15 = +HEAPF64[$14 >> 3];
  $16 = _mp_obj_new_float($15) | 0;
  $17 = $5;
  HEAP32[$17 >> 2] = $16;
  STACKTOP = sp;
  return;
 }
 $18 = $4;
 $19 = ($18 | 0) == 384;
 if (!$19) {
  STACKTOP = sp;
  return;
 }
 $20 = $6;
 $21 = $20 + 16 | 0;
 $22 = +HEAPF64[$21 >> 3];
 $23 = _mp_obj_new_float($22) | 0;
 $24 = $5;
 HEAP32[$24 >> 2] = $23;
 STACKTOP = sp;
 return;
}

function _tinf_read_bits($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = 0;
 $9 = $4;
 $10 = ($9 | 0) != 0;
 if (!$10) {
  $24 = $6;
  $25 = $5;
  $26 = $24 + $25 | 0;
  STACKTOP = sp;
  return $26 | 0;
 }
 $11 = $4;
 $12 = 1 << $11;
 $7 = $12;
 $8 = 1;
 while (1) {
  $13 = $8;
  $14 = $7;
  $15 = $13 >>> 0 < $14 >>> 0;
  if (!$15) {
   break;
  }
  $16 = $3;
  $17 = _tinf_getbit($16) | 0;
  $18 = ($17 | 0) != 0;
  if ($18) {
   $19 = $8;
   $20 = $6;
   $21 = $20 + $19 | 0;
   $6 = $21;
  }
  $22 = $8;
  $23 = $22 << 1;
  $8 = $23;
 }
 $24 = $6;
 $25 = $5;
 $26 = $24 + $25 | 0;
 STACKTOP = sp;
 return $26 | 0;
}

function _pad($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $$0$lcssa = 0, $$011 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 256 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(256 | 0);
 $5 = sp;
 $6 = $4 & 73728;
 $7 = ($6 | 0) == 0;
 $8 = ($2 | 0) > ($3 | 0);
 $or$cond = $8 & $7;
 if ($or$cond) {
  $9 = $2 - $3 | 0;
  $10 = $1 << 24 >> 24;
  $11 = $9 >>> 0 < 256;
  $12 = $11 ? $9 : 256;
  _memset($5 | 0, $10 | 0, $12 | 0) | 0;
  $13 = $9 >>> 0 > 255;
  if ($13) {
   $14 = $2 - $3 | 0;
   $$011 = $9;
   while (1) {
    _out($0, $5, 256);
    $15 = $$011 + -256 | 0;
    $16 = $15 >>> 0 > 255;
    if ($16) {
     $$011 = $15;
    } else {
     break;
    }
   }
   $17 = $14 & 255;
   $$0$lcssa = $17;
  } else {
   $$0$lcssa = $9;
  }
  _out($0, $5, $$0$lcssa);
 }
 STACKTOP = sp;
 return;
}

function _gen_instance_pend_throw($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $4 = $6;
 $7 = $4;
 $8 = $7 + 8 | 0;
 $9 = $8 + 8 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $4;
 $12 = $11 + 8 | 0;
 $13 = $12 + 20 | 0;
 $14 = $13 + -4 | 0;
 $15 = ($10 | 0) == ($14 | 0);
 if ($15) {
  _mp_raise_TypeError(31132);
 } else {
  $16 = $4;
  $17 = $16 + 8 | 0;
  $18 = $17 + 8 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $5 = $20;
  $21 = $3;
  $22 = $4;
  $23 = $22 + 8 | 0;
  $24 = $23 + 8 | 0;
  $25 = HEAP32[$24 >> 2] | 0;
  HEAP32[$25 >> 2] = $21;
  $26 = $5;
  STACKTOP = sp;
  return $26 | 0;
 }
 return 0 | 0;
}

function _mp_obj_str_get_qstr($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $5 = _mp_obj_is_qstr_1128($4) | 0;
 $6 = $2;
 if ($5) {
  $7 = $6;
  $8 = $7 >>> 2;
  $1 = $8;
  $22 = $1;
  STACKTOP = sp;
  return $22 | 0;
 }
 $9 = _mp_obj_is_obj_1154($6) | 0;
 if (!$9) {
  $21 = $2;
  _bad_implicit_conversion($21);
 }
 $10 = $2;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = ($11 | 0) == (18680 | 0);
 if (!$12) {
  $21 = $2;
  _bad_implicit_conversion($21);
 }
 $13 = $2;
 $3 = $13;
 $14 = $3;
 $15 = $14 + 12 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $3;
 $18 = $17 + 8 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = _qstr_from_strn($16, $19) | 0;
 $1 = $20;
 $22 = $1;
 STACKTOP = sp;
 return $22 | 0;
}

function _mp_make_closure_from_raw_code($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $8 = $7 & 256;
 $9 = ($8 | 0) != 0;
 $10 = $3;
 if ($9) {
  $11 = $5;
  $12 = HEAP32[$11 >> 2] | 0;
  $13 = $5;
  $14 = $13 + 4 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = _mp_make_function_from_raw_code($10, $12, $15) | 0;
  $6 = $16;
 } else {
  $17 = _mp_make_function_from_raw_code($10, 0, 0) | 0;
  $6 = $17;
 }
 $18 = $6;
 $19 = $4;
 $20 = $19 & 255;
 $21 = $5;
 $22 = $4;
 $23 = $22 >>> 7;
 $24 = $23 & 2;
 $25 = $21 + ($24 << 2) | 0;
 $26 = _mp_obj_new_closure($18, $20, $25) | 0;
 STACKTOP = sp;
 return $26 | 0;
}

function ___sin($0, $1, $2) {
 $0 = +$0;
 $1 = +$1;
 $2 = $2 | 0;
 var $$0 = 0.0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $25 = 0.0, $26 = 0.0, $27 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $3 = $0 * $0;
 $4 = $3 * $3;
 $5 = $3 * 2.7557313707070068e-06;
 $6 = $5 + -1.984126982985795e-04;
 $7 = $3 * $6;
 $8 = $7 + .00833333333332249;
 $9 = $3 * $4;
 $10 = $3 * 1.58969099521155e-10;
 $11 = $10 + -2.5050760253406863e-08;
 $12 = $9 * $11;
 $13 = $12 + $8;
 $14 = $3 * $0;
 $15 = ($2 | 0) == 0;
 if ($15) {
  $16 = $3 * $13;
  $17 = $16 + -.16666666666666632;
  $18 = $14 * $17;
  $19 = $18 + $0;
  $$0 = $19;
 } else {
  $20 = $1 * .5;
  $21 = $14 * $13;
  $22 = $20 - $21;
  $23 = $3 * $22;
  $24 = $23 - $1;
  $25 = $14 * .16666666666666632;
  $26 = $25 + $24;
  $27 = $0 - $26;
  $$0 = $27;
 }
 return +$$0;
}

function _is_char_or3($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $8 = $4;
 $9 = $8 + 16 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $5;
 $12 = $11 & 255;
 $13 = ($10 | 0) == ($12 | 0);
 if ($13) {
  $26 = 1;
  STACKTOP = sp;
  return $26 | 0;
 }
 $14 = $4;
 $15 = $14 + 16 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $6;
 $18 = $17 & 255;
 $19 = ($16 | 0) == ($18 | 0);
 if ($19) {
  $26 = 1;
  STACKTOP = sp;
  return $26 | 0;
 }
 $20 = $4;
 $21 = $20 + 16 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = $7;
 $24 = $23 & 255;
 $25 = ($22 | 0) == ($24 | 0);
 $26 = $25;
 STACKTOP = sp;
 return $26 | 0;
}

function _mp_reader_new_mem($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = _m_malloc(16) | 0;
 $8 = $9;
 $10 = $7;
 $11 = $8;
 HEAP32[$11 >> 2] = $10;
 $12 = $5;
 $13 = $8;
 $14 = $13 + 4 | 0;
 HEAP32[$14 >> 2] = $12;
 $15 = $5;
 $16 = $8;
 $17 = $16 + 8 | 0;
 HEAP32[$17 >> 2] = $15;
 $18 = $5;
 $19 = $6;
 $20 = $18 + $19 | 0;
 $21 = $8;
 $22 = $21 + 12 | 0;
 HEAP32[$22 >> 2] = $20;
 $23 = $8;
 $24 = $4;
 HEAP32[$24 >> 2] = $23;
 $25 = $4;
 $26 = $25 + 4 | 0;
 HEAP32[$26 >> 2] = 485;
 $27 = $4;
 $28 = $27 + 8 | 0;
 HEAP32[$28 >> 2] = 486;
 STACKTOP = sp;
 return;
}

function ___stdout_write($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_ptr1 = 0, $vararg_ptr2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = sp + 16 | 0;
 $4 = $0 + 36 | 0;
 HEAP32[$4 >> 2] = 631;
 $5 = HEAP32[$0 >> 2] | 0;
 $6 = $5 & 64;
 $7 = ($6 | 0) == 0;
 if ($7) {
  $8 = $0 + 60 | 0;
  $9 = HEAP32[$8 >> 2] | 0;
  $10 = $3;
  HEAP32[$vararg_buffer >> 2] = $9;
  $vararg_ptr1 = $vararg_buffer + 4 | 0;
  HEAP32[$vararg_ptr1 >> 2] = 21523;
  $vararg_ptr2 = $vararg_buffer + 8 | 0;
  HEAP32[$vararg_ptr2 >> 2] = $10;
  $11 = ___syscall54(54, $vararg_buffer | 0) | 0;
  $12 = ($11 | 0) == 0;
  if (!$12) {
   $13 = $0 + 75 | 0;
   HEAP8[$13 >> 0] = -1;
  }
 }
 $14 = ___stdio_write($0, $1, $2) | 0;
 STACKTOP = sp;
 return $14 | 0;
}

function _array_iterator_new($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $4 = $6;
 $7 = $3;
 $5 = $7;
 $8 = $5;
 HEAP32[$8 >> 2] = 13524;
 $9 = $4;
 $10 = $5;
 $11 = $10 + 4 | 0;
 HEAP32[$11 >> 2] = $9;
 $12 = $5;
 $13 = $12 + 8 | 0;
 HEAP32[$13 >> 2] = 0;
 $14 = $5;
 $15 = $14 + 12 | 0;
 HEAP32[$15 >> 2] = 0;
 $16 = $4;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = ($17 | 0) == (13464 | 0);
 if (!$18) {
  $25 = $5;
  STACKTOP = sp;
  return $25 | 0;
 }
 $19 = $4;
 $20 = $19 + 4 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $21 >>> 8;
 $23 = $5;
 $24 = $23 + 8 | 0;
 HEAP32[$24 >> 2] = $22;
 $25 = $5;
 STACKTOP = sp;
 return $25 | 0;
}

function _gs2_hmsb_getpixel($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $28 = 0, $29 = 0, $3 = 0, $30 = 0, $31 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $3;
 $9 = $8 + 8 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $4;
 $12 = $5;
 $13 = $3;
 $14 = $13 + 16 | 0;
 $15 = HEAP16[$14 >> 1] | 0;
 $16 = $15 & 65535;
 $17 = Math_imul($12, $16) | 0;
 $18 = $11 + $17 | 0;
 $19 = $18 >> 2;
 $20 = $10 + $19 | 0;
 $21 = HEAP8[$20 >> 0] | 0;
 $6 = $21;
 $22 = $4;
 $23 = $22 & 3;
 $24 = $23 << 1;
 $25 = $24 & 255;
 $7 = $25;
 $26 = $6;
 $27 = $26 & 255;
 $28 = $7;
 $29 = $28 & 255;
 $30 = $27 >> $29;
 $31 = $30 & 3;
 STACKTOP = sp;
 return $31 | 0;
}

function _enumerate_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp;
 $2 = $0;
 $6 = $2;
 $3 = $6;
 $7 = $3;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = _mp_iternext($9) | 0;
 $4 = $10;
 $11 = $4;
 $12 = ($11 | 0) == (0 | 0);
 if ($12) {
  $1 = 0;
  $23 = $1;
  STACKTOP = sp;
  return $23 | 0;
 } else {
  $13 = $3;
  $14 = $13 + 8 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $15 + 1 | 0;
  HEAP32[$14 >> 2] = $16;
  $17 = $15 << 1;
  $18 = $17 | 1;
  $19 = $18;
  HEAP32[$5 >> 2] = $19;
  $20 = $5 + 4 | 0;
  $21 = $4;
  HEAP32[$20 >> 2] = $21;
  $22 = _mp_obj_new_tuple(2, $5) | 0;
  $1 = $22;
  $23 = $1;
  STACKTOP = sp;
  return $23 | 0;
 }
 return 0 | 0;
}

function _mp_obj_new_memoryview($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = _m_malloc(16) | 0;
 $6 = $7;
 $8 = $6;
 HEAP32[$8 >> 2] = 13464;
 $9 = $3;
 $10 = $9 & 255;
 $11 = $6;
 $12 = $11 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $10 & 255;
 $15 = $13 & -256;
 $16 = $15 | $14;
 HEAP32[$12 >> 2] = $16;
 $17 = $6;
 $18 = $17 + 4 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $19 & 255;
 HEAP32[$18 >> 2] = $20;
 $21 = $4;
 $22 = $6;
 $23 = $22 + 8 | 0;
 HEAP32[$23 >> 2] = $21;
 $24 = $5;
 $25 = $6;
 $26 = $25 + 12 | 0;
 HEAP32[$26 >> 2] = $24;
 $27 = $6;
 STACKTOP = sp;
 return $27 | 0;
}

function _mp_obj_is_callable($0) {
 $0 = $0 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$pre_trunc = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = sp + 8 | 0;
 $2 = $0;
 $4 = $2;
 $5 = _mp_obj_get_type($4) | 0;
 $6 = $5 + 16 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $3 = $7;
 $8 = $3;
 $9 = ($8 | 0) != (512 | 0);
 if ($9) {
  $10 = $3;
  $11 = ($10 | 0) != (0 | 0);
  $$expand_i1_val = $11 & 1;
  HEAP8[$1 >> 0] = $$expand_i1_val;
  $$pre_trunc = HEAP8[$1 >> 0] | 0;
  $14 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $14 | 0;
 } else {
  $12 = $2;
  $13 = _mp_obj_instance_is_callable($12) | 0;
  $$expand_i1_val2 = $13 & 1;
  HEAP8[$1 >> 0] = $$expand_i1_val2;
  $$pre_trunc = HEAP8[$1 >> 0] | 0;
  $14 = $$pre_trunc & 1;
  STACKTOP = sp;
  return $14 | 0;
 }
 return 0 | 0;
}

function _mp_obj_namedtuple_find_field($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = 0;
 while (1) {
  $6 = $5;
  $7 = $3;
  $8 = $7 + 60 | 0;
  $9 = HEAP32[$8 >> 2] | 0;
  $10 = $6 >>> 0 < $9 >>> 0;
  if (!$10) {
   label = 6;
   break;
  }
  $11 = $3;
  $12 = $11 + 64 | 0;
  $13 = $5;
  $14 = $12 + ($13 << 2) | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $4;
  $17 = ($15 | 0) == ($16 | 0);
  $18 = $5;
  if ($17) {
   label = 4;
   break;
  }
  $19 = $18 + 1 | 0;
  $5 = $19;
 }
 if ((label | 0) == 4) {
  $2 = $18;
  $20 = $2;
  STACKTOP = sp;
  return $20 | 0;
 } else if ((label | 0) == 6) {
  $2 = -1;
  $20 = $2;
  STACKTOP = sp;
  return $20 | 0;
 }
 return 0 | 0;
}

function _tan($0) {
 $0 = +$0;
 var $$0 = 0.0, $1 = 0, $10 = 0, $11 = 0.0, $12 = 0, $13 = 0.0, $14 = 0, $15 = 0.0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = sp;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $2 = HEAP32[tempDoublePtr >> 2] | 0;
 $3 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $4 = $3 & 2147483647;
 $5 = $4 >>> 0 < 1072243196;
 do {
  if ($5) {
   $6 = $4 >>> 0 < 1044381696;
   if ($6) {
    $$0 = $0;
   } else {
    $7 = +___tan($0, 0.0, 0);
    $$0 = $7;
   }
  } else {
   $8 = $4 >>> 0 > 2146435071;
   if ($8) {
    $9 = $0 - $0;
    $$0 = $9;
    break;
   } else {
    $10 = ___rem_pio2($0, $1) | 0;
    $11 = +HEAPF64[$1 >> 3];
    $12 = $1 + 8 | 0;
    $13 = +HEAPF64[$12 >> 3];
    $14 = $10 & 1;
    $15 = +___tan($11, $13, $14);
    $$0 = $15;
    break;
   }
  }
 } while (0);
 STACKTOP = sp;
 return +$$0;
}

function _checked_fun_call($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $26 = 0, $27 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $4;
 $8 = $10;
 $11 = $5;
 $12 = $11 >>> 0 > 0;
 if ($12) {
  $13 = $7;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = _mp_obj_get_type($14) | 0;
  $9 = $15;
  $16 = $9;
  $17 = $8;
  $18 = $17 + 4 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = ($16 | 0) != ($19 | 0);
  if ($20) {
   _mp_raise_TypeError(29705);
  }
 }
 $21 = $8;
 $22 = $21 + 8 | 0;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $5;
 $25 = $6;
 $26 = $7;
 $27 = _mp_call_function_n_kw($23, $24, $25, $26) | 0;
 STACKTOP = sp;
 return $27 | 0;
}

function _scope_close_over_in_parents($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $4 = $8;
 while (1) {
  $9 = $4;
  $10 = $3;
  $11 = _scope_find_or_add_id($9, $10, 0) | 0;
  $5 = $11;
  $12 = $5;
  $13 = HEAP8[$12 >> 0] | 0;
  $14 = $13 & 255;
  $15 = ($14 | 0) == 0;
  $16 = $5;
  if (!$15) {
   break;
  }
  HEAP8[$16 >> 0] = 5;
  $17 = $4;
  $18 = $17 + 4 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $4 = $19;
 }
 $20 = HEAP8[$16 >> 0] | 0;
 $21 = $20 & 255;
 $22 = ($21 | 0) == 3;
 if (!$22) {
  STACKTOP = sp;
  return;
 }
 $23 = $5;
 HEAP8[$23 >> 0] = 4;
 STACKTOP = sp;
 return;
}

function _mp_obj_new_list($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = _list_new($6) | 0;
 $4 = $7;
 $8 = $3;
 $9 = ($8 | 0) != (0 | 0);
 if (!$9) {
  $24 = $4;
  STACKTOP = sp;
  return $24 | 0;
 }
 $5 = 0;
 while (1) {
  $10 = $5;
  $11 = $2;
  $12 = $10 >>> 0 < $11 >>> 0;
  if (!$12) {
   break;
  }
  $13 = $3;
  $14 = $5;
  $15 = $13 + ($14 << 2) | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  $17 = $4;
  $18 = $17 + 12 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = $5;
  $21 = $19 + ($20 << 2) | 0;
  HEAP32[$21 >> 2] = $16;
  $22 = $5;
  $23 = $22 + 1 | 0;
  $5 = $23;
 }
 $24 = $4;
 STACKTOP = sp;
 return $24 | 0;
}

function _array_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $6;
 $11 = $7;
 _mp_arg_check_num($10, $11, 1, 2, 0);
 $12 = $8;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = _mp_obj_str_get_str($13) | 0;
 $9 = $14;
 $15 = $6;
 $16 = ($15 | 0) == 1;
 $17 = $9;
 $18 = HEAP8[$17 >> 0] | 0;
 if ($16) {
  $19 = _array_new($18, 0) | 0;
  $4 = $19;
  $24 = $4;
  STACKTOP = sp;
  return $24 | 0;
 } else {
  $20 = $8;
  $21 = $20 + 4 | 0;
  $22 = HEAP32[$21 >> 2] | 0;
  $23 = _array_construct($18, $22) | 0;
  $4 = $23;
  $24 = $4;
  STACKTOP = sp;
  return $24 | 0;
 }
 return 0 | 0;
}

function _set_isdisjoint($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $6 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $9 = $3;
 $5 = $9;
 $10 = $4;
 $11 = _mp_getiter($10, $6) | 0;
 $7 = $11;
 while (1) {
  $12 = $7;
  $13 = _mp_iternext($12) | 0;
  $8 = $13;
  $14 = ($13 | 0) != (0 | 0);
  if (!$14) {
   label = 6;
   break;
  }
  $15 = $5;
  $16 = $15 + 4 | 0;
  $17 = $8;
  $18 = _mp_set_lookup($16, $17, 0) | 0;
  $19 = ($18 | 0) != (0 | 0);
  if ($19) {
   label = 4;
   break;
  }
 }
 if ((label | 0) == 4) {
  $2 = 13856;
  $20 = $2;
  STACKTOP = sp;
  return $20 | 0;
 } else if ((label | 0) == 6) {
  $2 = 13864;
  $20 = $2;
  STACKTOP = sp;
  return $20 | 0;
 }
 return 0 | 0;
}

function _mod_ujson_loads($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $2 = sp + 36 | 0;
 $4 = sp + 16 | 0;
 $5 = sp;
 $1 = $0;
 $6 = $1;
 $7 = _mp_obj_str_get_data($6, $2) | 0;
 $3 = $7;
 $8 = HEAP32[$2 >> 2] | 0;
 HEAP32[$4 >> 2] = $8;
 $9 = $4 + 4 | 0;
 $10 = HEAP32[$2 >> 2] | 0;
 HEAP32[$9 >> 2] = $10;
 $11 = $4 + 8 | 0;
 $12 = $3;
 HEAP32[$11 >> 2] = $12;
 $13 = $4 + 12 | 0;
 $14 = HEAP8[$13 >> 0] | 0;
 $15 = $14 & -2;
 $16 = $15 | 1;
 HEAP8[$13 >> 0] = $16;
 HEAP32[$5 >> 2] = 18756;
 $17 = $5 + 4 | 0;
 HEAP32[$17 >> 2] = $4;
 $18 = $5 + 8 | 0;
 HEAP32[$18 >> 2] = 0;
 $19 = $5 + 12 | 0;
 HEAP32[$19 >> 2] = 0;
 $20 = _mod_ujson_load($5) | 0;
 STACKTOP = sp;
 return $20 | 0;
}

function _reversed_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $3 = $4;
 $5 = $3;
 $6 = $5 + 8 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = ($7 | 0) == 0;
 if ($8) {
  $1 = 0;
  $23 = $1;
  STACKTOP = sp;
  return $23 | 0;
 } else {
  $9 = $3;
  $10 = $9 + 8 | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = $11 - 1 | 0;
  HEAP32[$10 >> 2] = $12;
  $13 = $3;
  $14 = $13 + 4 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $16 = $3;
  $17 = $16 + 8 | 0;
  $18 = HEAP32[$17 >> 2] | 0;
  $19 = $18 << 1;
  $20 = $19 | 1;
  $21 = $20;
  $22 = _mp_obj_subscr($15, $21, 4) | 0;
  $1 = $22;
  $23 = $1;
  STACKTOP = sp;
  return $23 | 0;
 }
 return 0 | 0;
}

function _slice_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $6 = $7;
 $8 = $3;
 _mp_print_str($8, 31709) | 0;
 $9 = $3;
 $10 = $6;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 _mp_obj_print_helper($9, $12, 1);
 $13 = $3;
 _mp_print_str($13, 33327) | 0;
 $14 = $3;
 $15 = $6;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 _mp_obj_print_helper($14, $17, 1);
 $18 = $3;
 _mp_print_str($18, 33327) | 0;
 $19 = $3;
 $20 = $6;
 $21 = $20 + 12 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 _mp_obj_print_helper($19, $22, 1);
 $23 = $3;
 _mp_print_str($23, 32991) | 0;
 STACKTOP = sp;
 return;
}

function _poll_ipoll($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = HEAP32[$6 >> 2] | 0;
 $4 = $7;
 $8 = $4;
 $9 = $8 + 24 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = ($10 | 0) == (0 | 0);
 if ($11) {
  $12 = _mp_obj_new_tuple(2, 0) | 0;
  $13 = $4;
  $14 = $13 + 24 | 0;
  HEAP32[$14 >> 2] = $12;
 }
 $15 = $2;
 $16 = $3;
 $17 = _poll_poll_internal($15, $16) | 0;
 $5 = $17;
 $18 = $5;
 $19 = $18 & 65535;
 $20 = $4;
 $21 = $20 + 16 | 0;
 HEAP16[$21 >> 1] = $19;
 $22 = $4;
 $23 = $22 + 18 | 0;
 HEAP16[$23 >> 1] = 0;
 $24 = $3;
 $25 = HEAP32[$24 >> 2] | 0;
 STACKTOP = sp;
 return $25 | 0;
}

function _mp_binary_set_int($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $7 = sp + 4 | 0;
 $4 = $0;
 $9 = $1 & 1;
 $5 = $9;
 $6 = $2;
 HEAP32[$7 >> 2] = $3;
 $10 = $5;
 $11 = $10 & 1;
 if (!$11) {
  $12 = $6;
  $13 = $4;
  _memcpy($12 | 0, $7 | 0, $13 | 0) | 0;
  STACKTOP = sp;
  return;
 }
 $14 = $4;
 $15 = $7 + $14 | 0;
 $8 = $15;
 while (1) {
  $16 = $4;
  $17 = $16 + -1 | 0;
  $4 = $17;
  $18 = ($16 | 0) != 0;
  if (!$18) {
   break;
  }
  $19 = $8;
  $20 = $19 + -1 | 0;
  $8 = $20;
  $21 = HEAP8[$20 >> 0] | 0;
  $22 = $6;
  $23 = $22 + 1 | 0;
  $6 = $23;
  HEAP8[$22 >> 0] = $21;
 }
 STACKTOP = sp;
 return;
}

function _mp_map_clear($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = HEAP32[$2 >> 2] | 0;
 $4 = $3 >>> 1;
 $5 = $4 & 1;
 $6 = ($5 | 0) != 0;
 if (!$6) {
  $7 = $1;
  $8 = $7 + 8 | 0;
  $9 = HEAP32[$8 >> 2] | 0;
  _m_free($9);
 }
 $10 = $1;
 $11 = $10 + 4 | 0;
 HEAP32[$11 >> 2] = 0;
 $12 = $1;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $13 & 7;
 HEAP32[$12 >> 2] = $14;
 $15 = $1;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $16 & -2;
 $18 = $17 | 1;
 HEAP32[$15 >> 2] = $18;
 $19 = $1;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = $20 & -3;
 HEAP32[$19 >> 2] = $21;
 $22 = $1;
 $23 = $22 + 8 | 0;
 HEAP32[$23 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _float_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0.0, $17 = 0, $18 = 0, $19 = 0, $20 = 0.0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $8 = $5;
 $9 = +_mp_obj_float_get($8);
 $7 = $9;
 $10 = $6;
 $11 = _mp_obj_is_obj_963($10) | 0;
 if ($11) {
  $12 = $6;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = ($13 | 0) == (14052 | 0);
  if ($14) {
   $15 = $4;
   $16 = $7;
   $17 = $6;
   $18 = _mp_obj_complex_binary_op($15, $16, 0.0, $17) | 0;
   $3 = $18;
   $23 = $3;
   STACKTOP = sp;
   return $23 | 0;
  }
 }
 $19 = $4;
 $20 = $7;
 $21 = $6;
 $22 = _mp_obj_float_binary_op($19, $20, $21) | 0;
 $3 = $22;
 $23 = $3;
 STACKTOP = sp;
 return $23 | 0;
}

function ___towrite($0) {
 $0 = $0 | 0;
 var $$0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = $0 + 74 | 0;
 $2 = HEAP8[$1 >> 0] | 0;
 $3 = $2 << 24 >> 24;
 $4 = $3 + 255 | 0;
 $5 = $4 | $3;
 $6 = $5 & 255;
 HEAP8[$1 >> 0] = $6;
 $7 = HEAP32[$0 >> 2] | 0;
 $8 = $7 & 8;
 $9 = ($8 | 0) == 0;
 if ($9) {
  $11 = $0 + 8 | 0;
  HEAP32[$11 >> 2] = 0;
  $12 = $0 + 4 | 0;
  HEAP32[$12 >> 2] = 0;
  $13 = $0 + 44 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = $0 + 28 | 0;
  HEAP32[$15 >> 2] = $14;
  $16 = $0 + 20 | 0;
  HEAP32[$16 >> 2] = $14;
  $17 = $14;
  $18 = $0 + 48 | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  $20 = $17 + $19 | 0;
  $21 = $0 + 16 | 0;
  HEAP32[$21 >> 2] = $20;
  $$0 = 0;
 } else {
  $10 = $7 | 32;
  HEAP32[$0 >> 2] = $10;
  $$0 = -1;
 }
 return $$0 | 0;
}

function _struct_pack($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = sp + 8 | 0;
 $2 = $0;
 $3 = $1;
 $7 = $3;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = _struct_calcsize($8) | 0;
 $10 = $9;
 $11 = $10 >> 1;
 $4 = $11;
 $12 = $4;
 _vstr_init_len($5, $12);
 $13 = $5 + 8 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $6 = $14;
 $15 = $6;
 $16 = $4;
 _memset($15 | 0, 0, $16 | 0) | 0;
 $17 = $3;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $6;
 $20 = $2;
 $21 = $20 - 1 | 0;
 $22 = $3;
 $23 = $22 + 4 | 0;
 _struct_pack_into_internal($18, $19, $21, $23);
 $24 = _mp_obj_new_str_from_vstr(18304, $5) | 0;
 STACKTOP = sp;
 return $24 | 0;
}

function _framebuf_fill($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $4 = $6;
 $7 = $3;
 $8 = _mp_obj_get_int($7) | 0;
 $5 = $8;
 $9 = $4;
 $10 = $9 + 18 | 0;
 $11 = HEAP8[$10 >> 0] | 0;
 $12 = $11 & 255;
 $13 = 9376 + ($12 * 12 | 0) | 0;
 $14 = $13 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $4;
 $17 = $4;
 $18 = $17 + 12 | 0;
 $19 = HEAP16[$18 >> 1] | 0;
 $20 = $19 & 65535;
 $21 = $4;
 $22 = $21 + 14 | 0;
 $23 = HEAP16[$22 >> 1] | 0;
 $24 = $23 & 65535;
 $25 = $5;
 FUNCTION_TABLE_viiiiii[$15 & 511]($16, 0, 0, $20, $24, $25);
 STACKTOP = sp;
 return 17668 | 0;
}

function _float_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0.0, $11 = 0.0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 64 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(64 | 0);
 $7 = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $4;
 $10 = +_mp_obj_float_get($9);
 $6 = $10;
 $8 = 16;
 $11 = $6;
 _mp_format_float($11, $7, 32, 103, 16, 0) | 0;
 $12 = $3;
 _mp_print_str($12, $7) | 0;
 $13 = _strchr($7, 46) | 0;
 $14 = ($13 | 0) == (0 | 0);
 if (!$14) {
  STACKTOP = sp;
  return;
 }
 $15 = _strchr($7, 101) | 0;
 $16 = ($15 | 0) == (0 | 0);
 if (!$16) {
  STACKTOP = sp;
  return;
 }
 $17 = _strchr($7, 110) | 0;
 $18 = ($17 | 0) == (0 | 0);
 if (!$18) {
  STACKTOP = sp;
  return;
 }
 $19 = $3;
 _mp_print_str($19, 31107) | 0;
 STACKTOP = sp;
 return;
}

function _mp_cmath_polar($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0, $15 = 0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 8 | 0;
 $3 = sp;
 $4 = sp + 16 | 0;
 $1 = $0;
 $5 = $1;
 _mp_obj_get_complex($5, $2, $3);
 $6 = +HEAPF64[$2 >> 3];
 $7 = +HEAPF64[$2 >> 3];
 $8 = $6 * $7;
 $9 = +HEAPF64[$3 >> 3];
 $10 = +HEAPF64[$3 >> 3];
 $11 = $9 * $10;
 $12 = $8 + $11;
 $13 = +Math_sqrt(+$12);
 $14 = _mp_obj_new_float($13) | 0;
 HEAP32[$4 >> 2] = $14;
 $15 = $4 + 4 | 0;
 $16 = +HEAPF64[$3 >> 3];
 $17 = +HEAPF64[$2 >> 3];
 $18 = +_atan2($16, $17);
 $19 = _mp_obj_new_float($18) | 0;
 HEAP32[$15 >> 2] = $19;
 $20 = _mp_obj_new_tuple(2, $4) | 0;
 STACKTOP = sp;
 return $20 | 0;
}

function _tinf_getbit($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = $3 + 16 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 $6 = $5 + -1 | 0;
 HEAP32[$4 >> 2] = $6;
 $7 = ($5 | 0) != 0;
 if (!$7) {
  $8 = $1;
  $9 = _uzlib_get_byte($8) | 0;
  $10 = $9 & 255;
  $11 = $1;
  $12 = $11 + 12 | 0;
  HEAP32[$12 >> 2] = $10;
  $13 = $1;
  $14 = $13 + 16 | 0;
  HEAP32[$14 >> 2] = 7;
 }
 $15 = $1;
 $16 = $15 + 12 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $17 & 1;
 $2 = $18;
 $19 = $1;
 $20 = $19 + 12 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $21 >>> 1;
 HEAP32[$20 >> 2] = $22;
 $23 = $2;
 STACKTOP = sp;
 return $23 | 0;
}

function _uctypes_get_buffer($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $7 = sp + 4 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $9 = $3;
 $6 = $9;
 HEAP32[$7 >> 2] = 0;
 $10 = $6;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $6;
 $14 = $13 + 12 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = _uctypes_struct_size($12, $15, $7) | 0;
 $8 = $16;
 $17 = $6;
 $18 = $17 + 8 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $4;
 HEAP32[$20 >> 2] = $19;
 $21 = $8;
 $22 = $4;
 $23 = $22 + 4 | 0;
 HEAP32[$23 >> 2] = $21;
 $24 = $4;
 $25 = $24 + 8 | 0;
 HEAP32[$25 >> 2] = 1;
 STACKTOP = sp;
 return 0;
}

function _strcmp($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$011 = 0, $$0710 = 0, $$lcssa = 0, $$lcssa8 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = HEAP8[$0 >> 0] | 0;
 $3 = HEAP8[$1 >> 0] | 0;
 $4 = $2 << 24 >> 24 != $3 << 24 >> 24;
 $5 = $2 << 24 >> 24 == 0;
 $or$cond9 = $5 | $4;
 if ($or$cond9) {
  $$lcssa = $3;
  $$lcssa8 = $2;
 } else {
  $$011 = $1;
  $$0710 = $0;
  while (1) {
   $6 = $$0710 + 1 | 0;
   $7 = $$011 + 1 | 0;
   $8 = HEAP8[$6 >> 0] | 0;
   $9 = HEAP8[$7 >> 0] | 0;
   $10 = $8 << 24 >> 24 != $9 << 24 >> 24;
   $11 = $8 << 24 >> 24 == 0;
   $or$cond = $11 | $10;
   if ($or$cond) {
    $$lcssa = $9;
    $$lcssa8 = $8;
    break;
   } else {
    $$011 = $7;
    $$0710 = $6;
   }
  }
 }
 $12 = $$lcssa8 & 255;
 $13 = $$lcssa & 255;
 $14 = $12 - $13 | 0;
 return $14 | 0;
}

function _mp_emit_bc_make_function($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $8 = $6;
 $9 = ($8 | 0) == 0;
 $10 = $7;
 $11 = ($10 | 0) == 0;
 $or$cond = $9 & $11;
 $12 = $4;
 if ($or$cond) {
  _emit_bc_pre($12, 1);
  $13 = $4;
  $14 = $5;
  $15 = $14 + 16 | 0;
  $16 = HEAP32[$15 >> 2] | 0;
  _emit_write_bytecode_byte_raw_code($13, 96, $16);
  STACKTOP = sp;
  return;
 } else {
  _emit_bc_pre($12, -1);
  $17 = $4;
  $18 = $5;
  $19 = $18 + 16 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  _emit_write_bytecode_byte_raw_code($17, 97, $20);
  STACKTOP = sp;
  return;
 }
}

function _uzlib_uncompress_init($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $6 + 37 | 0;
 HEAP8[$7 >> 0] = 0;
 $8 = $3;
 $9 = $8 + 16 | 0;
 HEAP32[$9 >> 2] = 0;
 $10 = $3;
 $11 = $10 + 44 | 0;
 HEAP32[$11 >> 2] = 0;
 $12 = $3;
 $13 = $12 + 40 | 0;
 HEAP32[$13 >> 2] = -1;
 $14 = $5;
 $15 = $3;
 $16 = $15 + 60 | 0;
 HEAP32[$16 >> 2] = $14;
 $17 = $4;
 $18 = $3;
 $19 = $18 + 56 | 0;
 HEAP32[$19 >> 2] = $17;
 $20 = $3;
 $21 = $20 + 64 | 0;
 HEAP32[$21 >> 2] = 0;
 $22 = $3;
 $23 = $22 + 48 | 0;
 HEAP32[$23 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _fmt_x($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $$05$lcssa = 0, $$056 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $4 = ($0 | 0) == 0;
 $5 = ($1 | 0) == 0;
 $6 = $4 & $5;
 if ($6) {
  $$05$lcssa = $2;
 } else {
  $$056 = $2;
  $15 = $1;
  $8 = $0;
  while (1) {
   $7 = $8 & 15;
   $9 = 10816 + $7 | 0;
   $10 = HEAP8[$9 >> 0] | 0;
   $11 = $10 & 255;
   $12 = $11 | $3;
   $13 = $12 & 255;
   $14 = $$056 + -1 | 0;
   HEAP8[$14 >> 0] = $13;
   $16 = _bitshift64Lshr($8 | 0, $15 | 0, 4) | 0;
   $17 = getTempRet0() | 0;
   $18 = ($16 | 0) == 0;
   $19 = ($17 | 0) == 0;
   $20 = $18 & $19;
   if ($20) {
    $$05$lcssa = $14;
    break;
   } else {
    $$056 = $14;
    $15 = $17;
    $8 = $16;
   }
  }
 }
 return $$05$lcssa | 0;
}

function _enumerate_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $8 = sp + 8 | 0;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $5;
 $11 = $6;
 $12 = $7;
 _mp_arg_parse_all_kw_array($10, $11, $12, 2, 3264, $8);
 $13 = _m_malloc(12) | 0;
 $9 = $13;
 $14 = $4;
 $15 = $9;
 HEAP32[$15 >> 2] = $14;
 $16 = HEAP32[$8 >> 2] | 0;
 $17 = _mp_getiter($16, 0) | 0;
 $18 = $9;
 $19 = $18 + 4 | 0;
 HEAP32[$19 >> 2] = $17;
 $20 = $8 + 4 | 0;
 $21 = HEAP32[$20 >> 2] | 0;
 $22 = $9;
 $23 = $22 + 8 | 0;
 HEAP32[$23 >> 2] = $21;
 $24 = $9;
 STACKTOP = sp;
 return $24 | 0;
}

function _namedtuple_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $5;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) == (0 | 0);
 if (!$10) {
  _mp_raise_msg(15292, 31607);
 }
 $11 = $3;
 $6 = $11;
 $12 = $6;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $4;
 $15 = _mp_obj_namedtuple_find_field($13, $14) | 0;
 $7 = $15;
 $16 = $7;
 $17 = ($16 | 0) == -1;
 if ($17) {
  STACKTOP = sp;
  return;
 }
 $18 = $6;
 $19 = $18 + 8 | 0;
 $20 = $7;
 $21 = $19 + ($20 << 2) | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = $5;
 HEAP32[$23 >> 2] = $22;
 STACKTOP = sp;
 return;
}

function _mp_load_name($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = _mp_locals_get() | 0;
 $5 = _mp_globals_get() | 0;
 $6 = ($4 | 0) != ($5 | 0);
 if ($6) {
  $7 = _mp_locals_get() | 0;
  $8 = $7 + 4 | 0;
  $9 = $2;
  $10 = $9 << 2;
  $11 = $10 | 2;
  $12 = $11;
  $13 = _mp_map_lookup($8, $12, 0) | 0;
  $3 = $13;
  $14 = $3;
  $15 = ($14 | 0) != (0 | 0);
  if ($15) {
   $16 = $3;
   $17 = $16 + 4 | 0;
   $18 = HEAP32[$17 >> 2] | 0;
   $1 = $18;
   $21 = $1;
   STACKTOP = sp;
   return $21 | 0;
  }
 }
 $19 = $2;
 $20 = _mp_load_global($19) | 0;
 $1 = $20;
 $21 = $1;
 STACKTOP = sp;
 return $21 | 0;
}

function _sin_pi_61($0) {
 $0 = +$0;
 var $$0 = 0.0, $1 = 0.0, $10 = Math_fround(0), $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0, $7 = 0, $8 = 0, $9 = Math_fround(0), label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = $0 * .5;
 $2 = +Math_floor(+$1);
 $3 = $1 - $2;
 $4 = $3 * 2.0;
 $5 = $4 * 4.0;
 $6 = ~~$5;
 $7 = $6 + 1 | 0;
 $8 = ($7 | 0) / 2 & -1;
 $9 = Math_fround($8 | 0);
 $10 = Math_fround($9 * Math_fround(.5));
 $11 = +$10;
 $12 = $4 - $11;
 $13 = $12 * 3.141592653589793;
 switch ($8 | 0) {
 case 3:
  {
   $18 = +___cos($13, 0.0);
   $19 = -$18;
   $$0 = $19;
   break;
  }
 case 1:
  {
   $15 = +___cos($13, 0.0);
   $$0 = $15;
   break;
  }
 case 2:
  {
   $16 = -$13;
   $17 = +___sin($16, 0.0, 0);
   $$0 = $17;
   break;
  }
 default:
  {
   $14 = +___sin($13, 0.0, 0);
   $$0 = $14;
  }
 }
 return +$$0;
}

function _dict_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $4;
 $5 = $6;
 $7 = $3;
 switch ($7 | 0) {
 case 4:
  {
   $8 = $5;
   $9 = $8 + 4 | 0;
   $10 = HEAP32[$9 >> 2] | 0;
   $11 = $10 >>> 3;
   $12 = ($11 | 0) != 0;
   $13 = $12 & 1;
   $14 = _mp_obj_new_bool_892($13) | 0;
   $2 = $14;
   break;
  }
 case 5:
  {
   $15 = $5;
   $16 = $15 + 4 | 0;
   $17 = HEAP32[$16 >> 2] | 0;
   $18 = $17 >>> 3;
   $19 = $18 << 1;
   $20 = $19 | 1;
   $21 = $20;
   $2 = $21;
   break;
  }
 default:
  {
   $2 = 0;
  }
 }
 $22 = $2;
 STACKTOP = sp;
 return $22 | 0;
}

function _mp_make_function_from_raw_code($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $8 = $5;
 $9 = $3;
 $10 = $9 + 4 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $3;
 $13 = $12 + 8 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = _mp_obj_new_fun_bc($7, $8, $11, $14) | 0;
 $6 = $15;
 $16 = $3;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $17 >>> 3;
 $19 = $18 & 127;
 $20 = $19 & 4;
 $21 = ($20 | 0) != 0;
 if (!$21) {
  $23 = $6;
  STACKTOP = sp;
  return $23 | 0;
 }
 $22 = $6;
 HEAP32[$22 >> 2] = 16672;
 $23 = $6;
 STACKTOP = sp;
 return $23 | 0;
}

function _mp_help_add_from_map($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = 0;
 while (1) {
  $5 = $4;
  $6 = $3;
  $7 = $6 + 4 | 0;
  $8 = HEAP32[$7 >> 2] | 0;
  $9 = $5 >>> 0 < $8 >>> 0;
  if (!$9) {
   break;
  }
  $10 = $3;
  $11 = $4;
  $12 = _mp_map_slot_is_filled_1377($10, $11) | 0;
  if ($12) {
   $13 = $2;
   $14 = $3;
   $15 = $14 + 8 | 0;
   $16 = HEAP32[$15 >> 2] | 0;
   $17 = $4;
   $18 = $16 + ($17 << 3) | 0;
   $19 = HEAP32[$18 >> 2] | 0;
   _mp_obj_list_append($13, $19) | 0;
  }
  $20 = $4;
  $21 = $20 + 1 | 0;
  $4 = $21;
 }
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_store_comp($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $4;
 $9 = ($8 | 0) == 3;
 do {
  if ($9) {
   $7 = 0;
   $6 = 0;
  } else {
   $10 = $4;
   $11 = ($10 | 0) == 4;
   if ($11) {
    $7 = 1;
    $6 = 1;
    break;
   } else {
    $7 = 0;
    $6 = 2;
    break;
   }
  }
 } while (0);
 $12 = $3;
 $13 = $7;
 $14 = -1 - $13 | 0;
 _emit_bc_pre($12, $14);
 $15 = $3;
 $16 = $5;
 $17 = $7;
 $18 = $16 + $17 | 0;
 $19 = $18 << 2;
 $20 = $6;
 $21 = $19 | $20;
 _emit_write_bytecode_byte_uint($15, 87, $21);
 STACKTOP = sp;
 return;
}

function _filter_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $5;
 $10 = $6;
 _mp_arg_check_num_958($9, $10, 2, 2, 0);
 $11 = _m_malloc(12) | 0;
 $8 = $11;
 $12 = $4;
 $13 = $8;
 HEAP32[$13 >> 2] = $12;
 $14 = $7;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $8;
 $17 = $16 + 4 | 0;
 HEAP32[$17 >> 2] = $15;
 $18 = $7;
 $19 = $18 + 4 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = _mp_getiter($20, 0) | 0;
 $22 = $8;
 $23 = $22 + 8 | 0;
 HEAP32[$23 >> 2] = $21;
 $24 = $8;
 STACKTOP = sp;
 return $24 | 0;
}

function _is_string_or_bytes($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _is_char_or($2, 39, 34) | 0;
 do {
  if ($3) {
   $14 = 1;
  } else {
   $4 = $1;
   $5 = _is_char_or3($4, 114, 117, 98) | 0;
   if ($5) {
    $6 = $1;
    $7 = _is_char_following_or($6, 39, 34) | 0;
    if ($7) {
     $14 = 1;
     break;
    }
   }
   $8 = $1;
   $9 = _is_char_and($8, 114, 98) | 0;
   if (!$9) {
    $10 = $1;
    $11 = _is_char_and($10, 98, 114) | 0;
    if (!$11) {
     $14 = 0;
     break;
    }
   }
   $12 = $1;
   $13 = _is_char_following_following_or($12, 39, 34) | 0;
   $14 = $13;
  }
 } while (0);
 STACKTOP = sp;
 return $14 | 0;
}

function _uctypes_struct_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $5;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) == (0 | 0);
 $10 = $3;
 $11 = $4;
 if ($9) {
  $12 = _uctypes_struct_attr_op($10, $11, 0) | 0;
  $6 = $12;
  $13 = $6;
  $14 = $5;
  HEAP32[$14 >> 2] = $13;
  STACKTOP = sp;
  return;
 }
 $15 = $5;
 $16 = $15 + 4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = _uctypes_struct_attr_op($10, $11, $17) | 0;
 $19 = ($18 | 0) != (0 | 0);
 if (!$19) {
  STACKTOP = sp;
  return;
 }
 $20 = $5;
 HEAP32[$20 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _mp_seq_count_obj($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = 0;
 $7 = 0;
 while (1) {
  $8 = $7;
  $9 = $4;
  $10 = $8 >>> 0 < $9 >>> 0;
  if (!$10) {
   break;
  }
  $11 = $3;
  $12 = $7;
  $13 = $11 + ($12 << 2) | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = $5;
  $16 = _mp_obj_equal($14, $15) | 0;
  if ($16) {
   $17 = $6;
   $18 = $17 + 1 | 0;
   $6 = $18;
  }
  $19 = $7;
  $20 = $19 + 1 | 0;
  $7 = $20;
 }
 $21 = $6;
 $22 = $21 << 1;
 $23 = $22 | 1;
 $24 = $23;
 STACKTOP = sp;
 return $24 | 0;
}

function _get_fmt_num($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $5 = $1;
 $6 = HEAP32[$5 >> 2] | 0;
 $2 = $6;
 $3 = 1;
 while (1) {
  $7 = $2;
  $8 = $7 + 1 | 0;
  $2 = $8;
  $9 = HEAP8[$8 >> 0] | 0;
  $10 = $9 << 24 >> 24;
  $11 = _unichar_isdigit($10) | 0;
  if (!$11) {
   break;
  }
  $12 = $3;
  $13 = $12 + 1 | 0;
  $3 = $13;
 }
 $14 = $1;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $3;
 $17 = _mp_parse_num_integer($15, $16, 10, 0) | 0;
 $18 = $17;
 $19 = $18 >> 1;
 $4 = $19;
 $20 = $2;
 $21 = $1;
 HEAP32[$21 >> 2] = $20;
 $22 = $4;
 STACKTOP = sp;
 return $22 | 0;
}

function _dict_view_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $8 = $5;
 $7 = $8;
 $9 = $7;
 $10 = $9 + 8 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = ($11 | 0) != 1;
 do {
  if ($12) {
   $3 = 0;
  } else {
   $13 = $4;
   $14 = ($13 | 0) != 34;
   if ($14) {
    $3 = 0;
    break;
   } else {
    $15 = $4;
    $16 = $7;
    $17 = $16 + 4 | 0;
    $18 = HEAP32[$17 >> 2] | 0;
    $19 = $6;
    $20 = _dict_binary_op($15, $18, $19) | 0;
    $3 = $20;
    break;
   }
  }
 } while (0);
 $21 = $3;
 STACKTOP = sp;
 return $21 | 0;
}

function _mp_seq_multiply($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $9 = $4;
 $10 = 0;
 while (1) {
  $12 = $10;
  $13 = $8;
  $14 = $12 >>> 0 < $13 >>> 0;
  if (!$14) {
   break;
  }
  $15 = $6;
  $16 = $7;
  $17 = Math_imul($15, $16) | 0;
  $11 = $17;
  $18 = $9;
  $19 = $5;
  $20 = $11;
  _memcpy($18 | 0, $19 | 0, $20 | 0) | 0;
  $21 = $9;
  $22 = $11;
  $23 = $21 + $22 | 0;
  $9 = $23;
  $24 = $10;
  $25 = $24 + 1 | 0;
  $10 = $25;
 }
 STACKTOP = sp;
 return;
}

function _mp_obj_new_bytearray_by_ref($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = _m_malloc(16) | 0;
 $4 = $5;
 $6 = $4;
 HEAP32[$6 >> 2] = 13584;
 $7 = $4;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 & -256;
 $11 = $10 | 1;
 HEAP32[$8 >> 2] = $11;
 $12 = $4;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $14 & 255;
 HEAP32[$13 >> 2] = $15;
 $16 = $2;
 $17 = $4;
 $18 = $17 + 8 | 0;
 HEAP32[$18 >> 2] = $16;
 $19 = $3;
 $20 = $4;
 $21 = $20 + 12 | 0;
 HEAP32[$21 >> 2] = $19;
 $22 = $4;
 STACKTOP = sp;
 return $22 | 0;
}

function _mp_builtin_sum($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $5 = sp + 8 | 0;
 $2 = $0;
 $3 = $1;
 $8 = $2;
 $cond = ($8 | 0) == 1;
 if ($cond) {
  $4 = 1;
 } else {
  $9 = $3;
  $10 = $9 + 4 | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  $4 = $11;
 }
 $12 = $3;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = _mp_getiter($13, $5) | 0;
 $6 = $14;
 while (1) {
  $15 = $6;
  $16 = _mp_iternext($15) | 0;
  $7 = $16;
  $17 = ($16 | 0) != (0 | 0);
  $18 = $4;
  if (!$17) {
   break;
  }
  $19 = $7;
  $20 = _mp_binary_op(26, $18, $19) | 0;
  $4 = $20;
 }
 STACKTOP = sp;
 return $18 | 0;
}

function _chop_component($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $6 = HEAP32[$5 >> 2] | 0;
 $4 = $6;
 while (1) {
  $7 = $4;
  $8 = $2;
  $9 = $7 >>> 0 > $8 >>> 0;
  $10 = $4;
  if (!$9) {
   label = 6;
   break;
  }
  $11 = $10 + -1 | 0;
  $4 = $11;
  $12 = HEAP8[$11 >> 0] | 0;
  $13 = $12 << 24 >> 24;
  $14 = ($13 | 0) == 46;
  if ($14) {
   label = 4;
   break;
  }
 }
 if ((label | 0) == 4) {
  $15 = $4;
  $16 = $3;
  HEAP32[$16 >> 2] = $15;
  STACKTOP = sp;
  return;
 } else if ((label | 0) == 6) {
  $17 = $3;
  HEAP32[$17 >> 2] = $10;
  STACKTOP = sp;
  return;
 }
}

function _native_base_init_wrapper($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $5 = sp;
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = HEAP32[$6 >> 2] | 0;
 $4 = $7;
 HEAP32[$5 >> 2] = 0;
 $8 = $4;
 $9 = HEAP32[$8 >> 2] | 0;
 _instance_count_native_bases($9, $5) | 0;
 $10 = HEAP32[$5 >> 2] | 0;
 $11 = $10 + 12 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = HEAP32[$5 >> 2] | 0;
 $14 = $2;
 $15 = $14 - 1 | 0;
 $16 = $3;
 $17 = $16 + 4 | 0;
 $18 = FUNCTION_TABLE_iiiii[$12 & 1023]($13, $15, 0, $17) | 0;
 $19 = $4;
 $20 = $19 + 16 | 0;
 HEAP32[$20 >> 2] = $18;
 STACKTOP = sp;
 return 17668 | 0;
}

function _uhashlib_sha256_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $5;
 $10 = $6;
 _mp_arg_check_num_1528($9, $10, 0, 1, 0);
 $11 = _m_malloc(116) | 0;
 $8 = $11;
 $12 = $4;
 $13 = $8;
 HEAP32[$13 >> 2] = $12;
 $14 = $8;
 $15 = $14 + 4 | 0;
 _sha256_init($15);
 $16 = $5;
 $17 = ($16 | 0) == 1;
 if (!$17) {
  $21 = $8;
  STACKTOP = sp;
  return $21 | 0;
 }
 $18 = $8;
 $19 = $7;
 $20 = HEAP32[$19 >> 2] | 0;
 _uhashlib_sha256_update($18, $20) | 0;
 $21 = $8;
 STACKTOP = sp;
 return $21 | 0;
}

function _mp_emit_glue_assign_bytecode($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $8 = $4;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 & -8;
 $11 = $10 | 2;
 HEAP32[$8 >> 2] = $11;
 $12 = $7;
 $13 = $4;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $12 & 127;
 $16 = $15 << 3;
 $17 = $14 & -1017;
 $18 = $17 | $16;
 HEAP32[$13 >> 2] = $18;
 $19 = $5;
 $20 = $4;
 $21 = $20 + 4 | 0;
 HEAP32[$21 >> 2] = $19;
 $22 = $6;
 $23 = $4;
 $24 = $23 + 8 | 0;
 HEAP32[$24 >> 2] = $22;
 STACKTOP = sp;
 return;
}

function _mp_obj_new_int_from_str_len($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $25 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $10 = $2 & 1;
 $6 = $10;
 $7 = $3;
 $11 = _mp_obj_int_new_mpz() | 0;
 $8 = $11;
 $12 = $8;
 $13 = $12 + 4 | 0;
 $14 = $4;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $5;
 $17 = $6;
 $18 = $17 & 1;
 $19 = $7;
 $20 = _mpz_set_from_str($13, $15, $16, $18, $19) | 0;
 $9 = $20;
 $21 = $9;
 $22 = $4;
 $23 = HEAP32[$22 >> 2] | 0;
 $24 = $23 + $21 | 0;
 HEAP32[$22 >> 2] = $24;
 $25 = $8;
 STACKTOP = sp;
 return $25 | 0;
}

function _mp_emit_bc_store_local($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $8 = $4;
 _emit_bc_pre($8, -1);
 $9 = $7;
 $10 = ($9 | 0) == 0;
 $11 = $6;
 $12 = $11 >>> 0 <= 15;
 $or$cond = $10 & $12;
 $13 = $4;
 if ($or$cond) {
  $14 = $6;
  $15 = 192 + $14 | 0;
  $16 = $15 & 255;
  _emit_write_bytecode_byte($13, $16);
  STACKTOP = sp;
  return;
 } else {
  $17 = $7;
  $18 = 34 + $17 | 0;
  $19 = $18 & 255;
  $20 = $6;
  _emit_write_bytecode_byte_uint($13, $19, $20);
  STACKTOP = sp;
  return;
 }
}

function _compile_atom_expr_await($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 36 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = ($7 | 0) != 7;
 if ($8) {
  $9 = $2;
  $10 = $9 + 36 | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = HEAP32[$11 >> 2] | 0;
  $13 = ($12 | 0) != 2;
  if ($13) {
   $14 = $2;
   $15 = $3;
   $16 = $15;
   _compile_syntax_error($14, $16, 29073);
   STACKTOP = sp;
   return;
  }
 }
 $17 = $2;
 $18 = $3;
 _compile_atom_expr_normal($17, $18);
 $19 = $2;
 _compile_yield_from($19);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_load_local($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $8 = $4;
 _emit_bc_pre($8, 1);
 $9 = $7;
 $10 = ($9 | 0) == 0;
 $11 = $6;
 $12 = $11 >>> 0 <= 15;
 $or$cond = $10 & $12;
 $13 = $4;
 if ($or$cond) {
  $14 = $6;
  $15 = 176 + $14 | 0;
  $16 = $15 & 255;
  _emit_write_bytecode_byte($13, $16);
  STACKTOP = sp;
  return;
 } else {
  $17 = $7;
  $18 = 25 + $17 | 0;
  $19 = $18 & 255;
  $20 = $6;
  _emit_write_bytecode_byte_uint($13, $19, $20);
  STACKTOP = sp;
  return;
 }
}

function _mp_obj_new_set($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = _m_malloc(16) | 0;
 $4 = $6;
 $7 = $4;
 HEAP32[$7 >> 2] = 17860;
 $8 = $4;
 $9 = $8 + 4 | 0;
 $10 = $2;
 _mp_set_init($9, $10);
 $5 = 0;
 while (1) {
  $11 = $5;
  $12 = $2;
  $13 = $11 >>> 0 < $12 >>> 0;
  $14 = $4;
  if (!$13) {
   break;
  }
  $15 = $14 + 4 | 0;
  $16 = $3;
  $17 = $5;
  $18 = $16 + ($17 << 2) | 0;
  $19 = HEAP32[$18 >> 2] | 0;
  _mp_set_lookup($15, $19, 1) | 0;
  $20 = $5;
  $21 = $20 + 1 | 0;
  $5 = $21;
 }
 STACKTOP = sp;
 return $14 | 0;
}

function _list_clear($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $2 = $3;
 $4 = $2;
 $5 = $4 + 8 | 0;
 HEAP32[$5 >> 2] = 0;
 $6 = $2;
 $7 = $6 + 12 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = _m_realloc($8, 16) | 0;
 $10 = $2;
 $11 = $10 + 12 | 0;
 HEAP32[$11 >> 2] = $9;
 $12 = $2;
 $13 = $12 + 4 | 0;
 HEAP32[$13 >> 2] = 4;
 $14 = $2;
 $15 = $14 + 12 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $2;
 $18 = $17 + 4 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $19 - 0 | 0;
 $21 = $20 << 2;
 _memset($16 | 0, 0, $21 | 0) | 0;
 STACKTOP = sp;
 return 17668 | 0;
}

function _arg_looks_integer($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_obj_is_obj_1154($2) | 0;
 if ($3) {
  $4 = $1;
  $5 = HEAP32[$4 >> 2] | 0;
  $6 = ($5 | 0) == (13796 | 0);
  if ($6) {
   $14 = 1;
  } else {
   label = 3;
  }
 } else {
  label = 3;
 }
 if ((label | 0) == 3) {
  $7 = $1;
  $8 = _mp_obj_is_small_int_1155($7) | 0;
  if ($8) {
   $14 = 1;
  } else {
   $9 = $1;
   $10 = _mp_obj_is_obj_1154($9) | 0;
   if ($10) {
    $11 = $1;
    $12 = HEAP32[$11 >> 2] | 0;
    $13 = ($12 | 0) == (16904 | 0);
    $14 = $13;
   } else {
    $14 = 0;
   }
  }
 }
 STACKTOP = sp;
 return $14 | 0;
}

function _mp_obj_new_instance($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = $3;
 $8 = _instance_count_native_bases($6, $7) | 0;
 $4 = $8;
 $9 = $4;
 $10 = $9 << 2;
 $11 = 16 + $10 | 0;
 $12 = _m_malloc($11) | 0;
 $5 = $12;
 $13 = $2;
 $14 = $5;
 HEAP32[$14 >> 2] = $13;
 $15 = $5;
 $16 = $15 + 4 | 0;
 _mp_map_init($16, 0);
 $17 = $4;
 $18 = ($17 | 0) != 0;
 if (!$18) {
  $21 = $5;
  STACKTOP = sp;
  return $21 | 0;
 }
 $19 = $5;
 $20 = $19 + 16 | 0;
 HEAP32[$20 >> 2] = 19108;
 $21 = $5;
 STACKTOP = sp;
 return $21 | 0;
}

function _mp_obj_get_type($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $5 = _mp_obj_is_small_int_784($4) | 0;
 do {
  if ($5) {
   $1 = 16904;
  } else {
   $6 = $2;
   $7 = _mp_obj_is_qstr_785($6) | 0;
   if ($7) {
    $1 = 18680;
    break;
   }
   $8 = $2;
   $9 = _mp_obj_is_obj_786($8) | 0;
   if ($9) {
    $10 = $2;
    $11 = HEAP32[$10 >> 2] | 0;
    $12 = ($11 | 0) == (16252 | 0);
    if ($12) {
     $1 = 16252;
     break;
    }
   }
   $13 = $2;
   $3 = $13;
   $14 = $3;
   $15 = HEAP32[$14 >> 2] | 0;
   $1 = $15;
  }
 } while (0);
 $16 = $1;
 STACKTOP = sp;
 return $16 | 0;
}

function _memcmp($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$01318 = 0, $$01417 = 0, $$019 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $3 = ($2 | 0) == 0;
 L1 : do {
  if ($3) {
   $14 = 0;
  } else {
   $$01318 = $0;
   $$01417 = $2;
   $$019 = $1;
   while (1) {
    $4 = HEAP8[$$01318 >> 0] | 0;
    $5 = HEAP8[$$019 >> 0] | 0;
    $6 = $4 << 24 >> 24 == $5 << 24 >> 24;
    if (!$6) {
     break;
    }
    $7 = $$01417 + -1 | 0;
    $8 = $$01318 + 1 | 0;
    $9 = $$019 + 1 | 0;
    $10 = ($7 | 0) == 0;
    if ($10) {
     $14 = 0;
     break L1;
    } else {
     $$01318 = $8;
     $$01417 = $7;
     $$019 = $9;
    }
   }
   $11 = $4 & 255;
   $12 = $5 & 255;
   $13 = $11 - $12 | 0;
   $14 = $13;
  }
 } while (0);
 return $14 | 0;
}

function ___fpclassify($0) {
 $0 = +$0;
 var $$0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $trunc$clear = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 $3 = _bitshift64Lshr($1 | 0, $2 | 0, 52) | 0;
 $4 = getTempRet0() | 0;
 $5 = $3 & 65535;
 $trunc$clear = $5 & 2047;
 switch ($trunc$clear << 16 >> 16) {
 case 0:
  {
   $6 = $2 & 2147483647;
   $7 = ($1 | 0) == 0;
   $8 = ($6 | 0) == 0;
   $9 = $7 & $8;
   $10 = $9 ? 2 : 3;
   $$0 = $10;
   break;
  }
 case 2047:
  {
   $11 = $2 & 1048575;
   $12 = ($1 | 0) == 0;
   $13 = ($11 | 0) == 0;
   $14 = $12 & $13;
   $15 = $14 & 1;
   $$0 = $15;
   break;
  }
 default:
  {
   $$0 = 4;
  }
 }
 return $$0 | 0;
}

function _fun_builtin_3_call($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $4;
 $8 = $9;
 $10 = $5;
 $11 = $6;
 _mp_arg_check_num_977($10, $11, 3, 3, 0);
 $12 = $8;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $7;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $7;
 $18 = $17 + 4 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $7;
 $21 = $20 + 8 | 0;
 $22 = HEAP32[$21 >> 2] | 0;
 $23 = FUNCTION_TABLE_iiii[$14 & 1023]($16, $19, $22) | 0;
 STACKTOP = sp;
 return $23 | 0;
}

function _list_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $4;
 $5 = $6;
 $7 = $3;
 switch ($7 | 0) {
 case 4:
  {
   $8 = $5;
   $9 = $8 + 8 | 0;
   $10 = HEAP32[$9 >> 2] | 0;
   $11 = ($10 | 0) != 0;
   $12 = $11 & 1;
   $13 = _mp_obj_new_bool_1064($12) | 0;
   $2 = $13;
   break;
  }
 case 5:
  {
   $14 = $5;
   $15 = $14 + 8 | 0;
   $16 = HEAP32[$15 >> 2] | 0;
   $17 = $16 << 1;
   $18 = $17 | 1;
   $19 = $18;
   $2 = $19;
   break;
  }
 default:
  {
   $2 = 0;
  }
 }
 $20 = $2;
 STACKTOP = sp;
 return $20 | 0;
}

function _array_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $4;
 $5 = $6;
 $7 = $3;
 switch ($7 | 0) {
 case 4:
  {
   $8 = $5;
   $9 = $8 + 8 | 0;
   $10 = HEAP32[$9 >> 2] | 0;
   $11 = ($10 | 0) != 0;
   $12 = $11 & 1;
   $13 = _mp_obj_new_bool_832($12) | 0;
   $2 = $13;
   break;
  }
 case 5:
  {
   $14 = $5;
   $15 = $14 + 8 | 0;
   $16 = HEAP32[$15 >> 2] | 0;
   $17 = $16 << 1;
   $18 = $17 | 1;
   $19 = $18;
   $2 = $19;
   break;
  }
 default:
  {
   $2 = 0;
  }
 }
 $20 = $2;
 STACKTOP = sp;
 return $20 | 0;
}

function _poll_modify($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $3;
 $6 = $8;
 $9 = $6;
 $10 = $9 + 4 | 0;
 $11 = $4;
 $12 = _mp_obj_id($11) | 0;
 $13 = _mp_map_lookup($10, $12, 0) | 0;
 $7 = $13;
 $14 = $7;
 $15 = ($14 | 0) == (0 | 0);
 if ($15) {
  _mp_raise_OSError(2);
 } else {
  $16 = $5;
  $17 = _mp_obj_get_int($16) | 0;
  $18 = $7;
  $19 = $18 + 4 | 0;
  $20 = HEAP32[$19 >> 2] | 0;
  $21 = $20 + 8 | 0;
  HEAP32[$21 >> 2] = $17;
  STACKTOP = sp;
  return 17668 | 0;
 }
 return 0 | 0;
}

function _mp_small_int_floor_divide($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = ($4 | 0) >= 0;
 $6 = $3;
 if ($5) {
  $7 = ($6 | 0) < 0;
  if ($7) {
   $8 = $3;
   $9 = 0 - $8 | 0;
   $10 = $9 - 1 | 0;
   $11 = $2;
   $12 = $11 + $10 | 0;
   $2 = $12;
  }
 } else {
  $13 = ($6 | 0) >= 0;
  if ($13) {
   $14 = $3;
   $15 = 0 - $14 | 0;
   $16 = $15 + 1 | 0;
   $17 = $2;
   $18 = $17 + $16 | 0;
   $2 = $18;
  }
 }
 $19 = $2;
 $20 = $3;
 $21 = ($19 | 0) / ($20 | 0) & -1;
 STACKTOP = sp;
 return $21 | 0;
}

function _compile_factor_2($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = $3;
 $8 = $7 + 8 | 0;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 _compile_node($6, $10);
 $11 = $3;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $13 >>> 4;
 $5 = $14;
 $15 = $5;
 switch ($15 | 0) {
 case 49:
  {
   $4 = 0;
   break;
  }
 case 50:
  {
   $4 = 1;
   break;
  }
 default:
  {
   $4 = 2;
  }
 }
 $16 = $2;
 $17 = $16 + 40 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = $4;
 _mp_emit_bc_unary_op($18, $19);
 STACKTOP = sp;
 return;
}

function _namedtuple_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $4;
 $6 = $8;
 $9 = $3;
 $10 = $6;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $11 + 6 | 0;
 $13 = HEAP16[$12 >> 1] | 0;
 $14 = $13 & 65535;
 HEAP32[$vararg_buffer >> 2] = $14;
 _mp_printf($9, 31706, $vararg_buffer) | 0;
 $15 = $6;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $16 + 64 | 0;
 $7 = $17;
 $18 = $3;
 $19 = $7;
 $20 = $6;
 _mp_obj_attrtuple_print_helper($18, $19, $20);
 STACKTOP = sp;
 return;
}

function _mpn_remove_trailing_zeros($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = $4 + -2 | 0;
 $3 = $5;
 while (1) {
  $6 = $3;
  $7 = $2;
  $8 = $6 >>> 0 >= $7 >>> 0;
  if (!$8) {
   break;
  }
  $9 = $3;
  $10 = HEAP16[$9 >> 1] | 0;
  $11 = $10 & 65535;
  $12 = ($11 | 0) == 0;
  if (!$12) {
   break;
  }
  $13 = $3;
  $14 = $13 + -2 | 0;
  $3 = $14;
 }
 $15 = $3;
 $16 = $15 + 2 | 0;
 $17 = $2;
 $18 = $16;
 $19 = $17;
 $20 = $18 - $19 | 0;
 $21 = ($20 | 0) / 2 & -1;
 STACKTOP = sp;
 return $21 | 0;
}

function _mp_obj_new_closure($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $8 = $7 << 2;
 $9 = 12 + $8 | 0;
 $10 = _m_malloc($9) | 0;
 $6 = $10;
 $11 = $6;
 HEAP32[$11 >> 2] = 13992;
 $12 = $3;
 $13 = $6;
 $14 = $13 + 4 | 0;
 HEAP32[$14 >> 2] = $12;
 $15 = $4;
 $16 = $6;
 $17 = $16 + 8 | 0;
 HEAP32[$17 >> 2] = $15;
 $18 = $6;
 $19 = $18 + 12 | 0;
 $20 = $5;
 $21 = $4;
 $22 = $21 << 2;
 _memcpy($19 | 0, $20 | 0, $22 | 0) | 0;
 $23 = $6;
 STACKTOP = sp;
 return $23 | 0;
}

function _vstr_init($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $spec$store$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = $4 >>> 0 < 1;
 $spec$store$select = $5 ? 1 : $1;
 $3 = $spec$store$select;
 $6 = $3;
 $7 = $2;
 HEAP32[$7 >> 2] = $6;
 $8 = $2;
 $9 = $8 + 4 | 0;
 HEAP32[$9 >> 2] = 0;
 $10 = $2;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $11;
 $13 = _m_malloc($12) | 0;
 $14 = $2;
 $15 = $14 + 8 | 0;
 HEAP32[$15 >> 2] = $13;
 $16 = $2;
 $17 = $16 + 12 | 0;
 $18 = HEAP8[$17 >> 0] | 0;
 $19 = $18 & -2;
 HEAP8[$17 >> 0] = $19;
 STACKTOP = sp;
 return;
}

function _set_equal($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $7 = $3;
 $5 = $7;
 $8 = $4;
 $6 = $8;
 $9 = $5;
 $10 = $9 + 4 | 0;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $6;
 $14 = $13 + 4 | 0;
 $15 = $14 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($12 | 0) != ($16 | 0);
 if ($17) {
  $2 = 13856;
  $21 = $2;
  STACKTOP = sp;
  return $21 | 0;
 } else {
  $18 = $3;
  $19 = $4;
  $20 = _set_issubset($18, $19) | 0;
  $2 = $20;
  $21 = $2;
  STACKTOP = sp;
  return $21 | 0;
 }
 return 0 | 0;
}

function _compile_delete_id($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 5 | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 & 255;
 $8 = ($7 | 0) == 1;
 $9 = $2;
 if ($8) {
  $10 = $9 + 36 | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = $3;
  _mp_emit_common_get_id_for_modification($11, $12);
  STACKTOP = sp;
  return;
 } else {
  $13 = $9 + 40 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = $2;
  $16 = $15 + 36 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = $3;
  _mp_emit_common_id_op($14, 13368, $17, $18);
  STACKTOP = sp;
  return;
 }
}

function _mp_decode_uint($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = 0;
 $5 = $1;
 $6 = HEAP32[$5 >> 2] | 0;
 $4 = $6;
 while (1) {
  $7 = $4;
  $8 = $7 + 1 | 0;
  $4 = $8;
  $9 = HEAP8[$7 >> 0] | 0;
  $3 = $9;
  $10 = $2;
  $11 = $10 << 7;
  $12 = $3;
  $13 = $12 & 255;
  $14 = $13 & 127;
  $15 = $11 | $14;
  $2 = $15;
  $16 = $3;
  $17 = $16 & 255;
  $18 = $17 & 128;
  $19 = ($18 | 0) != 0;
  if (!$19) {
   break;
  }
 }
 $20 = $4;
 $21 = $1;
 HEAP32[$21 >> 2] = $20;
 $22 = $2;
 STACKTOP = sp;
 return $22 | 0;
}

function _compile_store_id($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 5 | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 & 255;
 $8 = ($7 | 0) == 1;
 $9 = $2;
 if ($8) {
  $10 = $9 + 36 | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = $3;
  _mp_emit_common_get_id_for_modification($11, $12);
  STACKTOP = sp;
  return;
 } else {
  $13 = $9 + 40 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = $2;
  $16 = $15 + 36 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = $3;
  _mp_emit_common_id_op($14, 13360, $17, $18);
  STACKTOP = sp;
  return;
 }
}

function ___cos($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $19 = 0.0, $2 = 0.0, $20 = 0.0, $21 = 0.0, $22 = 0.0, $23 = 0.0, $24 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = $0 * $0;
 $3 = $2 * $2;
 $4 = $2 * 2.480158728947673e-05;
 $5 = $4 + -.001388888888887411;
 $6 = $2 * $5;
 $7 = $6 + .0416666666666666;
 $8 = $2 * $7;
 $9 = $3 * $3;
 $10 = $2 * 1.1359647557788195e-11;
 $11 = 2.087572321298175e-09 - $10;
 $12 = $2 * $11;
 $13 = $12 + -2.7557314351390663e-07;
 $14 = $9 * $13;
 $15 = $8 + $14;
 $16 = $2 * .5;
 $17 = 1.0 - $16;
 $18 = 1.0 - $17;
 $19 = $18 - $16;
 $20 = $2 * $15;
 $21 = $0 * $1;
 $22 = $20 - $21;
 $23 = $19 + $22;
 $24 = $17 + $23;
 return +$24;
}

function _getint($0) {
 $0 = $0 | 0;
 var $$0$lcssa = 0, $$04 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = HEAP32[$0 >> 2] | 0;
 $2 = HEAP8[$1 >> 0] | 0;
 $3 = $2 << 24 >> 24;
 $4 = _isdigit($3) | 0;
 $5 = ($4 | 0) == 0;
 if ($5) {
  $$0$lcssa = 0;
 } else {
  $$04 = 0;
  while (1) {
   $6 = $$04 * 10 | 0;
   $7 = HEAP32[$0 >> 2] | 0;
   $8 = HEAP8[$7 >> 0] | 0;
   $9 = $8 << 24 >> 24;
   $10 = $6 + -48 | 0;
   $11 = $10 + $9 | 0;
   $12 = $7 + 1 | 0;
   HEAP32[$0 >> 2] = $12;
   $13 = HEAP8[$12 >> 0] | 0;
   $14 = $13 << 24 >> 24;
   $15 = _isdigit($14) | 0;
   $16 = ($15 | 0) == 0;
   if ($16) {
    $$0$lcssa = $11;
    break;
   } else {
    $$04 = $11;
   }
  }
 }
 return $$0$lcssa | 0;
}

function _mp_small_int_modulo($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, $or$cond3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = $2;
 $6 = ($5 | 0) % ($4 | 0) & -1;
 $2 = $6;
 $7 = $2;
 $8 = ($7 | 0) < 0;
 $9 = $3;
 $10 = ($9 | 0) > 0;
 $or$cond = $8 & $10;
 if (!$or$cond) {
  $11 = $2;
  $12 = ($11 | 0) > 0;
  $13 = $3;
  $14 = ($13 | 0) < 0;
  $or$cond3 = $12 & $14;
  if (!$or$cond3) {
   $18 = $2;
   STACKTOP = sp;
   return $18 | 0;
  }
 }
 $15 = $3;
 $16 = $2;
 $17 = $16 + $15 | 0;
 $2 = $17;
 $18 = $2;
 STACKTOP = sp;
 return $18 | 0;
}

function _mp_emit_bc_binary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = 0;
 $5 = $3;
 $6 = ($5 | 0) == 36;
 if ($6) {
  $4 = 1;
  $3 = 6;
 } else {
  $7 = $3;
  $8 = ($7 | 0) == 37;
  if ($8) {
   $4 = 1;
   $3 = 7;
  }
 }
 $9 = $2;
 _emit_bc_pre($9, -1);
 $10 = $2;
 $11 = $3;
 $12 = 215 + $11 | 0;
 $13 = $12 & 255;
 _emit_write_bytecode_byte($10, $13);
 $14 = $4;
 $15 = $14 & 1;
 if (!$15) {
  STACKTOP = sp;
  return;
 }
 $16 = $2;
 _emit_bc_pre($16, 0);
 $17 = $2;
 _emit_write_bytecode_byte($17, -45);
 STACKTOP = sp;
 return;
}

function _mp_reader_mem_readbyte($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $3 = $4;
 $5 = $3;
 $6 = $5 + 8 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $3;
 $9 = $8 + 12 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $7 >>> 0 < $10 >>> 0;
 if ($11) {
  $12 = $3;
  $13 = $12 + 8 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = $14 + 1 | 0;
  HEAP32[$13 >> 2] = $15;
  $16 = HEAP8[$14 >> 0] | 0;
  $17 = $16 & 255;
  $1 = $17;
  $18 = $1;
  STACKTOP = sp;
  return $18 | 0;
 } else {
  $1 = -1;
  $18 = $1;
  STACKTOP = sp;
  return $18 | 0;
 }
 return 0 | 0;
}

function _mp_obj_fun_get_name($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $4 = $1;
 $2 = $4;
 $5 = $2;
 $6 = $5 + 8 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $3 = $7;
 $8 = $3;
 $9 = _mp_decode_uint_skip($8) | 0;
 $3 = $9;
 $10 = $3;
 $11 = _mp_decode_uint_skip($10) | 0;
 $3 = $11;
 $12 = $3;
 $13 = $12 + 1 | 0;
 $3 = $13;
 $14 = $3;
 $15 = $14 + 1 | 0;
 $3 = $15;
 $16 = $3;
 $17 = $16 + 1 | 0;
 $3 = $17;
 $18 = $3;
 $19 = $18 + 1 | 0;
 $3 = $19;
 $20 = $3;
 $21 = _mp_obj_code_get_name($20) | 0;
 STACKTOP = sp;
 return $21 | 0;
}

function _mvlsb_getpixel($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $6 + 8 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $5;
 $10 = $9 >> 3;
 $11 = $3;
 $12 = $11 + 16 | 0;
 $13 = HEAP16[$12 >> 1] | 0;
 $14 = $13 & 65535;
 $15 = Math_imul($10, $14) | 0;
 $16 = $4;
 $17 = $15 + $16 | 0;
 $18 = $8 + $17 | 0;
 $19 = HEAP8[$18 >> 0] | 0;
 $20 = $19 & 255;
 $21 = $5;
 $22 = $21 & 7;
 $23 = $20 >> $22;
 $24 = $23 & 1;
 STACKTOP = sp;
 return $24 | 0;
}

function _sinpi($0) {
 $0 = +$0;
 var $$0 = 0.0, $1 = 0.0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0.0, $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0, $7 = 0, $8 = 0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = $0 * .5;
 $2 = +Math_floor(+$1);
 $3 = $1 - $2;
 $4 = $3 * 2.0;
 $5 = $4 * 4.0;
 $6 = ~~$5;
 $7 = $6 + 1 | 0;
 $8 = ($7 | 0) / 2 & -1;
 $9 = +($8 | 0);
 $10 = $9 * .5;
 $11 = $4 - $10;
 $12 = $11 * 3.141592653589793;
 switch ($8 | 0) {
 case 3:
  {
   $17 = +___cos($12, 0.0);
   $18 = -$17;
   $$0 = $18;
   break;
  }
 case 1:
  {
   $14 = +___cos($12, 0.0);
   $$0 = $14;
   break;
  }
 case 2:
  {
   $15 = -$12;
   $16 = +___sin($15, 0.0, 0);
   $$0 = $16;
   break;
  }
 default:
  {
   $13 = +___sin($12, 0.0, 0);
   $$0 = $13;
  }
 }
 return +$$0;
}

function _compile_load_id($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 5 | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 & 255;
 $8 = ($7 | 0) == 1;
 $9 = $2;
 if ($8) {
  $10 = $9 + 36 | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  $12 = $3;
  _mp_emit_common_get_id_for_load($11, $12);
  STACKTOP = sp;
  return;
 } else {
  $13 = $9 + 40 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = $2;
  $16 = $15 + 36 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  $18 = $3;
  _mp_emit_common_id_op($14, 13352, $17, $18);
  STACKTOP = sp;
  return;
 }
}

function _mp_hal_move_cursor_back($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $2 = sp + 12 | 0;
 $1 = $0;
 $4 = $1;
 $5 = $4 >>> 0 <= 4;
 if ($5) {
  $6 = $1;
  _mp_hal_stdout_tx_strn(35332, $6);
  STACKTOP = sp;
  return;
 }
 $7 = $1;
 HEAP32[$vararg_buffer >> 2] = $7;
 $8 = _snprintf($2, 6, 35337, $vararg_buffer) | 0;
 $3 = $8;
 $9 = $3;
 $10 = ($9 | 0) > 0;
 if (!$10) {
  STACKTOP = sp;
  return;
 }
 $11 = $3;
 $12 = $2 + $11 | 0;
 HEAP8[$12 >> 0] = 68;
 $13 = $3;
 $14 = $13 + 1 | 0;
 _mp_hal_stdout_tx_strn($2, $14);
 STACKTOP = sp;
 return;
}

function _mp_cmath_log10($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 8 | 0;
 $3 = sp;
 $1 = $0;
 $4 = $1;
 _mp_obj_get_complex($4, $2, $3);
 $5 = +HEAPF64[$2 >> 3];
 $6 = +HEAPF64[$2 >> 3];
 $7 = $5 * $6;
 $8 = +HEAPF64[$3 >> 3];
 $9 = +HEAPF64[$3 >> 3];
 $10 = $8 * $9;
 $11 = $7 + $10;
 $12 = +_llvm_log10_f64(+$11);
 $13 = .5 * $12;
 $14 = +HEAPF64[$3 >> 3];
 $15 = +HEAPF64[$2 >> 3];
 $16 = +_atan2($14, $15);
 $17 = .4342944819032518 * $16;
 $18 = _mp_obj_new_complex($13, $17) | 0;
 STACKTOP = sp;
 return $18 | 0;
}

function _list_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $6;
 $11 = $7;
 _mp_arg_check_num_1065($10, $11, 0, 1, 0);
 $12 = $6;
 $cond = ($12 | 0) == 0;
 $13 = _mp_obj_new_list(0, 0) | 0;
 if ($cond) {
  $4 = $13;
  $18 = $4;
  STACKTOP = sp;
  return $18 | 0;
 } else {
  $9 = $13;
  $14 = $9;
  $15 = $8;
  $16 = HEAP32[$15 >> 2] | 0;
  $17 = _list_extend_from_iter($14, $16) | 0;
  $4 = $17;
  $18 = $4;
  STACKTOP = sp;
  return $18 | 0;
 }
 return 0 | 0;
}

function _mp_call_method_n_kw($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $5;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) == (0 | 0);
 $11 = $10 ? 0 : 1;
 $6 = $11;
 $12 = $5;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $3;
 $15 = $6;
 $16 = $14 + $15 | 0;
 $17 = $4;
 $18 = $5;
 $19 = $18 + 8 | 0;
 $20 = $6;
 $21 = 0 - $20 | 0;
 $22 = $19 + ($21 << 2) | 0;
 $23 = _mp_call_function_n_kw($13, $16, $17, $22) | 0;
 STACKTOP = sp;
 return $23 | 0;
}

function _mod_urandom_randint($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = _mp_obj_get_int($6) | 0;
 $4 = $7;
 $8 = $3;
 $9 = _mp_obj_get_int($8) | 0;
 $5 = $9;
 $10 = $4;
 $11 = $5;
 $12 = ($10 | 0) <= ($11 | 0);
 if ($12) {
  $13 = $4;
  $14 = $5;
  $15 = $4;
  $16 = $14 - $15 | 0;
  $17 = $16 + 1 | 0;
  $18 = _yasmarang_randbelow($17) | 0;
  $19 = $13 + $18 | 0;
  $20 = _mp_obj_new_int($19) | 0;
  STACKTOP = sp;
  return $20 | 0;
 } else {
  _mp_raise_ValueError(0);
 }
 return 0 | 0;
}

function _check_for_special_accessors($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$expand_i1_val = 0, $$expand_i1_val2 = 0, $$pre_trunc = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp + 8 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $4;
 $6 = _mp_obj_is_obj_1260($5) | 0;
 if ($6) {
  $7 = $4;
  $8 = HEAP32[$7 >> 2] | 0;
  $9 = ($8 | 0) == (17508 | 0);
  if ($9) {
   $$expand_i1_val = 1;
   HEAP8[$2 >> 0] = $$expand_i1_val;
  } else {
   label = 4;
  }
 } else {
  label = 4;
 }
 if ((label | 0) == 4) {
  $$expand_i1_val2 = 0;
  HEAP8[$2 >> 0] = $$expand_i1_val2;
 }
 $$pre_trunc = HEAP8[$2 >> 0] | 0;
 $10 = $$pre_trunc & 1;
 STACKTOP = sp;
 return $10 | 0;
}

function _mp_emit_bc_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $5;
 $7 = ($6 | 0) == 0;
 if ($7) {
  $8 = $3;
  _emit_bc_pre($8, 0);
  $9 = $3;
  $10 = $4;
  _emit_write_bytecode_byte_qstr($9, 29, $10);
  STACKTOP = sp;
  return;
 }
 $11 = $5;
 $12 = ($11 | 0) == 2;
 if ($12) {
  $13 = $3;
  _mp_emit_bc_load_null($13);
  $14 = $3;
  _mp_emit_bc_rot_two($14);
 }
 $15 = $3;
 _emit_bc_pre($15, -2);
 $16 = $3;
 $17 = $4;
 _emit_write_bytecode_byte_qstr($16, 38, $17);
 STACKTOP = sp;
 return;
}

function _gs8_setpixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $22 = 0, $23 = 0, $24 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $4;
 $10 = $9 + 8 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $5;
 $13 = $6;
 $14 = $4;
 $15 = $14 + 16 | 0;
 $16 = HEAP16[$15 >> 1] | 0;
 $17 = $16 & 65535;
 $18 = Math_imul($13, $17) | 0;
 $19 = $12 + $18 | 0;
 $20 = $11 + $19 | 0;
 $8 = $20;
 $21 = $7;
 $22 = $21 & 255;
 $23 = $22 & 255;
 $24 = $8;
 HEAP8[$24 >> 0] = $23;
 STACKTOP = sp;
 return;
}

function _stringio_getvalue($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $2 = $3;
 $4 = $2;
 _check_stringio_is_open($4);
 $5 = $2;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = ($6 | 0) == (18756 | 0);
 $8 = $7 ? 18680 : 18304;
 $9 = $2;
 $10 = $9 + 4 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $2;
 $15 = $14 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $16 + 4 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 $19 = _mp_obj_new_str_of_type($8, $13, $18) | 0;
 STACKTOP = sp;
 return $19 | 0;
}

function _emit_write_bytecode_byte_raw_code($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $8 = $4;
 _emit_write_bytecode_byte($7, $8);
 $9 = $3;
 $10 = $9 + 40 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $11 + 3 | 0;
 $13 = $12 & -4;
 $14 = $13;
 $15 = $14;
 $16 = $3;
 $17 = $16 + 40 | 0;
 HEAP32[$17 >> 2] = $15;
 $18 = $3;
 $19 = _emit_get_cur_to_write_bytecode($18, 4) | 0;
 $6 = $19;
 $20 = $5;
 $21 = $6;
 HEAP32[$21 >> 2] = $20;
 STACKTOP = sp;
 return;
}

function _vstr_add_strn($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $5;
 _vstr_ensure_extra($6, $7);
 $8 = $3;
 $9 = $8 + 8 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $3;
 $12 = $11 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $10 + $13 | 0;
 $15 = $4;
 $16 = $5;
 _memmove($14 | 0, $15 | 0, $16 | 0) | 0;
 $17 = $5;
 $18 = $3;
 $19 = $18 + 4 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = $20 + $17 | 0;
 HEAP32[$19 >> 2] = $21;
 STACKTOP = sp;
 return;
}

function _utf8_charlen($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = 0;
 $6 = $2;
 $7 = $3;
 $8 = $6 + $7 | 0;
 $5 = $8;
 while (1) {
  $9 = $2;
  $10 = $5;
  $11 = $9 >>> 0 < $10 >>> 0;
  if (!$11) {
   break;
  }
  $12 = $2;
  $13 = HEAP8[$12 >> 0] | 0;
  $14 = $13 & 255;
  $15 = $14 & 192;
  $16 = ($15 | 0) == 128;
  if (!$16) {
   $17 = $4;
   $18 = $17 + 1 | 0;
   $4 = $18;
  }
  $19 = $2;
  $20 = $19 + 1 | 0;
  $2 = $20;
 }
 $21 = $4;
 STACKTOP = sp;
 return $21 | 0;
}

function _emit_write_bytecode_byte_obj($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $8 = $4;
 _emit_write_bytecode_byte($7, $8);
 $9 = $3;
 $10 = $9 + 40 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $11 + 3 | 0;
 $13 = $12 & -4;
 $14 = $13;
 $15 = $14;
 $16 = $3;
 $17 = $16 + 40 | 0;
 HEAP32[$17 >> 2] = $15;
 $18 = $3;
 $19 = _emit_get_cur_to_write_bytecode($18, 4) | 0;
 $6 = $19;
 $20 = $5;
 $21 = $6;
 HEAP32[$21 >> 2] = $20;
 STACKTOP = sp;
 return;
}

function _mp_obj_get_int_truncated($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $2;
 $4 = _mp_obj_is_small_int_784($3) | 0;
 do {
  if (!$4) {
   $5 = $2;
   $6 = _mp_obj_is_obj_786($5) | 0;
   if ($6) {
    $7 = $2;
    $8 = HEAP32[$7 >> 2] | 0;
    $9 = ($8 | 0) == (16904 | 0);
    if ($9) {
     break;
    }
   }
   $12 = $2;
   $13 = _mp_obj_get_int($12) | 0;
   $1 = $13;
   $14 = $1;
   STACKTOP = sp;
   return $14 | 0;
  }
 } while (0);
 $10 = $2;
 $11 = _mp_obj_int_get_truncated($10) | 0;
 $1 = $11;
 $14 = $1;
 STACKTOP = sp;
 return $14 | 0;
}

function _mp_obj_int_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $6 = sp;
 $7 = sp + 28 | 0;
 $8 = sp + 24 | 0;
 $9 = sp + 20 | 0;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 HEAP32[$7 >> 2] = $6;
 HEAP32[$8 >> 2] = 16;
 $11 = $4;
 $12 = _mp_obj_int_formatted($7, $8, $9, $11, 10, 0, 0, 0) | 0;
 $10 = $12;
 $13 = $3;
 $14 = $10;
 _mp_print_str($13, $14) | 0;
 $15 = HEAP32[$7 >> 2] | 0;
 $16 = ($15 | 0) != ($6 | 0);
 if (!$16) {
  STACKTOP = sp;
  return;
 }
 $17 = HEAP32[$7 >> 2] | 0;
 _m_free($17);
 STACKTOP = sp;
 return;
}

function _gen_instance_close($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = sp;
 $2 = $0;
 $4 = $2;
 $5 = _mp_obj_gen_resume($4, 17668, 14856, $3) | 0;
 switch ($5 | 0) {
 case 1:
  {
   _mp_raise_msg(15772, 31288);
   break;
  }
 case 2:
  {
   $6 = HEAP32[$3 >> 2] | 0;
   $7 = _mp_obj_get_type($6) | 0;
   $8 = _mp_obj_is_subclass_fast($7, 14556) | 0;
   if (!$8) {
    $9 = HEAP32[$3 >> 2] | 0;
    _nlr_jump($9);
   }
   $1 = 17668;
   $10 = $1;
   STACKTOP = sp;
   return $10 | 0;
   break;
  }
 default:
  {
   $1 = 17668;
   $10 = $1;
   STACKTOP = sp;
   return $10 | 0;
  }
 }
 return 0 | 0;
}

function _dict_view_getiter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $4 = $6;
 $7 = $3;
 $5 = $7;
 $8 = $5;
 HEAP32[$8 >> 2] = 14352;
 $9 = $4;
 $10 = $9 + 8 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $5;
 $13 = $12 + 4 | 0;
 HEAP32[$13 >> 2] = $11;
 $14 = $4;
 $15 = $14 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $5;
 $18 = $17 + 8 | 0;
 HEAP32[$18 >> 2] = $16;
 $19 = $5;
 $20 = $19 + 12 | 0;
 HEAP32[$20 >> 2] = 0;
 $21 = $5;
 STACKTOP = sp;
 return $21 | 0;
}

function _bool_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $6 = $7;
 $8 = $5;
 $9 = ($8 | 0) == 3;
 $10 = $6;
 $11 = $10 + 4 | 0;
 $12 = HEAP8[$11 >> 0] | 0;
 $13 = $12 & 1;
 $14 = $3;
 do {
  if ($9) {
   if ($13) {
    _mp_print_str($14, 30856) | 0;
    break;
   } else {
    _mp_print_str($14, 30861) | 0;
    break;
   }
  } else {
   if ($13) {
    _mp_print_str($14, 30867) | 0;
    break;
   } else {
    _mp_print_str($14, 30872) | 0;
    break;
   }
  }
 } while (0);
 STACKTOP = sp;
 return;
}

function _static_class_method_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $9 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $10 = $5;
 $11 = $6;
 _mp_arg_check_num_1267($10, $11, 1, 1, 0);
 $12 = _m_malloc(8) | 0;
 $8 = $12;
 $13 = $8;
 $14 = $4;
 HEAP32[$9 >> 2] = $14;
 $15 = $9 + 4 | 0;
 $16 = $7;
 $17 = HEAP32[$16 >> 2] | 0;
 HEAP32[$15 >> 2] = $17;
 HEAP32[$13 >> 2] = HEAP32[$9 >> 2] | 0;
 HEAP32[$13 + 4 >> 2] = HEAP32[$9 + 4 >> 2] | 0;
 $18 = $8;
 STACKTOP = sp;
 return $18 | 0;
}

function _mp_pystack_alloc($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = $3 + 7 | 0;
 $5 = $4 & -8;
 $1 = $5;
 $6 = HEAP32[40556 >> 2] | 0;
 $7 = $1;
 $8 = $6 + $7 | 0;
 $9 = HEAP32[40552 >> 2] | 0;
 $10 = $8 >>> 0 > $9 >>> 0;
 if ($10) {
  $11 = _mp_obj_new_exception_arg1(15772, 866) | 0;
  _nlr_jump($11);
 } else {
  $12 = HEAP32[40556 >> 2] | 0;
  $2 = $12;
  $13 = $1;
  $14 = HEAP32[40556 >> 2] | 0;
  $15 = $14 + $13 | 0;
  HEAP32[40556 >> 2] = $15;
  $16 = $2;
  STACKTOP = sp;
  return $16 | 0;
 }
 return 0 | 0;
}

function _bool_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $9 = $6;
 $10 = $7;
 _mp_arg_check_num_837($9, $10, 0, 1, 0);
 $11 = $6;
 $12 = ($11 | 0) == 0;
 if ($12) {
  $4 = 13856;
  $18 = $4;
  STACKTOP = sp;
  return $18 | 0;
 } else {
  $13 = $8;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = _mp_obj_is_true($14) | 0;
  $16 = $15 & 1;
  $17 = _mp_obj_new_bool_840($16) | 0;
  $4 = $17;
  $18 = $4;
  STACKTOP = sp;
  return $18 | 0;
 }
 return 0 | 0;
}

function _mp_obj_new_getitem_iter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $4 = $5;
 $6 = $4;
 HEAP32[$6 >> 2] = 16844;
 $7 = $2;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $4;
 $10 = $9 + 4 | 0;
 HEAP32[$10 >> 2] = $8;
 $11 = $2;
 $12 = $11 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $4;
 $15 = $14 + 4 | 0;
 $16 = $15 + 4 | 0;
 HEAP32[$16 >> 2] = $13;
 $17 = $4;
 $18 = $17 + 4 | 0;
 $19 = $18 + 8 | 0;
 HEAP32[$19 >> 2] = 1;
 $20 = $4;
 STACKTOP = sp;
 return $20 | 0;
}

function _mp_builtin_pow($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $3;
 $cond = ($5 | 0) == 2;
 $6 = $4;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $4;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 if ($cond) {
  $11 = _mp_binary_op(32, $7, $10) | 0;
  $2 = $11;
  $16 = $2;
  STACKTOP = sp;
  return $16 | 0;
 } else {
  $12 = $4;
  $13 = $12 + 8 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = _mp_obj_int_pow3($7, $10, $14) | 0;
  $2 = $15;
  $16 = $2;
  STACKTOP = sp;
  return $16 | 0;
 }
 return 0 | 0;
}

function _mp_builtin_all($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = sp + 8 | 0;
 $2 = $0;
 $6 = $2;
 $7 = _mp_getiter($6, $3) | 0;
 $4 = $7;
 while (1) {
  $8 = $4;
  $9 = _mp_iternext($8) | 0;
  $5 = $9;
  $10 = ($9 | 0) != (0 | 0);
  if (!$10) {
   label = 6;
   break;
  }
  $11 = $5;
  $12 = _mp_obj_is_true($11) | 0;
  if (!$12) {
   label = 4;
   break;
  }
 }
 if ((label | 0) == 4) {
  $1 = 13856;
  $13 = $1;
  STACKTOP = sp;
  return $13 | 0;
 } else if ((label | 0) == 6) {
  $1 = 13864;
  $13 = $1;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0 | 0;
}

function _mp_builtin_any($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = sp + 8 | 0;
 $2 = $0;
 $6 = $2;
 $7 = _mp_getiter($6, $3) | 0;
 $4 = $7;
 while (1) {
  $8 = $4;
  $9 = _mp_iternext($8) | 0;
  $5 = $9;
  $10 = ($9 | 0) != (0 | 0);
  if (!$10) {
   label = 6;
   break;
  }
  $11 = $5;
  $12 = _mp_obj_is_true($11) | 0;
  if ($12) {
   label = 4;
   break;
  }
 }
 if ((label | 0) == 4) {
  $1 = 13864;
  $13 = $1;
  STACKTOP = sp;
  return $13 | 0;
 } else if ((label | 0) == 6) {
  $1 = 13856;
  $13 = $1;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0 | 0;
}

function _mod_urandom_getrandbits($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $4 = $1;
 $5 = _mp_obj_get_int($4) | 0;
 $2 = $5;
 $6 = $2;
 $7 = ($6 | 0) > 32;
 $8 = $2;
 $9 = ($8 | 0) == 0;
 $or$cond = $7 | $9;
 if ($or$cond) {
  _mp_raise_ValueError(0);
 } else {
  $3 = -1;
  $10 = $2;
  $11 = 32 - $10 | 0;
  $12 = $3;
  $13 = $12 >>> $11;
  $3 = $13;
  $14 = _yasmarang() | 0;
  $15 = $3;
  $16 = $14 & $15;
  $17 = _mp_obj_new_int_from_uint($16) | 0;
  STACKTOP = sp;
  return $17 | 0;
 }
 return 0 | 0;
}

function _mp_set_slot_is_filled_1104($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 $8 = $6 + ($7 << 2) | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) != (0 | 0);
 if (!$10) {
  $18 = 0;
  STACKTOP = sp;
  return $18 | 0;
 }
 $11 = $2;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $3;
 $15 = $13 + ($14 << 2) | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($16 | 0) != (4 | 0);
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _mp_map_slot_is_filled_1536($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 $8 = $6 + ($7 << 3) | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) != (0 | 0);
 if (!$10) {
  $18 = 0;
  STACKTOP = sp;
  return $18 | 0;
 }
 $11 = $2;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $3;
 $15 = $13 + ($14 << 3) | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($16 | 0) != (4 | 0);
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _mp_map_slot_is_filled_1474($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 $8 = $6 + ($7 << 3) | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) != (0 | 0);
 if (!$10) {
  $18 = 0;
  STACKTOP = sp;
  return $18 | 0;
 }
 $11 = $2;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $3;
 $15 = $13 + ($14 << 3) | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($16 | 0) != (4 | 0);
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _mp_map_slot_is_filled_1385($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 $8 = $6 + ($7 << 3) | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) != (0 | 0);
 if (!$10) {
  $18 = 0;
  STACKTOP = sp;
  return $18 | 0;
 }
 $11 = $2;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $3;
 $15 = $13 + ($14 << 3) | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($16 | 0) != (4 | 0);
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _mp_map_slot_is_filled_1377($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 $8 = $6 + ($7 << 3) | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) != (0 | 0);
 if (!$10) {
  $18 = 0;
  STACKTOP = sp;
  return $18 | 0;
 }
 $11 = $2;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $3;
 $15 = $13 + ($14 << 3) | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($16 | 0) != (4 | 0);
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _mp_map_slot_is_filled_1272($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 $8 = $6 + ($7 << 3) | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) != (0 | 0);
 if (!$10) {
  $18 = 0;
  STACKTOP = sp;
  return $18 | 0;
 }
 $11 = $2;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $3;
 $15 = $13 + ($14 << 3) | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($16 | 0) != (4 | 0);
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _range_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $7 = $4;
 $5 = $7;
 $8 = $5;
 $9 = _range_len($8) | 0;
 $6 = $9;
 $10 = $3;
 switch ($10 | 0) {
 case 4:
  {
   $11 = $6;
   $12 = ($11 | 0) > 0;
   $13 = $12 & 1;
   $14 = _mp_obj_new_bool_1096($13) | 0;
   $2 = $14;
   break;
  }
 case 5:
  {
   $15 = $6;
   $16 = $15 << 1;
   $17 = $16 | 1;
   $18 = $17;
   $2 = $18;
   break;
  }
 default:
  {
   $2 = 0;
  }
 }
 $19 = $2;
 STACKTOP = sp;
 return $19 | 0;
}

function _mp_map_slot_is_filled_875($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 $8 = $6 + ($7 << 3) | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) != (0 | 0);
 if (!$10) {
  $18 = 0;
  STACKTOP = sp;
  return $18 | 0;
 }
 $11 = $2;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $3;
 $15 = $13 + ($14 << 3) | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($16 | 0) != (4 | 0);
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _fmt_o($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$0$lcssa = 0, $$06 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $3 = ($0 | 0) == 0;
 $4 = ($1 | 0) == 0;
 $5 = $3 & $4;
 if ($5) {
  $$0$lcssa = $2;
 } else {
  $$06 = $2;
  $11 = $1;
  $7 = $0;
  while (1) {
   $6 = $7 & 255;
   $8 = $6 & 7;
   $9 = $8 | 48;
   $10 = $$06 + -1 | 0;
   HEAP8[$10 >> 0] = $9;
   $12 = _bitshift64Lshr($7 | 0, $11 | 0, 3) | 0;
   $13 = getTempRet0() | 0;
   $14 = ($12 | 0) == 0;
   $15 = ($13 | 0) == 0;
   $16 = $14 & $15;
   if ($16) {
    $$0$lcssa = $10;
    break;
   } else {
    $$06 = $10;
    $11 = $13;
    $7 = $12;
   }
  }
 }
 return $$0$lcssa | 0;
}

function _mp_set_slot_is_filled($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 $8 = $6 + ($7 << 2) | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) != (0 | 0);
 if (!$10) {
  $18 = 0;
  STACKTOP = sp;
  return $18 | 0;
 }
 $11 = $2;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $3;
 $15 = $13 + ($14 << 2) | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($16 | 0) != (4 | 0);
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _mp_map_slot_is_filled($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 $8 = $6 + ($7 << 3) | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) != (0 | 0);
 if (!$10) {
  $18 = 0;
  STACKTOP = sp;
  return $18 | 0;
 }
 $11 = $2;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $3;
 $15 = $13 + ($14 << 3) | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = ($16 | 0) != (4 | 0);
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _vstr_null_terminated_str($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = HEAP32[$2 >> 2] | 0;
 $4 = $1;
 $5 = $4 + 4 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = ($3 | 0) == ($6 | 0);
 if ($7) {
  $8 = $1;
  _vstr_extend($8, 1) | 0;
 }
 $9 = $1;
 $10 = $9 + 8 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $1;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $11 + $14 | 0;
 HEAP8[$15 >> 0] = 0;
 $16 = $1;
 $17 = $16 + 8 | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 STACKTOP = sp;
 return $18 | 0;
}

function _compile_error_set_line($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 12 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = ($6 | 0) == 0;
 $8 = $3;
 $9 = ($8 | 0) != 0;
 $or$cond = $7 & $9;
 if (!$or$cond) {
  STACKTOP = sp;
  return;
 }
 $10 = $3;
 $11 = $10 & 3;
 $12 = ($11 | 0) == 0;
 if (!$12) {
  STACKTOP = sp;
  return;
 }
 $13 = $3;
 $14 = $13;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $2;
 $17 = $16 + 12 | 0;
 HEAP32[$17 >> 2] = $15;
 STACKTOP = sp;
 return;
}

function _find_qstr($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = HEAP32[40572 >> 2] | 0;
 $2 = $3;
 while (1) {
  $4 = $1;
  $5 = $2;
  $6 = $5 + 4 | 0;
  $7 = HEAP32[$6 >> 2] | 0;
  $8 = $4 >>> 0 < $7 >>> 0;
  $9 = $2;
  if (!$8) {
   break;
  }
  $10 = HEAP32[$9 >> 2] | 0;
  $2 = $10;
 }
 $11 = $9 + 16 | 0;
 $12 = $1;
 $13 = $2;
 $14 = $13 + 4 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $12 - $15 | 0;
 $17 = $11 + ($16 << 2) | 0;
 $18 = HEAP32[$17 >> 2] | 0;
 STACKTOP = sp;
 return $18 | 0;
}

function _str_dup_maybe($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $5 = $2;
 $6 = _strlen($5) | 0;
 $3 = $6;
 $7 = $3;
 $8 = $7 + 1 | 0;
 $9 = $8;
 $10 = _m_malloc_maybe($9) | 0;
 $4 = $10;
 $11 = $4;
 $12 = ($11 | 0) == (0 | 0);
 if ($12) {
  $1 = 0;
  $18 = $1;
  STACKTOP = sp;
  return $18 | 0;
 } else {
  $13 = $4;
  $14 = $2;
  $15 = $3;
  $16 = $15 + 1 | 0;
  _memcpy($13 | 0, $14 | 0, $16 | 0) | 0;
  $17 = $4;
  $1 = $17;
  $18 = $1;
  STACKTOP = sp;
  return $18 | 0;
 }
 return 0 | 0;
}

function _mp_cmath_log($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 8 | 0;
 $3 = sp;
 $1 = $0;
 $4 = $1;
 _mp_obj_get_complex($4, $2, $3);
 $5 = +HEAPF64[$2 >> 3];
 $6 = +HEAPF64[$2 >> 3];
 $7 = $5 * $6;
 $8 = +HEAPF64[$3 >> 3];
 $9 = +HEAPF64[$3 >> 3];
 $10 = $8 * $9;
 $11 = $7 + $10;
 $12 = +Math_log(+$11);
 $13 = .5 * $12;
 $14 = +HEAPF64[$3 >> 3];
 $15 = +HEAPF64[$2 >> 3];
 $16 = +_atan2($14, $15);
 $17 = _mp_obj_new_complex($13, $16) | 0;
 STACKTOP = sp;
 return $17 | 0;
}

function _bool_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $3;
 $7 = ($6 | 0) == 5;
 if ($7) {
  $2 = 0;
  $19 = $2;
  STACKTOP = sp;
  return $19 | 0;
 } else {
  $8 = $4;
  $5 = $8;
  $9 = $3;
  $10 = $5;
  $11 = $10 + 4 | 0;
  $12 = HEAP8[$11 >> 0] | 0;
  $13 = $12 & 1;
  $14 = $13 & 1;
  $15 = $14 << 1;
  $16 = $15 | 1;
  $17 = $16;
  $18 = _mp_unary_op($9, $17) | 0;
  $2 = $18;
  $19 = $2;
  STACKTOP = sp;
  return $19 | 0;
 }
 return 0 | 0;
}

function _mp_obj_slice_get($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $4;
 $8 = $9;
 $10 = $8;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $5;
 HEAP32[$13 >> 2] = $12;
 $14 = $8;
 $15 = $14 + 8 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $6;
 HEAP32[$17 >> 2] = $16;
 $18 = $8;
 $19 = $18 + 12 | 0;
 $20 = HEAP32[$19 >> 2] | 0;
 $21 = $7;
 HEAP32[$21 >> 2] = $20;
 STACKTOP = sp;
 return;
}

function _super_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $6 = $7;
 $8 = $3;
 _mp_print_str($8, 33318) | 0;
 $9 = $3;
 $10 = $6;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 _mp_obj_print_helper($9, $12, 0);
 $13 = $3;
 _mp_print_str($13, 33327) | 0;
 $14 = $3;
 $15 = $6;
 $16 = $15 + 8 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 _mp_obj_print_helper($14, $17, 0);
 $18 = $3;
 _mp_print_str($18, 35323) | 0;
 STACKTOP = sp;
 return;
}

function _mp_obj_list_store($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $3;
 $6 = $8;
 $9 = $6;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $6;
 $12 = $11 + 8 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $4;
 $15 = _mp_get_index($10, $13, $14, 0) | 0;
 $7 = $15;
 $16 = $5;
 $17 = $6;
 $18 = $17 + 12 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = $7;
 $21 = $19 + ($20 << 2) | 0;
 HEAP32[$21 >> 2] = $16;
 STACKTOP = sp;
 return;
}

function _mp_obj_id($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $5 = $4;
 $3 = $5;
 $6 = $2;
 $7 = _mp_obj_is_obj_786($6) | 0;
 $8 = $3;
 do {
  if ($7) {
   $10 = ($8 | 0) >= 0;
   $11 = $3;
   if ($10) {
    $12 = $11 << 1;
    $13 = $12 | 1;
    $14 = $13;
    $1 = $14;
    break;
   } else {
    $15 = _mp_obj_new_int_from_uint($11) | 0;
    $1 = $15;
    break;
   }
  } else {
   $9 = _mp_obj_new_int($8) | 0;
   $1 = $9;
  }
 } while (0);
 $16 = $1;
 STACKTOP = sp;
 return $16 | 0;
}

function _fun_builtin_2_call($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $4;
 $8 = $9;
 $10 = $5;
 $11 = $6;
 _mp_arg_check_num_977($10, $11, 2, 2, 0);
 $12 = $8;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $7;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = $7;
 $18 = $17 + 4 | 0;
 $19 = HEAP32[$18 >> 2] | 0;
 $20 = FUNCTION_TABLE_iii[$14 & 1023]($16, $19) | 0;
 STACKTOP = sp;
 return $20 | 0;
}

function _mp_obj_exception_get_value($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $3 = $4;
 $5 = $3;
 $6 = $5 + 12 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $7 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) == 0;
 if ($10) {
  $1 = 17668;
  $16 = $1;
  STACKTOP = sp;
  return $16 | 0;
 } else {
  $11 = $3;
  $12 = $11 + 12 | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = $13 + 8 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $1 = $15;
  $16 = $1;
  STACKTOP = sp;
  return $16 | 0;
 }
 return 0 | 0;
}

function _rgb565_setpixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $8 = $7;
 $9 = $8 & 65535;
 $10 = $4;
 $11 = $10 + 8 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $5;
 $14 = $6;
 $15 = $4;
 $16 = $15 + 16 | 0;
 $17 = HEAP16[$16 >> 1] | 0;
 $18 = $17 & 65535;
 $19 = Math_imul($14, $18) | 0;
 $20 = $13 + $19 | 0;
 $21 = $12 + ($20 << 1) | 0;
 HEAP16[$21 >> 1] = $9;
 STACKTOP = sp;
 return;
}

function _mp_obj_new_str($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $3;
 $7 = $4;
 $8 = _qstr_find_strn($6, $7) | 0;
 $5 = $8;
 $9 = $5;
 $10 = ($9 | 0) != 0;
 if ($10) {
  $11 = $5;
  $12 = $11 << 2;
  $13 = $12 | 2;
  $14 = $13;
  $2 = $14;
  $18 = $2;
  STACKTOP = sp;
  return $18 | 0;
 } else {
  $15 = $3;
  $16 = $4;
  $17 = _mp_obj_new_str_copy(18680, $15, $16) | 0;
  $2 = $17;
  $18 = $2;
  STACKTOP = sp;
  return $18 | 0;
 }
 return 0 | 0;
}

function _mp_lexer_new_from_str_len($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $$byval_copy = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $$byval_copy = sp + 28 | 0;
 $8 = sp;
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $5;
 $10 = $6;
 $11 = $7;
 _mp_reader_new_mem($8, $9, $10, $11);
 $12 = $4;
 HEAP32[$$byval_copy >> 2] = HEAP32[$8 >> 2] | 0;
 HEAP32[$$byval_copy + 4 >> 2] = HEAP32[$8 + 4 >> 2] | 0;
 HEAP32[$$byval_copy + 8 >> 2] = HEAP32[$8 + 8 >> 2] | 0;
 $13 = _mp_lexer_new($12, $$byval_copy) | 0;
 STACKTOP = sp;
 return $13 | 0;
}

function _mp_load_attr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp;
 $3 = $0;
 $4 = $1;
 $6 = $3;
 $7 = $4;
 _mp_load_method($6, $7, $5);
 $8 = $5 + 4 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = ($9 | 0) == (0 | 0);
 $11 = HEAP32[$5 >> 2] | 0;
 if ($10) {
  $2 = $11;
  $15 = $2;
  STACKTOP = sp;
  return $15 | 0;
 } else {
  $12 = $5 + 4 | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  $14 = _mp_obj_new_bound_meth($11, $13) | 0;
  $2 = $14;
  $15 = $2;
  STACKTOP = sp;
  return $15 | 0;
 }
 return 0 | 0;
}

function _get_fmt_type($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $5 = HEAP32[$4 >> 2] | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 $3 = $6;
 $7 = $3;
 $8 = $7 << 24 >> 24;
 switch ($8 | 0) {
 case 33:
  {
   $3 = 62;
   break;
  }
 case 62:
 case 60:
 case 61:
 case 64:
  {
   break;
  }
 default:
  {
   $1 = 64;
   $13 = $1;
   STACKTOP = sp;
   return $13 | 0;
  }
 }
 $9 = $2;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $10 + 1 | 0;
 HEAP32[$9 >> 2] = $11;
 $12 = $3;
 $1 = $12;
 $13 = $1;
 STACKTOP = sp;
 return $13 | 0;
}

function _mp_obj_instance_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $5;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = ($7 | 0) == (0 | 0);
 $9 = $3;
 $10 = $4;
 $11 = $5;
 if ($8) {
  _mp_obj_instance_load_attr($9, $10, $11);
  STACKTOP = sp;
  return;
 }
 $12 = $11 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = _mp_obj_instance_store_attr($9, $10, $13) | 0;
 if (!$14) {
  STACKTOP = sp;
  return;
 }
 $15 = $5;
 HEAP32[$15 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _yasmarang_randbelow($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = 1;
 while (1) {
  $4 = $1;
  $5 = $2;
  $6 = $4 & $5;
  $7 = $1;
  $8 = $6 >>> 0 < $7 >>> 0;
  if (!$8) {
   break;
  }
  $9 = $2;
  $10 = $9 << 1;
  $11 = $10 | 1;
  $2 = $11;
 }
 while (1) {
  $12 = _yasmarang() | 0;
  $13 = $2;
  $14 = $12 & $13;
  $3 = $14;
  $15 = $3;
  $16 = $1;
  $17 = $15 >>> 0 >= $16 >>> 0;
  if (!$17) {
   break;
  }
 }
 $18 = $3;
 STACKTOP = sp;
 return $18 | 0;
}

function _mp_emit_bc_import($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $5;
 $7 = ($6 | 0) == 1;
 $8 = $3;
 if ($7) {
  _emit_bc_pre($8, 1);
 } else {
  _emit_bc_pre($8, -1);
 }
 $9 = $5;
 $10 = ($9 | 0) == 2;
 $11 = $3;
 if ($10) {
  _emit_write_bytecode_byte($11, 106);
  STACKTOP = sp;
  return;
 } else {
  $12 = $5;
  $13 = 104 + $12 | 0;
  $14 = $13 & 255;
  $15 = $4;
  _emit_write_bytecode_byte_qstr($11, $14, $15);
  STACKTOP = sp;
  return;
 }
}

function _mp_lexer_free($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != (0 | 0);
 if (!$3) {
  STACKTOP = sp;
  return;
 }
 $4 = $1;
 $5 = $4 + 4 | 0;
 $6 = $5 + 8 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $1;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 FUNCTION_TABLE_vi[$7 & 1023]($10);
 $11 = $1;
 $12 = $11 + 68 | 0;
 _vstr_clear($12);
 $13 = $1;
 $14 = $13 + 52 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 _m_free($15);
 $16 = $1;
 _m_free($16);
 STACKTOP = sp;
 return;
}

function _mod_re_exec($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $7 = sp + 8 | 0;
 $9 = $0 & 1;
 $3 = $9;
 $4 = $1;
 $5 = $2;
 $10 = $5;
 $11 = _mod_re_compile(1, $10) | 0;
 $6 = $11;
 $12 = $6;
 HEAP32[$7 >> 2] = $12;
 $13 = $7 + 4 | 0;
 $14 = $5;
 $15 = $14 + 4 | 0;
 $16 = HEAP32[$15 >> 2] | 0;
 HEAP32[$13 >> 2] = $16;
 $17 = $3;
 $18 = $17 & 1;
 $19 = _ure_exec($18, 2, $7) | 0;
 $8 = $19;
 $20 = $8;
 STACKTOP = sp;
 return $20 | 0;
}

function _mp_obj_instance_get_call($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp;
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $4 = $6;
 $7 = $4;
 HEAP32[$5 >> 2] = $7;
 $8 = $5 + 4 | 0;
 HEAP32[$8 >> 2] = 9;
 $9 = $5 + 8 | 0;
 HEAP32[$9 >> 2] = 16;
 $10 = $5 + 12 | 0;
 $11 = $3;
 HEAP32[$10 >> 2] = $11;
 $12 = $5 + 16 | 0;
 HEAP8[$12 >> 0] = 0;
 $13 = $4;
 $14 = HEAP32[$13 >> 2] | 0;
 _mp_obj_class_lookup($5, $14);
 $15 = $3;
 $16 = HEAP32[$15 >> 2] | 0;
 STACKTOP = sp;
 return $16 | 0;
}

function _is_char_following_following_or($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $6 + 24 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $4;
 $10 = $9 & 255;
 $11 = ($8 | 0) == ($10 | 0);
 if ($11) {
  $18 = 1;
  STACKTOP = sp;
  return $18 | 0;
 }
 $12 = $3;
 $13 = $12 + 24 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $5;
 $16 = $15 & 255;
 $17 = ($14 | 0) == ($16 | 0);
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _bad_implicit_conversion($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_ptr1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $vararg_buffer = sp;
 $1 = $0;
 $3 = $1;
 $4 = _mp_obj_get_type($3) | 0;
 $5 = $4 + 6 | 0;
 $6 = HEAP16[$5 >> 1] | 0;
 $7 = $6 & 65535;
 $2 = $7;
 $8 = $2;
 $9 = $2;
 $10 = ($9 | 0) == 151;
 $11 = $10 ? 66 : 151;
 HEAP32[$vararg_buffer >> 2] = $8;
 $vararg_ptr1 = $vararg_buffer + 4 | 0;
 HEAP32[$vararg_ptr1 >> 2] = $11;
 $12 = _mp_obj_new_exception_msg_varg(16012, 31732, $vararg_buffer) | 0;
 _nlr_jump($12);
}

function _is_set_or_frozenset($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_obj_is_obj_1105($2) | 0;
 if ($3) {
  $4 = $1;
  $5 = HEAP32[$4 >> 2] | 0;
  $6 = ($5 | 0) == (17860 | 0);
  if ($6) {
   $12 = 1;
  } else {
   label = 3;
  }
 } else {
  label = 3;
 }
 if ((label | 0) == 3) {
  $7 = $1;
  $8 = _mp_obj_is_obj_1105($7) | 0;
  if ($8) {
   $9 = $1;
   $10 = HEAP32[$9 >> 2] | 0;
   $11 = ($10 | 0) == (18084 | 0);
   $12 = $11;
  } else {
   $12 = 0;
  }
 }
 STACKTOP = sp;
 return $12 | 0;
}

function _mp_import_name($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $6 = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $8 = $7 << 2;
 $9 = $8 | 2;
 $10 = $9;
 HEAP32[$6 >> 2] = $10;
 $11 = $6 + 4 | 0;
 HEAP32[$11 >> 2] = 17668;
 $12 = $6 + 8 | 0;
 HEAP32[$12 >> 2] = 17668;
 $13 = $4;
 $14 = $6 + 12 | 0;
 HEAP32[$14 >> 2] = $13;
 $15 = $5;
 $16 = $6 + 16 | 0;
 HEAP32[$16 >> 2] = $15;
 $17 = _mp_builtin___import__(5, $6) | 0;
 STACKTOP = sp;
 return $17 | 0;
}

function _mp_obj_new_range_iterator($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $7;
 $8 = $9;
 $10 = $8;
 HEAP32[$10 >> 2] = 17740;
 $11 = $4;
 $12 = $8;
 $13 = $12 + 4 | 0;
 HEAP32[$13 >> 2] = $11;
 $14 = $5;
 $15 = $8;
 $16 = $15 + 8 | 0;
 HEAP32[$16 >> 2] = $14;
 $17 = $6;
 $18 = $8;
 $19 = $18 + 12 | 0;
 HEAP32[$19 >> 2] = $17;
 $20 = $8;
 STACKTOP = sp;
 return $20 | 0;
}

function _mp_emit_bc_yield($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = 0 - $5 | 0;
 _emit_bc_pre($4, $6);
 $7 = $2;
 $8 = $7 + 12 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 + 24 | 0;
 $11 = HEAP16[$10 >> 1] | 0;
 $12 = $11 & 65535;
 $13 = $12 | 4;
 $14 = $13 & 65535;
 HEAP16[$10 >> 1] = $14;
 $15 = $2;
 $16 = $3;
 $17 = 93 + $16 | 0;
 $18 = $17 & 255;
 _emit_write_bytecode_byte($15, $18);
 STACKTOP = sp;
 return;
}

function _mp_cmath_cos($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 8 | 0;
 $3 = sp;
 $1 = $0;
 $4 = $1;
 _mp_obj_get_complex($4, $2, $3);
 $5 = +HEAPF64[$2 >> 3];
 $6 = +_llvm_cos_f64(+$5);
 $7 = +HEAPF64[$3 >> 3];
 $8 = +_cosh($7);
 $9 = $6 * $8;
 $10 = +HEAPF64[$2 >> 3];
 $11 = +_llvm_sin_f64(+$10);
 $12 = -$11;
 $13 = +HEAPF64[$3 >> 3];
 $14 = +_sinh($13);
 $15 = $12 * $14;
 $16 = _mp_obj_new_complex($9, $15) | 0;
 STACKTOP = sp;
 return $16 | 0;
}

function _mp_handle_pending() {
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = HEAP16[40740 >> 1] | 0;
 $3 = $2 << 16 >> 16;
 $4 = ($3 | 0) == 0;
 if (!$4) {
  STACKTOP = sp;
  return;
 }
 $0 = 0;
 $5 = HEAP32[40624 >> 2] | 0;
 $1 = $5;
 $6 = $1;
 $7 = ($6 | 0) != (0 | 0);
 if (!$7) {
  $11 = $0;
  _mp_handle_pending_tail($11);
  STACKTOP = sp;
  return;
 }
 HEAP32[40624 >> 2] = 0;
 $8 = _mp_sched_num_pending() | 0;
 $9 = ($8 | 0) != 0;
 if ($9) {
  $10 = $1;
  _nlr_jump($10);
 }
 HEAP16[40740 >> 1] = 1;
 $10 = $1;
 _nlr_jump($10);
}

function _mp_arg_parse_all_kw_array($0, $1, $2, $3, $4, $5) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 $5 = $5 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 48 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(48 | 0);
 $12 = sp;
 $6 = $0;
 $7 = $1;
 $8 = $2;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 $13 = $7;
 $14 = $8;
 $15 = $6;
 $16 = $14 + ($15 << 2) | 0;
 _mp_map_init_fixed_table($12, $13, $16);
 $17 = $6;
 $18 = $8;
 $19 = $9;
 $20 = $10;
 $21 = $11;
 _mp_arg_parse_all($17, $18, $12, $19, $20, $21);
 STACKTOP = sp;
 return;
}

function _is_char_following_or($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $6 + 20 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $4;
 $10 = $9 & 255;
 $11 = ($8 | 0) == ($10 | 0);
 if ($11) {
  $18 = 1;
  STACKTOP = sp;
  return $18 | 0;
 }
 $12 = $3;
 $13 = $12 + 20 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $5;
 $16 = $15 & 255;
 $17 = ($14 | 0) == ($16 | 0);
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _vstr_add_len($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = $3;
 _vstr_ensure_extra($5, $6);
 $7 = $2;
 $8 = $7 + 8 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $2;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $9 + $12 | 0;
 $4 = $13;
 $14 = $3;
 $15 = $2;
 $16 = $15 + 4 | 0;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $17 + $14 | 0;
 HEAP32[$16 >> 2] = $18;
 $19 = $4;
 STACKTOP = sp;
 return $19 | 0;
}

function _poll_register($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = HEAP32[$6 >> 2] | 0;
 $4 = $7;
 $8 = $2;
 $9 = ($8 | 0) == 3;
 if ($9) {
  $10 = $3;
  $11 = $10 + 8 | 0;
  $12 = HEAP32[$11 >> 2] | 0;
  $13 = _mp_obj_get_int($12) | 0;
  $5 = $13;
 } else {
  $5 = 5;
 }
 $14 = $4;
 $15 = $14 + 4 | 0;
 $16 = $3;
 $17 = $16 + 4 | 0;
 $18 = $5;
 _poll_map_add($15, $17, 1, $18, 0);
 STACKTOP = sp;
 return 17668 | 0;
}

function _re1_5_recursiveloopprog($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $9 = $4;
 $10 = $9;
 $11 = ($10 | 0) != 0;
 $12 = $5;
 $13 = $12 + 12 | 0;
 $14 = $13 + 5 | 0;
 $15 = $11 ? $14 : $13;
 $16 = $6;
 $17 = HEAP32[$16 >> 2] | 0;
 $18 = $6;
 $19 = $7;
 $20 = $8;
 $21 = _recursiveloop($15, $17, $18, $19, $20) | 0;
 STACKTOP = sp;
 return $21 | 0;
}

function _mp_obj_new_int($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $2;
 $4 = $2;
 $5 = $4 << 1;
 $6 = $3 ^ $5;
 $7 = $6 & -2147483648;
 $8 = ($7 | 0) == 0;
 $9 = $2;
 if ($8) {
  $10 = $9 << 1;
  $11 = $10 | 1;
  $12 = $11;
  $1 = $12;
  $16 = $1;
  STACKTOP = sp;
  return $16 | 0;
 } else {
  $13 = ($9 | 0) < 0;
  $14 = $13 << 31 >> 31;
  $15 = _mp_obj_new_int_from_ll($9, $14) | 0;
  $1 = $15;
  $16 = $1;
  STACKTOP = sp;
  return $16 | 0;
 }
 return 0 | 0;
}

function _mp_instance_cast_to_native_base($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $7 = $3;
 $8 = _mp_obj_get_type($7) | 0;
 $5 = $8;
 $9 = $5;
 $10 = $4;
 $11 = _mp_obj_is_subclass_fast($9, $10) | 0;
 if ($11) {
  $12 = $3;
  $6 = $12;
  $13 = $6;
  $14 = $13 + 16 | 0;
  $15 = HEAP32[$14 >> 2] | 0;
  $2 = $15;
  $16 = $2;
  STACKTOP = sp;
  return $16 | 0;
 } else {
  $2 = 0;
  $16 = $2;
  STACKTOP = sp;
  return $16 | 0;
 }
 return 0 | 0;
}

function _mp_obj_dict_get($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $4 = $6;
 $7 = $4;
 $8 = $7 + 4 | 0;
 $9 = $3;
 $10 = _mp_map_lookup($8, $9, 0) | 0;
 $5 = $10;
 $11 = $5;
 $12 = ($11 | 0) == (0 | 0);
 if ($12) {
  $13 = $3;
  $14 = _mp_obj_new_exception_arg1(15592, $13) | 0;
  _nlr_jump($14);
 } else {
  $15 = $5;
  $16 = $15 + 4 | 0;
  $17 = HEAP32[$16 >> 2] | 0;
  STACKTOP = sp;
  return $17 | 0;
 }
 return 0 | 0;
}

function _mp_cmath_exp($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0, $2 = 0, $3 = 0, $4 = 0.0, $5 = 0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 16 | 0;
 $3 = sp + 8 | 0;
 $1 = $0;
 $5 = $1;
 _mp_obj_get_complex($5, $2, $3);
 $6 = +HEAPF64[$2 >> 3];
 $7 = +Math_exp(+$6);
 $4 = $7;
 $8 = $4;
 $9 = +HEAPF64[$3 >> 3];
 $10 = +_llvm_cos_f64(+$9);
 $11 = $8 * $10;
 $12 = $4;
 $13 = +HEAPF64[$3 >> 3];
 $14 = +_llvm_sin_f64(+$13);
 $15 = $12 * $14;
 $16 = _mp_obj_new_complex($11, $15) | 0;
 STACKTOP = sp;
 return $16 | 0;
}

function _time_ticks_diff($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $2 = 0, $20 = 0, $21 = 0, $22 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $7 = $3;
 $8 = $7;
 $9 = $8 >> 1;
 $4 = $9;
 $10 = $2;
 $11 = $10;
 $12 = $11 >> 1;
 $5 = $12;
 $13 = $5;
 $14 = $4;
 $15 = $13 - $14 | 0;
 $16 = $15 + 536870912 | 0;
 $17 = $16 & 1073741823;
 $18 = $17 - 536870912 | 0;
 $6 = $18;
 $19 = $6;
 $20 = $19 << 1;
 $21 = $20 | 1;
 $22 = $21;
 STACKTOP = sp;
 return $22 | 0;
}

function _is_char_and($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $6 + 16 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $4;
 $10 = $9 & 255;
 $11 = ($8 | 0) == ($10 | 0);
 if (!$11) {
  $18 = 0;
  STACKTOP = sp;
  return $18 | 0;
 }
 $12 = $3;
 $13 = $12 + 20 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $5;
 $16 = $15 & 255;
 $17 = ($14 | 0) == ($16 | 0);
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _get_aligned_basic($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $3;
 switch ($5 | 0) {
 case 0:
  {
   $6 = $4;
   $7 = HEAP8[$6 >> 0] | 0;
   $8 = $7 & 255;
   $2 = $8;
   break;
  }
 case 2:
  {
   $9 = $4;
   $10 = HEAP16[$9 >> 1] | 0;
   $11 = $10 & 65535;
   $2 = $11;
   break;
  }
 case 4:
  {
   $12 = $4;
   $13 = HEAP32[$12 >> 2] | 0;
   $2 = $13;
   break;
  }
 default:
  {
   $2 = 0;
  }
 }
 $14 = $2;
 STACKTOP = sp;
 return $14 | 0;
}

function _is_char_or($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $6 + 16 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $4;
 $10 = $9 & 255;
 $11 = ($8 | 0) == ($10 | 0);
 if ($11) {
  $18 = 1;
  STACKTOP = sp;
  return $18 | 0;
 }
 $12 = $3;
 $13 = $12 + 16 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $5;
 $16 = $15 & 255;
 $17 = ($14 | 0) == ($16 | 0);
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _gen_instance_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_ptr1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $6 = $7;
 $8 = $3;
 $9 = $6;
 $10 = $9 + 8 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = _mp_obj_fun_get_name($11) | 0;
 $13 = $6;
 HEAP32[$vararg_buffer >> 2] = $12;
 $vararg_ptr1 = $vararg_buffer + 4 | 0;
 HEAP32[$vararg_ptr1 >> 2] = $13;
 _mp_printf($8, 31320, $vararg_buffer) | 0;
 STACKTOP = sp;
 return;
}

function _mp_emit_common_get_id_for_modification($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = $3;
 $7 = _scope_find_or_add_id($5, $6, 1) | 0;
 $4 = $7;
 $8 = $2;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 >>> 0 >= 2;
 if (!$10) {
  STACKTOP = sp;
  return;
 }
 $11 = $4;
 $12 = HEAP8[$11 >> 0] | 0;
 $13 = $12 & 255;
 $14 = ($13 | 0) == 1;
 if (!$14) {
  STACKTOP = sp;
  return;
 }
 $15 = $4;
 HEAP8[$15 >> 0] = 3;
 STACKTOP = sp;
 return;
}

function _rgb565_getpixel($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $6 + 8 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $4;
 $10 = $5;
 $11 = $3;
 $12 = $11 + 16 | 0;
 $13 = HEAP16[$12 >> 1] | 0;
 $14 = $13 & 65535;
 $15 = Math_imul($10, $14) | 0;
 $16 = $9 + $15 | 0;
 $17 = $8 + ($16 << 1) | 0;
 $18 = HEAP16[$17 >> 1] | 0;
 $19 = $18 & 65535;
 STACKTOP = sp;
 return $19 | 0;
}

function _mp_obj_new_int_from_ull($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp;
 $4 = $2;
 $5 = $4;
 HEAP32[$5 >> 2] = $0;
 $6 = $4 + 4 | 0;
 $7 = $6;
 HEAP32[$7 >> 2] = $1;
 $8 = _mp_obj_int_new_mpz() | 0;
 $3 = $8;
 $9 = $3;
 $10 = $9 + 4 | 0;
 $11 = $2;
 $12 = $11;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $11 + 4 | 0;
 $15 = $14;
 $16 = HEAP32[$15 >> 2] | 0;
 _mpz_set_from_ll($10, $13, $16, 0);
 $17 = $3;
 STACKTOP = sp;
 return $17 | 0;
}

function _mp_emit_bc_subscr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = ($4 | 0) == 0;
 if ($5) {
  $6 = $2;
  _emit_bc_pre($6, -1);
  $7 = $2;
  _emit_write_bytecode_byte($7, 33);
  STACKTOP = sp;
  return;
 }
 $8 = $3;
 $9 = ($8 | 0) == 2;
 if ($9) {
  $10 = $2;
  _mp_emit_bc_load_null($10);
  $11 = $2;
  _mp_emit_bc_rot_three($11);
 }
 $12 = $2;
 _emit_bc_pre($12, -3);
 $13 = $2;
 _emit_write_bytecode_byte($13, 39);
 STACKTOP = sp;
 return;
}

function _mp_obj_new_int_from_ll($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp;
 $4 = $2;
 $5 = $4;
 HEAP32[$5 >> 2] = $0;
 $6 = $4 + 4 | 0;
 $7 = $6;
 HEAP32[$7 >> 2] = $1;
 $8 = _mp_obj_int_new_mpz() | 0;
 $3 = $8;
 $9 = $3;
 $10 = $9 + 4 | 0;
 $11 = $2;
 $12 = $11;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $11 + 4 | 0;
 $15 = $14;
 $16 = HEAP32[$15 >> 2] | 0;
 _mpz_set_from_ll($10, $13, $16, 1);
 $17 = $3;
 STACKTOP = sp;
 return $17 | 0;
}

function _object___new__($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp;
 $1 = $0;
 $3 = $1;
 $4 = _mp_obj_is_obj_1079($3) | 0;
 if ($4) {
  $5 = $1;
  $6 = HEAP32[$5 >> 2] | 0;
  $7 = ($6 | 0) == (19048 | 0);
  if ($7) {
   $8 = $1;
   $9 = $8 + 12 | 0;
   $10 = HEAP32[$9 >> 2] | 0;
   $11 = ($10 | 0) == (515 | 0);
   if ($11) {
    $12 = $1;
    $13 = _mp_obj_new_instance($12, $2) | 0;
    STACKTOP = sp;
    return $13 | 0;
   }
  }
 }
 _mp_raise_TypeError(31565);
 return 0 | 0;
}

function _mp_builtin_getattr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = 0;
 $5 = $2;
 $6 = $5 >>> 0 > 2;
 if ($6) {
  $7 = $3;
  $8 = $7 + 8 | 0;
  $9 = HEAP32[$8 >> 2] | 0;
  $4 = $9;
 }
 $10 = $3;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $3;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = _mp_obj_str_get_qstr($14) | 0;
 $16 = $4;
 $17 = _mp_load_attr_default($11, $15, $16) | 0;
 STACKTOP = sp;
 return $17 | 0;
}

function _mp_cmath_sin($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 8 | 0;
 $3 = sp;
 $1 = $0;
 $4 = $1;
 _mp_obj_get_complex($4, $2, $3);
 $5 = +HEAPF64[$2 >> 3];
 $6 = +_llvm_sin_f64(+$5);
 $7 = +HEAPF64[$3 >> 3];
 $8 = +_cosh($7);
 $9 = $6 * $8;
 $10 = +HEAPF64[$2 >> 3];
 $11 = +_llvm_cos_f64(+$10);
 $12 = +HEAPF64[$3 >> 3];
 $13 = +_sinh($12);
 $14 = $11 * $13;
 $15 = _mp_obj_new_complex($9, $14) | 0;
 STACKTOP = sp;
 return $15 | 0;
}

function _mp_obj_fun_bc_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $5;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = ($7 | 0) == (0 | 0);
 $9 = $4;
 $10 = ($9 | 0) == 23;
 $or$cond = $8 & $10;
 if (!$or$cond) {
  STACKTOP = sp;
  return;
 }
 $11 = $3;
 $12 = _mp_obj_fun_get_name($11) | 0;
 $13 = $12 << 2;
 $14 = $13 | 2;
 $15 = $14;
 $16 = $5;
 HEAP32[$16 >> 2] = $15;
 STACKTOP = sp;
 return;
}

function _mp_mpz_for_int($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $3;
 $7 = _mp_obj_is_small_int_1030($6) | 0;
 if ($7) {
  $8 = $4;
  $9 = $3;
  $10 = $9;
  $11 = $10 >> 1;
  _mpz_init_from_int($8, $11);
  $12 = $4;
  $2 = $12;
  $16 = $2;
  STACKTOP = sp;
  return $16 | 0;
 } else {
  $13 = $3;
  $5 = $13;
  $14 = $5;
  $15 = $14 + 4 | 0;
  $2 = $15;
  $16 = $2;
  STACKTOP = sp;
  return $16 | 0;
 }
 return 0 | 0;
}

function _mp_micropython_opt_level($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $3;
 $6 = ($5 | 0) == 0;
 if ($6) {
  $7 = HEAP32[40736 >> 2] | 0;
  $8 = $7 << 1;
  $9 = $8 | 1;
  $10 = $9;
  $2 = $10;
  $14 = $2;
  STACKTOP = sp;
  return $14 | 0;
 } else {
  $11 = $4;
  $12 = HEAP32[$11 >> 2] | 0;
  $13 = _mp_obj_get_int($12) | 0;
  HEAP32[40736 >> 2] = $13;
  $2 = 17668;
  $14 = $2;
  STACKTOP = sp;
  return $14 | 0;
 }
 return 0 | 0;
}

function _mp_obj_new_slice($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = _m_malloc(16) | 0;
 $6 = $7;
 $8 = $6;
 HEAP32[$8 >> 2] = 18228;
 $9 = $3;
 $10 = $6;
 $11 = $10 + 4 | 0;
 HEAP32[$11 >> 2] = $9;
 $12 = $4;
 $13 = $6;
 $14 = $13 + 8 | 0;
 HEAP32[$14 >> 2] = $12;
 $15 = $5;
 $16 = $6;
 $17 = $16 + 12 | 0;
 HEAP32[$17 >> 2] = $15;
 $18 = $6;
 STACKTOP = sp;
 return $18 | 0;
}

function _gs8_getpixel($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $6 + 8 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $4;
 $10 = $5;
 $11 = $3;
 $12 = $11 + 16 | 0;
 $13 = HEAP16[$12 >> 1] | 0;
 $14 = $13 & 65535;
 $15 = Math_imul($10, $14) | 0;
 $16 = $9 + $15 | 0;
 $17 = $8 + $16 | 0;
 $18 = HEAP8[$17 >> 0] | 0;
 $19 = $18 & 255;
 STACKTOP = sp;
 return $19 | 0;
}

function _mp_cmath_rect($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0.0, $18 = 0, $2 = 0, $3 = 0, $4 = 0.0, $5 = 0.0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = +_mp_obj_get_float($6);
 $4 = $7;
 $8 = $3;
 $9 = +_mp_obj_get_float($8);
 $5 = $9;
 $10 = $4;
 $11 = $5;
 $12 = +_llvm_cos_f64(+$11);
 $13 = $10 * $12;
 $14 = $4;
 $15 = $5;
 $16 = +_llvm_sin_f64(+$15);
 $17 = $14 * $16;
 $18 = _mp_obj_new_complex($13, $17) | 0;
 STACKTOP = sp;
 return $18 | 0;
}

function _mp_arg_check_num_1541($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1528($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1518($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1479($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1294($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1267($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1244($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1165($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1107($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1102($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1097($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1081($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1073($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1065($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_1013($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_977($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_973($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_958($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_904($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_882($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_862($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_arg_check_num_837($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _set_aligned_basic($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 switch ($6 | 0) {
 case 0:
  {
   $7 = $5;
   $8 = $7 & 255;
   $9 = $4;
   HEAP8[$9 >> 0] = $8;
   break;
  }
 case 2:
  {
   $10 = $5;
   $11 = $10 & 65535;
   $12 = $4;
   HEAP16[$12 >> 1] = $11;
   break;
  }
 case 4:
  {
   $13 = $5;
   $14 = $4;
   HEAP32[$14 >> 2] = $13;
   break;
  }
 default:
  {}
 }
 STACKTOP = sp;
 return;
}

function _mp_obj_int_get_checked($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = sp;
 $2 = $0;
 $5 = $2;
 $6 = _mp_obj_is_small_int_1030($5) | 0;
 $7 = $2;
 if ($6) {
  $8 = $7;
  $9 = $8 >> 1;
  $1 = $9;
  $14 = $1;
  STACKTOP = sp;
  return $14 | 0;
 }
 $3 = $7;
 $10 = $3;
 $11 = $10 + 4 | 0;
 $12 = _mpz_as_int_checked($11, $4) | 0;
 if (!$12) {
  _mp_raise_msg(15112, 31421);
 }
 $13 = HEAP32[$4 >> 2] | 0;
 $1 = $13;
 $14 = $1;
 STACKTOP = sp;
 return $14 | 0;
}

function _pop_arg_long_double($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0.0, $arglist_current = 0, $arglist_next = 0, $expanded = 0, $expanded1 = 0, $expanded3 = 0, $expanded4 = 0, $expanded5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $arglist_current = HEAP32[$1 >> 2] | 0;
 $2 = $arglist_current;
 $3 = 0 + 8 | 0;
 $expanded1 = $3;
 $expanded = $expanded1 - 1 | 0;
 $4 = $2 + $expanded | 0;
 $5 = 0 + 8 | 0;
 $expanded5 = $5;
 $expanded4 = $expanded5 - 1 | 0;
 $expanded3 = $expanded4 ^ -1;
 $6 = $4 & $expanded3;
 $7 = $6;
 $8 = +HEAPF64[$7 >> 3];
 $arglist_next = $7 + 8 | 0;
 HEAP32[$1 >> 2] = $arglist_next;
 HEAPF64[$0 >> 3] = $8;
 return;
}

function _mp_emit_bc_load_const_tok($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 _emit_bc_pre($4, 1);
 $5 = $3;
 switch ($5 | 0) {
 case 13:
  {
   $6 = $2;
   _emit_write_bytecode_byte($6, 16);
   break;
  }
 case 14:
  {
   $7 = $2;
   _emit_write_bytecode_byte($7, 17);
   break;
  }
 case 15:
  {
   $8 = $2;
   _emit_write_bytecode_byte($8, 18);
   break;
  }
 default:
  {
   $9 = $2;
   _emit_write_bytecode_byte_obj($9, 23, 18220);
  }
 }
 STACKTOP = sp;
 return;
}

function _utf8_ptr_to_index($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = 0;
 while (1) {
  $5 = $3;
  $6 = $2;
  $7 = $5 >>> 0 > $6 >>> 0;
  if (!$7) {
   break;
  }
  $8 = $3;
  $9 = $8 + -1 | 0;
  $3 = $9;
  $10 = HEAP8[$9 >> 0] | 0;
  $11 = $10 & 255;
  $12 = $11 & 192;
  $13 = ($12 | 0) == 128;
  if (!$13) {
   $14 = $4;
   $15 = $14 + 1 | 0;
   $4 = $15;
  }
 }
 $16 = $4;
 STACKTOP = sp;
 return $16 | 0;
}

function _mp_builtin_sorted($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $6 = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $8 = $7 >>> 0 > 1;
 if ($8) {
  _mp_raise_TypeError(33784);
 } else {
  $9 = HEAP32[17040 >> 2] | 0;
  $10 = $4;
  $11 = FUNCTION_TABLE_iiiii[$9 & 1023](17028, 1, 0, $10) | 0;
  HEAP32[$6 >> 2] = $11;
  $12 = $5;
  _mp_obj_list_sort(1, $6, $12) | 0;
  $13 = HEAP32[$6 >> 2] | 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0 | 0;
}

function _mp_arg_check_num($0, $1, $2, $3, $4) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 $4 = $4 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $20 = 0, $21 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = $0;
 $6 = $1;
 $7 = $2;
 $8 = $3;
 $10 = $4 & 1;
 $9 = $10;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 << 17;
 $15 = $8;
 $16 = $15 << 1;
 $17 = $14 | $16;
 $18 = $9;
 $19 = $18 & 1;
 $20 = $19 ? 1 : 0;
 $21 = $17 | $20;
 _mp_arg_check_num_sig($11, $12, $21);
 STACKTOP = sp;
 return;
}

function _mp_print_str($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $6 = _strlen($5) | 0;
 $4 = $6;
 $7 = $4;
 $8 = ($7 | 0) != 0;
 if (!$8) {
  $16 = $4;
  STACKTOP = sp;
  return $16 | 0;
 }
 $9 = $2;
 $10 = $9 + 4 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $2;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $3;
 $15 = $4;
 FUNCTION_TABLE_viii[$11 & 1023]($13, $14, $15);
 $16 = $4;
 STACKTOP = sp;
 return $16 | 0;
}

function _vstr_cut_tail_bytes($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = $2;
 $6 = $5 + 4 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $4 >>> 0 > $7 >>> 0;
 if ($8) {
  $9 = $2;
  $10 = $9 + 4 | 0;
  HEAP32[$10 >> 2] = 0;
  STACKTOP = sp;
  return;
 } else {
  $11 = $3;
  $12 = $2;
  $13 = $12 + 4 | 0;
  $14 = HEAP32[$13 >> 2] | 0;
  $15 = $14 - $11 | 0;
  HEAP32[$13 >> 2] = $15;
  STACKTOP = sp;
  return;
 }
}

function _mp_emit_bc_load_const_small_int($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 _emit_bc_pre($4, 1);
 $5 = $3;
 $6 = -16 <= ($5 | 0);
 $7 = $3;
 $8 = ($7 | 0) <= 47;
 $or$cond = $6 & $8;
 $9 = $2;
 $10 = $3;
 if ($or$cond) {
  $11 = 128 + $10 | 0;
  $12 = $11 & 255;
  _emit_write_bytecode_byte($9, $12);
  STACKTOP = sp;
  return;
 } else {
  _emit_write_bytecode_byte_int($9, 20, $10);
  STACKTOP = sp;
  return;
 }
}

function _stat_dir_or_file($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $5 = _vstr_null_terminated_str($4) | 0;
 $6 = _mp_import_stat_any($5) | 0;
 $3 = $6;
 $7 = $3;
 $8 = ($7 | 0) == 1;
 if ($8) {
  $9 = $3;
  $1 = $9;
  $13 = $1;
  STACKTOP = sp;
  return $13 | 0;
 } else {
  $10 = $2;
  _vstr_add_str($10, 33579);
  $11 = $2;
  $12 = _stat_file_py_or_mpy($11) | 0;
  $1 = $12;
  $13 = $1;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0 | 0;
}

function _sbrk(increment) {
 increment = increment | 0;
 var oldDynamicTop = 0, oldDynamicTopOnChange = 0, newDynamicTop = 0, totalMemory = 0;
 totalMemory = _emscripten_get_heap_size() | 0;
 oldDynamicTop = HEAP32[DYNAMICTOP_PTR >> 2] | 0;
 newDynamicTop = oldDynamicTop + increment | 0;
 if ((increment | 0) > 0 & (newDynamicTop | 0) < (oldDynamicTop | 0) | (newDynamicTop | 0) < 0) {
  abortOnCannotGrowMemory(newDynamicTop | 0) | 0;
  ___setErrNo(12);
  return -1;
 }
 if ((newDynamicTop | 0) > (totalMemory | 0)) {
  if (_emscripten_resize_heap(newDynamicTop | 0) | 0) {} else {
   ___setErrNo(12);
   return -1;
  }
 }
 HEAP32[DYNAMICTOP_PTR >> 2] = newDynamicTop | 0;
 return oldDynamicTop | 0;
}

function _mp_load_build_class() {
 var $0 = 0, $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = HEAP32[40684 >> 2] | 0;
 $3 = ($2 | 0) != (0 | 0);
 if ($3) {
  $4 = HEAP32[40684 >> 2] | 0;
  $5 = $4 + 4 | 0;
  $6 = _mp_map_lookup($5, 698, 0) | 0;
  $1 = $6;
  $7 = $1;
  $8 = ($7 | 0) != (0 | 0);
  if ($8) {
   $9 = $1;
   $10 = $9 + 4 | 0;
   $11 = HEAP32[$10 >> 2] | 0;
   $0 = $11;
   $12 = $0;
   STACKTOP = sp;
   return $12 | 0;
  }
 }
 $0 = 19640;
 $12 = $0;
 STACKTOP = sp;
 return $12 | 0;
}

function _compile_syntax_error($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $6 + 8 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) == (0 | 0);
 if (!$9) {
  STACKTOP = sp;
  return;
 }
 $10 = $5;
 $11 = _mp_obj_new_exception_msg(15892, $10) | 0;
 $12 = $3;
 $13 = $12 + 8 | 0;
 HEAP32[$13 >> 2] = $11;
 $14 = $3;
 $15 = $4;
 _compile_error_set_line($14, $15);
 STACKTOP = sp;
 return;
}
function _compile_dotted_as_name($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = sp;
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = $5 + 40 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 _mp_emit_bc_load_const_small_int($7, 0);
 $8 = $2;
 $9 = $8 + 40 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 _mp_emit_bc_load_const_tok($10, 14);
 $11 = $2;
 $12 = $3;
 _do_import_name($11, $12, $4);
 $13 = $2;
 $14 = HEAP32[$4 >> 2] | 0;
 _compile_store_id($13, $14);
 STACKTOP = sp;
 return;
}

function _bound_meth_call($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $19 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $4;
 $8 = $9;
 $10 = $8;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $8;
 $14 = $13 + 8 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $16 = $5;
 $17 = $6;
 $18 = $7;
 $19 = _mp_call_method_self_n_kw($12, $15, $16, $17, $18) | 0;
 STACKTOP = sp;
 return $19 | 0;
}

function _vstr_init_fixed_buf($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $4;
 $7 = $3;
 HEAP32[$7 >> 2] = $6;
 $8 = $3;
 $9 = $8 + 4 | 0;
 HEAP32[$9 >> 2] = 0;
 $10 = $5;
 $11 = $3;
 $12 = $11 + 8 | 0;
 HEAP32[$12 >> 2] = $10;
 $13 = $3;
 $14 = $13 + 12 | 0;
 $15 = HEAP8[$14 >> 0] | 0;
 $16 = $15 & -2;
 $17 = $16 | 1;
 HEAP8[$14 >> 0] = $17;
 STACKTOP = sp;
 return;
}

function _mp_math_modf($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0.0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 8 | 0;
 $4 = sp + 16 | 0;
 $1 = $0;
 HEAPF64[$2 >> 3] = 0.0;
 $5 = $1;
 $6 = +_mp_obj_get_float($5);
 $7 = +_modf($6, $2);
 $3 = $7;
 $8 = $3;
 $9 = _mp_obj_new_float($8) | 0;
 HEAP32[$4 >> 2] = $9;
 $10 = +HEAPF64[$2 >> 3];
 $11 = _mp_obj_new_float($10) | 0;
 $12 = $4 + 4 | 0;
 HEAP32[$12 >> 2] = $11;
 $13 = _mp_obj_new_tuple(2, $4) | 0;
 STACKTOP = sp;
 return $13 | 0;
}

function _make_node_const_object($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $8 = _parser_alloc($7, 12) | 0;
 $6 = $8;
 $9 = $4;
 $10 = $6;
 HEAP32[$10 >> 2] = $9;
 $11 = $6;
 $12 = $11 + 4 | 0;
 HEAP32[$12 >> 2] = 313;
 $13 = $5;
 $14 = $13;
 $15 = $6;
 $16 = $15 + 8 | 0;
 HEAP32[$16 >> 2] = $14;
 $17 = $6;
 $18 = $17;
 STACKTOP = sp;
 return $18 | 0;
}

function _property_deleter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = _m_malloc(16) | 0;
 $4 = $5;
 $6 = $4;
 $7 = $2;
 HEAP32[$6 >> 2] = HEAP32[$7 >> 2] | 0;
 HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2] | 0;
 HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2] | 0;
 HEAP32[$6 + 12 >> 2] = HEAP32[$7 + 12 >> 2] | 0;
 $8 = $3;
 $9 = $4;
 $10 = $9 + 4 | 0;
 $11 = $10 + 8 | 0;
 HEAP32[$11 >> 2] = $8;
 $12 = $4;
 STACKTOP = sp;
 return $12 | 0;
}

function _mp_stream_close($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = sp + 4 | 0;
 $1 = $0;
 $5 = $1;
 $6 = _mp_get_stream($5) | 0;
 $2 = $6;
 $7 = $2;
 $8 = $7 + 8 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $1;
 $11 = FUNCTION_TABLE_iiiii[$9 & 1023]($10, 4, 0, $3) | 0;
 $4 = $11;
 $12 = $4;
 $13 = ($12 | 0) == -1;
 if ($13) {
  $14 = HEAP32[$3 >> 2] | 0;
  _mp_raise_OSError($14);
 } else {
  STACKTOP = sp;
  return 17668 | 0;
 }
 return 0 | 0;
}

function _mp_make_raise_obj($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $2;
 $4 = _mp_obj_is_exception_type($3) | 0;
 $5 = $2;
 do {
  if ($4) {
   $6 = _mp_call_function_n_kw($5, 0, 0, 0) | 0;
   $1 = $6;
  } else {
   $7 = _mp_obj_is_exception_instance($5) | 0;
   if ($7) {
    $8 = $2;
    $1 = $8;
    break;
   } else {
    $9 = _mp_obj_new_exception_msg(16012, 29904) | 0;
    $1 = $9;
    break;
   }
  }
 } while (0);
 $10 = $1;
 STACKTOP = sp;
 return $10 | 0;
}

function _do_load_from_lexer($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = HEAP32[$6 >> 2] | 0;
 $4 = $7;
 $8 = $2;
 $9 = $4;
 $10 = $9 << 2;
 $11 = $10 | 2;
 $12 = $11;
 _mp_store_attr($8, 180, $12);
 $13 = $2;
 $14 = _mp_obj_module_get_globals_1357($13) | 0;
 $5 = $14;
 $15 = $3;
 $16 = $5;
 $17 = $5;
 _mp_parse_compile_execute($15, 1, $16, $17) | 0;
 STACKTOP = sp;
 return;
}

function _property_setter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = _m_malloc(16) | 0;
 $4 = $5;
 $6 = $4;
 $7 = $2;
 HEAP32[$6 >> 2] = HEAP32[$7 >> 2] | 0;
 HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2] | 0;
 HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2] | 0;
 HEAP32[$6 + 12 >> 2] = HEAP32[$7 + 12 >> 2] | 0;
 $8 = $3;
 $9 = $4;
 $10 = $9 + 4 | 0;
 $11 = $10 + 4 | 0;
 HEAP32[$11 >> 2] = $8;
 $12 = $4;
 STACKTOP = sp;
 return $12 | 0;
}

function _mp_math_frexp($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0.0, $7 = 0.0, $8 = 0.0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 16 | 0;
 $4 = sp + 8 | 0;
 $1 = $0;
 HEAP32[$2 >> 2] = 0;
 $5 = $1;
 $6 = +_mp_obj_get_float($5);
 $7 = +_frexp($6, $2);
 $3 = $7;
 $8 = $3;
 $9 = _mp_obj_new_float($8) | 0;
 HEAP32[$4 >> 2] = $9;
 $10 = HEAP32[$2 >> 2] | 0;
 $11 = _mp_obj_new_int($10) | 0;
 $12 = $4 + 4 | 0;
 HEAP32[$12 >> 2] = $11;
 $13 = _mp_obj_new_tuple(2, $4) | 0;
 STACKTOP = sp;
 return $13 | 0;
}

function _mod_urandom_choice($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _mp_obj_len($3) | 0;
 $5 = _mp_obj_get_int($4) | 0;
 $2 = $5;
 $6 = $2;
 $7 = ($6 | 0) > 0;
 if ($7) {
  $8 = $1;
  $9 = $2;
  $10 = _yasmarang_randbelow($9) | 0;
  $11 = _mp_obj_new_int($10) | 0;
  $12 = _mp_obj_subscr($8, $11, 4) | 0;
  STACKTOP = sp;
  return $12 | 0;
 } else {
  $13 = _mp_obj_new_exception(15532) | 0;
  _nlr_jump($13);
 }
 return 0 | 0;
}

function _mp_emit_bc_load_method($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $2 & 1;
 $5 = $6;
 $7 = $3;
 $8 = $5;
 $9 = $8 & 1;
 $10 = $9 & 1;
 $11 = $10 << 1;
 $12 = 1 - $11 | 0;
 _emit_bc_pre($7, $12);
 $13 = $3;
 $14 = $5;
 $15 = $14 & 1;
 $16 = $15 ? 31 : 30;
 $17 = $16 & 255;
 $18 = $4;
 _emit_write_bytecode_byte_qstr($13, $17, $18);
 STACKTOP = sp;
 return;
}

function _stream_flush($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = sp + 4 | 0;
 $1 = $0;
 $5 = $1;
 $6 = _mp_get_stream($5) | 0;
 $2 = $6;
 $7 = $2;
 $8 = $7 + 8 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $1;
 $11 = FUNCTION_TABLE_iiiii[$9 & 1023]($10, 1, 0, $3) | 0;
 $4 = $11;
 $12 = $4;
 $13 = ($12 | 0) == -1;
 if ($13) {
  $14 = HEAP32[$3 >> 2] | 0;
  _mp_raise_OSError($14);
 } else {
  STACKTOP = sp;
  return 17668 | 0;
 }
 return 0 | 0;
}

function _mp_obj_attrtuple_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $8 = $4;
 $6 = $8;
 $9 = $6;
 $10 = $9 + 8 | 0;
 $11 = $6;
 $12 = $11 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $10 + ($13 << 2) | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 $7 = $15;
 $16 = $3;
 $17 = $7;
 $18 = $6;
 _mp_obj_attrtuple_print_helper($16, $17, $18);
 STACKTOP = sp;
 return;
}

function _mp_obj_new_list_iterator($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $5;
 $6 = $7;
 $8 = $6;
 HEAP32[$8 >> 2] = 17448;
 $9 = $6;
 $10 = $9 + 4 | 0;
 HEAP32[$10 >> 2] = 514;
 $11 = $3;
 $12 = $6;
 $13 = $12 + 8 | 0;
 HEAP32[$13 >> 2] = $11;
 $14 = $4;
 $15 = $6;
 $16 = $15 + 12 | 0;
 HEAP32[$16 >> 2] = $14;
 $17 = $6;
 STACKTOP = sp;
 return $17 | 0;
}

function _mp_hal_stdout_tx_strn_cooked($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 while (1) {
  $4 = $3;
  $5 = $4 + -1 | 0;
  $3 = $5;
  $6 = ($4 | 0) != 0;
  if (!$6) {
   break;
  }
  $7 = $2;
  $8 = HEAP8[$7 >> 0] | 0;
  $9 = $8 << 24 >> 24;
  $10 = ($9 | 0) == 10;
  if ($10) {
   _mp_hal_stdout_tx_strn(35020, 1);
  }
  $11 = $2;
  $12 = $11 + 1 | 0;
  $2 = $12;
  _mp_hal_stdout_tx_strn($11, 1);
 }
 STACKTOP = sp;
 return;
}

function _mpz_neg_inpl($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = ($4 | 0) != ($5 | 0);
 if ($6) {
  $7 = $2;
  $8 = $3;
  _mpz_set($7, $8);
 }
 $9 = $2;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $10 & 1;
 $12 = 1 - $11 | 0;
 $13 = $2;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $12 & 1;
 $16 = $14 & -2;
 $17 = $16 | $15;
 HEAP32[$13 >> 2] = $17;
 STACKTOP = sp;
 return;
}

function _set_symmetric_difference_update($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $7 = $2;
 $4 = $7;
 $8 = $3;
 $9 = _mp_getiter($8, 0) | 0;
 $5 = $9;
 while (1) {
  $10 = $5;
  $11 = _mp_iternext($10) | 0;
  $6 = $11;
  $12 = ($11 | 0) != (0 | 0);
  if (!$12) {
   break;
  }
  $13 = $4;
  $14 = $13 + 4 | 0;
  $15 = $6;
  _mp_set_lookup($14, $15, 3) | 0;
 }
 STACKTOP = sp;
 return 17668 | 0;
}

function _mp_sched_unlock() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $0 = 0;
 $1 = HEAP16[40740 >> 1] | 0;
 $2 = $1 + 1 << 16 >> 16;
 HEAP16[40740 >> 1] = $2;
 $3 = $2 << 16 >> 16;
 $4 = ($3 | 0) == 0;
 if (!$4) {
  STACKTOP = sp;
  return;
 }
 $5 = HEAP32[40624 >> 2] | 0;
 $6 = ($5 | 0) != (0 | 0);
 if (!$6) {
  $7 = _mp_sched_num_pending() | 0;
  $8 = ($7 | 0) != 0;
  if (!$8) {
   HEAP16[40740 >> 1] = 1;
   STACKTOP = sp;
   return;
  }
 }
 HEAP16[40740 >> 1] = 0;
 STACKTOP = sp;
 return;
}

function _set_update($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = 1;
 while (1) {
  $5 = $4;
  $6 = $2;
  $7 = $5 >>> 0 < $6 >>> 0;
  if (!$7) {
   break;
  }
  $8 = $3;
  $9 = HEAP32[$8 >> 2] | 0;
  $10 = $3;
  $11 = $4;
  $12 = $10 + ($11 << 2) | 0;
  $13 = HEAP32[$12 >> 2] | 0;
  _set_update_int($9, $13);
  $14 = $4;
  $15 = $14 + 1 | 0;
  $4 = $15;
 }
 STACKTOP = sp;
 return 17668 | 0;
}

function _mpz_init_zero($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = HEAP32[$2 >> 2] | 0;
 $4 = $3 & -2;
 HEAP32[$2 >> 2] = $4;
 $5 = $1;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $6 & -3;
 HEAP32[$5 >> 2] = $7;
 $8 = $1;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 & 3;
 HEAP32[$8 >> 2] = $10;
 $11 = $1;
 $12 = $11 + 4 | 0;
 HEAP32[$12 >> 2] = 0;
 $13 = $1;
 $14 = $13 + 8 | 0;
 HEAP32[$14 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _mod_urandom_uniform($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0.0, $11 = 0.0, $12 = 0.0, $13 = 0.0, $14 = 0.0, $15 = 0.0, $16 = 0.0, $17 = 0, $2 = 0, $3 = 0, $4 = 0.0, $5 = 0.0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = +_mp_obj_get_float($6);
 $4 = $7;
 $8 = $3;
 $9 = +_mp_obj_get_float($8);
 $5 = $9;
 $10 = $4;
 $11 = $5;
 $12 = $4;
 $13 = $11 - $12;
 $14 = +_yasmarang_float();
 $15 = $13 * $14;
 $16 = $10 + $15;
 $17 = _mp_obj_new_float($16) | 0;
 STACKTOP = sp;
 return $17 | 0;
}

function _fun_builtin_1_call($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $4;
 $8 = $9;
 $10 = $5;
 $11 = $6;
 _mp_arg_check_num_977($10, $11, 1, 1, 0);
 $12 = $8;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $7;
 $16 = HEAP32[$15 >> 2] | 0;
 $17 = FUNCTION_TABLE_ii[$14 & 1023]($16) | 0;
 STACKTOP = sp;
 return $17 | 0;
}

function _re1_5_sizecode($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = sp;
 $2 = $0;
 HEAP32[$3 >> 2] = HEAP32[21292 >> 2] | 0;
 HEAP32[$3 + 4 >> 2] = HEAP32[21292 + 4 >> 2] | 0;
 HEAP32[$3 + 8 >> 2] = HEAP32[21292 + 8 >> 2] | 0;
 $4 = $2;
 $5 = __compilecode($4, $3, 1) | 0;
 $6 = ($5 | 0) == (0 | 0);
 if ($6) {
  $1 = -1;
  $8 = $1;
  STACKTOP = sp;
  return $8 | 0;
 } else {
  $7 = HEAP32[$3 >> 2] | 0;
  $1 = $7;
  $8 = $1;
  STACKTOP = sp;
  return $8 | 0;
 }
 return 0 | 0;
}

function _compile_async_with_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = sp + 4 | 0;
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = $6 + 8 | 0;
 $8 = _mp_parse_node_extract_list($7, 121, $4) | 0;
 $5 = $8;
 $9 = $2;
 $10 = $5;
 $11 = HEAP32[$4 >> 2] | 0;
 $12 = $3;
 $13 = $12 + 8 | 0;
 $14 = $13 + 4 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 _compile_async_with_stmt_helper($9, $10, $11, $15);
 STACKTOP = sp;
 return;
}

function _mp_obj_len($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $vararg_buffer = sp;
 $1 = $0;
 $3 = $1;
 $4 = _mp_obj_len_maybe($3) | 0;
 $2 = $4;
 $5 = $2;
 $6 = ($5 | 0) == (0 | 0);
 if ($6) {
  $7 = $1;
  $8 = _mp_obj_get_type_str($7) | 0;
  HEAP32[$vararg_buffer >> 2] = $8;
  $9 = _mp_obj_new_exception_msg_varg(16012, 30569, $vararg_buffer) | 0;
  _nlr_jump($9);
 } else {
  $10 = $2;
  STACKTOP = sp;
  return $10 | 0;
 }
 return 0 | 0;
}

function _saveSetjmp(env, label, table, size) {
 env = env | 0;
 label = label | 0;
 table = table | 0;
 size = size | 0;
 var i = 0;
 setjmpId = setjmpId + 1 | 0;
 HEAP32[env >> 2] = setjmpId;
 while ((i | 0) < (size | 0)) {
  if ((HEAP32[table + (i << 3) >> 2] | 0) == 0) {
   HEAP32[table + (i << 3) >> 2] = setjmpId;
   HEAP32[table + ((i << 3) + 4) >> 2] = label;
   HEAP32[table + ((i << 3) + 8) >> 2] = 0;
   setTempRet0(size | 0);
   return table | 0;
  }
  i = i + 1 | 0;
 }
 size = size * 2 | 0;
 table = _realloc(table | 0, 8 * (size + 1 | 0) | 0) | 0;
 table = _saveSetjmp(env | 0, label | 0, table | 0, size | 0) | 0;
 setTempRet0(size | 0);
 return table | 0;
}

function _set_unaligned($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp + 8 | 0;
 $4 = $0;
 HEAP32[$5 >> 2] = $1;
 $6 = $2;
 $7 = $3;
 $9 = $6;
 $10 = ($9 | 0) != 0;
 $11 = $10 ? 62 : 60;
 $12 = $11 & 255;
 $8 = $12;
 $13 = $8;
 $14 = $4;
 $15 = 7392 + $14 | 0;
 $16 = HEAP8[$15 >> 0] | 0;
 $17 = $7;
 _mp_binary_set_val($13, $16, $17, $5);
 STACKTOP = sp;
 return;
}

function _bytes_decode($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = sp;
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = ($5 | 0) == 1;
 if ($6) {
  $7 = $3;
  $8 = HEAP32[$7 >> 2] | 0;
  HEAP32[$4 >> 2] = $8;
  $9 = $4 + 4 | 0;
  HEAP32[$9 >> 2] = 646;
  $3 = $4;
  $10 = $2;
  $11 = $10 + 1 | 0;
  $2 = $11;
 }
 $12 = $2;
 $13 = $3;
 $14 = _mp_obj_str_make_new(18680, $12, 0, $13) | 0;
 STACKTOP = sp;
 return $14 | 0;
}

function _arg_as_int($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $2;
 $4 = _mp_obj_is_obj_1154($3) | 0;
 if ($4) {
  $5 = $2;
  $6 = HEAP32[$5 >> 2] | 0;
  $7 = ($6 | 0) == (16252 | 0);
  if ($7) {
   $8 = $2;
   $9 = +_mp_obj_float_get($8);
   $10 = _mp_obj_new_int_from_float($9) | 0;
   $1 = $10;
   $12 = $1;
   STACKTOP = sp;
   return $12 | 0;
  }
 }
 $11 = $2;
 $1 = $11;
 $12 = $1;
 STACKTOP = sp;
 return $12 | 0;
}

function _setpixel($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $8 = $4;
 $9 = $8 + 18 | 0;
 $10 = HEAP8[$9 >> 0] | 0;
 $11 = $10 & 255;
 $12 = 9376 + ($11 * 12 | 0) | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $4;
 $15 = $5;
 $16 = $6;
 $17 = $7;
 FUNCTION_TABLE_viiii[$13 & 1023]($14, $15, $16, $17);
 STACKTOP = sp;
 return;
}

function _property_getter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = _m_malloc(16) | 0;
 $4 = $5;
 $6 = $4;
 $7 = $2;
 HEAP32[$6 >> 2] = HEAP32[$7 >> 2] | 0;
 HEAP32[$6 + 4 >> 2] = HEAP32[$7 + 4 >> 2] | 0;
 HEAP32[$6 + 8 >> 2] = HEAP32[$7 + 8 >> 2] | 0;
 HEAP32[$6 + 12 >> 2] = HEAP32[$7 + 12 >> 2] | 0;
 $8 = $3;
 $9 = $4;
 $10 = $9 + 4 | 0;
 HEAP32[$10 >> 2] = $8;
 $11 = $4;
 STACKTOP = sp;
 return $11 | 0;
}

function _compile_with_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = sp + 4 | 0;
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = $6 + 8 | 0;
 $8 = _mp_parse_node_extract_list($7, 121, $4) | 0;
 $5 = $8;
 $9 = $2;
 $10 = $5;
 $11 = HEAP32[$4 >> 2] | 0;
 $12 = $3;
 $13 = $12 + 8 | 0;
 $14 = $13 + 4 | 0;
 $15 = HEAP32[$14 >> 2] | 0;
 _compile_with_stmt_helper($9, $10, $11, $15);
 STACKTOP = sp;
 return;
}

function _mp_obj_int_to_bytes_impl($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $9 = $1 & 1;
 $5 = $9;
 $6 = $2;
 $7 = $3;
 $10 = $4;
 $8 = $10;
 $11 = $7;
 $12 = $6;
 _memset($11 | 0, 0, $12 | 0) | 0;
 $13 = $8;
 $14 = $13 + 4 | 0;
 $15 = $5;
 $16 = $15 & 1;
 $17 = $6;
 $18 = $7;
 _mpz_as_bytes($14, $16, $17, $18);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_build($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $5;
 $7 = ($6 | 0) == 3;
 $8 = $3;
 if ($7) {
  _emit_bc_pre($8, 1);
 } else {
  $9 = $4;
  $10 = 1 - $9 | 0;
  _emit_bc_pre($8, $10);
 }
 $11 = $3;
 $12 = $5;
 $13 = 80 + $12 | 0;
 $14 = $13 & 255;
 $15 = $4;
 _emit_write_bytecode_byte_uint($11, $14, $15);
 STACKTOP = sp;
 return;
}

function _mp_load_super_method($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = sp;
 $2 = $0;
 $3 = $1;
 HEAP32[$4 >> 2] = 19180;
 $5 = $4 + 4 | 0;
 $6 = $3;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 HEAP32[$5 >> 2] = $8;
 $9 = $4 + 8 | 0;
 $10 = $3;
 $11 = $10 + 8 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 HEAP32[$9 >> 2] = $12;
 $13 = $2;
 $14 = $3;
 _mp_load_method($4, $13, $14);
 STACKTOP = sp;
 return;
}

function _mod_uheapq_heapify($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $4 = $1;
 $5 = _get_heap($4) | 0;
 $2 = $5;
 $6 = $2;
 $7 = $6 + 8 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 >>> 0) / 2 & -1;
 $3 = $9;
 while (1) {
  $10 = $3;
  $11 = $10 >>> 0 > 0;
  if (!$11) {
   break;
  }
  $12 = $2;
  $13 = $3;
  $14 = $13 + -1 | 0;
  $3 = $14;
  _heap_siftup($12, $14);
 }
 STACKTOP = sp;
 return 17668 | 0;
}

function _fun_bc_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, $vararg_ptr1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $6 = $7;
 $8 = $3;
 $9 = $4;
 $10 = _mp_obj_fun_get_name($9) | 0;
 $11 = $6;
 HEAP32[$vararg_buffer >> 2] = $10;
 $vararg_ptr1 = $vararg_buffer + 4 | 0;
 HEAP32[$vararg_ptr1 >> 2] = $11;
 _mp_printf($8, 31110, $vararg_buffer) | 0;
 STACKTOP = sp;
 return;
}

function _mp_obj_new_str_of_type($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $4;
 $8 = ($7 | 0) == (18680 | 0);
 $9 = $5;
 $10 = $6;
 if ($8) {
  $11 = _mp_obj_new_str($9, $10) | 0;
  $3 = $11;
  $13 = $3;
  STACKTOP = sp;
  return $13 | 0;
 } else {
  $12 = _mp_obj_new_bytes($9, $10) | 0;
  $3 = $12;
  $13 = $3;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0 | 0;
}

function _mp_init() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 _qstr_init();
 HEAP32[40624 >> 2] = 0;
 HEAP16[40740 >> 1] = 1;
 HEAP8[40743 >> 0] = 0;
 HEAP8[40742 >> 0] = 0;
 HEAP32[40592 >> 2] = 14932;
 $0 = HEAP32[40596 >> 2] | 0;
 $1 = $0 & -65536;
 HEAP32[40596 >> 2] = $1;
 $2 = HEAP32[40596 >> 2] | 0;
 $3 = $2 & 65535;
 HEAP32[40596 >> 2] = $3;
 HEAP32[40600 >> 2] = 0;
 HEAP32[40604 >> 2] = 18944;
 HEAP32[40736 >> 2] = 0;
 _mp_obj_dict_init(40608, 3);
 _mp_obj_dict_init(40636, 1);
 _mp_obj_dict_store(40636, 94, 86) | 0;
 _mp_locals_set(40636);
 _mp_globals_set(40636);
 HEAP32[40684 >> 2] = 0;
 return;
}

function _mp_obj_get_float($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0.0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $vararg_buffer = sp + 8 | 0;
 $2 = sp;
 $1 = $0;
 $3 = $1;
 $4 = _mp_obj_get_float_maybe($3, $2) | 0;
 if ($4) {
  $8 = +HEAPF64[$2 >> 3];
  STACKTOP = sp;
  return +$8;
 } else {
  $5 = $1;
  $6 = _mp_obj_get_type_str($5) | 0;
  HEAP32[$vararg_buffer >> 2] = $6;
  $7 = _mp_obj_new_exception_msg_varg(16012, 30423, $vararg_buffer) | 0;
  _nlr_jump($7);
 }
 return +(0.0);
}

function _mp_map_deinit($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = HEAP32[$2 >> 2] | 0;
 $4 = $3 >>> 1;
 $5 = $4 & 1;
 $6 = ($5 | 0) != 0;
 if (!$6) {
  $7 = $1;
  $8 = $7 + 8 | 0;
  $9 = HEAP32[$8 >> 2] | 0;
  _m_free($9);
 }
 $10 = $1;
 $11 = $10 + 4 | 0;
 HEAP32[$11 >> 2] = 0;
 $12 = $1;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $13 & 7;
 HEAP32[$12 >> 2] = $14;
 STACKTOP = sp;
 return;
}

function _mp_errno_to_str($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $5 = _mp_map_lookup(20884, $4, 0) | 0;
 $3 = $5;
 $6 = $3;
 $7 = ($6 | 0) == (0 | 0);
 if ($7) {
  $1 = 0;
  $13 = $1;
  STACKTOP = sp;
  return $13 | 0;
 } else {
  $8 = $3;
  $9 = $8 + 4 | 0;
  $10 = HEAP32[$9 >> 2] | 0;
  $11 = $10;
  $12 = $11 >>> 2;
  $1 = $12;
  $13 = $1;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0 | 0;
}

function _str_encode($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = sp;
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = ($5 | 0) == 1;
 if ($6) {
  $7 = $3;
  $8 = HEAP32[$7 >> 2] | 0;
  HEAP32[$4 >> 2] = $8;
  $9 = $4 + 4 | 0;
  HEAP32[$9 >> 2] = 646;
  $3 = $4;
  $10 = $2;
  $11 = $10 + 1 | 0;
  $2 = $11;
 }
 $12 = $2;
 $13 = $3;
 $14 = _bytes_make_new(0, $12, 0, $13) | 0;
 STACKTOP = sp;
 return $14 | 0;
}

function _range_getiter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $4 = $5;
 $6 = $4;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $4;
 $10 = $9 + 8 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $4;
 $13 = $12 + 12 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $3;
 $16 = _mp_obj_new_range_iterator($8, $11, $14, $15) | 0;
 STACKTOP = sp;
 return $16 | 0;
}

function _getpixel($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $6 + 18 | 0;
 $8 = HEAP8[$7 >> 0] | 0;
 $9 = $8 & 255;
 $10 = 9376 + ($9 * 12 | 0) | 0;
 $11 = $10 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $3;
 $14 = $4;
 $15 = $5;
 $16 = FUNCTION_TABLE_iiii[$12 & 1023]($13, $14, $15) | 0;
 STACKTOP = sp;
 return $16 | 0;
}

function _is_following_base_char($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = $3 + 20 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 $6 = $5 | 32;
 $2 = $6;
 $7 = $2;
 $8 = ($7 | 0) == 98;
 $9 = $2;
 $10 = ($9 | 0) == 111;
 $or$cond = $8 | $10;
 if ($or$cond) {
  $13 = 1;
  STACKTOP = sp;
  return $13 | 0;
 }
 $11 = $2;
 $12 = ($11 | 0) == 120;
 $13 = $12;
 STACKTOP = sp;
 return $13 | 0;
}

function _mp_builtin_issubclass($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = _mp_obj_is_obj_1260($4) | 0;
 if (!$5) {
  _mp_raise_TypeError(33330);
 }
 $6 = $2;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = ($7 | 0) == (19048 | 0);
 if ($8) {
  $9 = $2;
  $10 = $3;
  $11 = _mp_obj_is_subclass($9, $10) | 0;
  STACKTOP = sp;
  return $11 | 0;
 } else {
  _mp_raise_TypeError(33330);
 }
 return 0 | 0;
}

function _mp_builtin___repl_print__($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp;
 $1 = $0;
 $3 = $1;
 $4 = ($3 | 0) != (17668 | 0);
 if (!$4) {
  STACKTOP = sp;
  return 17668 | 0;
 }
 $5 = $1;
 _mp_obj_print_helper(13344, $5, 1);
 _mp_print_str(13344, 34812) | 0;
 HEAP32[$2 >> 2] = 4;
 $6 = $2 + 4 | 0;
 $7 = $1;
 HEAP32[$6 >> 2] = $7;
 $8 = HEAP32[17292 >> 2] | 0;
 FUNCTION_TABLE_viii[$8 & 1023](19836, 8, $2);
 STACKTOP = sp;
 return 17668 | 0;
}

function _bool_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $18 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $6 = $7;
 $8 = $3;
 $9 = $6;
 $10 = $9 + 4 | 0;
 $11 = HEAP8[$10 >> 0] | 0;
 $12 = $11 & 1;
 $13 = $12 & 1;
 $14 = $13 << 1;
 $15 = $14 | 1;
 $16 = $15;
 $17 = $5;
 $18 = _mp_binary_op($8, $16, $17) | 0;
 STACKTOP = sp;
 return $18 | 0;
}

function _mp_compile($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $9 = $3 & 1;
 $7 = $9;
 $10 = $4;
 $11 = $5;
 $12 = $6;
 $13 = $7;
 $14 = $13 & 1;
 $15 = _mp_compile_to_raw_code($10, $11, $12, $14) | 0;
 $8 = $15;
 $16 = $8;
 $17 = _mp_make_function_from_raw_code($16, 0, 0) | 0;
 STACKTOP = sp;
 return $17 | 0;
}

function _bound_meth_attr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $5;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = ($8 | 0) != (0 | 0);
 if ($9) {
  STACKTOP = sp;
  return;
 }
 $10 = $3;
 $6 = $10;
 $11 = $6;
 $12 = $11 + 4 | 0;
 $13 = HEAP32[$12 >> 2] | 0;
 $14 = $4;
 $15 = $5;
 _mp_load_method_maybe($13, $14, $15);
 STACKTOP = sp;
 return;
}

function _readline_init($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 HEAP32[10405] = $4;
 $5 = $2;
 $6 = $5 + 4 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 HEAP32[10406] = $7;
 HEAP32[10407] = 0;
 HEAP8[41644] = 0;
 HEAP32[10408] = -1;
 $8 = HEAP32[10406] | 0;
 HEAP32[10409] = $8;
 $9 = $3;
 HEAP32[10410] = $9;
 $10 = $3;
 _mp_hal_stdout_tx_str($10);
 _readline_auto_indent();
 STACKTOP = sp;
 return;
}

function _mp_math_isfinite($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = +_mp_obj_get_float($2);
 $4 = ___DOUBLE_BITS_1412($3) | 0;
 $5 = getTempRet0() | 0;
 $6 = $5 & 2147483647;
 $7 = $6 >>> 0 < 2146435072;
 $8 = $4 >>> 0 < 0;
 $9 = ($6 | 0) == 2146435072;
 $10 = $9 & $8;
 $11 = $7 | $10;
 $12 = $11 & 1;
 $13 = _mp_obj_new_bool_1414($12) | 0;
 STACKTOP = sp;
 return $13 | 0;
}

function _is_head_of_identifier($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _is_letter($2) | 0;
 if ($3) {
  $12 = 1;
 } else {
  $4 = $1;
  $5 = $4 + 16 | 0;
  $6 = HEAP32[$5 >> 2] | 0;
  $7 = ($6 | 0) == 95;
  if ($7) {
   $12 = 1;
  } else {
   $8 = $1;
   $9 = $8 + 16 | 0;
   $10 = HEAP32[$9 >> 2] | 0;
   $11 = $10 >>> 0 >= 128;
   $12 = $11;
  }
 }
 STACKTOP = sp;
 return $12 | 0;
}

function _mp_emit_bc_unpack_ex($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $4;
 $8 = -1 + $7 | 0;
 $9 = $5;
 $10 = $8 + $9 | 0;
 $11 = $10 + 1 | 0;
 _emit_bc_pre($6, $11);
 $12 = $3;
 $13 = $4;
 $14 = $5;
 $15 = $14 << 8;
 $16 = $13 | $15;
 _emit_write_bytecode_byte_uint($12, 90, $16);
 STACKTOP = sp;
 return;
}

function _stringio_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $6 = $7;
 $8 = $3;
 $9 = $6;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = ($10 | 0) == (18756 | 0);
 $12 = $11 ? 32897 : 32916;
 $13 = $6;
 HEAP32[$vararg_buffer >> 2] = $13;
 _mp_printf($8, $12, $vararg_buffer) | 0;
 STACKTOP = sp;
 return;
}

function _mp_math_isnan($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = +_mp_obj_get_float($2);
 $4 = ___DOUBLE_BITS_1412($3) | 0;
 $5 = getTempRet0() | 0;
 $6 = $5 & 2147483647;
 $7 = $6 >>> 0 > 2146435072;
 $8 = $4 >>> 0 > 0;
 $9 = ($6 | 0) == 2146435072;
 $10 = $9 & $8;
 $11 = $7 | $10;
 $12 = $11 & 1;
 $13 = _mp_obj_new_bool_1414($12) | 0;
 STACKTOP = sp;
 return $13 | 0;
}

function _compile_classdef($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $2;
 $8 = $7 + 36 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 + 26 | 0;
 $11 = HEAP16[$10 >> 1] | 0;
 $12 = $11 & 65535;
 $13 = _compile_classdef_helper($5, $6, $12) | 0;
 $4 = $13;
 $14 = $2;
 $15 = $4;
 _compile_store_id($14, $15);
 STACKTOP = sp;
 return;
}

function _compile_funcdef($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $2;
 $8 = $7 + 36 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 + 26 | 0;
 $11 = HEAP16[$10 >> 1] | 0;
 $12 = $11 & 65535;
 $13 = _compile_funcdef_helper($5, $6, $12) | 0;
 $4 = $13;
 $14 = $2;
 $15 = $4;
 _compile_store_id($14, $15);
 STACKTOP = sp;
 return;
}

function _complex_binary_op($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0.0, $12 = 0, $13 = 0, $14 = 0.0, $15 = 0, $16 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $6 = $7;
 $8 = $3;
 $9 = $6;
 $10 = $9 + 8 | 0;
 $11 = +HEAPF64[$10 >> 3];
 $12 = $6;
 $13 = $12 + 16 | 0;
 $14 = +HEAPF64[$13 >> 3];
 $15 = $5;
 $16 = _mp_obj_complex_binary_op($8, $11, $14, $15) | 0;
 STACKTOP = sp;
 return $16 | 0;
}

function _raise_exc($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = ($4 | 0) != (0 | 0);
 if (!$5) {
  $13 = $2;
  _nlr_jump($13);
 }
 $6 = $2;
 HEAP32[$6 >> 2] = 15892;
 $7 = $2;
 $8 = $3;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $3;
 $11 = $10 + 56 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 _mp_obj_exception_add_traceback($7, $9, $12, 0);
 $13 = $2;
 _nlr_jump($13);
}

function _mp_js_init($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp + 4 | 0;
 $1 = $0;
 HEAP32[10259] = $2;
 $4 = $1;
 $5 = $4;
 $6 = _malloc($5) | 0;
 $3 = $6;
 $7 = $3;
 $8 = $3;
 $9 = $1;
 $10 = $8 + $9 | 0;
 _gc_init($7, $10);
 $11 = 39504;
 _mp_pystack_init(35408, $11);
 _mp_init();
 _mp_obj_list_init(40652, 0);
 _mp_obj_list_append(40652, 6) | 0;
 _mp_obj_list_init(40668, 0);
 STACKTOP = sp;
 return;
}

function _get_unaligned($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = sp + 4 | 0;
 $3 = $0;
 HEAP32[$4 >> 2] = $1;
 $5 = $2;
 $7 = $5;
 $8 = ($7 | 0) != 0;
 $9 = $8 ? 62 : 60;
 $10 = $9 & 255;
 $6 = $10;
 $11 = $6;
 $12 = $3;
 $13 = 7392 + $12 | 0;
 $14 = HEAP8[$13 >> 0] | 0;
 $15 = _mp_binary_get_val($11, $14, $4) | 0;
 STACKTOP = sp;
 return $15 | 0;
}

function _mp_emit_bc_jump_if_or_pop($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $6 = $1 & 1;
 $4 = $6;
 $5 = $2;
 $7 = $3;
 _emit_bc_pre($7, -1);
 $8 = $4;
 $9 = $8 & 1;
 $10 = $3;
 $11 = $5;
 if ($9) {
  _emit_write_bytecode_byte_signed_label($10, 56, $11);
  STACKTOP = sp;
  return;
 } else {
  _emit_write_bytecode_byte_signed_label($10, 57, $11);
  STACKTOP = sp;
  return;
 }
}

function _mp_obj_int_get_truncated($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $5 = _mp_obj_is_small_int_1030($4) | 0;
 $6 = $2;
 if ($5) {
  $7 = $6;
  $8 = $7 >> 1;
  $1 = $8;
  $12 = $1;
  STACKTOP = sp;
  return $12 | 0;
 } else {
  $3 = $6;
  $9 = $3;
  $10 = $9 + 4 | 0;
  $11 = _mpz_hash($10) | 0;
  $1 = $11;
  $12 = $1;
  STACKTOP = sp;
  return $12 | 0;
 }
 return 0 | 0;
}

function _mp_emit_bc_pop_jump_if($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $6 = $1 & 1;
 $4 = $6;
 $5 = $2;
 $7 = $3;
 _emit_bc_pre($7, -1);
 $8 = $4;
 $9 = $8 & 1;
 $10 = $3;
 $11 = $5;
 if ($9) {
  _emit_write_bytecode_byte_signed_label($10, 54, $11);
  STACKTOP = sp;
  return;
 } else {
  _emit_write_bytecode_byte_signed_label($10, 55, $11);
  STACKTOP = sp;
  return;
 }
}

function _m_realloc($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = $3;
 $7 = _gc_realloc($5, $6, 1) | 0;
 $4 = $7;
 $8 = $4;
 $9 = ($8 | 0) == (0 | 0);
 $10 = $3;
 $11 = ($10 | 0) != 0;
 $or$cond = $9 & $11;
 if ($or$cond) {
  $12 = $3;
  _m_malloc_fail($12);
 } else {
  $13 = $4;
  STACKTOP = sp;
  return $13 | 0;
 }
 return 0 | 0;
}

function _mp_obj_new_bytes_iterator($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $4 = $5;
 $6 = $4;
 HEAP32[$6 >> 2] = 17448;
 $7 = $4;
 $8 = $7 + 4 | 0;
 HEAP32[$8 >> 2] = 520;
 $9 = $2;
 $10 = $4;
 $11 = $10 + 8 | 0;
 HEAP32[$11 >> 2] = $9;
 $12 = $4;
 $13 = $12 + 12 | 0;
 HEAP32[$13 >> 2] = 0;
 $14 = $4;
 STACKTOP = sp;
 return $14 | 0;
}

function _mp_emit_bc_setup_block($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $5;
 $7 = ($6 | 0) == 0;
 $8 = $3;
 if ($7) {
  _emit_bc_pre($8, 2);
 } else {
  _emit_bc_pre($8, 0);
 }
 $9 = $3;
 $10 = $5;
 $11 = 61 + $10 | 0;
 $12 = $11 & 255;
 $13 = $4;
 _emit_write_bytecode_byte_unsigned_label($9, $12, $13);
 STACKTOP = sp;
 return;
}

function _mp_obj_exception_clear_traceback($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _mp_obj_get_type($3) | 0;
 $5 = $4 + 12 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = ($6 | 0) == (108 | 0);
 $8 = $1;
 if ($7) {
  $2 = $8;
 } else {
  $9 = $8 + 16 | 0;
  $10 = HEAP32[$9 >> 2] | 0;
  $2 = $10;
 }
 $11 = $2;
 $12 = $11 + 8 | 0;
 HEAP32[$12 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _mp_obj_new_str_iterator($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $4 = $5;
 $6 = $4;
 HEAP32[$6 >> 2] = 17448;
 $7 = $4;
 $8 = $7 + 4 | 0;
 HEAP32[$8 >> 2] = 528;
 $9 = $2;
 $10 = $4;
 $11 = $10 + 8 | 0;
 HEAP32[$11 >> 2] = $9;
 $12 = $4;
 $13 = $12 + 12 | 0;
 HEAP32[$13 >> 2] = 0;
 $14 = $4;
 STACKTOP = sp;
 return $14 | 0;
}

function _mp_obj_tuple_getiter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $4 = $5;
 $6 = $4;
 HEAP32[$6 >> 2] = 17448;
 $7 = $4;
 $8 = $7 + 4 | 0;
 HEAP32[$8 >> 2] = 529;
 $9 = $2;
 $10 = $4;
 $11 = $10 + 8 | 0;
 HEAP32[$11 >> 2] = $9;
 $12 = $4;
 $13 = $12 + 12 | 0;
 HEAP32[$13 >> 2] = 0;
 $14 = $4;
 STACKTOP = sp;
 return $14 | 0;
}

function _unichar_isident($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 >>> 0 < 128;
 if (!$3) {
  $13 = 0;
  STACKTOP = sp;
  return $13 | 0;
 }
 $4 = $1;
 $5 = 1088 + $4 | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 & 255;
 $8 = $7 & 12;
 $9 = ($8 | 0) != 0;
 $10 = $1;
 $11 = ($10 | 0) == 95;
 $12 = $9 ? 1 : $11;
 $13 = $12;
 STACKTOP = sp;
 return $13 | 0;
}

function _fun_builtin_0_call($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $4;
 $8 = $9;
 $10 = $5;
 $11 = $6;
 _mp_arg_check_num_977($10, $11, 0, 0, 0);
 $12 = $8;
 $13 = $12 + 4 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = FUNCTION_TABLE_i[$14 & 1023]() | 0;
 STACKTOP = sp;
 return $15 | 0;
}

function _mp_parse_tree_clear($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $4 = $1;
 $5 = $4 + 4 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $2 = $6;
 while (1) {
  $7 = $2;
  $8 = ($7 | 0) != (0 | 0);
  if (!$8) {
   break;
  }
  $9 = $2;
  $10 = $9 + 4 | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  $3 = $11;
  $12 = $2;
  _m_free($12);
  $13 = $3;
  $2 = $13;
 }
 STACKTOP = sp;
 return;
}

function _tinf_get_le_uint32($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = 0;
 $3 = 4;
 while (1) {
  $4 = $3;
  $5 = $4 + -1 | 0;
  $3 = $5;
  $6 = ($4 | 0) != 0;
  $7 = $2;
  if (!$6) {
   break;
  }
  $8 = $7 >>> 8;
  $9 = $1;
  $10 = _uzlib_get_byte($9) | 0;
  $11 = $10 & 255;
  $12 = $11 << 24;
  $13 = $8 | $12;
  $2 = $13;
 }
 STACKTOP = sp;
 return $7 | 0;
}

function _time_ticks_add($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $16 = 0, $17 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = $6;
 $8 = $7 >> 1;
 $4 = $8;
 $9 = $3;
 $10 = _mp_obj_get_int($9) | 0;
 $5 = $10;
 $11 = $4;
 $12 = $5;
 $13 = $11 + $12 | 0;
 $14 = $13 & 1073741823;
 $15 = $14 << 1;
 $16 = $15 | 1;
 $17 = $16;
 STACKTOP = sp;
 return $17 | 0;
}

function _list_index($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $6 = HEAP32[$5 >> 2] | 0;
 $4 = $6;
 $7 = $4;
 $8 = $7 + 12 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $4;
 $11 = $10 + 8 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $2;
 $14 = $3;
 $15 = _mp_seq_index_obj($9, $12, $13, $14) | 0;
 STACKTOP = sp;
 return $15 | 0;
}

function _mp_obj_new_int_from_uint($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $2;
 $4 = $3 & -1073741824;
 $5 = ($4 | 0) == 0;
 $6 = $2;
 if ($5) {
  $7 = $6 << 1;
  $8 = $7 | 1;
  $9 = $8;
  $1 = $9;
  $11 = $1;
  STACKTOP = sp;
  return $11 | 0;
 } else {
  $10 = _mp_obj_new_int_from_ull($6, 0) | 0;
  $1 = $10;
  $11 = $1;
  STACKTOP = sp;
  return $11 | 0;
 }
 return 0 | 0;
}

function _set_update_int($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = _mp_getiter($6, 0) | 0;
 $4 = $7;
 while (1) {
  $8 = $4;
  $9 = _mp_iternext($8) | 0;
  $5 = $9;
  $10 = ($9 | 0) != (0 | 0);
  if (!$10) {
   break;
  }
  $11 = $2;
  $12 = $11 + 4 | 0;
  $13 = $5;
  _mp_set_lookup($12, $13, 1) | 0;
 }
 STACKTOP = sp;
 return;
}

function _set_getiter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $4 = $5;
 $6 = $4;
 HEAP32[$6 >> 2] = 17448;
 $7 = $4;
 $8 = $7 + 4 | 0;
 HEAP32[$8 >> 2] = 519;
 $9 = $2;
 $10 = $4;
 $11 = $10 + 8 | 0;
 HEAP32[$11 >> 2] = $9;
 $12 = $4;
 $13 = $12 + 12 | 0;
 HEAP32[$13 >> 2] = 0;
 $14 = $4;
 STACKTOP = sp;
 return $14 | 0;
}

function _mp_obj_dict_store($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $6 = $7;
 $8 = $6;
 _mp_ensure_not_fixed($8);
 $9 = $5;
 $10 = $6;
 $11 = $10 + 4 | 0;
 $12 = $4;
 $13 = _mp_map_lookup($11, $12, 1) | 0;
 $14 = $13 + 4 | 0;
 HEAP32[$14 >> 2] = $9;
 $15 = $3;
 STACKTOP = sp;
 return $15 | 0;
}

function _mp_obj_complex_get($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0.0, $11 = 0, $12 = 0, $13 = 0, $14 = 0.0, $15 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $6 = $7;
 $8 = $6;
 $9 = $8 + 8 | 0;
 $10 = +HEAPF64[$9 >> 3];
 $11 = $4;
 HEAPF64[$11 >> 3] = $10;
 $12 = $6;
 $13 = $12 + 16 | 0;
 $14 = +HEAPF64[$13 >> 3];
 $15 = $5;
 HEAPF64[$15 >> 3] = $14;
 STACKTOP = sp;
 return;
}

function _mp_builtin_hasattr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp;
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = _mp_obj_str_get_qstr($6) | 0;
 $4 = $7;
 $8 = $2;
 $9 = $4;
 _mp_load_method_protected($8, $9, $5, 0);
 $10 = HEAP32[$5 >> 2] | 0;
 $11 = ($10 | 0) != (0 | 0);
 $12 = $11 & 1;
 $13 = _mp_obj_new_bool_1400($12) | 0;
 STACKTOP = sp;
 return $13 | 0;
}

function _dict_getiter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $4 = $5;
 $6 = $4;
 HEAP32[$6 >> 2] = 14352;
 $7 = $4;
 $8 = $7 + 4 | 0;
 HEAP32[$8 >> 2] = 1;
 $9 = $2;
 $10 = $4;
 $11 = $10 + 8 | 0;
 HEAP32[$11 >> 2] = $9;
 $12 = $4;
 $13 = $12 + 12 | 0;
 HEAP32[$13 >> 2] = 0;
 $14 = $4;
 STACKTOP = sp;
 return $14 | 0;
}

function _mp_obj_list_get($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $6 = $7;
 $8 = $6;
 $9 = $8 + 8 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $4;
 HEAP32[$11 >> 2] = $10;
 $12 = $6;
 $13 = $12 + 12 | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 $15 = $5;
 HEAP32[$15 >> 2] = $14;
 STACKTOP = sp;
 return;
}

function _vstr_free($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != (0 | 0);
 if (!$3) {
  STACKTOP = sp;
  return;
 }
 $4 = $1;
 $5 = $4 + 12 | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 & 1;
 $8 = $7 & 1;
 if (!$8) {
  $9 = $1;
  $10 = $9 + 8 | 0;
  $11 = HEAP32[$10 >> 2] | 0;
  _m_free($11);
 }
 $12 = $1;
 _m_free($12);
 STACKTOP = sp;
 return;
}

function _scope_find_global($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 while (1) {
  $4 = $2;
  $5 = $4 + 4 | 0;
  $6 = HEAP32[$5 >> 2] | 0;
  $7 = ($6 | 0) != (0 | 0);
  $8 = $2;
  if (!$7) {
   break;
  }
  $9 = $8 + 4 | 0;
  $10 = HEAP32[$9 >> 2] | 0;
  $2 = $10;
 }
 $11 = $3;
 $12 = _scope_find($8, $11) | 0;
 STACKTOP = sp;
 return $12 | 0;
}

function _mp_obj_int_from_bytes_impl($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $7 = $0 & 1;
 $3 = $7;
 $4 = $1;
 $5 = $2;
 $8 = _mp_obj_int_new_mpz() | 0;
 $6 = $8;
 $9 = $6;
 $10 = $9 + 4 | 0;
 $11 = $3;
 $12 = $11 & 1;
 $13 = $4;
 $14 = $5;
 _mpz_set_from_bytes($10, $12, $13, $14);
 $15 = $6;
 STACKTOP = sp;
 return $15 | 0;
}

function _op_setitem($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $15 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $8 = _mp_obj_get_type($7) | 0;
 $6 = $8;
 $9 = $6;
 $10 = $9 + 32 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $3;
 $13 = $4;
 $14 = $5;
 $15 = FUNCTION_TABLE_iiii[$11 & 1023]($12, $13, $14) | 0;
 STACKTOP = sp;
 return $15 | 0;
}

function _set_remove($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $4 = $5;
 $6 = $4;
 $7 = $6 + 4 | 0;
 $8 = $3;
 $9 = _mp_set_lookup($7, $8, 2) | 0;
 $10 = ($9 | 0) == (0 | 0);
 if ($10) {
  $11 = $3;
  $12 = _mp_obj_new_exception_arg1(15592, $11) | 0;
  _nlr_jump($12);
 } else {
  STACKTOP = sp;
  return 17668 | 0;
 }
 return 0 | 0;
}

function _mp_warning($0, $1, $varargs) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $varargs = $varargs | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = sp;
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = ($5 | 0) == (0 | 0);
 if ($6) {
  $2 = 30344;
 }
 $7 = $2;
 _mp_print_str(13344, $7) | 0;
 _mp_print_str(13344, 31090) | 0;
 HEAP32[$4 >> 2] = $varargs;
 $8 = $3;
 _mp_vprintf(13344, $8, $4) | 0;
 _mp_print_str(13344, 34812) | 0;
 STACKTOP = sp;
 return;
}

function _get_rule_arg($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = $3 & 255;
 $5 = 1584 + $4 | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 & 255;
 $2 = $7;
 $8 = $1;
 $9 = $8 & 255;
 $10 = $9 >>> 0 >= 102;
 if ($10) {
  $11 = $2;
  $12 = $11 | 256;
  $2 = $12;
 }
 $13 = $2;
 $14 = 1760 + ($13 << 1) | 0;
 STACKTOP = sp;
 return $14 | 0;
}

function _list_extend_from_iter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = _mp_getiter($6, 0) | 0;
 $4 = $7;
 while (1) {
  $8 = $4;
  $9 = _mp_iternext($8) | 0;
  $5 = $9;
  $10 = ($9 | 0) != (0 | 0);
  $11 = $2;
  if (!$10) {
   break;
  }
  $12 = $5;
  _mp_obj_list_append($11, $12) | 0;
 }
 STACKTOP = sp;
 return $11 | 0;
}

function _gc_init($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = $1;
 $3 = $2 & -16;
 $4 = $3;
 $5 = $0;
 $6 = $3 - $5 | 0;
 $7 = ($6 >>> 0) / 65 & -1;
 HEAP32[40748 >> 2] = $7;
 HEAP32[40744 >> 2] = $0;
 $8 = $7 << 6;
 $9 = 0 - $8 | 0;
 $10 = $4 + $9 | 0;
 HEAP32[40752 >> 2] = $10;
 HEAP32[40756 >> 2] = $4;
 _memset($0 | 0, 0, $7 | 0) | 0;
 HEAP32[41032 >> 2] = 0;
 HEAP16[41020 >> 1] = 0;
 HEAP16[41022 >> 1] = 1;
 HEAP32[41028 >> 2] = -1;
 HEAP32[41024 >> 2] = 0;
 return;
}

function _mp_sys_exit($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = ($5 | 0) == 0;
 if ($6) {
  $7 = _mp_obj_new_exception(14872) | 0;
  $4 = $7;
  $11 = $4;
  _nlr_jump($11);
 } else {
  $8 = $3;
  $9 = HEAP32[$8 >> 2] | 0;
  $10 = _mp_obj_new_exception_arg1(14872, $9) | 0;
  $4 = $10;
  $11 = $4;
  _nlr_jump($11);
 }
 return 0 | 0;
}

function _mp_micropython_mem_info($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $vararg_buffer = sp;
 $2 = $0;
 $3 = $1;
 $4 = _mp_stack_usage() | 0;
 HEAP32[$vararg_buffer >> 2] = $4;
 _mp_printf(13344, 33952, $vararg_buffer) | 0;
 _gc_dump_info();
 $5 = $2;
 $6 = ($5 | 0) == 1;
 if (!$6) {
  STACKTOP = sp;
  return 17668 | 0;
 }
 _gc_dump_alloc_table();
 STACKTOP = sp;
 return 17668 | 0;
}

function _type_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $6 = $7;
 $8 = $3;
 $9 = $6;
 $10 = $9 + 6 | 0;
 $11 = HEAP16[$10 >> 1] | 0;
 $12 = $11 & 65535;
 HEAP32[$vararg_buffer >> 2] = $12;
 _mp_printf($8, 33305, $vararg_buffer) | 0;
 STACKTOP = sp;
 return;
}

function _peek_result($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 20 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $2;
 $8 = $7 + 16 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 - 1 | 0;
 $11 = $3;
 $12 = $10 - $11 | 0;
 $13 = $6 + ($12 << 2) | 0;
 $14 = HEAP32[$13 >> 2] | 0;
 STACKTOP = sp;
 return $14 | 0;
}

function _fun_pos_args_mismatch($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $vararg_buffer = 0, $vararg_ptr1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $4;
 $7 = $5;
 HEAP32[$vararg_buffer >> 2] = $6;
 $vararg_ptr1 = $vararg_buffer + 4 | 0;
 HEAP32[$vararg_ptr1 >> 2] = $7;
 $8 = _mp_obj_new_exception_msg_varg(16012, 34348, $vararg_buffer) | 0;
 _nlr_jump($8);
}

function _mod_uheapq_heappush($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = _get_heap($5) | 0;
 $4 = $6;
 $7 = $2;
 $8 = $3;
 _mp_obj_list_append($7, $8) | 0;
 $9 = $4;
 $10 = $4;
 $11 = $10 + 8 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $12 - 1 | 0;
 _heap_siftdown($9, 0, $13);
 STACKTOP = sp;
 return 17668 | 0;
}

function _compile_await_object_method($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 40 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 _mp_emit_bc_load_method($6, $7, 0);
 $8 = $2;
 $9 = $8 + 40 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 _mp_emit_bc_call_method($10, 0, 0, 0);
 $11 = $2;
 _compile_yield_from($11);
 STACKTOP = sp;
 return;
}

function _pyexec_event_repl_process_char($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = HEAP32[5566] | 0;
 $4 = ($3 | 0) == 0;
 $5 = $1;
 if ($4) {
  $6 = _pyexec_raw_repl_process_char($5) | 0;
  $2 = $6;
  $8 = $2;
  STACKTOP = sp;
  return $8 | 0;
 } else {
  $7 = _pyexec_friendly_repl_process_char($5) | 0;
  $2 = $7;
  $8 = $2;
  STACKTOP = sp;
  return $8 | 0;
 }
 return 0 | 0;
}

function _emit_bc_set_max_num_labels($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = $2;
 $6 = $5 + 24 | 0;
 HEAP32[$6 >> 2] = $4;
 $7 = $2;
 $8 = $7 + 24 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 << 2;
 $11 = _m_malloc($10) | 0;
 $12 = $2;
 $13 = $12 + 28 | 0;
 HEAP32[$13 >> 2] = $11;
 STACKTOP = sp;
 return;
}

function _tinf_get_be_uint32($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = 0;
 $3 = 4;
 while (1) {
  $4 = $3;
  $5 = $4 + -1 | 0;
  $3 = $5;
  $6 = ($4 | 0) != 0;
  $7 = $2;
  if (!$6) {
   break;
  }
  $8 = $7 << 8;
  $9 = $1;
  $10 = _uzlib_get_byte($9) | 0;
  $11 = $10 & 255;
  $12 = $8 | $11;
  $2 = $12;
 }
 STACKTOP = sp;
 return $7 | 0;
}

function _mp_set_init($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = $2;
 HEAP32[$5 >> 2] = $4;
 $6 = $2;
 $7 = $6 + 4 | 0;
 HEAP32[$7 >> 2] = 0;
 $8 = $2;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 << 2;
 $11 = _m_malloc0($10) | 0;
 $12 = $2;
 $13 = $12 + 8 | 0;
 HEAP32[$13 >> 2] = $11;
 STACKTOP = sp;
 return;
}

function _mp_obj_new_complex($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $10 = 0.0, $11 = 0, $12 = 0, $13 = 0, $2 = 0.0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0.0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = $0;
 $3 = $1;
 $5 = _m_malloc(24) | 0;
 $4 = $5;
 $6 = $4;
 HEAP32[$6 >> 2] = 14052;
 $7 = $2;
 $8 = $4;
 $9 = $8 + 8 | 0;
 HEAPF64[$9 >> 3] = $7;
 $10 = $3;
 $11 = $4;
 $12 = $11 + 16 | 0;
 HEAPF64[$12 >> 3] = $10;
 $13 = $4;
 STACKTOP = sp;
 return $13 | 0;
}

function _push_rule_from_arg($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $6 = $5 & 4095;
 $4 = $6;
 $7 = $2;
 $8 = $2;
 $9 = $8 + 24 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $10 + 56 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 $13 = $4;
 $14 = $13 & 255;
 _push_rule($7, $12, $14, 0);
 STACKTOP = sp;
 return;
}

function _mp_obj_new_checked_fun($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = _m_malloc(12) | 0;
 $4 = $5;
 $6 = $4;
 HEAP32[$6 >> 2] = 13384;
 $7 = $2;
 $8 = $4;
 $9 = $8 + 4 | 0;
 HEAP32[$9 >> 2] = $7;
 $10 = $3;
 $11 = $4;
 $12 = $11 + 8 | 0;
 HEAP32[$12 >> 2] = $10;
 $13 = $4;
 STACKTOP = sp;
 return $13 | 0;
}

function _mp_obj_new_bound_meth($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = _m_malloc(12) | 0;
 $4 = $5;
 $6 = $4;
 HEAP32[$6 >> 2] = 13872;
 $7 = $2;
 $8 = $4;
 $9 = $8 + 4 | 0;
 HEAP32[$9 >> 2] = $7;
 $10 = $3;
 $11 = $4;
 $12 = $11 + 8 | 0;
 HEAP32[$12 >> 2] = $10;
 $13 = $4;
 STACKTOP = sp;
 return $13 | 0;
}

function _mp_obj_new_dict_view($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = _m_malloc(12) | 0;
 $4 = $5;
 $6 = $4;
 HEAP32[$6 >> 2] = 14292;
 $7 = $2;
 $8 = $4;
 $9 = $8 + 4 | 0;
 HEAP32[$9 >> 2] = $7;
 $10 = $3;
 $11 = $4;
 $12 = $11 + 8 | 0;
 HEAP32[$12 >> 2] = $10;
 $13 = $4;
 STACKTOP = sp;
 return $13 | 0;
}

function _compile_yield_from($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 40 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 _mp_emit_bc_get_iter($4, 0);
 $5 = $1;
 $6 = $5 + 40 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 _mp_emit_bc_load_const_tok($7, 14);
 $8 = $1;
 $9 = $8 + 40 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 _mp_emit_bc_yield($10, 1);
 STACKTOP = sp;
 return;
}

function _uhashlib_sha256_update($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $5 = sp;
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $4 = $6;
 $7 = $3;
 _mp_get_buffer_raise($7, $5, 1);
 $8 = $4;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$5 >> 2] | 0;
 $11 = $5 + 4 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 _sha256_update($9, $10, $12);
 STACKTOP = sp;
 return 17668 | 0;
}

function _tuple_index($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $6 = HEAP32[$5 >> 2] | 0;
 $4 = $6;
 $7 = $4;
 $8 = $7 + 8 | 0;
 $9 = $4;
 $10 = $9 + 4 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $2;
 $13 = $3;
 $14 = _mp_seq_index_obj($8, $11, $12, $13) | 0;
 STACKTOP = sp;
 return $14 | 0;
}

function _gen_instance_send($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = $3;
 $7 = _gen_resume_and_raise($5, $6, 0) | 0;
 $4 = $7;
 $8 = $4;
 $9 = ($8 | 0) == (0 | 0);
 if ($9) {
  $10 = _mp_obj_new_exception(14676) | 0;
  _nlr_jump($10);
 } else {
  $11 = $4;
  STACKTOP = sp;
  return $11 | 0;
 }
 return 0 | 0;
}

function _qstr_data($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = _find_qstr($5) | 0;
 $4 = $6;
 $7 = $4;
 $8 = $7 + 2 | 0;
 $9 = HEAP8[$8 >> 0] | 0;
 $10 = $9 & 255;
 $11 = $3;
 HEAP32[$11 >> 2] = $10;
 $12 = $4;
 $13 = $12 + 2 | 0;
 $14 = $13 + 1 | 0;
 STACKTOP = sp;
 return $14 | 0;
}

function _object_make_new($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $9 = $5;
 $10 = $6;
 _mp_arg_check_num_1081($9, $10, 0, 0, 0);
 $11 = _m_malloc(4) | 0;
 $8 = $11;
 $12 = $4;
 $13 = $8;
 HEAP32[$13 >> 2] = $12;
 $14 = $8;
 STACKTOP = sp;
 return $14 | 0;
}

function _emit_write_bytecode_byte_byte($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $8 = _emit_get_cur_to_write_bytecode($7, 2) | 0;
 $6 = $8;
 $9 = $4;
 $10 = $6;
 HEAP8[$10 >> 0] = $9;
 $11 = $5;
 $12 = $6;
 $13 = $12 + 1 | 0;
 HEAP8[$13 >> 0] = $11;
 STACKTOP = sp;
 return;
}

function _mp_math_isinf($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = +_mp_obj_get_float($2);
 $4 = ___DOUBLE_BITS_1412($3) | 0;
 $5 = getTempRet0() | 0;
 $6 = $5 & 2147483647;
 $7 = ($4 | 0) == 0;
 $8 = ($6 | 0) == 2146435072;
 $9 = $7 & $8;
 $10 = $9 & 1;
 $11 = _mp_obj_new_bool_1414($10) | 0;
 STACKTOP = sp;
 return $11 | 0;
}

function _singleton_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $6 = $7;
 $8 = $3;
 $9 = $6;
 $10 = $9 + 4 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 HEAP32[$vararg_buffer >> 2] = $11;
 _mp_printf($8, 31706, $vararg_buffer) | 0;
 STACKTOP = sp;
 return;
}

function _mp_stream_unbuffered_iter($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp + 4 | 0;
 HEAP32[$2 >> 2] = $0;
 $4 = _stream_unbuffered_readline(1, $2) | 0;
 $3 = $4;
 $5 = $3;
 $6 = _mp_obj_is_true($5) | 0;
 if ($6) {
  $7 = $3;
  $1 = $7;
  $8 = $1;
  STACKTOP = sp;
  return $8 | 0;
 } else {
  $1 = 0;
  $8 = $1;
  STACKTOP = sp;
  return $8 | 0;
 }
 return 0 | 0;
}

function _mp_obj_tuple_get($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $14 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $6 = $7;
 $8 = $6;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $4;
 HEAP32[$11 >> 2] = $10;
 $12 = $6;
 $13 = $12 + 8 | 0;
 $14 = $5;
 HEAP32[$14 >> 2] = $13;
 STACKTOP = sp;
 return;
}

function _match_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $6 = $7;
 $8 = $3;
 $9 = $6;
 $10 = $9 + 4 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 HEAP32[$vararg_buffer >> 2] = $11;
 _mp_printf($8, 34660, $vararg_buffer) | 0;
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_get_iter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $1 & 1;
 $3 = $4;
 $5 = $2;
 $6 = $3;
 $7 = $6 & 1;
 $8 = $7 ? 3 : 0;
 _emit_bc_pre($5, $8);
 $9 = $2;
 $10 = $3;
 $11 = $10 & 1;
 $12 = $11 ? 71 : 66;
 $13 = $12 & 255;
 _emit_write_bytecode_byte($9, $13);
 STACKTOP = sp;
 return;
}

function ___muldi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 var $x_sroa_0_0_extract_trunc = 0, $y_sroa_0_0_extract_trunc = 0, $1$0 = 0, $1$1 = 0, $2 = 0;
 $x_sroa_0_0_extract_trunc = $a$0;
 $y_sroa_0_0_extract_trunc = $b$0;
 $1$0 = ___muldsi3($x_sroa_0_0_extract_trunc, $y_sroa_0_0_extract_trunc) | 0;
 $1$1 = getTempRet0() | 0;
 $2 = Math_imul($a$1, $y_sroa_0_0_extract_trunc) | 0;
 return (setTempRet0(((Math_imul($b$1, $x_sroa_0_0_extract_trunc) | 0) + $2 | 0) + $1$1 | $1$1 & 0 | 0), 0 | $1$0 & -1) | 0;
}

function _compile_dictorsetmaker_item($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = $5 + 8 | 0;
 $7 = $6 + 4 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 _compile_node($4, $8);
 $9 = $2;
 $10 = $3;
 $11 = $10 + 8 | 0;
 $12 = HEAP32[$11 >> 2] | 0;
 _compile_node($9, $12);
 STACKTOP = sp;
 return;
}

function _arg_looks_numeric($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _arg_looks_integer($2) | 0;
 if ($3) {
  $9 = 1;
 } else {
  $4 = $1;
  $5 = _mp_obj_is_obj_1154($4) | 0;
  if ($5) {
   $6 = $1;
   $7 = HEAP32[$6 >> 2] | 0;
   $8 = ($7 | 0) == (16252 | 0);
   $9 = $8;
  } else {
   $9 = 0;
  }
 }
 STACKTOP = sp;
 return $9 | 0;
}

function _mpz_deinit($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != (0 | 0);
 if ($3) {
  $4 = $1;
  $5 = HEAP32[$4 >> 2] | 0;
  $6 = $5 >>> 1;
  $7 = $6 & 1;
  $8 = ($7 | 0) != 0;
  if (!$8) {
   $9 = $1;
   $10 = $9 + 8 | 0;
   $11 = HEAP32[$10 >> 2] | 0;
   _m_free($11);
  }
 }
 STACKTOP = sp;
 return;
}

function _readline($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $2;
 $7 = $3;
 _readline_init($6, $7);
 while (1) {
  $4 = 0;
  $8 = $4;
  $9 = _readline_process_char($8) | 0;
  $5 = $9;
  $10 = $5;
  $11 = ($10 | 0) >= 0;
  if ($11) {
   break;
  }
 }
 $12 = $5;
 STACKTOP = sp;
 return $12 | 0;
}

function _tinf_get_uint16($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _uzlib_get_byte($3) | 0;
 $5 = $4 & 255;
 $2 = $5;
 $6 = $1;
 $7 = _uzlib_get_byte($6) | 0;
 $8 = $7 & 255;
 $9 = $8 << 8;
 $10 = $2;
 $11 = $9 | $10;
 $2 = $11;
 $12 = $2;
 $13 = $12 & 65535;
 STACKTOP = sp;
 return $13 | 0;
}

function _m_malloc($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $or$cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _gc_alloc($3, 0) | 0;
 $2 = $4;
 $5 = $2;
 $6 = ($5 | 0) == (0 | 0);
 $7 = $1;
 $8 = ($7 | 0) != 0;
 $or$cond = $6 & $8;
 if ($or$cond) {
  $9 = $1;
  _m_malloc_fail($9);
 } else {
  $10 = $2;
  STACKTOP = sp;
  return $10 | 0;
 }
 return 0 | 0;
}

function _mp_parse_node_is_const_false($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) == 222;
 if ($3) {
  $10 = 1;
 } else {
  $4 = $1;
  $5 = $4 & 1;
  $6 = ($5 | 0) == 1;
  if ($6) {
   $7 = $1;
   $8 = $7 >> 1;
   $9 = ($8 | 0) == 0;
   $10 = $9;
  } else {
   $10 = 0;
  }
 }
 STACKTOP = sp;
 return $10 | 0;
}

function _sn_write($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $$cast = 0, $10 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $spec$select = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $3 = $0 + 16 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $0 + 20 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $4 - $6 | 0;
 $8 = $7 >>> 0 > $2 >>> 0;
 $spec$select = $8 ? $2 : $7;
 $$cast = $6;
 _memcpy($$cast | 0, $1 | 0, $spec$select | 0) | 0;
 $9 = HEAP32[$5 >> 2] | 0;
 $10 = $9 + $spec$select | 0;
 HEAP32[$5 >> 2] = $10;
 return $2 | 0;
}

function _mp_parse_node_is_const_true($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) == 254;
 if ($3) {
  $10 = 1;
 } else {
  $4 = $1;
  $5 = $4 & 1;
  $6 = ($5 | 0) == 1;
  if ($6) {
   $7 = $1;
   $8 = $7 >> 1;
   $9 = ($8 | 0) != 0;
   $10 = $9;
  } else {
   $10 = 0;
  }
 }
 STACKTOP = sp;
 return $10 | 0;
}

function _is_following_odigit($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 20 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $4 >>> 0 >= 48;
 if (!$5) {
  $10 = 0;
  STACKTOP = sp;
  return $10 | 0;
 }
 $6 = $1;
 $7 = $6 + 20 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $8 >>> 0 <= 55;
 $10 = $9;
 STACKTOP = sp;
 return $10 | 0;
}

function _mp_emit_bc_return_value($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _emit_bc_pre($2, -1);
 $3 = $1;
 $4 = $3 + 5 | 0;
 $5 = HEAPU8[$4 >> 0] | HEAPU8[$4 + 1 >> 0] << 8;
 $6 = $5 & 255;
 $7 = $6 | 256;
 HEAP8[$4 >> 0] = $7 & 255;
 HEAP8[$4 + 1 >> 0] = $7 >> 8;
 $8 = $1;
 _emit_write_bytecode_byte($8, 91);
 STACKTOP = sp;
 return;
}

function _list_count($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $4 = $5;
 $6 = $4;
 $7 = $6 + 12 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $4;
 $10 = $9 + 8 | 0;
 $11 = HEAP32[$10 >> 2] | 0;
 $12 = $3;
 $13 = _mp_seq_count_obj($8, $11, $12) | 0;
 STACKTOP = sp;
 return $13 | 0;
}

function _compile_decrease_except_level($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 28 | 0;
 $4 = HEAP16[$3 >> 1] | 0;
 $5 = $4 & 65535;
 $6 = $5 - 1 | 0;
 $7 = $6 & 65535;
 HEAP16[$3 >> 1] = $7;
 $8 = $1;
 $9 = $8 + 40 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 _mp_emit_bc_end_finally($10);
 STACKTOP = sp;
 return;
}

function _qstr_hash($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $12 = 0, $13 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _find_qstr($3) | 0;
 $2 = $4;
 $5 = $2;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 & 255;
 $8 = $2;
 $9 = $8 + 1 | 0;
 $10 = HEAP8[$9 >> 0] | 0;
 $11 = $10 & 255;
 $12 = $11 << 8;
 $13 = $7 | $12;
 STACKTOP = sp;
 return $13 | 0;
}

function _mp_emit_bc_with_cleanup($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 _mp_emit_bc_load_const_tok($4, 14);
 $5 = $2;
 $6 = $3;
 _mp_emit_bc_label_assign($5, $6);
 $7 = $2;
 _emit_bc_pre($7, 2);
 $8 = $2;
 _emit_write_bytecode_byte($8, 62);
 $9 = $2;
 _emit_bc_pre($9, -4);
 STACKTOP = sp;
 return;
}

function _vstr_clear($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 12 | 0;
 $4 = HEAP8[$3 >> 0] | 0;
 $5 = $4 & 1;
 $6 = $5 & 1;
 if (!$6) {
  $7 = $1;
  $8 = $7 + 8 | 0;
  $9 = HEAP32[$8 >> 2] | 0;
  _m_free($9);
 }
 $10 = $1;
 $11 = $10 + 8 | 0;
 HEAP32[$11 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _op_contains($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = _mp_obj_get_type($5) | 0;
 $4 = $6;
 $7 = $4;
 $8 = $7 + 24 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $2;
 $11 = $3;
 $12 = FUNCTION_TABLE_iiii[$9 & 1023](34, $10, $11) | 0;
 STACKTOP = sp;
 return $12 | 0;
}

function _op_getitem($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = _mp_obj_get_type($5) | 0;
 $4 = $6;
 $7 = $4;
 $8 = $7 + 32 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $2;
 $11 = $3;
 $12 = FUNCTION_TABLE_iiii[$9 & 1023]($10, $11, 4) | 0;
 STACKTOP = sp;
 return $12 | 0;
}

function _op_delitem($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = _mp_obj_get_type($5) | 0;
 $4 = $6;
 $7 = $4;
 $8 = $7 + 32 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $2;
 $11 = $3;
 $12 = FUNCTION_TABLE_iiii[$9 & 1023]($10, $11, 0) | 0;
 STACKTOP = sp;
 return $12 | 0;
}

function _utf8_next_char($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 1 | 0;
 $1 = $3;
 while (1) {
  $4 = $1;
  $5 = HEAP8[$4 >> 0] | 0;
  $6 = $5 & 255;
  $7 = $6 & 192;
  $8 = ($7 | 0) == 128;
  $9 = $1;
  if (!$8) {
   break;
  }
  $10 = $9 + 1 | 0;
  $1 = $10;
 }
 STACKTOP = sp;
 return $9 | 0;
}

function _mp_obj_new_exception_args($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $6 + 12 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 $9 = $3;
 $10 = $4;
 $11 = $5;
 $12 = FUNCTION_TABLE_iiiii[$8 & 1023]($9, $10, 0, $11) | 0;
 STACKTOP = sp;
 return $12 | 0;
}

function _mp_obj_exception_match($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = _mp_obj_is_exception_instance($4) | 0;
 if ($5) {
  $6 = $2;
  $7 = _mp_obj_get_type($6) | 0;
  $2 = $7;
 }
 $8 = $2;
 $9 = $3;
 $10 = _mp_obj_is_subclass_fast($8, $9) | 0;
 STACKTOP = sp;
 return $10 | 0;
}

function _mpz_is_neg($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = ($4 | 0) != 0;
 if (!$5) {
  $10 = 0;
  STACKTOP = sp;
  return $10 | 0;
 }
 $6 = $1;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $7 & 1;
 $9 = ($8 | 0) != 0;
 $10 = $9;
 STACKTOP = sp;
 return $10 | 0;
}

function _unichar_isxdigit($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 >>> 0 < 128;
 if (!$3) {
  $10 = 0;
  STACKTOP = sp;
  return $10 | 0;
 }
 $4 = $1;
 $5 = 1088 + $4 | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 & 255;
 $8 = $7 & 64;
 $9 = ($8 | 0) != 0;
 $10 = $9;
 STACKTOP = sp;
 return $10 | 0;
}

function _unichar_isupper($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 >>> 0 < 128;
 if (!$3) {
  $10 = 0;
  STACKTOP = sp;
  return $10 | 0;
 }
 $4 = $1;
 $5 = 1088 + $4 | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 & 255;
 $8 = $7 & 16;
 $9 = ($8 | 0) != 0;
 $10 = $9;
 STACKTOP = sp;
 return $10 | 0;
}

function _unichar_islower($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 >>> 0 < 128;
 if (!$3) {
  $10 = 0;
  STACKTOP = sp;
  return $10 | 0;
 }
 $4 = $1;
 $5 = 1088 + $4 | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 & 255;
 $8 = $7 & 32;
 $9 = ($8 | 0) != 0;
 $10 = $9;
 STACKTOP = sp;
 return $10 | 0;
}

function _unichar_isspace($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 >>> 0 < 128;
 if (!$3) {
  $10 = 0;
  STACKTOP = sp;
  return $10 | 0;
 }
 $4 = $1;
 $5 = 1088 + $4 | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 & 255;
 $8 = $7 & 2;
 $9 = ($8 | 0) != 0;
 $10 = $9;
 STACKTOP = sp;
 return $10 | 0;
}

function _unichar_isdigit($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 >>> 0 < 128;
 if (!$3) {
  $10 = 0;
  STACKTOP = sp;
  return $10 | 0;
 }
 $4 = $1;
 $5 = 1088 + $4 | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 & 255;
 $8 = $7 & 4;
 $9 = ($8 | 0) != 0;
 $10 = $9;
 STACKTOP = sp;
 return $10 | 0;
}

function _unichar_isalpha($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 >>> 0 < 128;
 if (!$3) {
  $10 = 0;
  STACKTOP = sp;
  return $10 | 0;
 }
 $4 = $1;
 $5 = 1088 + $4 | 0;
 $6 = HEAP8[$5 >> 0] | 0;
 $7 = $6 & 255;
 $8 = $7 & 8;
 $9 = ($8 | 0) != 0;
 $10 = $9;
 STACKTOP = sp;
 return $10 | 0;
}

function _indent_top($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 52 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $1;
 $6 = $5 + 48 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $7 - 1 | 0;
 $9 = $4 + ($8 << 1) | 0;
 $10 = HEAP16[$9 >> 1] | 0;
 $11 = $10 & 65535;
 STACKTOP = sp;
 return $11 | 0;
}

function _set_pop($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $4 = $1;
 $2 = $4;
 $5 = $2;
 $6 = $5 + 4 | 0;
 $7 = _mp_set_remove_first($6) | 0;
 $3 = $7;
 $8 = $3;
 $9 = ($8 | 0) == (0 | 0);
 if ($9) {
  _mp_raise_msg(15592, 31656);
 } else {
  $10 = $3;
  STACKTOP = sp;
  return $10 | 0;
 }
 return 0 | 0;
}

function _readline_note_newline($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = HEAP32[10405] | 0;
 $3 = $2 + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 HEAP32[10406] = $4;
 $5 = HEAP32[10406] | 0;
 HEAP32[10409] = $5;
 $6 = $1;
 HEAP32[10410] = $6;
 $7 = $1;
 _mp_hal_stdout_tx_str($7);
 _readline_auto_indent();
 STACKTOP = sp;
 return;
}

function _mp_builtin_help($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = ($4 | 0) == 0;
 if ($5) {
  _mp_print_str(13344, 4656) | 0;
  STACKTOP = sp;
  return 17668 | 0;
 } else {
  $6 = $3;
  $7 = HEAP32[$6 >> 2] | 0;
  _mp_help_print_obj($7);
  STACKTOP = sp;
  return 17668 | 0;
 }
 return 0 | 0;
}

function _mp_obj_list_remove($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = sp;
 $2 = $0;
 $3 = $1;
 $5 = $2;
 HEAP32[$4 >> 2] = $5;
 $6 = $4 + 4 | 0;
 $7 = $3;
 HEAP32[$6 >> 2] = $7;
 $8 = _list_index(2, $4) | 0;
 $9 = $4 + 4 | 0;
 HEAP32[$9 >> 2] = $8;
 _list_pop(2, $4) | 0;
 STACKTOP = sp;
 return 17668 | 0;
}

function _pop_result($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 20 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $1;
 $6 = $5 + 16 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 $8 = $7 + -1 | 0;
 HEAP32[$6 >> 2] = $8;
 $9 = $4 + ($8 << 2) | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 STACKTOP = sp;
 return $10 | 0;
}

function _nlr_push_tail($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = 40568;
 $3 = $2;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $1;
 HEAP32[$5 >> 2] = $4;
 $6 = HEAP32[40556 >> 2] | 0;
 $7 = $1;
 $8 = $7 + 164 | 0;
 HEAP32[$8 >> 2] = $6;
 $9 = $1;
 $10 = $2;
 HEAP32[$10 >> 2] = $9;
 STACKTOP = sp;
 return 0;
}

function _mp_generic_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $cond = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $3;
 $cond = ($5 | 0) == 6;
 if ($cond) {
  $6 = $4;
  $7 = $6;
  $8 = $7 << 1;
  $9 = $8 | 1;
  $10 = $9;
  $2 = $10;
 } else {
  $2 = 0;
 }
 $11 = $2;
 STACKTOP = sp;
 return $11 | 0;
}

function _select_poll() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = _m_malloc(28) | 0;
 $0 = $1;
 $2 = $0;
 HEAP32[$2 >> 2] = 21872;
 $3 = $0;
 $4 = $3 + 4 | 0;
 _mp_map_init($4, 0);
 $5 = $0;
 $6 = $5 + 16 | 0;
 HEAP16[$6 >> 1] = 0;
 $7 = $0;
 $8 = $7 + 24 | 0;
 HEAP32[$8 >> 2] = 0;
 $9 = $0;
 STACKTOP = sp;
 return $9 | 0;
}

function _mpz_abs_inpl($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = ($4 | 0) != ($5 | 0);
 if ($6) {
  $7 = $2;
  $8 = $3;
  _mpz_set($7, $8);
 }
 $9 = $2;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $10 & -2;
 HEAP32[$9 >> 2] = $11;
 STACKTOP = sp;
 return;
}

function _stat_file_py_or_mpy($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $4 = $2;
 $5 = _vstr_null_terminated_str($4) | 0;
 $6 = _mp_import_stat_any($5) | 0;
 $3 = $6;
 $7 = $3;
 $8 = ($7 | 0) == 2;
 if ($8) {
  $9 = $3;
  $1 = $9;
 } else {
  $1 = 0;
 }
 $10 = $1;
 STACKTOP = sp;
 return $10 | 0;
}

function _uhashlib_sha256_digest($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $3 = sp;
 $1 = $0;
 $4 = $1;
 $2 = $4;
 _vstr_init_len($3, 32);
 $5 = $2;
 $6 = $5 + 4 | 0;
 $7 = $3 + 8 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 _sha256_final($6, $8);
 $9 = _mp_obj_new_str_from_vstr(18304, $3) | 0;
 STACKTOP = sp;
 return $9 | 0;
}

function _isalignment($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 << 24 >> 24;
 $4 = ($3 | 0) != 0;
 if (!$4) {
  $9 = 0;
  STACKTOP = sp;
  return $9 | 0;
 }
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = _strchr(32340, $6) | 0;
 $8 = ($7 | 0) != (0 | 0);
 $9 = $8;
 STACKTOP = sp;
 return $9 | 0;
}

function _mp_emit_bc_store_global($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 _emit_bc_pre($6, -1);
 $7 = $3;
 $8 = $5;
 $9 = 36 + $8 | 0;
 $10 = $9 & 255;
 $11 = $4;
 _emit_write_bytecode_byte_qstr($7, $10, $11);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_delete_global($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 _emit_bc_pre($6, 0);
 $7 = $3;
 $8 = $5;
 $9 = 42 + $8 | 0;
 $10 = $9 & 255;
 $11 = $4;
 _emit_write_bytecode_byte_qstr($7, $10, $11);
 STACKTOP = sp;
 return;
}

function _compile_trailer_bracket($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = $5 + 8 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 _compile_node($4, $7);
 $8 = $2;
 $9 = $8 + 40 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 _mp_emit_bc_subscr($10, 0);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_load_global($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 _emit_bc_pre($6, 1);
 $7 = $3;
 $8 = $5;
 $9 = 27 + $8 | 0;
 $10 = $9 & 255;
 $11 = $4;
 _emit_write_bytecode_byte_qstr($7, $10, $11);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_delete_local($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $8 = $4;
 $9 = $7;
 $10 = 40 + $9 | 0;
 $11 = $10 & 255;
 $12 = $6;
 _emit_write_bytecode_byte_uint($8, $11, $12);
 STACKTOP = sp;
 return;
}

function _tuple_count($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $4 = $5;
 $6 = $4;
 $7 = $6 + 8 | 0;
 $8 = $4;
 $9 = $8 + 4 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 $11 = $3;
 $12 = _mp_seq_count_obj($7, $10, $11) | 0;
 STACKTOP = sp;
 return $12 | 0;
}

function _istype($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 << 24 >> 24;
 $4 = ($3 | 0) != 0;
 if (!$4) {
  $9 = 0;
  STACKTOP = sp;
  return $9 | 0;
 }
 $5 = $1;
 $6 = $5 << 24 >> 24;
 $7 = _strchr(32324, $6) | 0;
 $8 = ($7 | 0) != (0 | 0);
 $9 = $8;
 STACKTOP = sp;
 return $9 | 0;
}

function _compile_not_test_2($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = $5 + 8 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 _compile_node($4, $7);
 $8 = $2;
 $9 = $8 + 40 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 _mp_emit_bc_unary_op($10, 3);
 STACKTOP = sp;
 return;
}

function _unichar_xdigit_value($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = $3 - 48 | 0;
 $2 = $4;
 $5 = $2;
 $6 = $5 >>> 0 > 9;
 if ($6) {
  $7 = $2;
  $8 = $7 & -33;
  $2 = $8;
  $9 = $2;
  $10 = $9 - 7 | 0;
  $2 = $10;
 }
 $11 = $2;
 STACKTOP = sp;
 return $11 | 0;
}

function _mp_builtin_next($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _mp_iternext_allow_raise($3) | 0;
 $2 = $4;
 $5 = $2;
 $6 = ($5 | 0) == (0 | 0);
 if ($6) {
  $7 = _mp_obj_new_exception(14676) | 0;
  _nlr_jump($7);
 } else {
  $8 = $2;
  STACKTOP = sp;
  return $8 | 0;
 }
 return 0 | 0;
}

function _compile_yield_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = $5 + 8 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 _compile_node($4, $7);
 $8 = $2;
 $9 = $8 + 40 | 0;
 $10 = HEAP32[$9 >> 2] | 0;
 _mp_emit_bc_pop_top($10);
 STACKTOP = sp;
 return;
}

function _stringio_new($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = _m_malloc(16) | 0;
 $2 = $3;
 $4 = $1;
 $5 = $2;
 HEAP32[$5 >> 2] = $4;
 $6 = $2;
 $7 = $6 + 8 | 0;
 HEAP32[$7 >> 2] = 0;
 $8 = $2;
 $9 = $8 + 12 | 0;
 HEAP32[$9 >> 2] = 0;
 $10 = $2;
 STACKTOP = sp;
 return $10 | 0;
}

function _m_realloc_maybe($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $13 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $7 = $2 & 1;
 $5 = $7;
 $8 = $3;
 $9 = $4;
 $10 = $5;
 $11 = $10 & 1;
 $12 = _gc_realloc($8, $9, $11) | 0;
 $6 = $12;
 $13 = $6;
 STACKTOP = sp;
 return $13 | 0;
}

function _do_load($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $11 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $6 = $3;
 $7 = _vstr_null_terminated_str($6) | 0;
 $4 = $7;
 $8 = $4;
 $9 = _mp_lexer_new_from_file($8) | 0;
 $5 = $9;
 $10 = $2;
 $11 = $5;
 _do_load_from_lexer($10, $11);
 STACKTOP = sp;
 return;
}

function _vstr_ins_char($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $12 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $8 = $4;
 $9 = _vstr_ins_blank_bytes($7, $8, 1) | 0;
 $6 = $9;
 $10 = $5;
 $11 = $10 & 255;
 $12 = $6;
 HEAP8[$12 >> 0] = $11;
 STACKTOP = sp;
 return;
}

function _mp_reader_mem_close($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $2 = $3;
 $4 = $2;
 $5 = HEAP32[$4 >> 2] | 0;
 $6 = $5 >>> 0 > 0;
 if ($6) {
  $7 = $2;
  $8 = $7 + 4 | 0;
  $9 = HEAP32[$8 >> 2] | 0;
  _m_free($9);
 }
 $10 = $2;
 _m_free($10);
 STACKTOP = sp;
 return;
}

function _uctypes_struct_bytearray_at($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = _mp_obj_int_get_truncated($4) | 0;
 $6 = $2;
 $7 = _mp_obj_int_get_truncated($6) | 0;
 $8 = $7;
 $9 = _mp_obj_new_bytearray_by_ref($5, $8) | 0;
 STACKTOP = sp;
 return $9 | 0;
}

function _vstr_init_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $4;
 _vstr_init($6, $7);
 $8 = $3;
 $9 = $5;
 HEAP32[$9 >> 2] = $8;
 $10 = $5;
 $11 = $10 + 4 | 0;
 HEAP32[$11 >> 2] = 484;
 STACKTOP = sp;
 return;
}

function _mp_set_clear($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 8 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 _m_free($4);
 $5 = $1;
 HEAP32[$5 >> 2] = 0;
 $6 = $1;
 $7 = $6 + 4 | 0;
 HEAP32[$7 >> 2] = 0;
 $8 = $1;
 $9 = $8 + 8 | 0;
 HEAP32[$9 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _compile_trailer_period($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 40 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 $8 = $7 + 8 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = $9 >>> 4;
 _mp_emit_bc_attr($6, $10, 0);
 STACKTOP = sp;
 return;
}

function _re_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $vararg_buffer = sp;
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $4;
 $6 = $7;
 $8 = $3;
 $9 = $6;
 HEAP32[$vararg_buffer >> 2] = $9;
 _mp_printf($8, 34891, $vararg_buffer) | 0;
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_call_function($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $8 = $4;
 $9 = $5;
 $10 = $6;
 $11 = $7;
 _emit_bc_call_function_method_helper($8, 0, 100, $9, $10, $11);
 STACKTOP = sp;
 return;
}

function _mod_ujson_dump($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = sp;
 $2 = $0;
 $3 = $1;
 $5 = $3;
 _mp_get_stream_raise($5, 2) | 0;
 $6 = $3;
 HEAP32[$4 >> 2] = $6;
 $7 = $4 + 4 | 0;
 HEAP32[$7 >> 2] = 614;
 $8 = $2;
 _mp_obj_print_helper($4, $8, 3);
 STACKTOP = sp;
 return 17668 | 0;
}

function _m_malloc_fail($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $vararg_buffer = sp;
 $1 = $0;
 $2 = _gc_is_locked() | 0;
 if ($2) {
  _mp_raise_msg(15652, 29968);
 } else {
  $3 = $1;
  HEAP32[$vararg_buffer >> 2] = $3;
  $4 = _mp_obj_new_exception_msg_varg(15652, 30009, $vararg_buffer) | 0;
  _nlr_jump($4);
 }
}

function _mp_emit_bc_call_method($0, $1, $2, $3) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $3 = $3 | 0;
 var $10 = 0, $11 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = $0;
 $5 = $1;
 $6 = $2;
 $7 = $3;
 $8 = $4;
 $9 = $5;
 $10 = $6;
 $11 = $7;
 _emit_bc_call_function_method_helper($8, -1, 102, $9, $10, $11);
 STACKTOP = sp;
 return;
}

function _mp_raise_msg($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = ($4 | 0) == (0 | 0);
 $6 = $2;
 if ($5) {
  $7 = _mp_obj_new_exception($6) | 0;
  _nlr_jump($7);
 } else {
  $8 = $3;
  $9 = _mp_obj_new_exception_msg($6, $8) | 0;
  _nlr_jump($9);
 }
}

function _struct_calcsize($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = sp;
 $1 = $0;
 $4 = $1;
 $5 = _mp_obj_str_get_str($4) | 0;
 $2 = $5;
 $6 = $2;
 _calc_size_items($6, $3) | 0;
 $7 = HEAP32[$3 >> 2] | 0;
 $8 = $7 << 1;
 $9 = $8 | 1;
 $10 = $9;
 STACKTOP = sp;
 return $10 | 0;
}

function _get_heap($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_obj_is_obj_1523($2) | 0;
 if ($3) {
  $4 = $1;
  $5 = HEAP32[$4 >> 2] | 0;
  $6 = ($5 | 0) == (17028 | 0);
  if ($6) {
   $7 = $1;
   STACKTOP = sp;
   return $7 | 0;
  }
 }
 _mp_raise_TypeError(34918);
 return 0 | 0;
}

function _none_print($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $5;
 $7 = ($6 | 0) == 3;
 $8 = $3;
 if ($7) {
  _mp_print_str($8, 31597) | 0;
  STACKTOP = sp;
  return;
 } else {
  _mp_print_str($8, 31602) | 0;
  STACKTOP = sp;
  return;
 }
}

function _uctypes_struct_bytes_at($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = _mp_obj_int_get_truncated($4) | 0;
 $6 = $5;
 $7 = $3;
 $8 = _mp_obj_int_get_truncated($7) | 0;
 $9 = _mp_obj_new_bytes($6, $8) | 0;
 STACKTOP = sp;
 return $9 | 0;
}

function ___stdio_close($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $vararg_buffer = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $vararg_buffer = sp;
 $1 = $0 + 60 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 $3 = _dummy($2) | 0;
 HEAP32[$vararg_buffer >> 2] = $3;
 $4 = ___syscall6(6, $vararg_buffer | 0) | 0;
 $5 = ___syscall_ret($4) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_cmath_phase($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0.0, $6 = 0.0, $7 = 0.0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 8 | 0;
 $3 = sp;
 $1 = $0;
 $4 = $1;
 _mp_obj_get_complex($4, $2, $3);
 $5 = +HEAPF64[$3 >> 3];
 $6 = +HEAPF64[$2 >> 3];
 $7 = +_atan2($5, $6);
 $8 = _mp_obj_new_float($7) | 0;
 STACKTOP = sp;
 return $8 | 0;
}

function _js_exec($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _mp_obj_str_get_str($3) | 0;
 $5 = _emscripten_run_script_string($4 | 0) | 0;
 $2 = $5;
 $6 = $2;
 $7 = $2;
 $8 = _strlen($7) | 0;
 $9 = _mp_obj_new_str($6, $8) | 0;
 STACKTOP = sp;
 return $9 | 0;
}

function _mp_decode_uint_skip($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 while (1) {
  $2 = $1;
  $3 = $2 + 1 | 0;
  $1 = $3;
  $4 = HEAP8[$2 >> 0] | 0;
  $5 = $4 & 255;
  $6 = $5 & 128;
  $7 = ($6 | 0) != 0;
  if (!$7) {
   break;
  }
 }
 $8 = $1;
 STACKTOP = sp;
 return $8 | 0;
}

function _list_copy($0) {
 $0 = $0 | 0;
 var $1 = 0, $10 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $2 = $3;
 $4 = $2;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $2;
 $8 = $7 + 12 | 0;
 $9 = HEAP32[$8 >> 2] | 0;
 $10 = _mp_obj_new_list($6, $9) | 0;
 STACKTOP = sp;
 return $10 | 0;
}

function ___DOUBLE_BITS_1412($0) {
 $0 = +$0;
 var $1 = 0.0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp;
 $1 = $0;
 $3 = $1;
 HEAPF64[$2 >> 3] = $3;
 $4 = $2;
 $5 = $4;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $4 + 4 | 0;
 $8 = $7;
 $9 = HEAP32[$8 >> 2] | 0;
 setTempRet0($9 | 0);
 STACKTOP = sp;
 return $6 | 0;
}

function ___DOUBLE_BITS_968($0) {
 $0 = +$0;
 var $1 = 0.0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp;
 $1 = $0;
 $3 = $1;
 HEAPF64[$2 >> 3] = $3;
 $4 = $2;
 $5 = $4;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $4 + 4 | 0;
 $8 = $7;
 $9 = HEAP32[$8 >> 2] | 0;
 setTempRet0($9 | 0);
 STACKTOP = sp;
 return $6 | 0;
}

function ___DOUBLE_BITS_870($0) {
 $0 = +$0;
 var $1 = 0.0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp;
 $1 = $0;
 $3 = $1;
 HEAPF64[$2 >> 3] = $3;
 $4 = $2;
 $5 = $4;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $4 + 4 | 0;
 $8 = $7;
 $9 = HEAP32[$8 >> 2] | 0;
 setTempRet0($9 | 0);
 STACKTOP = sp;
 return $6 | 0;
}

function _vstr_ins_byte($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $10 = 0, $11 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $7 = $3;
 $8 = $4;
 $9 = _vstr_ins_blank_bytes($7, $8, 1) | 0;
 $6 = $9;
 $10 = $5;
 $11 = $6;
 HEAP8[$11 >> 0] = $10;
 STACKTOP = sp;
 return;
}

function _mp_hal_delay_us($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = _mp_hal_ticks_us() | 0;
 $2 = $3;
 while (1) {
  $4 = _mp_hal_ticks_us() | 0;
  $5 = $2;
  $6 = $4 - $5 | 0;
  $7 = $1;
  $8 = $6 >>> 0 < $7 >>> 0;
  if (!$8) {
   break;
  }
 }
 STACKTOP = sp;
 return;
}

function _mp_hal_delay_ms($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = _mp_hal_ticks_ms() | 0;
 $2 = $3;
 while (1) {
  $4 = _mp_hal_ticks_ms() | 0;
  $5 = $2;
  $6 = $4 - $5 | 0;
  $7 = $1;
  $8 = $6 >>> 0 < $7 >>> 0;
  if (!$8) {
   break;
  }
 }
 STACKTOP = sp;
 return;
}

function ___DOUBLE_BITS($0) {
 $0 = +$0;
 var $1 = 0.0, $2 = 0, $3 = 0.0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp;
 $1 = $0;
 $3 = $1;
 HEAPF64[$2 >> 3] = $3;
 $4 = $2;
 $5 = $4;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $4 + 4 | 0;
 $8 = $7;
 $9 = HEAP32[$8 >> 2] | 0;
 setTempRet0($9 | 0);
 STACKTOP = sp;
 return $6 | 0;
}

function _mp_help_print_info_about_object($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 _mp_print_str(13344, 33624) | 0;
 $4 = $2;
 _mp_obj_print($4, 0);
 _mp_print_str(13344, 33627) | 0;
 $5 = $3;
 _mp_obj_print($5, 0);
 _mp_print_str(13344, 34812) | 0;
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_pop_except_jump($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $6 = $2 & 1;
 $5 = $6;
 $7 = $3;
 _emit_bc_pre($7, 0);
 $8 = $3;
 $9 = $4;
 _emit_write_bytecode_byte_unsigned_label($8, 68, $9);
 STACKTOP = sp;
 return;
}

function _mp_printf($0, $1, $varargs) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $varargs = $varargs | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $4 = sp;
 $2 = $0;
 $3 = $1;
 HEAP32[$4 >> 2] = $varargs;
 $6 = $2;
 $7 = $3;
 $8 = _mp_vprintf($6, $7, $4) | 0;
 $5 = $8;
 $9 = $5;
 STACKTOP = sp;
 return $9 | 0;
}

function _mp_emit_bc_raise_varargs($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = 0 - $5 | 0;
 _emit_bc_pre($4, $6);
 $7 = $2;
 $8 = $3;
 $9 = $8 & 255;
 _emit_write_bytecode_byte_byte($7, 92, $9);
 STACKTOP = sp;
 return;
}

function _mp_obj_str_intern_checked($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp + 4 | 0;
 $1 = $0;
 $4 = $1;
 $5 = _mp_obj_str_get_data($4, $2) | 0;
 $3 = $5;
 $6 = $3;
 $7 = HEAP32[$2 >> 2] | 0;
 $8 = _mp_obj_new_str_via_qstr($6, $7) | 0;
 STACKTOP = sp;
 return $8 | 0;
}

function _mp_get_buffer_raise($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $4;
 $8 = $5;
 $9 = _mp_get_buffer($6, $7, $8) | 0;
 if ($9) {
  STACKTOP = sp;
  return;
 } else {
  _mp_raise_TypeError(30720);
 }
}

function _mp_math_ldexp($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0.0, $6 = 0, $7 = 0, $8 = 0.0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = +_mp_obj_get_float($4);
 $6 = $3;
 $7 = _mp_obj_get_int($6) | 0;
 $8 = +_ldexp($5, $7);
 $9 = _mp_obj_new_float($8) | 0;
 STACKTOP = sp;
 return $9 | 0;
}

function _uctypes_struct_scalar_size($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $2;
 $4 = ($3 | 0) == 14;
 if ($4) {
  $1 = 4;
 } else {
  $5 = $2;
  $6 = $5 & 7;
  $7 = $6 >> 1;
  $8 = 1 << $7;
  $1 = $8;
 }
 $9 = $1;
 STACKTOP = sp;
 return $9 | 0;
}

function _nlr_jump($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = HEAP32[40568 >> 2] | 0;
 $2 = ($1 | 0) == (0 | 0);
 if ($2) {
  _nlr_jump_fail($0);
 } else {
  $3 = $1 + 4 | 0;
  HEAP32[$3 >> 2] = $0;
  $4 = $1 + 164 | 0;
  $5 = HEAP32[$4 >> 2] | 0;
  HEAP32[40556 >> 2] = $5;
  $6 = HEAP32[$1 >> 2] | 0;
  HEAP32[40568 >> 2] = $6;
  $7 = $1 + 8 | 0;
  _longjmp($7 | 0, 1);
 }
}

function _emit_write_bytecode_byte_uint($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $4;
 _emit_write_bytecode_byte($6, $7);
 $8 = $3;
 $9 = $5;
 _emit_write_uint($8, 492, $9);
 STACKTOP = sp;
 return;
}

function _mp_obj_dict_delete($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $4 = sp;
 $2 = $0;
 $3 = $1;
 $5 = $2;
 HEAP32[$4 >> 2] = $5;
 $6 = $4 + 4 | 0;
 $7 = $3;
 HEAP32[$6 >> 2] = $7;
 _dict_get_helper(2, $4, 2) | 0;
 $8 = $2;
 STACKTOP = sp;
 return $8 | 0;
}

function _set_symmetric_difference($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = _set_copy($5) | 0;
 $4 = $6;
 $7 = $4;
 $8 = $3;
 _set_symmetric_difference_update($7, $8) | 0;
 $9 = $4;
 STACKTOP = sp;
 return $9 | 0;
}

function _mp_emit_bc_last_emit_was_return_value($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 5 | 0;
 $4 = HEAPU8[$3 >> 0] | HEAPU8[$3 + 1 >> 0] << 8;
 $5 = ($4 & 65535) >>> 8;
 $6 = $5 & 65535;
 $7 = ($6 | 0) != 0;
 STACKTOP = sp;
 return $7 | 0;
}

function _compile_power($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 _compile_generic_all_nodes($4, $5);
 $6 = $2;
 $7 = $6 + 40 | 0;
 $8 = HEAP32[$7 >> 2] | 0;
 _mp_emit_bc_binary_op($8, 32);
 STACKTOP = sp;
 return;
}

function _compile_const_object($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 40 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 $8 = _get_const_object($7) | 0;
 _mp_emit_bc_load_const_obj($6, $8);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_unpack_sequence($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = -1 + $5 | 0;
 _emit_bc_pre($4, $6);
 $7 = $2;
 $8 = $3;
 _emit_write_bytecode_byte_uint($7, 89, $8);
 STACKTOP = sp;
 return;
}

function _tinf_skip_bytes($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 while (1) {
  $4 = $3;
  $5 = $4 + -1 | 0;
  $3 = $5;
  $6 = ($4 | 0) != 0;
  if (!$6) {
   break;
  }
  $7 = $2;
  _uzlib_get_byte($7) | 0;
 }
 STACKTOP = sp;
 return;
}

function _mpz_free($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != (0 | 0);
 if (!$3) {
  STACKTOP = sp;
  return;
 }
 $4 = $1;
 $5 = $4 + 8 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 _m_free($6);
 $7 = $1;
 _m_free($7);
 STACKTOP = sp;
 return;
}

function ___muldsi3($a, $b) {
 $a = $a | 0;
 $b = $b | 0;
 var $1 = 0, $2 = 0, $3 = 0, $6 = 0, $8 = 0, $11 = 0, $12 = 0;
 $1 = $a & 65535;
 $2 = $b & 65535;
 $3 = Math_imul($2, $1) | 0;
 $6 = $a >>> 16;
 $8 = ($3 >>> 16) + (Math_imul($2, $6) | 0) | 0;
 $11 = $b >>> 16;
 $12 = Math_imul($11, $1) | 0;
 return (setTempRet0((($8 >>> 16) + (Math_imul($11, $6) | 0) | 0) + ((($8 & 65535) + $12 | 0) >>> 16) | 0 | 0), 0 | ($8 + $12 << 16 | $3 & 65535)) | 0;
}

function _mp_builtin_setattr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $4;
 $8 = _mp_obj_str_get_qstr($7) | 0;
 $9 = $5;
 _mp_store_attr($6, $8, $9);
 STACKTOP = sp;
 return 17668 | 0;
}

function _poll_unregister($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $4 = $5;
 $6 = $4;
 $7 = $6 + 4 | 0;
 $8 = $3;
 $9 = _mp_obj_id($8) | 0;
 _mp_map_lookup($7, $9, 2) | 0;
 STACKTOP = sp;
 return 17668 | 0;
}

function _mp_parse_node_new_small_int_checked($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $3;
 $6 = $5;
 $7 = $6 >> 1;
 $4 = $7;
 $8 = $4;
 $9 = _mp_parse_node_new_small_int($8) | 0;
 STACKTOP = sp;
 return $9 | 0;
}

function _mp_ensure_not_fixed($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $4 >>> 1;
 $6 = $5 & 1;
 $7 = ($6 | 0) != 0;
 if ($7) {
  _mp_raise_TypeError(0);
 } else {
  STACKTOP = sp;
  return;
 }
}

function _mp_store_global($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = _mp_globals_get() | 0;
 $5 = $2;
 $6 = $5 << 2;
 $7 = $6 | 2;
 $8 = $7;
 $9 = $3;
 _mp_obj_dict_store($4, $8, $9) | 0;
 STACKTOP = sp;
 return;
}

function _mp_obj_new_float($0) {
 $0 = +$0;
 var $1 = 0.0, $2 = 0, $3 = 0, $4 = 0, $5 = 0.0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = _m_malloc(16) | 0;
 $2 = $3;
 $4 = $2;
 HEAP32[$4 >> 2] = 16252;
 $5 = $1;
 $6 = $2;
 $7 = $6 + 8 | 0;
 HEAPF64[$7 >> 3] = $5;
 $8 = $2;
 STACKTOP = sp;
 return $8 | 0;
}

function _mp_micropython_schedule($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _mp_sched_schedule($4, $5) | 0;
 if ($6) {
  STACKTOP = sp;
  return 17668 | 0;
 } else {
  _mp_raise_msg(15772, 33860);
 }
 return 0 | 0;
}

function _mp_store_name($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = _mp_locals_get() | 0;
 $5 = $2;
 $6 = $5 << 2;
 $7 = $6 | 2;
 $8 = $7;
 $9 = $3;
 _mp_obj_dict_store($4, $8, $9) | 0;
 STACKTOP = sp;
 return;
}

function _mp_obj_new_cell($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = _m_malloc(8) | 0;
 $2 = $3;
 $4 = $2;
 HEAP32[$4 >> 2] = 13932;
 $5 = $1;
 $6 = $2;
 $7 = $6 + 4 | 0;
 HEAP32[$7 >> 2] = $5;
 $8 = $2;
 STACKTOP = sp;
 return $8 | 0;
}

function _mp_emit_bc_unary_op($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 _emit_bc_pre($4, 0);
 $5 = $2;
 $6 = $3;
 $7 = 208 + $6 | 0;
 $8 = $7 & 255;
 _emit_write_bytecode_byte($5, $8);
 STACKTOP = sp;
 return;
}

function _is_char_following($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 20 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 $8 = $7 & 255;
 $9 = ($6 | 0) == ($8 | 0);
 STACKTOP = sp;
 return $9 | 0;
}

function _vstr_init_len($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = $5 + 1 | 0;
 _vstr_init($4, $6);
 $7 = $3;
 $8 = $2;
 $9 = $8 + 4 | 0;
 HEAP32[$9 >> 2] = $7;
 STACKTOP = sp;
 return;
}

function _pyexec_event_repl_init() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = _vstr_new(32) | 0;
 HEAP32[40720 >> 2] = $0;
 HEAP8[41654] = 0;
 HEAP8[41655] = 0;
 $1 = HEAP32[40720 >> 2] | 0;
 _readline_init($1, 41653);
 $2 = HEAP32[5566] | 0;
 $3 = ($2 | 0) == 0;
 if ($3) {
  _pyexec_raw_repl_process_char(1) | 0;
  return;
 } else {
  _pyexec_friendly_repl_process_char(2) | 0;
  return;
 }
}

function _memmove(dest, src, num) {
 dest = dest | 0;
 src = src | 0;
 num = num | 0;
 var ret = 0;
 if ((src | 0) < (dest | 0) & (dest | 0) < (src + num | 0)) {
  ret = dest;
  src = src + num | 0;
  dest = dest + num | 0;
  while ((num | 0) > 0) {
   dest = dest - 1 | 0;
   src = src - 1 | 0;
   num = num - 1 | 0;
   HEAP8[dest >> 0] = HEAP8[src >> 0] | 0;
  }
  dest = ret;
 } else {
  _memcpy(dest, src, num) | 0;
 }
 return dest | 0;
}

function _mp_obj_instance_is_callable($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp;
 $1 = $0;
 HEAP32[$2 >> 2] = 0 | 0;
 HEAP32[$2 + 4 >> 2] = 0 | 0;
 $3 = $1;
 $4 = _mp_obj_instance_get_call($3, $2) | 0;
 $5 = ($4 | 0) != (0 | 0);
 STACKTOP = sp;
 return $5 | 0;
}

function _polymorph_it_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $2 = $3;
 $4 = $2;
 $5 = $4 + 4 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $1;
 $8 = FUNCTION_TABLE_ii[$6 & 1023]($7) | 0;
 STACKTOP = sp;
 return $8 | 0;
}

function _emit_write_bytecode_byte($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = _emit_get_cur_to_write_bytecode($5, 1) | 0;
 $4 = $6;
 $7 = $3;
 $8 = $4;
 HEAP8[$8 >> 0] = $7;
 STACKTOP = sp;
 return;
}

function _mod_urandom_seed($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _mp_obj_get_int_truncated($3) | 0;
 $2 = $4;
 $5 = $2;
 HEAP32[5449] = $5;
 HEAP32[5448] = 69;
 HEAP32[5447] = 233;
 HEAP8[41652] = 0;
 STACKTOP = sp;
 return 17668 | 0;
}

function _mp_obj_new_str_via_qstr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _qstr_from_strn($4, $5) | 0;
 $7 = $6 << 2;
 $8 = $7 | 2;
 $9 = $8;
 STACKTOP = sp;
 return $9 | 0;
}

function _is_char($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $4 + 16 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $3;
 $8 = $7 & 255;
 $9 = ($6 | 0) == ($8 | 0);
 STACKTOP = sp;
 return $9 | 0;
}

function _mp_builtin_repr($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 8 | 0;
 $3 = sp;
 $1 = $0;
 _vstr_init_print($2, 16, $3);
 $4 = $1;
 _mp_obj_print_helper($3, $4, 1);
 $5 = _mp_obj_new_str_from_vstr(18680, $2) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_get_type_str($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_obj_get_type($2) | 0;
 $4 = $3 + 6 | 0;
 $5 = HEAP16[$4 >> 1] | 0;
 $6 = $5 & 65535;
 $7 = _qstr_str($6) | 0;
 STACKTOP = sp;
 return $7 | 0;
}

function _mod_ujson_dumps($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $2 = sp + 8 | 0;
 $3 = sp;
 $1 = $0;
 _vstr_init_print($2, 8, $3);
 $4 = $1;
 _mp_obj_print_helper($3, $4, 3);
 $5 = _mp_obj_new_str_from_vstr(18680, $2) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _time_sleep_us($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _mp_obj_get_int($3) | 0;
 $2 = $4;
 $5 = $2;
 $6 = ($5 | 0) > 0;
 if ($6) {
  $7 = $2;
  _mp_hal_delay_us($7);
 }
 STACKTOP = sp;
 return 17668 | 0;
}

function _time_sleep_ms($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _mp_obj_get_int($3) | 0;
 $2 = $4;
 $5 = $2;
 $6 = ($5 | 0) > 0;
 if ($6) {
  $7 = $2;
  _mp_hal_delay_ms($7);
 }
 STACKTOP = sp;
 return 17668 | 0;
}

function _set_union($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = _set_copy($5) | 0;
 $4 = $6;
 $7 = $4;
 $8 = $3;
 _set_update_int($7, $8);
 $9 = $4;
 STACKTOP = sp;
 return $9 | 0;
}

function _mp_builtin_min($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $4;
 $8 = $5;
 $9 = _mp_builtin_min_max($6, $7, $8, 0) | 0;
 STACKTOP = sp;
 return $9 | 0;
}

function _mp_builtin_max($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, $9 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $4;
 $8 = $5;
 $9 = _mp_builtin_min_max($6, $7, $8, 1) | 0;
 STACKTOP = sp;
 return $9 | 0;
}

function _emit_write_bytecode_byte_qstr($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $4;
 $8 = $5;
 _emit_write_bytecode_byte_uint($6, $7, $8);
 STACKTOP = sp;
 return;
}

function _compile_trailer_paren($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = $5 + 8 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 _compile_trailer_paren_helper($4, $7, 0, 0);
 STACKTOP = sp;
 return;
}

function _unichar_toupper($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $2;
 $4 = _unichar_islower($3) | 0;
 $5 = $2;
 if ($4) {
  $6 = $5 - 32 | 0;
  $1 = $6;
 } else {
  $1 = $5;
 }
 $7 = $1;
 STACKTOP = sp;
 return $7 | 0;
}

function _unichar_tolower($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $2;
 $4 = _unichar_isupper($3) | 0;
 $5 = $2;
 if ($4) {
  $6 = $5 + 32 | 0;
  $1 = $6;
 } else {
  $1 = $5;
 }
 $7 = $1;
 STACKTOP = sp;
 return $7 | 0;
}

function _is_tail_of_identifier($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _is_head_of_identifier($2) | 0;
 if ($3) {
  $6 = 1;
 } else {
  $4 = $1;
  $5 = _is_digit($4) | 0;
  $6 = $5;
 }
 STACKTOP = sp;
 return $6 | 0;
}

function _compile_import_name($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = $5 + 8 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 _apply_to_single_or_list($4, $7, 106, 490);
 STACKTOP = sp;
 return;
}

function _compile_del_stmt($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = $5 + 8 | 0;
 $7 = HEAP32[$6 >> 2] | 0;
 _apply_to_single_or_list($4, $7, 155, 489);
 STACKTOP = sp;
 return;
}

function _uctypes_struct_addressof($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp;
 $1 = $0;
 $3 = $1;
 _mp_get_buffer_raise($3, $2, 1);
 $4 = HEAP32[$2 >> 2] | 0;
 $5 = $4;
 $6 = _mp_obj_new_int($5) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _check_stringio_is_open($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = ($4 | 0) == (0 | 0);
 if ($5) {
  _mp_raise_ValueError(32868);
 } else {
  STACKTOP = sp;
  return;
 }
}

function _mp_emit_glue_new_raw_code() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = _m_malloc0(12) | 0;
 $0 = $1;
 $2 = $0;
 $3 = HEAP32[$2 >> 2] | 0;
 $4 = $3 & -8;
 $5 = $4 | 1;
 HEAP32[$2 >> 2] = $5;
 $6 = $0;
 STACKTOP = sp;
 return $6 | 0;
}

function _set_discard($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $4 = $5;
 $6 = $4;
 $7 = $6 + 4 | 0;
 $8 = $3;
 _mp_set_lookup($7, $8, 2) | 0;
 STACKTOP = sp;
 return 17668 | 0;
}

function _qstr_len($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _find_qstr($3) | 0;
 $2 = $4;
 $5 = $2;
 $6 = $5 + 2 | 0;
 $7 = HEAP8[$6 >> 0] | 0;
 $8 = $7 & 255;
 STACKTOP = sp;
 return $8 | 0;
}

function _mp_stream_write_adaptor($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $4;
 $8 = $5;
 _mp_stream_write($6, $7, $8, 2) | 0;
 STACKTOP = sp;
 return;
}

function _mp_builtin_isinstance($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = _mp_obj_get_type($4) | 0;
 $6 = $3;
 $7 = _mp_obj_is_subclass($5, $6) | 0;
 STACKTOP = sp;
 return $7 | 0;
}

function _mp_emit_bc_for_iter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 _emit_bc_pre($4, 1);
 $5 = $2;
 $6 = $3;
 _emit_write_bytecode_byte_unsigned_label($5, 67, $6);
 STACKTOP = sp;
 return;
}

function _vstr_add_byte($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $6 = _vstr_add_len($5, 1) | 0;
 $4 = $6;
 $7 = $3;
 $8 = $4;
 HEAP8[$8 >> 0] = $7;
 STACKTOP = sp;
 return;
}

function _set_add($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $4 = $5;
 $6 = $4;
 $7 = $6 + 4 | 0;
 $8 = $3;
 _mp_set_lookup($7, $8, 1) | 0;
 STACKTOP = sp;
 return 17668 | 0;
}

function _mp_pystack_init($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 HEAP32[40548 >> 2] = $4;
 $5 = $3;
 HEAP32[40552 >> 2] = $5;
 $6 = $2;
 HEAP32[40556 >> 2] = $6;
 STACKTOP = sp;
 return;
}

function _mp_obj_set_store($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $4 = $5;
 $6 = $4;
 $7 = $6 + 4 | 0;
 $8 = $3;
 _mp_set_lookup($7, $8, 1) | 0;
 STACKTOP = sp;
 return;
}

function _mp_nonlocal_realloc($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $3;
 $7 = $5;
 _mp_pystack_realloc($6, $7);
 $8 = $3;
 STACKTOP = sp;
 return $8 | 0;
}

function _mp_emit_bc_load_const_str($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 _emit_bc_pre($4, 1);
 $5 = $2;
 $6 = $3;
 _emit_write_bytecode_byte_qstr($5, 22, $6);
 STACKTOP = sp;
 return;
}

function _mp_obj_dict_init($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 HEAP32[$4 >> 2] = 14112;
 $5 = $2;
 $6 = $5 + 4 | 0;
 $7 = $3;
 _mp_map_init($6, $7);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_load_const_obj($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 _emit_bc_pre($4, 1);
 $5 = $2;
 $6 = $3;
 _emit_write_bytecode_byte_obj($5, 23, $6);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_jump($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 _emit_bc_pre($4, 0);
 $5 = $2;
 $6 = $3;
 _emit_write_bytecode_byte_signed_label($5, 53, $6);
 STACKTOP = sp;
 return;
}

function _mp_builtin_bin($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp;
 $1 = $0;
 HEAP32[$2 >> 2] = 830;
 $3 = $2 + 4 | 0;
 $4 = $1;
 HEAP32[$3 >> 2] = $4;
 $5 = _mp_obj_str_format(2, $2, 0) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _emit_write_code_info_byte($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = $2;
 $6 = _emit_get_cur_to_write_code_info($5, 1) | 0;
 HEAP8[$6 >> 0] = $4;
 STACKTOP = sp;
 return;
}

function _mp_obj_list_set_len($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $4 = $5;
 $6 = $3;
 $7 = $4;
 $8 = $7 + 8 | 0;
 HEAP32[$8 >> 2] = $6;
 STACKTOP = sp;
 return;
}

function _mp_obj_cell_set($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, $8 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $5 = $2;
 $4 = $5;
 $6 = $3;
 $7 = $4;
 $8 = $7 + 4 | 0;
 HEAP32[$8 >> 2] = $6;
 STACKTOP = sp;
 return;
}

function _mp_obj_int_new_mpz() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = _m_malloc(16) | 0;
 $0 = $1;
 $2 = $0;
 HEAP32[$2 >> 2] = 16904;
 $3 = $0;
 $4 = $3 + 4 | 0;
 _mpz_init_zero($4);
 $5 = $0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_hal_set_interrupt_char($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != -1;
 if ($3) {
  _mp_obj_exception_clear_traceback(40592);
 }
 $4 = $1;
 HEAP32[5565] = $4;
 STACKTOP = sp;
 return;
}

function _mp_delete_global($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = _mp_globals_get() | 0;
 $3 = $1;
 $4 = $3 << 2;
 $5 = $4 | 2;
 $6 = $5;
 _mp_obj_dict_delete($2, $6) | 0;
 STACKTOP = sp;
 return;
}

function _mp_obj_is_package($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = sp;
 $1 = $0;
 $3 = $1;
 _mp_load_method_maybe($3, 195, $2);
 $4 = HEAP32[$2 >> 2] | 0;
 $5 = ($4 | 0) != (0 | 0);
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_math_trunc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0.0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = +_mp_obj_get_float($2);
 $4 = +_llvm_trunc_f64(+$3);
 $5 = _mp_obj_new_int_from_float($4) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_new_exception_arg1($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = sp;
 $2 = $0;
 HEAP32[$3 >> 2] = $1;
 $4 = $2;
 $5 = _mp_obj_new_exception_args($4, 1, $3) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_delete_name($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = _mp_locals_get() | 0;
 $3 = $1;
 $4 = $3 << 2;
 $5 = $4 | 2;
 $6 = $5;
 _mp_obj_dict_delete($2, $6) | 0;
 STACKTOP = sp;
 return;
}

function _mp_builtin_callable($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $2;
 $4 = _mp_obj_is_callable($3) | 0;
 if ($4) {
  $1 = 13864;
 } else {
  $1 = 13856;
 }
 $5 = $1;
 STACKTOP = sp;
 return $5 | 0;
}

function _dict_clear($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $2 = $3;
 $4 = $2;
 _mp_ensure_not_fixed($4);
 $5 = $2;
 $6 = $5 + 4 | 0;
 _mp_map_clear($6);
 STACKTOP = sp;
 return 17668 | 0;
}

function _plat_print_strn($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 $6 = $4;
 $7 = $5;
 _mp_hal_stdout_tx_strn_cooked($6, $7);
 STACKTOP = sp;
 return;
}

function _mp_math_radians($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0.0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = +_mp_obj_get_float($2);
 $4 = $3 * .017453292519943295;
 $5 = _mp_obj_new_float($4) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _vstr_add_str($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = $3;
 $7 = _strlen($6) | 0;
 _vstr_add_strn($4, $5, $7);
 STACKTOP = sp;
 return;
}

function _snprintf($0, $1, $2, $varargs) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 $varargs = $varargs | 0;
 var $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = sp;
 HEAP32[$3 >> 2] = $varargs;
 $4 = _vsnprintf($0, $1, $2, $3) | 0;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_code_get_name($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_decode_uint_skip($2) | 0;
 $1 = $3;
 $4 = $1;
 $5 = _mp_decode_uint_value($4) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_math_floor($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0.0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = +_mp_obj_get_float($2);
 $4 = +Math_floor(+$3);
 $5 = _mp_obj_new_int_from_float($4) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_dict_len($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $2 = $3;
 $4 = $2;
 $5 = $4 + 4 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 $7 = $6 >>> 3;
 STACKTOP = sp;
 return $7 | 0;
}

function _mp_math_degrees($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0.0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = +_mp_obj_get_float($2);
 $4 = $3 * 57.29577951308232;
 $5 = _mp_obj_new_float($4) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_math_ceil($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0.0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = +_mp_obj_get_float($2);
 $4 = +Math_ceil(+$3);
 $5 = _mp_obj_new_int_from_float($4) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_sys_print_exception($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = HEAP32[$4 >> 2] | 0;
 _mp_obj_print_exception(13344, $5);
 STACKTOP = sp;
 return 17668 | 0;
}

function _mp_call_function_1($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = sp;
 $2 = $0;
 HEAP32[$3 >> 2] = $1;
 $4 = $2;
 $5 = _mp_call_function_n_kw($4, 1, 0, $3) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mpz_init_from_int($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 _mpz_init_zero($4);
 $5 = $2;
 $6 = $3;
 _mpz_set_from_int($5, $6);
 STACKTOP = sp;
 return;
}

function _time_sleep($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0.0, $4 = 0.0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = +_mp_obj_get_float($2);
 $4 = 1.0e3 * $3;
 $5 = ~~$4 >>> 0;
 _mp_hal_delay_ms($5);
 STACKTOP = sp;
 return 17668 | 0;
}

function _qstr_str($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _find_qstr($3) | 0;
 $2 = $4;
 $5 = $2;
 $6 = $5 + 2 | 0;
 $7 = $6 + 1 | 0;
 STACKTOP = sp;
 return $7 | 0;
}

function _mp_obj_new_dict($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = _m_malloc(16) | 0;
 $2 = $3;
 $4 = $2;
 $5 = $1;
 _mp_obj_dict_init($4, $5);
 $6 = $2;
 STACKTOP = sp;
 return $6 | 0;
}

function _stringio___exit__($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = HEAP32[$4 >> 2] | 0;
 $6 = _mp_stream_close($5) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _set_issuperset_proper($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = $2;
 $6 = _set_issubset_internal($4, $5, 1) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _compile_scope_lambda_param($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 _compile_scope_func_lambda_param($4, $5, 77, 78, 79);
 STACKTOP = sp;
 return;
}

function _set_issubset_proper($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _set_issubset_internal($4, $5, 1) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _printf($0, $varargs) {
 $0 = $0 | 0;
 $varargs = $varargs | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = sp;
 HEAP32[$1 >> 2] = $varargs;
 $2 = HEAP32[5586] | 0;
 $3 = _vfprintf($2, $0, $1) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _compile_scope_func_param($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 _compile_scope_func_lambda_param($4, $5, 69, 70, 71);
 STACKTOP = sp;
 return;
}

function _comp_next_label($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 16 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $4 + 1 | 0;
 HEAP32[$3 >> 2] = $5;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bytes($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _mp_obj_new_str_copy(18304, $4, $5) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _set_intersect_update($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _set_intersect_int($4, $5, 1) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _list_new($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = _m_malloc(16) | 0;
 $2 = $3;
 $4 = $2;
 $5 = $1;
 _mp_obj_list_init($4, $5);
 $6 = $2;
 STACKTOP = sp;
 return $6 | 0;
}

function _mp_parse_node_new_leaf($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, $7 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = $5 << 4;
 $7 = $4 | $6;
 STACKTOP = sp;
 return $7 | 0;
}

function _mp_builtin_delattr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _mp_builtin_setattr($4, $5, 0) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _list_getiter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _mp_obj_new_list_iterator($4, 0, $5) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _set_issuperset($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $3;
 $5 = $2;
 $6 = _set_issubset_internal($4, $5, 0) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _mp_builtin_execfile($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _eval_exec_helper($4, $5, 0) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _compile_star_expr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = $5;
 _compile_syntax_error($4, $6, 29098);
 STACKTOP = sp;
 return;
}

function _mp_raise_OSError($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 << 1;
 $4 = $3 | 1;
 $5 = $4;
 $6 = _mp_obj_new_exception_arg1(14796, $5) | 0;
 _nlr_jump($6);
}

function _mp_pystack_realloc($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 _mp_pystack_free_745($4);
 $5 = $3;
 _mp_pystack_alloc($5) | 0;
 STACKTOP = sp;
 return;
}

function _is_following_digit($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 20 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = _unichar_isdigit($4) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _set_issubset($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _set_issubset_internal($4, $5, 0) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _mp_obj_int_as_float_impl($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $2 = $3;
 $4 = $2;
 $5 = $4 + 4 | 0;
 $6 = +_mpz_as_float($5);
 STACKTOP = sp;
 return +$6;
}

function _mp_math_copysign($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _math_generic_2($4, $5, 549) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _mp_obj_is_exception_instance($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_obj_get_type($2) | 0;
 $4 = _mp_obj_is_exception_type($3) | 0;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_builtin_exec($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _eval_exec_helper($4, $5, 1) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _mp_builtin_eval($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _eval_exec_helper($4, $5, 2) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _gc_mem_alloc() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $0 = sp;
 _gc_info($0);
 $1 = $0 + 4 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 $3 = $2 << 1;
 $4 = $3 | 1;
 $5 = $4;
 STACKTOP = sp;
 return $5 | 0;
}

function _vstr_new($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = _m_malloc(16) | 0;
 $2 = $3;
 $4 = $2;
 $5 = $1;
 _vstr_init($4, $5);
 $6 = $2;
 STACKTOP = sp;
 return $6 | 0;
}

function _stream_read($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _stream_read_generic($4, $5, 0) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _str_rpartition($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _str_partitioner($4, $5, -1) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _set_intersect($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _set_intersect_int($4, $5, 0) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _mp_emit_common_get_id_for_load($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 _scope_find_or_add_id($4, $5, 1) | 0;
 STACKTOP = sp;
 return;
}

function _mp_builtin_divmod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _mp_binary_op(33, $4, $5) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _gc_mem_free() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 32 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(32 | 0);
 $0 = sp;
 _gc_info($0);
 $1 = $0 + 8 | 0;
 $2 = HEAP32[$1 >> 2] | 0;
 $3 = $2 << 1;
 $4 = $3 | 1;
 $5 = $4;
 STACKTOP = sp;
 return $5 | 0;
}

function _dict_setdefault($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _dict_get_helper($4, $5, 1) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _mp_math_atan2($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _math_generic_2($4, $5, 550) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _mp_get_stream_1520($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = HEAP32[$2 >> 2] | 0;
 $4 = $3 + 48 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _is_whitespace($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 16 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = _unichar_isspace($4) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _str_partition($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _str_partitioner($4, $5, 1) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _mp_math_fmod($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _math_generic_2($4, $5, 547) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _indent_pop($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 48 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $4 - 1 | 0;
 HEAP32[$3 >> 2] = $5;
 STACKTOP = sp;
 return;
}

function _mp_math_pow($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _math_generic_2($4, $5, 567) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _emit_bc_free($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 28 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 _m_free($4);
 $5 = $1;
 _m_free($5);
 STACKTOP = sp;
 return;
}

function _copysign_func($0, $1) {
 $0 = +$0;
 $1 = +$1;
 var $2 = 0.0, $3 = 0.0, $4 = 0.0, $5 = 0.0, $6 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = +_llvm_copysign_f64(+$4, +$5);
 STACKTOP = sp;
 return +$6;
}

function _mp_obj_cell_get($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $2 = $3;
 $4 = $2;
 $5 = $4 + 4 | 0;
 $6 = HEAP32[$5 >> 2] | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _dict_view($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _mp_obj_new_dict_view($4, $5) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _scope_free($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 44 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 _m_free($4);
 $5 = $1;
 _m_free($5);
 STACKTOP = sp;
 return;
}

function _is_physical_newline($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 16 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = ($4 | 0) == 10;
 STACKTOP = sp;
 return $5 | 0;
}

function _is_letter($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 16 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = _unichar_isalpha($4) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _str_rindex($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _str_finder($4, $5, -1, 1) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _mp_obj_float_get($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $2 = $3;
 $4 = $2;
 $5 = $4 + 8 | 0;
 $6 = +HEAPF64[$5 >> 3];
 STACKTOP = sp;
 return +$6;
}

function _mp_get_stream($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = HEAP32[$2 >> 2] | 0;
 $4 = $3 + 48 | 0;
 $5 = HEAP32[$4 >> 2] | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mod_re_search($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _mod_re_exec(0, $4, $5) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _is_digit($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 16 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = _unichar_isdigit($4) | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _str_rstrip($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _str_uni_strip(1, $4, $5) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _str_rfind($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _str_finder($4, $5, -1, 0) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _str_lstrip($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _str_uni_strip(0, $4, $5) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _mod_re_match($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _mod_re_exec(1, $4, $5) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _dict_pop($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _dict_get_helper($4, $5, 2) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _dict_get($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _dict_get_helper($4, $5, 0) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _str_strip($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _str_uni_strip(2, $4, $5) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _str_index($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _str_finder($4, $5, 1, 1) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _str_find($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _str_finder($4, $5, 1, 0) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _set_diff($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _set_diff_int($4, $5, 0) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _mpz_is_zero_1033($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _compile_atom_brace($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 _compile_atom_brace_helper($4, $5, 1);
 STACKTOP = sp;
 return;
}

function _emit_write_code_info_uint($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 _emit_write_uint($4, 493, $5);
 STACKTOP = sp;
 return;
}

function _emit_write_code_info_qstr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 _emit_write_uint($4, 493, $5);
 STACKTOP = sp;
 return;
}

function _set_diff_update($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 _set_diff_int($4, $5, 1) | 0;
 STACKTOP = sp;
 return 17668 | 0;
}

function _re_search($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _ure_exec(0, $4, $5) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _re_match($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 $6 = _ure_exec(1, $4, $5) | 0;
 STACKTOP = sp;
 return $6 | 0;
}

function _mpz_is_zero($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mpz_max_num_bits($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $4 << 4;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_hal_stdout_tx_strn($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 _mp_js_write($4 | 0, $5 | 0);
 STACKTOP = sp;
 return;
}

function _nlr_pop() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $0 = 40568;
 $1 = $0;
 $2 = HEAP32[$1 >> 2] | 0;
 $3 = HEAP32[$2 >> 2] | 0;
 $4 = $0;
 HEAP32[$4 >> 2] = $3;
 STACKTOP = sp;
 return;
}

function _mp_micropython_kbd_intr($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_obj_get_int($2) | 0;
 _mp_hal_set_interrupt_char($3);
 STACKTOP = sp;
 return 17668 | 0;
}

function _is_end($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 16 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = ($4 | 0) == -1;
 STACKTOP = sp;
 return $5 | 0;
}

function _emit_bc_pre($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 _mp_emit_bc_adjust_stack_size($4, $5);
 STACKTOP = sp;
 return;
}

function _mp_obj_print($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 _mp_obj_print_helper(13344, $4, $5);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_load_build_class($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _emit_bc_pre($2, 1);
 $3 = $1;
 _emit_write_bytecode_byte($3, 32);
 STACKTOP = sp;
 return;
}

function _mp_hal_stdout_tx_str($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $1;
 $4 = _strlen($3) | 0;
 _mp_hal_stdout_tx_strn($2, $4);
 STACKTOP = sp;
 return;
}

function _get_const_object($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 8 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 $5 = $4;
 STACKTOP = sp;
 return $5 | 0;
}

function _set_clear($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $2 = $3;
 $4 = $2;
 $5 = $4 + 4 | 0;
 _mp_set_clear($5);
 STACKTOP = sp;
 return 17668 | 0;
}

function _mp_obj_is_small_int_1472($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_small_int_1399($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_small_int_1277($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_small_int_1220($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_small_int_1205($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_small_int_1155($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_small_int_1030($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_small_int_1012($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_small_int_909($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_small_int_831($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_small_int_784($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_small_int_727($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_small_int_558($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_emit_bc_end_finally($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _emit_bc_pre($2, -1);
 $3 = $1;
 _emit_write_bytecode_byte($3, 65);
 STACKTOP = sp;
 return;
}

function _mp_obj_module_get_globals_1371($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_module_get_globals_1357($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_emit_bc_dup_top_two($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _emit_bc_pre($2, 2);
 $3 = $1;
 _emit_write_bytecode_byte($3, 49);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_store_map($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _emit_bc_pre($2, -2);
 $3 = $1;
 _emit_write_bytecode_byte($3, 84);
 STACKTOP = sp;
 return;
}

function _compile_generic_tuple($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 $5 = $3;
 _c_tuple($4, 0, $5);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_rot_three($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _emit_bc_pre($2, 0);
 $3 = $1;
 _emit_write_bytecode_byte($3, 52);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_load_null($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _emit_bc_pre($2, 1);
 $3 = $1;
 _emit_write_bytecode_byte($3, 24);
 STACKTOP = sp;
 return;
}

function _js_sleep($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_obj_get_int($2) | 0;
 _emscripten_sleep_with_yield($3 | 0);
 STACKTOP = sp;
 return 17668 | 0;
}

function _testSetjmp(id, table, size) {
 id = id | 0;
 table = table | 0;
 size = size | 0;
 var i = 0, curr = 0;
 while ((i | 0) < (size | 0)) {
  curr = HEAP32[table + (i << 3) >> 2] | 0;
  if ((curr | 0) == 0) break;
  if ((curr | 0) == (id | 0)) {
   return HEAP32[table + ((i << 3) + 4) >> 2] | 0;
  }
  i = i + 1 | 0;
 }
 return 0;
}

function _mp_obj_is_small_int($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 1;
 $5 = ($4 | 0) != 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_qstr_1390($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 2;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_qstr_1222($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 2;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_qstr_1200($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 2;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_qstr_1128($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 2;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_qstr_1088($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 2;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_qstr_1015($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 2;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_emit_bc_pop_top($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _emit_bc_pre($2, -1);
 $3 = $1;
 _emit_write_bytecode_byte($3, 50);
 STACKTOP = sp;
 return;
}

function _mp_obj_is_qstr_863($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 2;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_qstr_785($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 2;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_qstr_780($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 2;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_qstr_728($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 2;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1523($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1471($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1391($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1366($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1345($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1260($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1239($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1221($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1201($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1154($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1105($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1095($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1089($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1079($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1061($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1037($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_1014($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_emit_bc_rot_two($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _emit_bc_pre($2, 0);
 $3 = $1;
 _emit_write_bytecode_byte($3, 51);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_dup_top($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _emit_bc_pre($2, 1);
 $3 = $1;
 _emit_write_bytecode_byte($3, 48);
 STACKTOP = sp;
 return;
}

function _mp_obj_module_get_globals($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_is_obj_963($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_949($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_883($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_864($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_817($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_786($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_781($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_729($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_568($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_is_obj_559($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _m_malloc_maybe($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _gc_alloc($3, 0) | 0;
 $2 = $4;
 $5 = $2;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_new_bool_1414($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bool_1404($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bool_1400($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bool_1243($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bool_1208($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bool_1159($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bool_1106($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bool_1096($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bool_1064($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bool_1034($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_is_qstr($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 2;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_new_bool_971($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bool_892($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bool_859($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bool_840($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_bool_832($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_is_obj($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2;
 $4 = $3 & 3;
 $5 = ($4 | 0) == 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _bitshift64Ashr(low, high, bits) {
 low = low | 0;
 high = high | 0;
 bits = bits | 0;
 var ander = 0;
 if ((bits | 0) < 32) {
  ander = (1 << bits) - 1 | 0;
  setTempRet0(high >> bits | 0);
  return low >>> bits | (high & ander) << 32 - bits;
 }
 setTempRet0(((high | 0) < 0 ? -1 : 0) | 0);
 return high >> bits - 32 | 0;
}

function _mp_obj_property_get($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $2 = $3;
 $4 = $2;
 $5 = $4 + 4 | 0;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_obj_new_bool($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ($2 | 0) != 0;
 $4 = $3 ? 13864 : 13856;
 STACKTOP = sp;
 return $4 | 0;
}

function _m_malloc0($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $4 = _m_malloc($3) | 0;
 $2 = $4;
 $5 = $2;
 STACKTOP = sp;
 return $5 | 0;
}

function _mp_stack_usage() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $0 = sp;
 $1 = HEAP32[10136] | 0;
 $2 = $1;
 $3 = $0;
 $4 = $2 - $3 | 0;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_parse_node_new_small_int_582($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 << 1;
 $4 = 1 | $3;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_obj_new_exception($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_obj_new_exception_args($2, 0, 0) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _gen_instance_iternext($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _gen_resume_and_raise($2, 17668, 0) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _vstr_len_1566($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_js_process_char($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _pyexec_event_repl_process_char($2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_call_function_0($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_call_function_n_kw($2, 0, 0, 0) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_parse_node_new_small_int($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 << 1;
 $4 = 1 | $3;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_nonlocal_free($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 _mp_pystack_free_745($4);
 STACKTOP = sp;
 return;
}

function _mp_builtin_open($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $3 = $0;
 $4 = $1;
 $5 = $2;
 STACKTOP = sp;
 return 17668 | 0;
}

function _vstr_str($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 8 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 STACKTOP = sp;
 return $4 | 0;
}

function _vstr_len($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 $4 = HEAP32[$3 >> 2] | 0;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_decode_uint_value($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = sp;
 HEAP32[$1 >> 2] = $0;
 $2 = _mp_decode_uint($1) | 0;
 STACKTOP = sp;
 return $2 | 0;
}

function _bitshift64Shl(low, high, bits) {
 low = low | 0;
 high = high | 0;
 bits = bits | 0;
 var ander = 0;
 if ((bits | 0) < 32) {
  ander = (1 << bits) - 1 | 0;
  setTempRet0(high << bits | (low & ander << 32 - bits) >>> 32 - bits | 0);
  return low << bits;
 }
 setTempRet0(low << bits - 32 | 0);
 return 0;
}

function _mp_emit_bc_start_except_handler($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _mp_emit_bc_adjust_stack_size($2, 4);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_end_except_handler($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _mp_emit_bc_adjust_stack_size($2, -3);
 STACKTOP = sp;
 return;
}

function _mp_local_alloc_1491($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_pystack_alloc($2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_local_alloc_1352($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_pystack_alloc($2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_builtin_oct($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_binary_op(31, 822, $2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_builtin_hex($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_binary_op(31, 826, $2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _bitshift64Lshr(low, high, bits) {
 low = low | 0;
 high = high | 0;
 bits = bits | 0;
 var ander = 0;
 if ((bits | 0) < 32) {
  ander = (1 << bits) - 1 | 0;
  setTempRet0(high >>> bits | 0);
  return low >>> bits | (high & ander) << 32 - bits;
 }
 setTempRet0(0 | 0);
 return high >>> bits - 32 | 0;
}

function _mp_obj_tuple_del($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $3 = $1;
 $2 = $3;
 $4 = $2;
 _m_free($4);
 STACKTOP = sp;
 return;
}

function _mp_local_alloc_752($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_pystack_alloc($2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_nonlocal_alloc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_pystack_alloc($2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_lgamma($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 543) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_log10($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 563) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_gamma($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 544) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_expm1($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 565) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_atanh($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 557) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_asinh($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 558) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_acosh($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 559) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_import_stat_any($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_import_stat($2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _vstr_reset_1555($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 HEAP32[$3 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _vstr_reset_1488($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 HEAP32[$3 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _vstr_reset_1359($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 HEAP32[$3 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _mp_math_tanh($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 560) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_sqrt($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 568) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_sinh($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 561) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_log2($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 564) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_fabs($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 548) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_erfc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 545) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_cosh($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 562) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_atan($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 551) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_asin($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 552) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_acos($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 553) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _str_isupper($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _str_uni_istype(522, $2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _str_isspace($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _str_uni_istype(525, $2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _str_islower($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _str_uni_istype(521, $2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _str_isdigit($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _str_uni_istype(523, $2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _str_isalpha($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _str_uni_istype(524, $2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_tan($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 554) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_sin($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 555) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_exp($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 566) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_erf($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 546) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_math_cos($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _math_generic_1($2, 556) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_local_alloc($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_pystack_alloc($2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_identity_getiter($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 $4 = $2;
 STACKTOP = sp;
 return $4 | 0;
}

function _mp_builtin_hash($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_unary_op(6, $2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_builtin_iter($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_getiter($2, 0) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_builtin_abs($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _mp_unary_op(7, $2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _vstr_reset($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 HEAP32[$3 >> 2] = 0;
 STACKTOP = sp;
 return;
}

function _str_upper($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _str_caseconv(526, $2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _str_lower($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _str_caseconv(527, $2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _dict_values($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _dict_view($2, 2) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function ___syscall_ret($0) {
 $0 = $0 | 0;
 var $$0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = $0 >>> 0 > 4294963200;
 if ($1) {
  $2 = 0 - $0 | 0;
  $3 = ___errno_location() | 0;
  HEAP32[$3 >> 2] = $2;
  $$0 = -1;
 } else {
  $$0 = $0;
 }
 return $$0 | 0;
}

function _dict_items($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _dict_view($2, 0) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _strchr($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, $4 = 0, $5 = 0, $6 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = ___strchrnul($0, $1) | 0;
 $3 = HEAP8[$2 >> 0] | 0;
 $4 = $1 & 255;
 $5 = $3 << 24 >> 24 == $4 << 24 >> 24;
 $6 = $5 ? $2 : 0;
 return $6 | 0;
}

function _mp_js_do_str($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _do_str($2, 1) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _dict_keys($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = _dict_view($2, 1) | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_obj_dict_get_map($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = $2 + 4 | 0;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_pystack_free_1494($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 HEAP32[40556 >> 2] = $2;
 STACKTOP = sp;
 return;
}

function _mp_pystack_free_1360($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 HEAP32[40556 >> 2] = $2;
 STACKTOP = sp;
 return;
}

function _mp_local_free_1493($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _mp_pystack_free_1494($2);
 STACKTOP = sp;
 return;
}

function _mp_local_free_1353($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _mp_pystack_free_1360($2);
 STACKTOP = sp;
 return;
}

function _mp_hal_erase_line_from_cursor($0) {
 $0 = $0 | 0;
 var $1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 _mp_hal_stdout_tx_strn(35328, 3);
 STACKTOP = sp;
 return;
}

function _mp_emit_bc_for_iter_end($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _emit_bc_pre($2, -4);
 STACKTOP = sp;
 return;
}

function _fabs_func($0) {
 $0 = +$0;
 var $1 = 0.0, $2 = 0.0, $3 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = +Math_abs(+$2);
 STACKTOP = sp;
 return +$3;
}

function _mp_pystack_free_990($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 HEAP32[40556 >> 2] = $2;
 STACKTOP = sp;
 return;
}

function _mp_pystack_free_847($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 HEAP32[40556 >> 2] = $2;
 STACKTOP = sp;
 return;
}

function _mp_pystack_free_745($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 HEAP32[40556 >> 2] = $2;
 STACKTOP = sp;
 return;
}

function _mp_globals_set_1367($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 HEAP32[40564 >> 2] = $2;
 STACKTOP = sp;
 return;
}

function _mp_globals_set_1004($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 HEAP32[40564 >> 2] = $2;
 STACKTOP = sp;
 return;
}

function _mp_float_hash_972($0) {
 $0 = +$0;
 var $1 = 0.0, $2 = 0.0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ~~$2;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_locals_set_1383($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 HEAP32[40560 >> 2] = $2;
 STACKTOP = sp;
 return;
}

function _mp_locals_set_1368($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 HEAP32[40560 >> 2] = $2;
 STACKTOP = sp;
 return;
}

function _mp_local_free_753($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _mp_pystack_free_745($2);
 STACKTOP = sp;
 return;
}

function _mp_globals_set_989($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 HEAP32[40564 >> 2] = $2;
 STACKTOP = sp;
 return;
}

function _mp_module_call_init_1354($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 STACKTOP = sp;
 return;
}

function _mp_pystack_free($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 HEAP32[40556 >> 2] = $2;
 STACKTOP = sp;
 return;
}

function _mp_float_hash($0) {
 $0 = +$0;
 var $1 = 0.0, $2 = 0.0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 $3 = ~~$2;
 STACKTOP = sp;
 return $3 | 0;
}

function _mp_globals_set($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 HEAP32[40564 >> 2] = $2;
 STACKTOP = sp;
 return;
}

function _mp_locals_set($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 HEAP32[40560 >> 2] = $2;
 STACKTOP = sp;
 return;
}

function _mp_module_call_init($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $2 = $0;
 $3 = $1;
 STACKTOP = sp;
 return;
}

function _mp_local_free($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _mp_pystack_free($2);
 STACKTOP = sp;
 return;
}

function _emit_bc_new() {
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = _m_malloc0(56) | 0;
 $0 = $1;
 $2 = $0;
 STACKTOP = sp;
 return $2 | 0;
}

function ___expo2($0) {
 $0 = +$0;
 var $1 = 0.0, $2 = 0.0, $3 = 0.0, $4 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = $0 + -1416.0996898839683;
 $2 = +_exp($1);
 $3 = $2 * 2247116418577894884661631.0e283;
 $4 = $3 * 2247116418577894884661631.0e283;
 return +$4;
}

function _mp_raise_NotImplementedError($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _mp_raise_msg(15832, $2);
}

function _mp_keyboard_interrupt() {
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAP32[40624 >> 2] = 40592;
 $0 = HEAP16[40740 >> 1] | 0;
 $1 = $0 << 16 >> 16;
 $2 = ($1 | 0) == 1;
 if (!$2) {
  return;
 }
 HEAP16[40740 >> 1] = 0;
 return;
}

function ___DOUBLE_BITS_378($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 setTempRet0($2 | 0);
 return $1 | 0;
}

function ___DOUBLE_BITS_149($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 setTempRet0($2 | 0);
 return $1 | 0;
}

function ___DOUBLE_BITS_15($0) {
 $0 = +$0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAPF64[tempDoublePtr >> 3] = $0;
 $1 = HEAP32[tempDoublePtr >> 2] | 0;
 $2 = HEAP32[tempDoublePtr + 4 >> 2] | 0;
 setTempRet0($2 | 0);
 return $1 | 0;
}

function _mp_raise_ValueError($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _mp_raise_msg(16072, $2);
}

function _m_free($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _gc_free($2);
 STACKTOP = sp;
 return;
}

function _mp_raise_TypeError($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 _mp_raise_msg(16012, $2);
}

function _out($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, $4 = 0, $5 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $3 = HEAP32[$0 >> 2] | 0;
 $4 = $3 & 32;
 $5 = ($4 | 0) == 0;
 if ($5) {
  ___fwritex($1, $2, $0) | 0;
 }
 return;
}

function _mp_identity($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 $2 = $1;
 STACKTOP = sp;
 return $2 | 0;
}

function _mp_lexer_new_from_file($0) {
 $0 = $0 | 0;
 var $1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 _mp_raise_OSError(2);
 return 0 | 0;
}

function _wctomb($0, $1) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 var $$0 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = ($0 | 0) == (0 | 0);
 if ($2) {
  $$0 = 0;
 } else {
  $3 = _wcrtomb($0, $1, 0) | 0;
  $$0 = $3;
 }
 return $$0 | 0;
}

function dynCall_iidiiii(index, a1, a2, a3, a4, a5, a6) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = +a2;
 a3 = a3 | 0;
 a4 = a4 | 0;
 a5 = a5 | 0;
 a6 = a6 | 0;
 return FUNCTION_TABLE_iidiiii[index & 1023](a1 | 0, +a2, a3 | 0, a4 | 0, a5 | 0, a6 | 0) | 0;
}

function _object___init__($0) {
 $0 = $0 | 0;
 var $1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 STACKTOP = sp;
 return 17668 | 0;
}

function dynCall_viiiiii(index, a1, a2, a3, a4, a5, a6) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 a5 = a5 | 0;
 a6 = a6 | 0;
 FUNCTION_TABLE_viiiiii[index & 511](a1 | 0, a2 | 0, a3 | 0, a4 | 0, a5 | 0, a6 | 0);
}

function _mp_import_stat($0) {
 $0 = $0 | 0;
 var $1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 STACKTOP = sp;
 return 0;
}

function _mp_pystack_usage() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP32[40556 >> 2] | 0;
 $1 = HEAP32[40548 >> 2] | 0;
 $2 = $0;
 $3 = $1;
 $4 = $2 - $3 | 0;
 return $4 | 0;
}

function stackAlloc(size) {
 size = size | 0;
 var ret = 0;
 ret = STACKTOP;
 STACKTOP = STACKTOP + size | 0;
 STACKTOP = STACKTOP + 15 & -16;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(size | 0);
 return ret | 0;
}

function _time_ticks_cpu() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = _mp_hal_ticks_cpu() | 0;
 $1 = $0 & 1073741823;
 $2 = $1 << 1;
 $3 = $2 | 1;
 $4 = $3;
 return $4 | 0;
}

function _time_ticks_us() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = _mp_hal_ticks_us() | 0;
 $1 = $0 & 1073741823;
 $2 = $1 << 1;
 $3 = $2 | 1;
 $4 = $3;
 return $4 | 0;
}

function _time_ticks_ms() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, $4 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = _mp_hal_ticks_ms() | 0;
 $1 = $0 & 1073741823;
 $2 = $1 << 1;
 $3 = $2 | 1;
 $4 = $3;
 return $4 | 0;
}

function _nlr_jump_fail($0) {
 $0 = $0 | 0;
 var $1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 STACKTOP = STACKTOP + 16 | 0;
 if ((STACKTOP | 0) >= (STACK_MAX | 0)) abortStackOverflow(16 | 0);
 $1 = $0;
 while (1) {}
}

function _i64Subtract(a, b, c, d) {
 a = a | 0;
 b = b | 0;
 c = c | 0;
 d = d | 0;
 var l = 0, h = 0;
 l = a - c >>> 0;
 h = b - d >>> 0;
 h = b - d - (c >>> 0 > a >>> 0 | 0) >>> 0;
 return (setTempRet0(h | 0), l | 0) | 0;
}

function _mp_micropython_pystack_use() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = _mp_pystack_usage() | 0;
 $1 = $0 << 1;
 $2 = $1 | 1;
 $3 = $2;
 return $3 | 0;
}

function _mp_micropython_stack_use() {
 var $0 = 0, $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = _mp_stack_usage() | 0;
 $1 = $0 << 1;
 $2 = $1 | 1;
 $3 = $2;
 return $3 | 0;
}

function _vfprintf($0, $1, $2) {
 $0 = $0 | 0;
 $1 = $1 | 0;
 $2 = $2 | 0;
 var $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $3 = ___vfprintf_internal($0, $1, $2, 632, 633) | 0;
 return $3 | 0;
}

function ___udivdi3($a$0, $a$1, $b$0, $b$1) {
 $a$0 = $a$0 | 0;
 $a$1 = $a$1 | 0;
 $b$0 = $b$0 | 0;
 $b$1 = $b$1 | 0;
 var $1$0 = 0;
 $1$0 = ___udivmoddi4($a$0, $a$1, $b$0, $b$1, 0) | 0;
 return $1$0 | 0;
}

function dynCall_iiiii(index, a1, a2, a3, a4) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 return FUNCTION_TABLE_iiiii[index & 1023](a1 | 0, a2 | 0, a3 | 0, a4 | 0) | 0;
}

function _gc_isenabled() {
 var $0 = 0, $1 = 0, $2 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP16[41022 >> 1] | 0;
 $1 = $0 & 65535;
 $2 = _mp_obj_new_bool_1404($1) | 0;
 return $2 | 0;
}

function _i64Add(a, b, c, d) {
 a = a | 0;
 b = b | 0;
 c = c | 0;
 d = d | 0;
 var l = 0, h = 0;
 l = a + c >>> 0;
 h = b + d + (l >>> 0 < a >>> 0 | 0) >>> 0;
 return (setTempRet0(h | 0), l | 0) | 0;
}

function dynCall_viiii(index, a1, a2, a3, a4) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 a4 = a4 | 0;
 FUNCTION_TABLE_viiii[index & 1023](a1 | 0, a2 | 0, a3 | 0, a4 | 0);
}

function _isdigit($0) {
 $0 = $0 | 0;
 var $1 = 0, $2 = 0, $3 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = $0 + -48 | 0;
 $2 = $1 >>> 0 < 10;
 $3 = $2 & 1;
 return $3 | 0;
}

function _gc_unlock() {
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP16[41020 >> 1] | 0;
 $1 = $0 + -1 << 16 >> 16;
 HEAP16[41020 >> 1] = $1;
 return;
}

function _gc_lock() {
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP16[41020 >> 1] | 0;
 $1 = $0 + 1 << 16 >> 16;
 HEAP16[41020 >> 1] = $1;
 return;
}

function _mod_urandom_random() {
 var $0 = 0.0, $1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = +_yasmarang_float();
 $1 = _mp_obj_new_float($0) | 0;
 return $1 | 0;
}

function dynCall_iiii(index, a1, a2, a3) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 return FUNCTION_TABLE_iiii[index & 1023](a1 | 0, a2 | 0, a3 | 0) | 0;
}

function _mp_sched_empty() {
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = _mp_sched_num_pending() | 0;
 $1 = ($0 | 0) == 0;
 return $1 | 0;
}

function _mp_sched_full() {
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = _mp_sched_num_pending() | 0;
 $1 = ($0 | 0) == 1;
 return $1 | 0;
}

function _gc_is_locked() {
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP16[41020 >> 1] | 0;
 $1 = $0 << 16 >> 16 != 0;
 return $1 | 0;
}

function dynCall_viii(index, a1, a2, a3) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 a3 = a3 | 0;
 FUNCTION_TABLE_viii[index & 1023](a1 | 0, a2 | 0, a3 | 0);
}

function _mp_sched_num_pending() {
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP8[40742 >> 0] | 0;
 $1 = $0 & 255;
 return $1 | 0;
}

function _mp_hal_ticks_us() {
 var $0 = 0, $1 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = _mp_js_ticks_ms() | 0;
 $1 = $0 * 1e3 | 0;
 return $1 | 0;
}

function establishStackSpace(stackBase, stackMax) {
 stackBase = stackBase | 0;
 stackMax = stackMax | 0;
 STACKTOP = stackBase;
 STACK_MAX = stackMax;
}

function b4(p0, p1, p2, p3, p4, p5) {
 p0 = p0 | 0;
 p1 = +p1;
 p2 = p2 | 0;
 p3 = p3 | 0;
 p4 = p4 | 0;
 p5 = p5 | 0;
 nullFunc_iidiiii(4);
 return 0;
}

function _setThrew(threw, value) {
 threw = threw | 0;
 value = value | 0;
 if ((__THREW__ | 0) == 0) {
  __THREW__ = threw;
  threwValue = value;
 }
}

function _ldexp($0, $1) {
 $0 = +$0;
 $1 = $1 | 0;
 var $2 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $2 = +_scalbn($0, $1);
 return +$2;
}

function dynCall_iii(index, a1, a2) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 return FUNCTION_TABLE_iii[index & 1023](a1 | 0, a2 | 0) | 0;
}

function b13(p0, p1, p2, p3, p4, p5) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 p4 = p4 | 0;
 p5 = p5 | 0;
 nullFunc_viiiiii(13);
}

function _mp_builtin_globals() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = _mp_globals_get_1401() | 0;
 return $0 | 0;
}

function _mp_builtin_locals() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = _mp_locals_get_1382() | 0;
 return $0 | 0;
}

function _mp_hal_get_interrupt_char() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP32[5565] | 0;
 return $0 | 0;
}

function _mp_globals_get_1401() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP32[40564 >> 2] | 0;
 return $0 | 0;
}

function _mp_globals_get_1364() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP32[40564 >> 2] | 0;
 return $0 | 0;
}

function _mp_globals_get_1350() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP32[40564 >> 2] | 0;
 return $0 | 0;
}

function _mp_globals_get_1003() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP32[40564 >> 2] | 0;
 return $0 | 0;
}

function _lgamma($0) {
 $0 = +$0;
 var $1 = 0.0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $1 = +___lgamma_r($0, 41536);
 return +$1;
}

function _qstr_init() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAP32[40572 >> 2] = 11280;
 HEAP32[40724 >> 2] = 0;
 return;
}

function _mp_locals_get_1382() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP32[40560 >> 2] | 0;
 return $0 | 0;
}

function _mp_locals_get_1365() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP32[40560 >> 2] | 0;
 return $0 | 0;
}

function _mp_globals_get_988() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP32[40564 >> 2] | 0;
 return $0 | 0;
}

function dynCall_vii(index, a1, a2) {
 index = index | 0;
 a1 = a1 | 0;
 a2 = a2 | 0;
 FUNCTION_TABLE_vii[index & 1023](a1 | 0, a2 | 0);
}

function ___pthread_self_853() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = _pthread_self() | 0;
 return $0 | 0;
}

function _mp_hal_ticks_ms() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = _mp_js_ticks_ms() | 0;
 return $0 | 0;
}

function _mp_globals_get() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP32[40564 >> 2] | 0;
 return $0 | 0;
}

function _mp_locals_get() {
 var $0 = 0, label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 $0 = HEAP32[40560 >> 2] | 0;
 return $0 | 0;
}

function dynCall_ddd(index, a1, a2) {
 index = index | 0;
 a1 = +a1;
 a2 = +a2;
 return +FUNCTION_TABLE_ddd[index & 1023](+a1, +a2);
}

function _mp_arg_error_unimpl_kw() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 _mp_raise_NotImplementedError(30278);
}

function _mp_micropython_heap_unlock() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 _gc_unlock();
 return 17668 | 0;
}

function _mp_micropython_heap_lock() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 _gc_lock();
 return 17668 | 0;
}

function _gc_disable() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAP16[41022 >> 1] = 0;
 return 17668 | 0;
}

function dynCall_ii(index, a1) {
 index = index | 0;
 a1 = a1 | 0;
 return FUNCTION_TABLE_ii[index & 1023](a1 | 0) | 0;
}

function _gc_enable() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 HEAP16[41022 >> 1] = 1;
 return 17668 | 0;
}

function _mp_js_init_repl() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 _pyexec_event_repl_init();
 return;
}

function b7(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 nullFunc_iiiii(7);
 return 0;
}

function ___ofl_lock() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 ___lock(41608 | 0);
 return 41616 | 0;
}

function _py_gc_collect() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 _gc_collect();
 return 17668 | 0;
}

function _llvm_nearbyint_f64(f) {
 f = +f;
 return f - +Math_floor(f) != .5 ? +_round(f) : +_round(f / 2.0) * 2.0;
}

function dynCall_dd(index, a1) {
 index = index | 0;
 a1 = +a1;
 return +FUNCTION_TABLE_dd[index & 1023](+a1);
}

function ___ofl_unlock() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 ___unlock(41608 | 0);
 return;
}

function dynCall_vi(index, a1) {
 index = index | 0;
 a1 = a1 | 0;
 FUNCTION_TABLE_vi[index & 1023](a1 | 0);
}

function b12(p0, p1, p2, p3) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 p3 = p3 | 0;
 nullFunc_viiii(12);
}

function _syntax_error() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 _mp_raise_TypeError(34496);
}

function _math_error() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 _mp_raise_ValueError(33827);
}

function _dummy($0) {
 $0 = $0 | 0;
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 return $0 | 0;
}

function ___unlockfile($0) {
 $0 = $0 | 0;
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 return;
}

function ___lockfile($0) {
 $0 = $0 | 0;
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 return 1;
}

function __emscripten_dceable_type_decls() {
 +_sqrt(0.0);
 _mp_js_hook();
 _emscripten_longjmp(0, 0);
}

function ___errno_location() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 return 41540 | 0;
}

function _nan($0) {
 $0 = $0 | 0;
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 return +nan;
}

function b6(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 nullFunc_iiii(6);
 return 0;
}

function _pthread_self() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 return 22352 | 0;
}

function dynCall_i(index) {
 index = index | 0;
 return FUNCTION_TABLE_i[index & 1023]() | 0;
}

function _mp_hal_ticks_cpu() {
 var label = 0, sp = 0;
 label = 0;
 sp = STACKTOP;
 return 0;
}

function _round(d) {
 d = +d;
 return d >= 0.0 ? +Math_floor(d + .5) : +Math_ceil(d - .5);
}

function b11(p0, p1, p2) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 p2 = p2 | 0;
 nullFunc_viii(11);
}

function dynCall_v(index) {
 index = index | 0;
 FUNCTION_TABLE_v[index & 1023]();
}

function b5(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 nullFunc_iii(5);
 return 0;
}

function b1(p0, p1) {
 p0 = +p0;
 p1 = +p1;
 nullFunc_ddd(1);
 return 0.0;
}

function b10(p0, p1) {
 p0 = p0 | 0;
 p1 = p1 | 0;
 nullFunc_vii(10);
}

function stackRestore(top) {
 top = top | 0;
 STACKTOP = top;
}

function setEmtStackMax(x) {
 x = x | 0;
 EMT_STACK_MAX = x;
}

function emtStackRestore(x) {
 x = x | 0;
 EMTSTACKTOP = x;
}

function b3(p0) {
 p0 = p0 | 0;
 nullFunc_ii(3);
 return 0;
}

function b0(p0) {
 p0 = +p0;
 nullFunc_dd(0);
 return 0.0;
}

function setAsyncState(x) {
 x = x | 0;
 asyncState = x;
}

function getEmtStackMax() {
 return EMT_STACK_MAX | 0;
}

function emterpret(pc) {
 pc = pc | 0;
 assert(0);
}

function emtStackSave() {
 return EMTSTACKTOP | 0;
}

function b9(p0) {
 p0 = p0 | 0;
 nullFunc_vi(9);
}

function stackSave() {
 return STACKTOP | 0;
}

function b2() {
 nullFunc_i(2);
 return 0;
}

function b8() {
 nullFunc_v(8);
}

// EMSCRIPTEN_END_FUNCS
var FUNCTION_TABLE_dd = [b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,_lgamma,_tgamma,_erfc,_erf,b0,_fabs_func,b0,b0,_atan,_asin,_acos,_tan,_sin,_cos,_atanh,_asinh,_acosh,_tanh,_sinh,_cosh,_log10,_log2,_expm1,_exp,b0,_sqrt
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0,b0
,b0,b0,b0,b0,b0];
var FUNCTION_TABLE_ddd = [b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,_fmod,b1,_copysign_func,_atan2,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,_pow,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1,b1
,b1,b1,b1,b1,b1];
var FUNCTION_TABLE_i = [b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,_mp_builtin_globals,b2,b2,b2,_mp_builtin_locals,b2,b2,b2,b2,_py_gc_collect,_gc_disable,_gc_enable,_gc_isenabled,_gc_mem_free,_gc_mem_alloc,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,_mp_micropython_stack_use,_mp_micropython_pystack_use,_mp_micropython_heap_lock,_mp_micropython_heap_unlock,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,_mod_urandom_random,b2,b2,b2,b2,b2,b2,b2,_select_poll,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,_time_ticks_ms,_time_ticks_us,_time_ticks_cpu,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,_mp_globals_get,_mp_locals_get,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,_mp_globals_get_1364,_mp_locals_get_1365
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,_mp_load_build_class,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,_mp_hal_ticks_ms,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2,b2
,b2,b2,b2,b2,b2];
var FUNCTION_TABLE_ii = [b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,_mp_identity,b3,b3,b3,b3,b3,b3
,b3,_array_it_iternext,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,_dict_clear,_dict_copy,b3,_dict_items,_dict_keys,b3,_dict_popitem,b3,b3,_dict_values,b3,b3,b3,_dict_view_it_iternext,b3,b3,_enumerate_iternext,b3,b3,b3,b3,_filter_iternext,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,_gen_instance_iternext,_gen_instance_close,b3,b3,b3,_it_iternext,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,_list_clear,_list_copy,b3
,b3,b3,b3,b3,b3,_list_reverse,b3,b3,_map_iternext,b3,b3,b3,_object___init__,_object___new__,_polymorph_it_iternext,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,_range_it_iternext,b3,_reversed_iternext
,b3,b3,b3,b3,b3,b3,_set_clear,_set_copy,b3,b3,b3,b3,b3,b3,b3,b3,_set_pop,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,_str_lower,_str_upper,_str_isspace,_str_isalpha,_str_isdigit,_str_isupper,_str_islower,b3,b3
,b3,b3,b3,b3,b3,b3,_mp_stream_unbuffered_iter,b3,b3,b3,_stringio_getvalue,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,_zip_iternext,b3
,b3,b3,b3,b3,b3,b3,b3,_mp_stream_close,b3,_stream_flush,b3,b3,b3,b3,b3,b3,b3,_mp_builtin_abs,_mp_builtin_all,_mp_builtin_any,_mp_builtin_bin,_mp_builtin_callable,_mp_builtin_chr,b3,b3,_mp_builtin_hash,_mp_builtin_hex,b3,_mp_builtin_iter,b3
,b3,_mp_builtin_next,_mp_builtin_oct,_mp_builtin_ord,b3,b3,_mp_builtin___repl_print__,b3,b3,b3,b3,b3,_mp_obj_id,_mp_obj_len,b3,_mp_builtin_repr,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,_mp_math_sqrt,b3,_mp_math_exp,_mp_math_expm1
,b3,_mp_math_log2,_mp_math_log10,_mp_math_cosh,_mp_math_sinh,_mp_math_tanh,_mp_math_acosh,_mp_math_asinh,_mp_math_atanh,_mp_math_cos,_mp_math_sin,_mp_math_tan,_mp_math_acos,_mp_math_asin,_mp_math_atan,b3,_mp_math_ceil,b3,_mp_math_fabs,_mp_math_floor,b3,_mp_math_frexp,b3,_mp_math_modf,_mp_math_isfinite,_mp_math_isinf,_mp_math_isnan,_mp_math_trunc,_mp_math_radians,_mp_math_degrees
,_mp_math_erf,_mp_math_erfc,_mp_math_gamma,_mp_math_lgamma,_mp_cmath_phase,_mp_cmath_polar,b3,_mp_cmath_exp,_mp_cmath_log,_mp_cmath_log10,_mp_cmath_sqrt,_mp_cmath_cos,_mp_cmath_sin,b3,b3,b3,b3,b3,b3,b3,_mp_micropython_kbd_intr,b3,_struct_calcsize,b3,b3,b3,b3,b3,_uctypes_struct_addressof,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,_mod_ujson_dumps,_mod_ujson_load,_mod_ujson_loads,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,_mod_uheapq_heappop,_mod_uheapq_heapify,b3,b3,_uhashlib_sha256_digest
,b3,_mod_binascii_unhexlify,_mod_binascii_a2b_base64,_mod_binascii_b2a_base64,_mod_urandom_getrandbits,_mod_urandom_seed,b3,b3,_mod_urandom_choice,b3,b3,b3,b3,b3,b3,b3,b3,b3,_poll_iternext,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,_time_sleep,_time_sleep_ms,_time_sleep_us,b3,b3,b3,b3,b3,b3,_js_exec
,_js_sleep,___stdio_close,b3,b3,b3,b3,_mp_reader_mem_readbyte,b3,b3,b3,b3,b3,b3,b3,b3,_mp_obj_get_type,b3,_nlr_push_tail,b3,b3,b3,b3,_mp_obj_get_type_str,b3,b3,b3,b3,b3,b3,b3
,_mp_call_function_0,b3,b3,b3,b3,_list_it_iternext,b3,b3,b3,b3,_set_it_iternext,_bytes_it_iternext,_unichar_islower,_unichar_isupper,_unichar_isdigit,_unichar_isalpha,_unichar_isspace,_unichar_toupper,_unichar_tolower,_str_it_iternext,_tuple_it_iternext,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,_mp_obj_is_obj_1366,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,_mp_decode_uint_value,_mp_make_raise_obj,b3,_mp_obj_cell_get,_mp_load_name,_mp_load_global,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,_mp_obj_is_true,b3,_mp_iternext_allow_raise,b3,b3,_mp_obj_new_dict,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,_mp_obj_exception_get_value,b3,b3,b3,b3,b3,b3,_mp_decode_uint_skip,b3,b3,_read_src_stream,b3,_mp_lexer_new_from_file,b3,b3,b3,b3,b3,b3,b3,_strlen,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3,b3
,b3,b3,b3,b3,b3];
var FUNCTION_TABLE_iidiiii = [b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,_fmt_fp,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4,b4
,b4,b4,b4,b4,b4];
var FUNCTION_TABLE_iii = [b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,_array_unary_op,b5,b5,_array_iterator_new,b5
,_mp_identity_getiter,b5,b5,b5,b5,_array_append,_array_extend,b5,_mp_obj_tuple_unary_op,b5,b5,b5,_mp_obj_tuple_getiter,b5,b5,_bool_unary_op,b5,b5,b5,b5,b5,b5,_complex_unary_op,b5,b5,b5,b5,_dict_unary_op,b5,b5
,_dict_getiter,b5,b5,_dict_get,b5,b5,_dict_pop,b5,_dict_setdefault,b5,b5,b5,b5,_dict_view_getiter,b5,_dict_fromkeys,b5,b5,b5,b5,b5,b5,b5,b5,b5,_float_unary_op,b5,b5,_mp_generic_unary_op,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,_gen_instance_send,_gen_instance_throw,_gen_instance_pend_throw,b5,b5,b5,_mp_obj_int_unary_op,b5,_int_to_bytes,_int_from_bytes,b5,b5,_list_unary_op,b5,b5,_list_getiter,_mp_obj_list_append,b5,b5,_list_count
,_list_extend,_list_index,b5,_list_pop,_mp_obj_list_remove,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,_property_getter,_property_setter,_property_deleter,b5,_new_namedtuple_type,b5,b5,_range_unary_op,b5,b5,_range_getiter,b5,b5,b5
,b5,b5,_set_unary_op,b5,_set_getiter,_set_add,b5,b5,_set_discard,_set_diff,_set_diff_update,_set_intersect,_set_intersect_update,_set_isdisjoint,_set_issubset,_set_issuperset,b5,_set_remove,_set_symmetric_difference,_set_symmetric_difference_update,_set_union,_set_update,b5,b5,b5,b5,b5,b5,b5,_mp_obj_new_bytes_iterator
,b5,_bytes_decode,_str_find,_str_rfind,_str_index,_str_rindex,_str_join,_mp_obj_str_split,b5,_str_rsplit,_str_startswith,_str_endswith,_str_strip,_str_lstrip,_str_rstrip,b5,_str_replace,_str_count,_str_partition,_str_rpartition,_str_center,b5,b5,b5,b5,b5,b5,b5,_str_encode,b5
,b5,_uni_unary_op,b5,_mp_obj_new_str_iterator,b5,b5,b5,b5,b5,b5,b5,_stringio___exit__,b5,b5,_tuple_count,_tuple_index,b5,b5,b5,b5,_native_base_init_wrapper,b5,b5,b5,b5,_mp_builtin_issubclass,_mp_builtin_isinstance,b5,b5,_op_getitem
,b5,_op_delitem,_op_contains,_stream_read,_stream_write_method,_stream_readinto,_stream_unbuffered_readline,b5,_stream_seek,b5,_mp_builtin___import__,_mp_builtin_compile,_mp_builtin_eval,_mp_builtin_exec,_mp_builtin_execfile,_mp_builtin_help,_mp_builtin___build_class__,b5,b5,b5,b5,b5,b5,_mp_builtin_dir,_mp_builtin_divmod,b5,b5,_mp_builtin_input,b5,b5
,b5,b5,b5,b5,_mp_builtin_pow,b5,b5,_mp_builtin_delattr,_mp_builtin_getattr,b5,b5,_mp_builtin_hasattr,b5,b5,b5,b5,_mp_builtin_round,b5,_mp_builtin_sum,b5,b5,b5,b5,b5,b5,_gc_threshold,b5,_mp_math_pow,b5,b5
,_mp_math_log,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,_mp_math_atan2,b5,_mp_math_copysign,b5,b5,_mp_math_fmod,b5,_mp_math_ldexp,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,_mp_cmath_rect,b5,b5,b5,b5,b5,b5,_mp_micropython_opt_level,_mp_micropython_mem_info,_mp_micropython_qstr_info,b5,b5,b5,b5,b5,_mp_micropython_schedule,b5,_struct_unpack_from,_struct_pack,_struct_pack_into,_mp_sys_exit,_mp_sys_print_exception,b5,_uctypes_struct_bytearray_at
,_uctypes_struct_bytes_at,b5,b5,_uctypes_struct_unary_op,b5,b5,b5,_uctypes_struct_sizeof,_mod_ujson_dump,b5,b5,b5,_match_group,_re_match,b5,_re_search,_re_split,_mod_re_compile,b5,_mod_re_match,_mod_re_search,_mod_uzlib_decompress,b5,b5,_mod_uheapq_heappush,b5,b5,b5,_uhashlib_sha256_update,b5
,_mod_binascii_hexlify,b5,b5,b5,b5,b5,_mod_urandom_randrange,_mod_urandom_randint,b5,b5,_mod_urandom_uniform,_select_select,_poll_register,_poll_unregister,b5,_poll_poll,_poll_ipoll,b5,b5,b5,b5,_legacy_framebuffer1,_framebuf_fill,_framebuf_fill_rect,_framebuf_pixel,_framebuf_hline,_framebuf_vline,_framebuf_rect,_framebuf_line,_framebuf_blit
,b5,_framebuf_text,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,_time_ticks_diff,_time_ticks_add,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,_emit_get_cur_to_write_bytecode,_emit_get_cur_to_write_code_info,b5,b5,b5,b5,b5,_mp_obj_is_subclass_fast,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,_mp_call_function_1,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,_instance_unary_op,b5,b5,b5,_instance_getiter,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,_mp_obj_new_exception_msg,b5,b5,b5,_mp_load_attr,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,_mp_getiter,b5,_mp_obj_new_tuple,_mp_obj_new_list,b5,b5,_mp_obj_new_set,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,_mp_obj_exception_match,b5,b5,_mp_import_from,b5,_mp_unary_op,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,_printf,b5,b5,b5,b5,_mp_obj_get_int_maybe,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5,b5
,b5,b5,b5,b5,b5];
var FUNCTION_TABLE_iiii = [b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,_array_binary_op,_array_subscr,b6,_array_get_buffer
,b6,b6,b6,b6,b6,b6,b6,b6,b6,_mp_obj_tuple_binary_op,b6,_mp_obj_tuple_subscr,b6,b6,b6,b6,_bool_binary_op,b6,b6,b6,b6,b6,b6,_complex_binary_op,b6,b6,b6,b6,_dict_binary_op,_dict_subscr
,b6,b6,b6,b6,b6,b6,b6,b6,b6,_dict_update,b6,b6,_dict_view_binary_op,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,_float_binary_op,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,_mp_obj_int_binary_op,b6,b6,b6,b6,b6,_list_binary_op,_list_subscr,b6,b6,b6,b6,b6
,b6,b6,_list_insert,b6,b6,b6,_mp_obj_list_sort,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,_range_subscr,b6,b6,b6,b6
,b6,b6,b6,_set_binary_op,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,_mp_obj_str_binary_op,_bytes_subscr,b6
,_mp_obj_str_get_buffer,b6,b6,b6,b6,b6,b6,b6,_str_splitlines,b6,b6,b6,b6,b6,b6,_mp_obj_str_format,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,_str_subscr,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,_op_setitem,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,_mp_builtin_max
,_mp_builtin_min,b6,b6,b6,b6,_mp_builtin_print,b6,b6,b6,_mp_builtin_setattr,b6,b6,b6,b6,b6,b6,b6,_mp_builtin_sorted,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,_uctypes_struct_subscr,_uctypes_get_buffer,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,_poll_modify,b6,b6,b6,b6,b6,_framebuf_get_buffer,b6,b6,b6,b6,b6,b6,b6,b6,b6
,_framebuf_scroll,b6,b6,_mvlsb_getpixel,b6,b6,_rgb565_getpixel,b6,b6,_gs4_hmsb_getpixel,b6,b6,_mono_horiz_getpixel,b6,b6,_gs2_hmsb_getpixel,b6,b6,_gs8_getpixel,b6,b6,b6,b6,b6,b6,b6,b6,b6,_mp_builtin_open,b6
,b6,b6,___stdout_write,b6,_sn_write,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,_mp_call_method_n_kw,b6,b6,b6,b6,_mp_obj_new_exception_msg_varg,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,_instance_binary_op,b6,_instance_subscr,b6,_instance_get_buffer,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,_mp_obj_subscr,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,_mp_obj_dict_store,b6,_mp_obj_new_slice,b6,b6,b6,_mp_make_function_from_raw_code,_mp_make_closure_from_raw_code
,b6,_mp_call_method_n_kw_var,b6,b6,b6,b6,b6,_mp_import_name,b6,b6,b6,_mp_binary_op,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,___stdio_write,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6,b6
,b6,b6,b6,b6,b6];
var FUNCTION_TABLE_iiiii = [b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,_checked_fun_call,b7,_memoryview_make_new,b7,b7,b7,b7,b7
,b7,b7,b7,_bytearray_make_new,_array_make_new,b7,b7,b7,b7,b7,b7,b7,b7,b7,_bool_make_new,b7,b7,_bound_meth_call,b7,_closure_call,b7,_complex_make_new,b7,b7,b7,b7,_dict_make_new,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,_enumerate_make_new,b7,b7,_mp_obj_exception_make_new,b7,_filter_make_new,b7,b7,_float_make_new,b7,b7,_fun_builtin_0_call,b7,_fun_builtin_1_call
,_fun_builtin_2_call,_fun_builtin_3_call,_fun_builtin_var_call,b7,_fun_bc_call,b7,_gen_wrap_call,b7,b7,b7,b7,b7,b7,b7,b7,_mp_obj_int_make_new,b7,b7,b7,b7,b7,_list_make_new,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,_map_make_new,b7,b7,b7,_object_make_new,b7,b7,b7,_property_make_new,b7,b7,b7,b7,b7,b7,_range_make_new,b7,b7,b7,b7,b7,_reversed_make_new,b7
,b7,_set_make_new,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,_bytes_make_new,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,_mp_obj_str_make_new,b7,b7,b7,b7,_stringio_make_new,b7,_stringio_read,_stringio_write,_stringio_ioctl,b7,b7,b7,_mp_obj_tuple_make_new,b7,b7,b7,_type_make_new,_type_call,b7,b7,_static_class_method_make_new,b7,_super_make_new,b7,b7,b7,_zip_make_new,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,_uctypes_struct_make_new,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,_decompio_make_new,_decompio_read,b7,b7,b7,_uhashlib_sha256_make_new,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,_framebuf_make_new,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,___stdio_seek,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,_mp_compile
,b7,b7,b7,_mp_obj_instance_call,b7,b7,_mp_obj_instance_make_new,b7,_namedtuple_make_new,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,_mp_call_function_n_kw,b7,b7,b7,_mp_resume,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,_mp_lexer_new_from_str_len,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7,b7
,b7,b7,b7,b7,b7];
var FUNCTION_TABLE_v = [b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,_nlr_pop,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,_mp_js_hook,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,_gc_collect,_gc_dump_info,b8,b8,b8,_gc_collect_start
,b8,_gc_collect_end,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8,b8
,b8,b8,b8,b8,b8];
var FUNCTION_TABLE_vi = [b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,_mp_reader_mem_close,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,_nlr_jump,b9,b9,b9,b9,_mp_globals_set,_mp_locals_set,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,_mp_globals_set_1367,_mp_locals_set_1368,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,_mp_delete_name,_mp_delete_global,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,_mp_import_all,b9,b9,_mp_handle_pending_tail,b9,b9,b9,b9,b9,b9,_mp_hal_set_interrupt_char,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9,b9
,b9,b9,b9,b9,b9];
var FUNCTION_TABLE_vii = [b10,b10,_compile_generic_all_nodes,_compile_decorated,_compile_funcdef,_compile_expr_stmt,_compile_generic_tuple,_compile_del_stmt,_compile_break_cont_stmt,_compile_return_stmt,_compile_yield_stmt,_compile_raise_stmt,_compile_import_name,_compile_import_from,_compile_global_nonlocal_stmt,_compile_assert_stmt,_compile_async_stmt,_compile_if_stmt,_compile_while_stmt,_compile_for_stmt,_compile_try_stmt,_compile_with_stmt,_compile_test_if_expr,_compile_lambdef,_compile_or_and_test,_compile_not_test_2,_compile_comparison,_compile_star_expr,_compile_binary_op
,_compile_term,_compile_factor_2,_compile_power,_compile_atom_expr_await,_compile_atom_expr_normal,_compile_atom_paren,_compile_atom_bracket,_compile_atom_brace,_compile_trailer_paren,_compile_trailer_bracket,_compile_trailer_period,_compile_subscript,_compile_dictorsetmaker_item,_compile_classdef,_compile_yield_expr,_compile_const_object,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,_compile_scope_func_param,_compile_scope_lambda_param,_c_del_stmt,_compile_dotted_as_name,_compile_funcdef_lambdef_param,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,_mp_obj_print_exception,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,_mp_load_super_method,b10,b10,_mp_obj_cell_set,_mp_store_name,_mp_store_global,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,_mp_obj_set_store,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,_mp_hal_stdout_tx_strn,b10,b10,b10,b10,b10,b10,_emscripten_longjmp,b10
,_gc_collect_root,b10,b10,b10,_pop_arg_long_double,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10,b10
,b10,b10,b10,b10,b10];
var FUNCTION_TABLE_viii = [b11,_plat_print_strn,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,_mp_emit_bc_load_global,b11,_mp_emit_bc_store_global,b11,_mp_emit_bc_delete_global,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,_array_print,b11,b11,b11,b11,_mp_obj_attrtuple_print,b11,b11,_mp_obj_attrtuple_attr,b11,b11,_bool_print,b11,b11,b11,b11,_bound_meth_attr,b11,_complex_print,b11,b11,b11,_complex_attr,_dict_print,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,_dict_view_print,b11,b11,b11,b11,b11,b11,_mp_obj_exception_print,b11,_mp_obj_exception_attr,b11,b11,_float_print,b11,b11,b11,b11,b11,b11
,b11,b11,b11,_fun_bc_print,b11,_mp_obj_fun_bc_attr,b11,_gen_instance_print,b11,b11,b11,b11,b11,b11,_mp_obj_int_print,b11,b11,b11,b11,b11,_list_print,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,_module_print,_module_attr,b11,b11,b11,b11,b11,b11,b11,b11,_none_print,b11,_range_print,b11,b11,_range_attr,b11,b11,b11,b11,b11
,_set_print,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,_singleton_print,_slice_print,_slice_attr,_str_print,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,_uni_print
,b11,b11,b11,b11,_stringio_print,b11,b11,b11,b11,b11,b11,b11,_mp_obj_tuple_print,b11,b11,b11,_type_print,b11,b11,_type_attr,b11,b11,_super_print,b11,_super_attr,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,_uctypes_struct_print,b11,b11,_uctypes_struct_attr,b11,b11,b11,b11,b11,b11,b11,b11,b11,_match_print,b11,b11,b11,_re_print,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,_vstr_add_strn,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,_mp_load_method_maybe,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,_mp_parse,b11
,b11,b11,b11,b11,_exc_add_strn,b11,b11,_namedtuple_print,b11,_namedtuple_attr,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,_instance_print,b11,b11,_mp_obj_instance_attr,b11,b11,b11,b11,b11
,b11,b11,b11,_mp_load_method,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,_mp_store_attr,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,_mp_unpack_sequence,_mp_unpack_ex,b11,b11
,b11,b11,b11,_mp_warning,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,_mp_stream_write_adaptor,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11,b11
,b11,b11,b11,b11,b11];
var FUNCTION_TABLE_viiii = [b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,_mp_emit_bc_load_local,b12,_mp_emit_bc_store_local,b12,_mp_emit_bc_delete_local,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,_mvlsb_setpixel,b12,b12,_rgb565_setpixel,b12,b12,_gs4_hmsb_setpixel,b12,b12,_mono_horiz_setpixel,b12,b12,_gs2_hmsb_setpixel,b12,b12,_gs8_setpixel,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,_mp_obj_exception_add_traceback,b12,b12,b12,b12,b12,b12,b12,b12,_qstr_pool_info,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12,b12
,b12,b12,b12,b12,b12];
var FUNCTION_TABLE_viiiiii = [b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,_mvlsb_fill_rect,b13,b13,_rgb565_fill_rect,b13,b13,_gs4_hmsb_fill_rect,b13,b13,_mono_horiz_fill_rect,b13,b13,_gs2_hmsb_fill_rect,b13,b13,_gs8_fill_rect,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13,b13
,b13,b13,b13];

  return { ___errno_location: ___errno_location, ___muldi3: ___muldi3, ___udivdi3: ___udivdi3, _bitshift64Ashr: _bitshift64Ashr, _bitshift64Lshr: _bitshift64Lshr, _bitshift64Shl: _bitshift64Shl, _fflush: _fflush, _free: _free, _i64Add: _i64Add, _i64Subtract: _i64Subtract, _llvm_nearbyint_f64: _llvm_nearbyint_f64, _malloc: _malloc, _memcpy: _memcpy, _memmove: _memmove, _memset: _memset, _mp_hal_get_interrupt_char: _mp_hal_get_interrupt_char, _mp_js_do_str: _mp_js_do_str, _mp_js_init: _mp_js_init, _mp_js_init_repl: _mp_js_init_repl, _mp_js_process_char: _mp_js_process_char, _mp_keyboard_interrupt: _mp_keyboard_interrupt, _realloc: _realloc, _saveSetjmp: _saveSetjmp, _sbrk: _sbrk, _setThrew: _setThrew, _testSetjmp: _testSetjmp, dynCall_dd: dynCall_dd, dynCall_ddd: dynCall_ddd, dynCall_i: dynCall_i, dynCall_ii: dynCall_ii, dynCall_iidiiii: dynCall_iidiiii, dynCall_iii: dynCall_iii, dynCall_iiii: dynCall_iiii, dynCall_iiiii: dynCall_iiiii, dynCall_v: dynCall_v, dynCall_vi: dynCall_vi, dynCall_vii: dynCall_vii, dynCall_viii: dynCall_viii, dynCall_viiii: dynCall_viiii, dynCall_viiiiii: dynCall_viiiiii, emtStackRestore: emtStackRestore, emtStackSave: emtStackSave, emterpret: emterpret, establishStackSpace: establishStackSpace, getEmtStackMax: getEmtStackMax, setAsyncState: setAsyncState, setEmtStackMax: setEmtStackMax, stackAlloc: stackAlloc, stackRestore: stackRestore, stackSave: stackSave };
})
// EMSCRIPTEN_END_ASM
(asmGlobalArg, asmLibraryArg, buffer);

var real____errno_location = asm["___errno_location"]; asm["___errno_location"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real____errno_location.apply(null, arguments);
};

var real____muldi3 = asm["___muldi3"]; asm["___muldi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real____muldi3.apply(null, arguments);
};

var real____udivdi3 = asm["___udivdi3"]; asm["___udivdi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real____udivdi3.apply(null, arguments);
};

var real__bitshift64Ashr = asm["_bitshift64Ashr"]; asm["_bitshift64Ashr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__bitshift64Ashr.apply(null, arguments);
};

var real__bitshift64Lshr = asm["_bitshift64Lshr"]; asm["_bitshift64Lshr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__bitshift64Lshr.apply(null, arguments);
};

var real__bitshift64Shl = asm["_bitshift64Shl"]; asm["_bitshift64Shl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__bitshift64Shl.apply(null, arguments);
};

var real__fflush = asm["_fflush"]; asm["_fflush"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__fflush.apply(null, arguments);
};

var real__free = asm["_free"]; asm["_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__free.apply(null, arguments);
};

var real__i64Add = asm["_i64Add"]; asm["_i64Add"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__i64Add.apply(null, arguments);
};

var real__i64Subtract = asm["_i64Subtract"]; asm["_i64Subtract"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__i64Subtract.apply(null, arguments);
};

var real__llvm_nearbyint_f64 = asm["_llvm_nearbyint_f64"]; asm["_llvm_nearbyint_f64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__llvm_nearbyint_f64.apply(null, arguments);
};

var real__malloc = asm["_malloc"]; asm["_malloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__malloc.apply(null, arguments);
};

var real__memmove = asm["_memmove"]; asm["_memmove"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__memmove.apply(null, arguments);
};

var real__mp_hal_get_interrupt_char = asm["_mp_hal_get_interrupt_char"]; asm["_mp_hal_get_interrupt_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__mp_hal_get_interrupt_char.apply(null, arguments);
};

var real__mp_js_do_str = asm["_mp_js_do_str"]; asm["_mp_js_do_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__mp_js_do_str.apply(null, arguments);
};

var real__mp_js_init = asm["_mp_js_init"]; asm["_mp_js_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__mp_js_init.apply(null, arguments);
};

var real__mp_js_init_repl = asm["_mp_js_init_repl"]; asm["_mp_js_init_repl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__mp_js_init_repl.apply(null, arguments);
};

var real__mp_js_process_char = asm["_mp_js_process_char"]; asm["_mp_js_process_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__mp_js_process_char.apply(null, arguments);
};

var real__mp_keyboard_interrupt = asm["_mp_keyboard_interrupt"]; asm["_mp_keyboard_interrupt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__mp_keyboard_interrupt.apply(null, arguments);
};

var real__realloc = asm["_realloc"]; asm["_realloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__realloc.apply(null, arguments);
};

var real__saveSetjmp = asm["_saveSetjmp"]; asm["_saveSetjmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__saveSetjmp.apply(null, arguments);
};

var real__sbrk = asm["_sbrk"]; asm["_sbrk"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__sbrk.apply(null, arguments);
};

var real__setThrew = asm["_setThrew"]; asm["_setThrew"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__setThrew.apply(null, arguments);
};

var real__testSetjmp = asm["_testSetjmp"]; asm["_testSetjmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real__testSetjmp.apply(null, arguments);
};

var real_emtStackRestore = asm["emtStackRestore"]; asm["emtStackRestore"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_emtStackRestore.apply(null, arguments);
};

var real_emtStackSave = asm["emtStackSave"]; asm["emtStackSave"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_emtStackSave.apply(null, arguments);
};

var real_emterpret = asm["emterpret"]; asm["emterpret"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_emterpret.apply(null, arguments);
};

var real_establishStackSpace = asm["establishStackSpace"]; asm["establishStackSpace"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_establishStackSpace.apply(null, arguments);
};

var real_getEmtStackMax = asm["getEmtStackMax"]; asm["getEmtStackMax"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_getEmtStackMax.apply(null, arguments);
};

var real_setAsyncState = asm["setAsyncState"]; asm["setAsyncState"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_setAsyncState.apply(null, arguments);
};

var real_setEmtStackMax = asm["setEmtStackMax"]; asm["setEmtStackMax"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_setEmtStackMax.apply(null, arguments);
};

var real_stackAlloc = asm["stackAlloc"]; asm["stackAlloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_stackAlloc.apply(null, arguments);
};

var real_stackRestore = asm["stackRestore"]; asm["stackRestore"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_stackRestore.apply(null, arguments);
};

var real_stackSave = asm["stackSave"]; asm["stackSave"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return real_stackSave.apply(null, arguments);
};
Module["asm"] = asm;
var ___errno_location = Module["___errno_location"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["___errno_location"].apply(null, arguments) };
var ___muldi3 = Module["___muldi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["___muldi3"].apply(null, arguments) };
var ___udivdi3 = Module["___udivdi3"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["___udivdi3"].apply(null, arguments) };
var _bitshift64Ashr = Module["_bitshift64Ashr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_bitshift64Ashr"].apply(null, arguments) };
var _bitshift64Lshr = Module["_bitshift64Lshr"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_bitshift64Lshr"].apply(null, arguments) };
var _bitshift64Shl = Module["_bitshift64Shl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_bitshift64Shl"].apply(null, arguments) };
var _fflush = Module["_fflush"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_fflush"].apply(null, arguments) };
var _free = Module["_free"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_free"].apply(null, arguments) };
var _i64Add = Module["_i64Add"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_i64Add"].apply(null, arguments) };
var _i64Subtract = Module["_i64Subtract"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_i64Subtract"].apply(null, arguments) };
var _llvm_nearbyint_f64 = Module["_llvm_nearbyint_f64"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_llvm_nearbyint_f64"].apply(null, arguments) };
var _malloc = Module["_malloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_malloc"].apply(null, arguments) };
var _memcpy = Module["_memcpy"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_memcpy"].apply(null, arguments) };
var _memmove = Module["_memmove"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_memmove"].apply(null, arguments) };
var _memset = Module["_memset"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_memset"].apply(null, arguments) };
var _mp_hal_get_interrupt_char = Module["_mp_hal_get_interrupt_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_mp_hal_get_interrupt_char"].apply(null, arguments) };
var _mp_js_do_str = Module["_mp_js_do_str"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_mp_js_do_str"].apply(null, arguments) };
var _mp_js_init = Module["_mp_js_init"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_mp_js_init"].apply(null, arguments) };
var _mp_js_init_repl = Module["_mp_js_init_repl"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_mp_js_init_repl"].apply(null, arguments) };
var _mp_js_process_char = Module["_mp_js_process_char"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_mp_js_process_char"].apply(null, arguments) };
var _mp_keyboard_interrupt = Module["_mp_keyboard_interrupt"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_mp_keyboard_interrupt"].apply(null, arguments) };
var _realloc = Module["_realloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_realloc"].apply(null, arguments) };
var _saveSetjmp = Module["_saveSetjmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_saveSetjmp"].apply(null, arguments) };
var _sbrk = Module["_sbrk"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_sbrk"].apply(null, arguments) };
var _setThrew = Module["_setThrew"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_setThrew"].apply(null, arguments) };
var _testSetjmp = Module["_testSetjmp"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["_testSetjmp"].apply(null, arguments) };
var emtStackRestore = Module["emtStackRestore"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emtStackRestore"].apply(null, arguments) };
var emtStackSave = Module["emtStackSave"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emtStackSave"].apply(null, arguments) };
var emterpret = Module["emterpret"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["emterpret"].apply(null, arguments) };
var establishStackSpace = Module["establishStackSpace"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["establishStackSpace"].apply(null, arguments) };
var getEmtStackMax = Module["getEmtStackMax"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["getEmtStackMax"].apply(null, arguments) };
var setAsyncState = Module["setAsyncState"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setAsyncState"].apply(null, arguments) };
var setEmtStackMax = Module["setEmtStackMax"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["setEmtStackMax"].apply(null, arguments) };
var stackAlloc = Module["stackAlloc"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackAlloc"].apply(null, arguments) };
var stackRestore = Module["stackRestore"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackRestore"].apply(null, arguments) };
var stackSave = Module["stackSave"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["stackSave"].apply(null, arguments) };
var dynCall_dd = Module["dynCall_dd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_dd"].apply(null, arguments) };
var dynCall_ddd = Module["dynCall_ddd"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_ddd"].apply(null, arguments) };
var dynCall_i = Module["dynCall_i"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_i"].apply(null, arguments) };
var dynCall_ii = Module["dynCall_ii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_ii"].apply(null, arguments) };
var dynCall_iidiiii = Module["dynCall_iidiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iidiiii"].apply(null, arguments) };
var dynCall_iii = Module["dynCall_iii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iii"].apply(null, arguments) };
var dynCall_iiii = Module["dynCall_iiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiii"].apply(null, arguments) };
var dynCall_iiiii = Module["dynCall_iiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_iiiii"].apply(null, arguments) };
var dynCall_v = Module["dynCall_v"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_v"].apply(null, arguments) };
var dynCall_vi = Module["dynCall_vi"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vi"].apply(null, arguments) };
var dynCall_vii = Module["dynCall_vii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_vii"].apply(null, arguments) };
var dynCall_viii = Module["dynCall_viii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viii"].apply(null, arguments) };
var dynCall_viiii = Module["dynCall_viiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiii"].apply(null, arguments) };
var dynCall_viiiiii = Module["dynCall_viiiiii"] = function() {
  assert(runtimeInitialized, 'you need to wait for the runtime to be ready (e.g. wait for main() to be called)');
  assert(!runtimeExited, 'the runtime was exited (use NO_EXIT_RUNTIME to keep it alive after main() exits)');
  return Module["asm"]["dynCall_viiiiii"].apply(null, arguments) };
;



// === Auto-generated postamble setup entry stuff ===

Module['asm'] = asm;

if (!Module["intArrayFromString"]) Module["intArrayFromString"] = function() { abort("'intArrayFromString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["intArrayToString"]) Module["intArrayToString"] = function() { abort("'intArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
Module["ccall"] = ccall;
Module["cwrap"] = cwrap;
if (!Module["setValue"]) Module["setValue"] = function() { abort("'setValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["getValue"]) Module["getValue"] = function() { abort("'getValue' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["allocate"]) Module["allocate"] = function() { abort("'allocate' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["getMemory"]) Module["getMemory"] = function() { abort("'getMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Module["AsciiToString"]) Module["AsciiToString"] = function() { abort("'AsciiToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["stringToAscii"]) Module["stringToAscii"] = function() { abort("'stringToAscii' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["UTF8ArrayToString"]) Module["UTF8ArrayToString"] = function() { abort("'UTF8ArrayToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["UTF8ToString"]) Module["UTF8ToString"] = function() { abort("'UTF8ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["stringToUTF8Array"]) Module["stringToUTF8Array"] = function() { abort("'stringToUTF8Array' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["stringToUTF8"]) Module["stringToUTF8"] = function() { abort("'stringToUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["lengthBytesUTF8"]) Module["lengthBytesUTF8"] = function() { abort("'lengthBytesUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["UTF16ToString"]) Module["UTF16ToString"] = function() { abort("'UTF16ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["stringToUTF16"]) Module["stringToUTF16"] = function() { abort("'stringToUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["lengthBytesUTF16"]) Module["lengthBytesUTF16"] = function() { abort("'lengthBytesUTF16' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["UTF32ToString"]) Module["UTF32ToString"] = function() { abort("'UTF32ToString' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["stringToUTF32"]) Module["stringToUTF32"] = function() { abort("'stringToUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["lengthBytesUTF32"]) Module["lengthBytesUTF32"] = function() { abort("'lengthBytesUTF32' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["allocateUTF8"]) Module["allocateUTF8"] = function() { abort("'allocateUTF8' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["stackTrace"]) Module["stackTrace"] = function() { abort("'stackTrace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["addOnPreRun"]) Module["addOnPreRun"] = function() { abort("'addOnPreRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["addOnInit"]) Module["addOnInit"] = function() { abort("'addOnInit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["addOnPreMain"]) Module["addOnPreMain"] = function() { abort("'addOnPreMain' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["addOnExit"]) Module["addOnExit"] = function() { abort("'addOnExit' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["addOnPostRun"]) Module["addOnPostRun"] = function() { abort("'addOnPostRun' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["writeStringToMemory"]) Module["writeStringToMemory"] = function() { abort("'writeStringToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["writeArrayToMemory"]) Module["writeArrayToMemory"] = function() { abort("'writeArrayToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["writeAsciiToMemory"]) Module["writeAsciiToMemory"] = function() { abort("'writeAsciiToMemory' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["addRunDependency"]) Module["addRunDependency"] = function() { abort("'addRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Module["removeRunDependency"]) Module["removeRunDependency"] = function() { abort("'removeRunDependency' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Module["ENV"]) Module["ENV"] = function() { abort("'ENV' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["FS"]) Module["FS"] = function() { abort("'FS' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["FS_createFolder"]) Module["FS_createFolder"] = function() { abort("'FS_createFolder' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Module["FS_createPath"]) Module["FS_createPath"] = function() { abort("'FS_createPath' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Module["FS_createDataFile"]) Module["FS_createDataFile"] = function() { abort("'FS_createDataFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Module["FS_createPreloadedFile"]) Module["FS_createPreloadedFile"] = function() { abort("'FS_createPreloadedFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Module["FS_createLazyFile"]) Module["FS_createLazyFile"] = function() { abort("'FS_createLazyFile' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Module["FS_createLink"]) Module["FS_createLink"] = function() { abort("'FS_createLink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Module["FS_createDevice"]) Module["FS_createDevice"] = function() { abort("'FS_createDevice' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Module["FS_unlink"]) Module["FS_unlink"] = function() { abort("'FS_unlink' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ). Alternatively, forcing filesystem support (-s FORCE_FILESYSTEM=1) can export this for you") };
if (!Module["GL"]) Module["GL"] = function() { abort("'GL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["dynamicAlloc"]) Module["dynamicAlloc"] = function() { abort("'dynamicAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["warnOnce"]) Module["warnOnce"] = function() { abort("'warnOnce' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["loadDynamicLibrary"]) Module["loadDynamicLibrary"] = function() { abort("'loadDynamicLibrary' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["loadWebAssemblyModule"]) Module["loadWebAssemblyModule"] = function() { abort("'loadWebAssemblyModule' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["getLEB"]) Module["getLEB"] = function() { abort("'getLEB' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["getFunctionTables"]) Module["getFunctionTables"] = function() { abort("'getFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["alignFunctionTables"]) Module["alignFunctionTables"] = function() { abort("'alignFunctionTables' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["registerFunctions"]) Module["registerFunctions"] = function() { abort("'registerFunctions' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["addFunction"]) Module["addFunction"] = function() { abort("'addFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["removeFunction"]) Module["removeFunction"] = function() { abort("'removeFunction' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["getFuncWrapper"]) Module["getFuncWrapper"] = function() { abort("'getFuncWrapper' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["prettyPrint"]) Module["prettyPrint"] = function() { abort("'prettyPrint' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["makeBigInt"]) Module["makeBigInt"] = function() { abort("'makeBigInt' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["dynCall"]) Module["dynCall"] = function() { abort("'dynCall' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["getCompilerSetting"]) Module["getCompilerSetting"] = function() { abort("'getCompilerSetting' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["stackSave"]) Module["stackSave"] = function() { abort("'stackSave' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["stackRestore"]) Module["stackRestore"] = function() { abort("'stackRestore' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["stackAlloc"]) Module["stackAlloc"] = function() { abort("'stackAlloc' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["establishStackSpace"]) Module["establishStackSpace"] = function() { abort("'establishStackSpace' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["print"]) Module["print"] = function() { abort("'print' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["printErr"]) Module["printErr"] = function() { abort("'printErr' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["getTempRet0"]) Module["getTempRet0"] = function() { abort("'getTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["setTempRet0"]) Module["setTempRet0"] = function() { abort("'setTempRet0' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };
if (!Module["Pointer_stringify"]) Module["Pointer_stringify"] = function() { abort("'Pointer_stringify' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") };if (!Module["ALLOC_NORMAL"]) Object.defineProperty(Module, "ALLOC_NORMAL", { get: function() { abort("'ALLOC_NORMAL' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Module["ALLOC_STACK"]) Object.defineProperty(Module, "ALLOC_STACK", { get: function() { abort("'ALLOC_STACK' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Module["ALLOC_DYNAMIC"]) Object.defineProperty(Module, "ALLOC_DYNAMIC", { get: function() { abort("'ALLOC_DYNAMIC' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });
if (!Module["ALLOC_NONE"]) Object.defineProperty(Module, "ALLOC_NONE", { get: function() { abort("'ALLOC_NONE' was not exported. add it to EXTRA_EXPORTED_RUNTIME_METHODS (see the FAQ)") } });




/**
 * @constructor
 * @extends {Error}
 * @this {ExitStatus}
 */
function ExitStatus(status) {
  this.name = "ExitStatus";
  this.message = "Program terminated with exit(" + status + ")";
  this.status = status;
};
ExitStatus.prototype = new Error();
ExitStatus.prototype.constructor = ExitStatus;

var calledMain = false;

dependenciesFulfilled = function runCaller() {
  // If run has never been called, and we should call run (INVOKE_RUN is true, and Module.noInitialRun is not false)
  if (!Module['calledRun']) run();
  if (!Module['calledRun']) dependenciesFulfilled = runCaller; // try this again later, after new deps are fulfilled
}





/** @type {function(Array=)} */
function run(args) {
  args = args || Module['arguments'];

  if (runDependencies > 0) {
    return;
  }

  writeStackCookie();

  preRun();

  if (runDependencies > 0) return; // a preRun added a dependency, run will be called later
  if (Module['calledRun']) return; // run may have just been called through dependencies being fulfilled just in this very frame

  function doRun() {
    if (Module['calledRun']) return; // run may have just been called while the async setStatus time below was happening
    Module['calledRun'] = true;

    if (ABORT) return;

    ensureInitRuntime();

    preMain();

    if (Module['onRuntimeInitialized']) Module['onRuntimeInitialized']();

    assert(!Module['_main'], 'compiled without a main, but one is present. if you added it from JS, use Module["onRuntimeInitialized"]');

    postRun();
  }

  if (Module['setStatus']) {
    Module['setStatus']('Running...');
    setTimeout(function() {
      setTimeout(function() {
        Module['setStatus']('');
      }, 1);
      doRun();
    }, 1);
  } else {
    doRun();
  }
  checkStackCookie();
}
Module['run'] = run;

function checkUnflushedContent() {
  // Compiler settings do not allow exiting the runtime, so flushing
  // the streams is not possible. but in ASSERTIONS mode we check
  // if there was something to flush, and if so tell the user they
  // should request that the runtime be exitable.
  // Normally we would not even include flush() at all, but in ASSERTIONS
  // builds we do so just for this check, and here we see if there is any
  // content to flush, that is, we check if there would have been
  // something a non-ASSERTIONS build would have not seen.
  // How we flush the streams depends on whether we are in SYSCALLS_REQUIRE_FILESYSTEM=0
  // mode (which has its own special function for this; otherwise, all
  // the code is inside libc)
  var print = out;
  var printErr = err;
  var has = false;
  out = err = function(x) {
    has = true;
  }
  try { // it doesn't matter if it fails
    var flush = flush_NO_FILESYSTEM;
    if (flush) flush(0);
  } catch(e) {}
  out = print;
  err = printErr;
  if (has) {
    warnOnce('stdio streams had content in them that was not flushed. you should set EXIT_RUNTIME to 1 (see the FAQ), or make sure to emit a newline when you printf etc.');
    warnOnce('(this may also be due to not including full filesystem support - try building with -s FORCE_FILESYSTEM=1)');
  }
}

function exit(status, implicit) {
  checkUnflushedContent();

  // if this is just main exit-ing implicitly, and the status is 0, then we
  // don't need to do anything here and can just leave. if the status is
  // non-zero, though, then we need to report it.
  // (we may have warned about this earlier, if a situation justifies doing so)
  if (implicit && Module['noExitRuntime'] && status === 0) {
    return;
  }

  if (Module['noExitRuntime']) {
    // if exit() was called, we may warn the user if the runtime isn't actually being shut down
    if (!implicit) {
      err('exit(' + status + ') called, but EXIT_RUNTIME is not set, so halting execution but not exiting the runtime or preventing further async execution (build with EXIT_RUNTIME=1, if you want a true shutdown)');
    }
  } else {

    ABORT = true;
    EXITSTATUS = status;

    exitRuntime();

    if (Module['onExit']) Module['onExit'](status);
  }

  Module['quit'](status, new ExitStatus(status));
}

var abortDecorators = [];

function abort(what) {
  if (Module['onAbort']) {
    Module['onAbort'](what);
  }

  if (what !== undefined) {
    out(what);
    err(what);
    what = JSON.stringify(what)
  } else {
    what = '';
  }

  ABORT = true;
  EXITSTATUS = 1;

  var extra = '';
  var output = 'abort(' + what + ') at ' + stackTrace() + extra;
  if (abortDecorators) {
    abortDecorators.forEach(function(decorator) {
      output = decorator(output, what);
    });
  }
  throw output;
}
Module['abort'] = abort;

if (Module['preInit']) {
  if (typeof Module['preInit'] == 'function') Module['preInit'] = [Module['preInit']];
  while (Module['preInit'].length > 0) {
    Module['preInit'].pop()();
  }
}


  Module["noExitRuntime"] = true;

run();





// {{MODULE_ADDITIONS}}







